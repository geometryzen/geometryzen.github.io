(function () {
  var async = {};
  var root, previous_async;
  root = this;
  if (root != null) {
    previous_async = root.async;
  }
  async.noConflict = function () {
    root.async = previous_async;
    return async;
  };
  function only_once(fn) {
    var called = false;
    return function () {
      if (called)
        throw new Error('Callback was already called.');
      called = true;
      fn.apply(root, arguments);
    };
  }
  var _each = function (arr, iterator) {
    if (arr.forEach) {
      return arr.forEach(iterator);
    }
    for (var i = 0; i < arr.length; i += 1) {
      iterator(arr[i], i, arr);
    }
  };
  var _map = function (arr, iterator) {
    if (arr.map) {
      return arr.map(iterator);
    }
    var results = [];
    _each(arr, function (x, i, a) {
      results.push(iterator(x, i, a));
    });
    return results;
  };
  var _reduce = function (arr, iterator, memo) {
    if (arr.reduce) {
      return arr.reduce(iterator, memo);
    }
    _each(arr, function (x, i, a) {
      memo = iterator(memo, x, i, a);
    });
    return memo;
  };
  var _keys = function (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keys = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        keys.push(k);
      }
    }
    return keys;
  };
  if (typeof process === 'undefined' || !process.nextTick) {
    if (typeof setImmediate === 'function') {
      async.nextTick = function (fn) {
        setImmediate(fn);
      };
    } else {
      async.nextTick = function (fn) {
        setTimeout(fn, 0);
      };
    }
  } else {
    async.nextTick = process.nextTick;
  }
  async.each = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    _each(arr, function (x) {
      iterator(x, only_once(function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          }
        }
      }));
    });
  };
  async.forEach = async.each;
  async.eachSeries = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    var iterate = function () {
      var sync = true;
      iterator(arr[completed], function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          } else {
            if (sync) {
              async.nextTick(iterate);
            } else {
              iterate();
            }
          }
        }
      });
      sync = false;
    };
    iterate();
  };
  async.forEachSeries = async.eachSeries;
  async.eachLimit = function (arr, limit, iterator, callback) {
    var fn = _eachLimit(limit);
    fn.apply(null, [
      arr,
      iterator,
      callback
    ]);
  };
  async.forEachLimit = async.eachLimit;
  var _eachLimit = function (limit) {
    return function (arr, iterator, callback) {
      callback = callback || function () {
      };
      if (!arr.length || limit <= 0) {
        return callback();
      }
      var completed = 0;
      var started = 0;
      var running = 0;
      (function replenish() {
        if (completed >= arr.length) {
          return callback();
        }
        while (running < limit && started < arr.length) {
          started += 1;
          running += 1;
          iterator(arr[started - 1], function (err) {
            if (err) {
              callback(err);
              callback = function () {
              };
            } else {
              completed += 1;
              running -= 1;
              if (completed >= arr.length) {
                callback();
              } else {
                replenish();
              }
            }
          });
        }
      }());
    };
  };
  var doParallel = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.each].concat(args));
    };
  };
  var doParallelLimit = function (limit, fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [_eachLimit(limit)].concat(args));
    };
  };
  var doSeries = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.eachSeries].concat(args));
    };
  };
  var _asyncMap = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (err, v) {
        results[x.index] = v;
        callback(err);
      });
    }, function (err) {
      callback(err, results);
    });
  };
  async.map = doParallel(_asyncMap);
  async.mapSeries = doSeries(_asyncMap);
  async.mapLimit = function (arr, limit, iterator, callback) {
    return _mapLimit(limit)(arr, iterator, callback);
  };
  var _mapLimit = function (limit) {
    return doParallelLimit(limit, _asyncMap);
  };
  async.reduce = function (arr, memo, iterator, callback) {
    async.eachSeries(arr, function (x, callback) {
      iterator(memo, x, function (err, v) {
        memo = v;
        callback(err);
      });
    }, function (err) {
      callback(err, memo);
    });
  };
  async.inject = async.reduce;
  async.foldl = async.reduce;
  async.reduceRight = function (arr, memo, iterator, callback) {
    var reversed = _map(arr, function (x) {
        return x;
      }).reverse();
    async.reduce(reversed, memo, iterator, callback);
  };
  async.foldr = async.reduceRight;
  var _filter = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.filter = doParallel(_filter);
  async.filterSeries = doSeries(_filter);
  async.select = async.filter;
  async.selectSeries = async.filterSeries;
  var _reject = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (!v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.reject = doParallel(_reject);
  async.rejectSeries = doSeries(_reject);
  var _detect = function (eachfn, arr, iterator, main_callback) {
    eachfn(arr, function (x, callback) {
      iterator(x, function (result) {
        if (result) {
          main_callback(x);
          main_callback = function () {
          };
        } else {
          callback();
        }
      });
    }, function (err) {
      main_callback();
    });
  };
  async.detect = doParallel(_detect);
  async.detectSeries = doSeries(_detect);
  async.some = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (v) {
          main_callback(true);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(false);
    });
  };
  async.any = async.some;
  async.every = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (!v) {
          main_callback(false);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(true);
    });
  };
  async.all = async.every;
  async.sortBy = function (arr, iterator, callback) {
    async.map(arr, function (x, callback) {
      iterator(x, function (err, criteria) {
        if (err) {
          callback(err);
        } else {
          callback(null, {
            value: x,
            criteria: criteria
          });
        }
      });
    }, function (err, results) {
      if (err) {
        return callback(err);
      } else {
        var fn = function (left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        };
        callback(null, _map(results.sort(fn), function (x) {
          return x.value;
        }));
      }
    });
  };
  async.auto = function (tasks, callback) {
    callback = callback || function () {
    };
    var keys = _keys(tasks);
    if (!keys.length) {
      return callback(null);
    }
    var results = {};
    var listeners = [];
    var addListener = function (fn) {
      listeners.unshift(fn);
    };
    var removeListener = function (fn) {
      for (var i = 0; i < listeners.length; i += 1) {
        if (listeners[i] === fn) {
          listeners.splice(i, 1);
          return;
        }
      }
    };
    var taskComplete = function () {
      _each(listeners.slice(0), function (fn) {
        fn();
      });
    };
    addListener(function () {
      if (_keys(results).length === keys.length) {
        callback(null, results);
        callback = function () {
        };
      }
    });
    _each(keys, function (k) {
      var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];
      var taskCallback = function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          async.nextTick(taskComplete);
        }
      };
      var requires = task.slice(0, Math.abs(task.length - 1)) || [];
      var ready = function () {
        return _reduce(requires, function (a, x) {
          return a && results.hasOwnProperty(x);
        }, true) && !results.hasOwnProperty(k);
      };
      if (ready()) {
        task[task.length - 1](taskCallback, results);
      } else {
        var listener = function () {
          if (ready()) {
            removeListener(listener);
            task[task.length - 1](taskCallback, results);
          }
        };
        addListener(listener);
      }
    });
  };
  async.waterfall = function (tasks, callback) {
    callback = callback || function () {
    };
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {
          };
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }
          async.nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(async.iterator(tasks))();
  };
  var _parallel = function (eachfn, tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      eachfn.map(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      eachfn.each(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.parallel = function (tasks, callback) {
    _parallel({
      map: async.map,
      each: async.each
    }, tasks, callback);
  };
  async.parallelLimit = function (tasks, limit, callback) {
    _parallel({
      map: _mapLimit(limit),
      each: _eachLimit(limit)
    }, tasks, callback);
  };
  async.series = function (tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      async.mapSeries(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      async.eachSeries(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.iterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return index < tasks.length - 1 ? makeCallback(index + 1) : null;
      };
      return fn;
    };
    return makeCallback(0);
  };
  async.apply = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));
    };
  };
  var _concat = function (eachfn, arr, fn, callback) {
    var r = [];
    eachfn(arr, function (x, cb) {
      fn(x, function (err, y) {
        r = r.concat(y || []);
        cb(err);
      });
    }, function (err) {
      callback(err, r);
    });
  };
  async.concat = doParallel(_concat);
  async.concatSeries = doSeries(_concat);
  async.whilst = function (test, iterator, callback) {
    if (test()) {
      var sync = true;
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        if (sync) {
          async.nextTick(function () {
            async.whilst(test, iterator, callback);
          });
        } else {
          async.whilst(test, iterator, callback);
        }
      });
      sync = false;
    } else {
      callback();
    }
  };
  async.doWhilst = function (iterator, test, callback) {
    var sync = true;
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (test()) {
        if (sync) {
          async.nextTick(function () {
            async.doWhilst(iterator, test, callback);
          });
        } else {
          async.doWhilst(iterator, test, callback);
        }
      } else {
        callback();
      }
    });
    sync = false;
  };
  async.until = function (test, iterator, callback) {
    if (!test()) {
      var sync = true;
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        if (sync) {
          async.nextTick(function () {
            async.until(test, iterator, callback);
          });
        } else {
          async.until(test, iterator, callback);
        }
      });
      sync = false;
    } else {
      callback();
    }
  };
  async.doUntil = function (iterator, test, callback) {
    var sync = true;
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (!test()) {
        if (sync) {
          async.nextTick(function () {
            async.doUntil(iterator, test, callback);
          });
        } else {
          async.doUntil(iterator, test, callback);
        }
      } else {
        callback();
      }
    });
    sync = false;
  };
  async.queue = function (worker, concurrency) {
    function _insert(q, data, pos, callback) {
      if (data.constructor !== Array) {
        data = [data];
      }
      _each(data, function (task) {
        var item = {
            data: task,
            callback: typeof callback === 'function' ? callback : null
          };
        if (pos) {
          q.tasks.unshift(item);
        } else {
          q.tasks.push(item);
        }
        if (q.saturated && q.tasks.length === concurrency) {
          q.saturated();
        }
        async.nextTick(q.process);
      });
    }
    var workers = 0;
    var q = {
        tasks: [],
        concurrency: concurrency,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          _insert(q, data, false, callback);
        },
        unshift: function (data, callback) {
          _insert(q, data, true, callback);
        },
        process: function () {
          if (workers < q.concurrency && q.tasks.length) {
            var task = q.tasks.shift();
            if (q.empty && q.tasks.length === 0) {
              q.empty();
            }
            workers += 1;
            var sync = true;
            var next = function () {
              workers -= 1;
              if (task.callback) {
                task.callback.apply(task, arguments);
              }
              if (q.drain && q.tasks.length + workers === 0) {
                q.drain();
              }
              q.process();
            };
            var cb = only_once(function () {
                var cbArgs = arguments;
                if (sync) {
                  async.nextTick(function () {
                    next.apply(null, cbArgs);
                  });
                } else {
                  next.apply(null, arguments);
                }
              });
            worker(task.data, cb);
            sync = false;
          }
        },
        length: function () {
          return q.tasks.length;
        },
        running: function () {
          return workers;
        }
      };
    return q;
  };
  async.cargo = function (worker, payload) {
    var working = false, tasks = [];
    var cargo = {
        tasks: tasks,
        payload: payload,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          if (data.constructor !== Array) {
            data = [data];
          }
          _each(data, function (task) {
            tasks.push({
              data: task,
              callback: typeof callback === 'function' ? callback : null
            });
            if (cargo.saturated && tasks.length === payload) {
              cargo.saturated();
            }
          });
          async.nextTick(cargo.process);
        },
        process: function process() {
          if (working)
            return;
          if (tasks.length === 0) {
            if (cargo.drain)
              cargo.drain();
            return;
          }
          var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0);
          var ds = _map(ts, function (task) {
              return task.data;
            });
          if (cargo.empty)
            cargo.empty();
          working = true;
          worker(ds, function () {
            working = false;
            var args = arguments;
            _each(ts, function (data) {
              if (data.callback) {
                data.callback.apply(null, args);
              }
            });
            process();
          });
        },
        length: function () {
          return tasks.length;
        },
        running: function () {
          return working;
        }
      };
    return cargo;
  };
  var _console_fn = function (name) {
    return function (fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      fn.apply(null, args.concat([function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (typeof console !== 'undefined') {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              _each(args, function (x) {
                console[name](x);
              });
            }
          }
        }]));
    };
  };
  async.log = _console_fn('log');
  async.dir = _console_fn('dir');
  async.memoize = function (fn, hasher) {
    var memo = {};
    var queues = {};
    hasher = hasher || function (x) {
      return x;
    };
    var memoized = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      var key = hasher.apply(null, args);
      if (key in memo) {
        callback.apply(null, memo[key]);
      } else if (key in queues) {
        queues[key].push(callback);
      } else {
        queues[key] = [callback];
        fn.apply(null, args.concat([function () {
            memo[key] = arguments;
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length; i < l; i++) {
              q[i].apply(null, arguments);
            }
          }]));
      }
    };
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
  };
  async.unmemoize = function (fn) {
    return function () {
      return (fn.unmemoized || fn).apply(null, arguments);
    };
  };
  async.times = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.map(counter, iterator, callback);
  };
  async.timesSeries = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.mapSeries(counter, iterator, callback);
  };
  async.compose = function () {
    var fns = Array.prototype.reverse.call(arguments);
    return function () {
      var that = this;
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      async.reduce(fns, args, function (newargs, fn, cb) {
        fn.apply(that, newargs.concat([function () {
            var err = arguments[0];
            var nextargs = Array.prototype.slice.call(arguments, 1);
            cb(err, nextargs);
          }]));
      }, function (err, results) {
        callback.apply(that, [err].concat(results));
      });
    };
  };
  if (typeof define !== 'undefined' && define.amd) {
    define([], function () {
      return async;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = async;
  } else {
    root.async = async;
  }
}());
(function (window, undefined) {
  var rootjQuery, readyList, core_strundefined = typeof undefined, location = window.location, document = window.document, docElem = document.documentElement, _jQuery = window.jQuery, _$ = window.$, class2type = {}, core_deletedIds = [], core_version = '2.0.3', core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim, jQuery = function (selector, context) {
      return new jQuery.fn.init(selector, context, rootjQuery);
    }, core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, core_rnotwhite = /\S+/g, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    }, completed = function () {
      document.removeEventListener('DOMContentLoaded', completed, false);
      window.removeEventListener('load', completed, false);
      jQuery.ready();
    };
  jQuery.fn = jQuery.prototype = {
    jquery: core_version,
    constructor: jQuery,
    init: function (selector, context, rootjQuery) {
      var match, elem;
      if (!selector) {
        return this;
      }
      if (typeof selector === 'string') {
        if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
          match = [
            null,
            selector,
            null
          ];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem && elem.parentNode) {
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else if (jQuery.isFunction(selector)) {
        return rootjQuery.ready(selector);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    },
    selector: '',
    length: 0,
    toArray: function () {
      return core_slice.call(this);
    },
    get: function (num) {
      return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num];
    },
    pushStack: function (elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function (callback, args) {
      return jQuery.each(this, callback, args);
    },
    ready: function (fn) {
      jQuery.ready.promise().done(fn);
      return this;
    },
    slice: function () {
      return this.pushStack(core_slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length, j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    push: core_push,
    sort: [].sort,
    splice: [].splice
  };
  jQuery.fn.init.prototype = jQuery.fn;
  jQuery.extend = jQuery.fn.extend = function () {
    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {};
    }
    if (length === i) {
      target = this;
      --i;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: 'jQuery' + (core_version + Math.random()).replace(/\D/g, ''),
    noConflict: function (deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }
      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }
      return jQuery;
    },
    isReady: false,
    readyWait: 1,
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function (wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.trigger) {
        jQuery(document).trigger('ready').off('ready');
      }
    },
    isFunction: function (obj) {
      return jQuery.type(obj) === 'function';
    },
    isArray: Array.isArray,
    isWindow: function (obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function (obj) {
      return !isNaN(parseFloat(obj)) && isFinite(obj);
    },
    type: function (obj) {
      if (obj == null) {
        return String(obj);
      }
      return typeof obj === 'object' || typeof obj === 'function' ? class2type[core_toString.call(obj)] || 'object' : typeof obj;
    },
    isPlainObject: function (obj) {
      if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      try {
        if (obj.constructor && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
          return false;
        }
      } catch (e) {
        return false;
      }
      return true;
    },
    isEmptyObject: function (obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    error: function (msg) {
      throw new Error(msg);
    },
    parseHTML: function (data, context, keepScripts) {
      if (!data || typeof data !== 'string') {
        return null;
      }
      if (typeof context === 'boolean') {
        keepScripts = context;
        context = false;
      }
      context = context || document;
      var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = jQuery.buildFragment([data], context, scripts);
      if (scripts) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    },
    parseJSON: JSON.parse,
    parseXML: function (data) {
      var xml, tmp;
      if (!data || typeof data !== 'string') {
        return null;
      }
      try {
        tmp = new DOMParser();
        xml = tmp.parseFromString(data, 'text/xml');
      } catch (e) {
        xml = undefined;
      }
      if (!xml || xml.getElementsByTagName('parsererror').length) {
        jQuery.error('Invalid XML: ' + data);
      }
      return xml;
    },
    noop: function () {
    },
    globalEval: function (code) {
      var script, indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf('use strict') === 1) {
          script = document.createElement('script');
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function (string) {
      return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
    },
    nodeName: function (elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function (obj, callback, args) {
      var value, i = 0, length = obj.length, isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function (text) {
      return text == null ? '' : core_trim.call(text);
    },
    makeArray: function (arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
        } else {
          core_push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : core_indexOf.call(arr, elem, i);
    },
    merge: function (first, second) {
      var l = second.length, i = first.length, j = 0;
      if (typeof l === 'number') {
        for (; j < l; j++) {
          first[i++] = second[j];
        }
      } else {
        while (second[j] !== undefined) {
          first[i++] = second[j++];
        }
      }
      first.length = i;
      return first;
    },
    grep: function (elems, callback, inv) {
      var retVal, ret = [], i = 0, length = elems.length;
      inv = !!inv;
      for (; i < length; i++) {
        retVal = !!callback(elems[i], i);
        if (inv !== retVal) {
          ret.push(elems[i]);
        }
      }
      return ret;
    },
    map: function (elems, callback, arg) {
      var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      }
      return core_concat.apply([], ret);
    },
    guid: 1,
    proxy: function (fn, context) {
      var tmp, args, proxy;
      if (typeof context === 'string') {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = core_slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(core_slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    access: function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, length = elems.length, bulk = key == null;
      if (jQuery.type(key) === 'object') {
        chainable = true;
        for (i in key) {
          jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== undefined) {
        chainable = true;
        if (!jQuery.isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }
        if (fn) {
          for (; i < length; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
      return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    },
    now: Date.now,
    swap: function (elem, options, callback, args) {
      var ret, name, old = {};
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.apply(elem, args || []);
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    }
  });
  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === 'complete') {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener('DOMContentLoaded', completed, false);
        window.addEventListener('load', completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
    class2type['[object ' + name + ']'] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = obj.length, type = jQuery.type(obj);
    if (jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === 'array' || type !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
  }
  rootjQuery = jQuery(document);
  (function (window, undefined) {
    var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), hasDuplicate = false, sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        return 0;
      }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
        var i = 0, len = this.length;
        for (; i < len; i++) {
          if (this[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rsibling = new RegExp(whitespace + '*[+~]'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
        'ID': new RegExp('^#(' + characterEncoding + ')'),
        'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
        'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
        'ATTR': new RegExp('^' + attributes),
        'PSEUDO': new RegExp('^' + pseudos),
        'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
        'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
        'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
      }, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
        var high = '0x' + escaped - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      };
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function (target, els) {
          push_native.apply(target, slice.call(els));
        } : function (target, els) {
          var j = target.length, i = 0;
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    function Sizzle(selector, context, results, seed) {
      var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      if (!selector || typeof selector !== 'string') {
        return results;
      }
      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
        return [];
      }
      if (documentIsHTML && !seed) {
        if (match = rquickExpr.exec(selector)) {
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
            groups = tokenize(selector);
            if (old = context.getAttribute('id')) {
              nid = old.replace(rescape, '\\$&');
            } else {
              context.setAttribute('id', nid);
            }
            nid = '[id=\'' + nid + '\'] ';
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && context.parentNode || context;
            newSelector = groups.join(',');
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, '$1'), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key += ' ') > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key] = value;
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement('div');
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split('|'), i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    isXML = Sizzle.isXML = function (elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== 'HTML' : false;
    };
    support = Sizzle.support = {};
    setDocument = Sizzle.setDocument = function (node) {
      var doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      documentIsHTML = !isXML(doc);
      if (parent && parent.attachEvent && parent !== parent.top) {
        parent.attachEvent('onbeforeunload', function () {
          setDocument();
        });
      }
      support.attributes = assert(function (div) {
        div.className = 'i';
        return !div.getAttribute('className');
      });
      support.getElementsByTagName = assert(function (div) {
        div.appendChild(doc.createComment(''));
        return !div.getElementsByTagName('*').length;
      });
      support.getElementsByClassName = assert(function (div) {
        div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
        div.firstChild.className = 'i';
        return div.getElementsByClassName('i').length === 2;
      });
      support.getById = assert(function (div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== strundefined && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute('id') === attrId;
          };
        };
      } else {
        delete Expr.find['ID'];
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
            return node && node.value === attrId;
          };
        };
      }
      Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== strundefined) {
          return context.getElementsByTagName(tag);
        }
      } : function (tag, context) {
        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if (support.qsa = rnative.test(doc.querySelectorAll)) {
        assert(function (div) {
          div.innerHTML = '<select><option selected=\'\'></option></select>';
          if (!div.querySelectorAll('[selected]').length) {
            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
          }
          if (!div.querySelectorAll(':checked').length) {
            rbuggyQSA.push(':checked');
          }
        });
        assert(function (div) {
          var input = doc.createElement('input');
          input.setAttribute('type', 'hidden');
          div.appendChild(input).setAttribute('t', '');
          if (div.querySelectorAll('[t^=\'\']').length) {
            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
          }
          if (!div.querySelectorAll(':enabled').length) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          div.querySelectorAll('*,:x');
          rbuggyQSA.push(',.*:');
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (div) {
          support.disconnectedMatch = matches.call(div, 'div');
          matches.call(div, '[s!=\'\']:x');
          rbuggyMatches.push('!=', pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = docElem.compareDocumentPosition ? function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
        if (compare) {
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            if (a === doc || contains(preferredDoc, a)) {
              return -1;
            }
            if (b === doc || contains(preferredDoc, b)) {
              return 1;
            }
            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        }
        return a.compareDocumentPosition ? -1 : 1;
      } : function (a, b) {
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } else if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, '=\'$1\']');
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val;
    };
    Sizzle.error = function (msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    Sizzle.uniqueSort = function (results) {
      var elem, duplicates = [], j = 0, i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      return results;
    };
    getText = Sizzle.getText = function (elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        for (; node = elem[i]; i++) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === 'string') {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        '>': {
          dir: 'parentNode',
          first: true
        },
        ' ': { dir: 'parentNode' },
        '+': {
          dir: 'previousSibling',
          first: true
        },
        '~': { dir: 'previousSibling' }
      },
      preFilter: {
        'ATTR': function (match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
          if (match[2] === '~=') {
            match[3] = ' ' + match[3] + ' ';
          }
          return match.slice(0, 4);
        },
        'CHILD': function (match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === 'nth') {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
            match[5] = +(match[7] + match[8] || match[3] === 'odd');
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        'PSEUDO': function (match) {
          var excess, unquoted = !match[5] && match[2];
          if (matchExpr['CHILD'].test(match[0])) {
            return null;
          }
          if (match[3] && match[4] !== undefined) {
            match[2] = match[4];
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        'TAG': function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === '*' ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        'CLASS': function (className) {
          var pattern = classCache[className + ' '];
          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
          });
        },
        'ATTR': function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === '!=';
            }
            if (!operator) {
              return true;
            }
            result += '';
            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
          };
        },
        'CHILD': function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
          return first === 1 && last === 0 ? function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === 'only' && !start && 'nextSibling';
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [
                      dirruns,
                      nodeIndex,
                      diff
                    ];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [
                        dirruns,
                        diff
                      ];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        'PSEUDO': function (pseudo, argument) {
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              '',
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx, matched = fn(seed, argument), i = matched.length;
              while (i--) {
                idx = indexOf.call(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        'not': markFunction(function (selector) {
          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            return !results.pop();
          };
        }),
        'has': markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        'contains': markFunction(function (text) {
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        'lang': markFunction(function (lang) {
          if (!ridentifier.test(lang || '')) {
            Sizzle.error('unsupported lang: ' + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        'target': function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        'root': function (elem) {
          return elem === docElem;
        },
        'focus': function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        'enabled': function (elem) {
          return elem.disabled === false;
        },
        'disabled': function (elem) {
          return elem.disabled === true;
        },
        'checked': function (elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
        },
        'selected': function (elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        'empty': function (elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeName > '@' || elem.nodeType === 3 || elem.nodeType === 4) {
              return false;
            }
          }
          return true;
        },
        'parent': function (elem) {
          return !Expr.pseudos['empty'](elem);
        },
        'header': function (elem) {
          return rheader.test(elem.nodeName);
        },
        'input': function (elem) {
          return rinputs.test(elem.nodeName);
        },
        'button': function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === 'button' || name === 'button';
        },
        'text': function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === elem.type);
        },
        'first': createPositionalPseudo(function () {
          return [0];
        }),
        'last': createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        'even': createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'odd': createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos['nth'] = Expr.pseudos['eq'];
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
      }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    function tokenize(selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, ' ')
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    }
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
      return combinator.first ? function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function (elem, context, xml) {
        var data, cache, outerCache, dirkey = dirruns + ' ' + doneName;
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((cache = outerCache[dir]) && cache[0] === dirkey) {
                if ((data = cache[1]) === true || data === cachedruns) {
                  return data === true;
                }
              } else {
                cache = outerCache[dir] = [dirkey];
                cache[1] = matcher(elem, context, xml) || cachedruns;
                if (cache[1] === true) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
          return indexOf.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
          }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var matcherCachedRuns = 0, bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, expandContext) {
          var elem, j, matcher, setMatched = [], matchedCount = 0, i = '0', unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', expandContext && context.parentNode || context), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;
          if (outermost) {
            outermostContext = context !== document && context;
            cachedruns = matcherCachedRuns;
          }
          for (; (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                cachedruns = ++matcherCachedRuns;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, group) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        if (!group) {
          group = tokenize(selector);
        }
        i = group.length;
        while (i--) {
          cached = matcherFromTokens(group[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      }
      return cached;
    };
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function select(selector, context, results, seed) {
      var i, tokens, token, type, find, match = tokenize(selector);
      if (!seed) {
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find = Expr.find[type]) {
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
      }
      compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector));
      return results;
    }
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    support.detectDuplicates = hasDuplicate;
    setDocument();
    support.sortDetached = assert(function (div1) {
      return div1.compareDocumentPosition(document.createElement('div')) & 1;
    });
    if (!assert(function (div) {
        div.innerHTML = '<a href=\'#\'></a>';
        return div.firstChild.getAttribute('href') === '#';
      })) {
      addHandle('type|href|height|width', function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function (div) {
        div.innerHTML = '<input/>';
        div.firstChild.setAttribute('value', '');
        return div.firstChild.getAttribute('value') === '';
      })) {
      addHandle('value', function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function (div) {
        return div.getAttribute('disabled') == null;
      })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === true ? name.toLowerCase() : null;
        }
      });
    }
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
  }(window));
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function (options) {
    options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
    var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function (data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list && firingIndex < firingLength; firingIndex++) {
          if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
            memory = false;
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      }, self = {
        add: function () {
          if (list) {
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function (_, arg) {
                var type = jQuery.type(arg);
                if (type === 'function') {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && type !== 'string') {
                  add(arg);
                }
              });
            }(arguments));
            if (firing) {
              firingLength = list.length;
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function () {
          if (list) {
            jQuery.each(arguments, function (_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (firing) {
                  if (index <= firingLength) {
                    firingLength--;
                  }
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        empty: function () {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function () {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function () {
          return !list;
        },
        lock: function () {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function () {
          return !stack;
        },
        fireWith: function (context, args) {
          if (list && (!fired || stack)) {
            args = args || [];
            args = [
              context,
              args.slice ? args.slice() : args
            ];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function () {
          return !!fired;
        }
      };
    return self;
  };
  jQuery.extend({
    Deferred: function (func) {
      var tuples = [
          [
            'resolve',
            'done',
            jQuery.Callbacks('once memory'),
            'resolved'
          ],
          [
            'reject',
            'fail',
            jQuery.Callbacks('once memory'),
            'rejected'
          ],
          [
            'notify',
            'progress',
            jQuery.Callbacks('memory')
          ]
        ], state = 'pending', promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function () {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                var action = tuple[0], fn = jQuery.isFunction(fns[i]) && fns[i];
                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && jQuery.isFunction(returned.promise)) {
                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                  } else {
                    newDefer[action + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2], stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function () {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + 'With'] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function (subordinate) {
      var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
          return function (value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        }, progressValues, progressContexts, resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  jQuery.support = function (support) {
    var input = document.createElement('input'), fragment = document.createDocumentFragment(), div = document.createElement('div'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
    if (!input.type) {
      return support;
    }
    input.type = 'checkbox';
    support.checkOn = input.value !== '';
    support.optSelected = opt.selected;
    support.reliableMarginRight = true;
    support.boxSizingReliable = true;
    support.pixelPosition = false;
    input.checked = true;
    support.noCloneChecked = input.cloneNode(true).checked;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement('input');
    input.value = 't';
    input.type = 'radio';
    support.radioValue = input.value === 't';
    input.setAttribute('checked', 't');
    input.setAttribute('name', 't');
    fragment.appendChild(input);
    support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
    support.focusinBubbles = 'onfocusin' in window;
    div.style.backgroundClip = 'content-box';
    div.cloneNode(true).style.backgroundClip = '';
    support.clearCloneStyle = div.style.backgroundClip === 'content-box';
    jQuery(function () {
      var container, marginDiv, divReset = 'padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box', body = document.getElementsByTagName('body')[0];
      if (!body) {
        return;
      }
      container = document.createElement('div');
      container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
      body.appendChild(container).appendChild(div);
      div.innerHTML = '';
      div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%';
      jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
        support.boxSizing = div.offsetWidth === 4;
      });
      if (window.getComputedStyle) {
        support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== '1%';
        support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
        marginDiv = div.appendChild(document.createElement('div'));
        marginDiv.style.cssText = div.style.cssText = divReset;
        marginDiv.style.marginRight = marginDiv.style.width = '0';
        div.style.width = '1px';
        support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
      }
      body.removeChild(container);
    });
    return support;
  }({});
  var data_user, data_priv, rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
  function Data() {
    Object.defineProperty(this.cache = {}, 0, {
      get: function () {
        return {};
      }
    });
    this.expando = jQuery.expando + Math.random();
  }
  Data.uid = 1;
  Data.accepts = function (owner) {
    return owner.nodeType ? owner.nodeType === 1 || owner.nodeType === 9 : true;
  };
  Data.prototype = {
    key: function (owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {}, unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = { value: unlock };
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function (owner, data, value) {
      var prop, unlock = this.key(owner), cache = this.cache[unlock];
      if (typeof data === 'string') {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function (owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function (owner, key, value) {
      var stored;
      if (key === undefined || key && typeof key === 'string' && value === undefined) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [
              key,
              camel
            ];
          } else {
            name = camel;
            name = name in cache ? [name] : name.match(core_rnotwhite) || [];
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function (owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function (owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  data_user = new Data();
  data_priv = new Data();
  jQuery.extend({
    acceptData: Data.accepts,
    hasData: function (elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function (elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function (elem, name) {
      data_user.remove(elem, name);
    },
    _data: function (elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var attrs, name, elem = this[0], i = 0, data = null;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
            attrs = elem.attributes;
            for (; i < attrs.length; i++) {
              name = attrs[i].name;
              if (name.indexOf('data-') === 0) {
                name = jQuery.camelCase(name.slice(5));
                dataAttr(elem, name, data[name]);
              }
            }
            data_priv.set(elem, 'hasDataAttrs', true);
          }
        }
        return data;
      }
      if (typeof key === 'object') {
        return this.each(function () {
          data_user.set(this, key);
        });
      }
      return jQuery.access(this, function (value) {
        var data, camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function () {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf('-') !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function (key) {
      return this.each(function () {
        data_user.remove(this, key);
      });
    }
  });
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === 'string') {
        try {
          data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? JSON.parse(data) : data;
        } catch (e) {
        }
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;
      if (elem) {
        type = (type || 'fx') + 'queue';
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || 'fx';
      var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
          jQuery.dequeue(elem, type);
        };
      if (fn === 'inprogress') {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === 'fx') {
          queue.unshift('inprogress');
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function (elem, type) {
      var key = type + 'queueHooks';
      return data_priv.get(elem, key) || data_priv.access(elem, key, {
        empty: jQuery.Callbacks('once memory').add(function () {
          data_priv.remove(elem, [
            type + 'queue',
            key
          ]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;
      if (typeof type !== 'string') {
        data = type;
        type = 'fx';
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === 'fx' && queue[0] !== 'inprogress') {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    delay: function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || 'fx';
      return this.queue(type, function (next, hooks) {
        var timeout = setTimeout(next, time);
        hooks.stop = function () {
          clearTimeout(timeout);
        };
      });
    },
    clearQueue: function (type) {
      return this.queue(type || 'fx', []);
    },
    promise: function (type, obj) {
      var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== 'string') {
        obj = type;
        type = undefined;
      }
      type = type || 'fx';
      while (i--) {
        tmp = data_priv.get(elements[i], type + 'queueHooks');
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var nodeHook, boolHook, rclass = /[\t\r\n\f]/g, rreturn = /\r/g, rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    attr: function (name, value) {
      return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    },
    prop: function (name, value) {
      return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    },
    addClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              if (cur.indexOf(' ' + clazz + ' ') < 0) {
                cur += clazz + ' ';
              }
            }
            elem.className = jQuery.trim(cur);
          }
        }
      }
      return this;
    },
    removeClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                cur = cur.replace(' ' + clazz + ' ', ' ');
              }
            }
            elem.className = value ? jQuery.trim(cur) : '';
          }
        }
      }
      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === 'boolean' && type === 'string') {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function () {
        if (type === 'string') {
          var className, i = 0, self = jQuery(this), classNames = value.match(core_rnotwhite) || [];
          while (className = classNames[i++]) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === core_strundefined || type === 'boolean') {
          if (this.className) {
            data_priv.set(this, '__className__', this.className);
          }
          this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
        }
      });
    },
    hasClass: function (selector) {
      var className = ' ' + selector + ' ', i = 0, l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    },
    val: function (value) {
      var hooks, ret, isFunction, elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = '';
        } else if (typeof val === 'number') {
          val += '';
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? '' : value + '';
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = elem.attributes.value;
          return !val || val.specified ? elem.value : elem.text;
        }
      },
      select: {
        get: function (elem) {
          var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function (elem, value) {
          var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    },
    attr: function (elem, name, value) {
      var hooks, ret, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === core_strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + '');
          return value;
        }
      } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function (elem, value) {
      var name, propName, i = 0, attrNames = value && value.match(core_rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!jQuery.support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
            var val = elem.value;
            elem.setAttribute('type', value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },
    propFix: {
      'for': 'htmlFor',
      'class': 'className'
    },
    prop: function (elem, name, value) {
      var ret, hooks, notxml, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
      } else {
        return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }
      }
    }
  });
  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
    jQuery.expr.attrHandle[name] = function (elem, name, isXML) {
      var fn = jQuery.expr.attrHandle[name], ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
      jQuery.expr.attrHandle[name] = fn;
      return ret;
    };
  });
  if (!jQuery.support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }
    };
  }
  jQuery.each([
    'tabIndex',
    'readOnly',
    'maxLength',
    'cellSpacing',
    'cellPadding',
    'rowSpan',
    'colSpan',
    'useMap',
    'frameBorder',
    'contentEditable'
  ], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  jQuery.each([
    'radio',
    'checkbox'
  ], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
        }
      }
    };
    if (!jQuery.support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute('value') === null ? 'on' : elem.value;
      };
    }
  });
  var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {
    }
  }
  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
        };
        eventHandle.elem = elem;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join('.')
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
      elem = null;
    },
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, 'events');
      }
    },
    trigger: function (event, data, elem, onlyHandlers) {
      var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = core_hasOwn.call(event, 'type') ? event.type : event, namespaces = core_hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf('.') >= 0) {
        namespaces = type.split('.');
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(':') < 0 && 'on' + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join('.');
      event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
          event.preventDefault();
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function (event) {
      event = jQuery.event.fix(event);
      var i, j, ret, matched, handleObj, handlerQueue = [], args = core_slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function (event, handlers) {
      var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== 'click') {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + ' ';
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
    fixHooks: {},
    keyHooks: {
      props: 'char charCode key keyCode'.split(' '),
      filter: function (event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
      filter: function (event, original) {
        var eventDoc, doc, body, button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }
        return event;
      }
    },
    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: { noBubble: true },
      focus: {
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: 'focusin'
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: 'focusout'
      },
      click: {
        trigger: function () {
          if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
            this.click();
            return false;
          }
        },
        _default: function (event) {
          return jQuery.nodeName(event.target, 'a');
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          if (event.result !== undefined) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function (type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function (src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!jQuery.support.focusinBubbles) {
    jQuery.each({
      focus: 'focusin',
      blur: 'focusout'
    }, function (orig, fix) {
      var attaches = 0, handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
        };
      jQuery.event.special[fix] = {
        setup: function () {
          if (attaches++ === 0) {
            document.addEventListener(orig, handler, true);
          }
        },
        teardown: function () {
          if (--attaches === 0) {
            document.removeEventListener(orig, handler, true);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function (types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === 'object') {
        if (typeof selector !== 'string') {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === 'string') {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function (event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function (types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === 'object') {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === 'function') {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var isSimple = /^.[^:#\[\.,]*$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, rneedsContext = jQuery.expr.match.needsContext, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.fn.extend({
    find: function (selector) {
      var i, ret = [], self = this, len = self.length;
      if (typeof selector !== 'string') {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + ' ' + selector : selector;
      return ret;
    },
    has: function (target) {
      var targets = jQuery(target, this), l = targets.length;
      return this.filter(function () {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    is: function (selector) {
      return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    },
    closest: function (selectors, context) {
      var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            cur = matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function (elem) {
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }
      if (typeof elem === 'string') {
        return core_indexOf.call(jQuery(elem), this[0]);
      }
      return core_indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      var set = typeof selector === 'string' ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector), all = jQuery.merge(this.get(), set);
      return this.pushStack(jQuery.unique(all));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {
    }
    return cur;
  }
  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return jQuery.dir(elem, 'parentNode');
    },
    parentsUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'parentNode', until);
    },
    next: function (elem) {
      return sibling(elem, 'nextSibling');
    },
    prev: function (elem) {
      return sibling(elem, 'previousSibling');
    },
    nextAll: function (elem) {
      return jQuery.dir(elem, 'nextSibling');
    },
    prevAll: function (elem) {
      return jQuery.dir(elem, 'previousSibling');
    },
    nextUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'nextSibling', until);
    },
    prevUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'previousSibling', until);
    },
    siblings: function (elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function (elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== 'Until') {
        selector = until;
      }
      if (selector && typeof selector === 'string') {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  jQuery.extend({
    filter: function (expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ':not(' + expr + ')';
      }
      return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    },
    dir: function (elem, dir, until) {
      var matched = [], truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function (n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }
    if (typeof qualifier === 'string') {
      if (isSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function (elem) {
      return core_indexOf.call(qualifier, elem) >= 0 !== not;
    });
  }
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, manipulation_rcheckableType = /^(?:checkbox|radio)$/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
      option: [
        1,
        '<select multiple=\'multiple\'>',
        '</select>'
      ],
      thead: [
        1,
        '<table>',
        '</table>'
      ],
      col: [
        2,
        '<table><colgroup>',
        '</colgroup></table>'
      ],
      tr: [
        2,
        '<table><tbody>',
        '</tbody></table>'
      ],
      td: [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
      ],
      _default: [
        0,
        '',
        ''
      ]
    };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  jQuery.fn.extend({
    text: function (value) {
      return jQuery.access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
      }, null, value, arguments.length);
    },
    append: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function (selector, keepData) {
      var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, 'script'));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function () {
      var elem, i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = '';
        }
      }
      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return jQuery.access(this, function (value) {
        var elem = this[0] || {}, i = 0, l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
            '',
            ''
          ])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, '<$1></$2>');
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {
          }
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var args = jQuery.map(this, function (elem) {
          return [
            elem.nextSibling,
            elem.parentNode
          ];
        }), i = 0;
      this.domManip(arguments, function (elem) {
        var next = args[i++], parent = args[i++];
        if (parent) {
          if (next && next.parentNode !== parent) {
            next = this.nextSibling;
          }
          jQuery(this).remove();
          parent.insertBefore(elem, next);
        }
      }, true);
      return i ? this : this.remove();
    },
    detach: function (selector) {
      return this.remove(selector, true);
    },
    domManip: function (args, callback, allowIntersection) {
      args = core_concat.apply([], args);
      var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
      if (isFunction || !(l <= 1 || typeof value !== 'string' || jQuery.support.checkClone || !rchecked.test(value))) {
        return this.each(function (index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback, allowIntersection);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, !allowIntersection && this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, 'script'));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                if (node.src) {
                  jQuery._evalUrl(node.src);
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: 'append',
    prependTo: 'prepend',
    insertBefore: 'before',
    insertAfter: 'after',
    replaceAll: 'replaceWith'
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        core_push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  jQuery.extend({
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!jQuery.support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, 'script');
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
      }
      return clone;
    },
    buildFragment: function (elems, context, scripts, selection) {
      var elem, tmp, tag, wrap, contains, j, i = 0, l = elems.length, fragment = context.createDocumentFragment(), nodes = [];
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === 'object') {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement('div'));
            tag = (rtagName.exec(elem) || [
              '',
              ''
            ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = '';
          }
        }
      }
      fragment.textContent = '';
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), 'script');
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || '')) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function (elems) {
      var data, elem, events, type, key, j, special = jQuery.event.special, i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (Data.accepts(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            events = Object.keys(data.events || {});
            if (events.length) {
              for (j = 0; (type = events[j]) !== undefined; j++) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    },
    _evalUrl: function (url) {
      return jQuery.ajax({
        url: url,
        type: 'GET',
        dataType: 'script',
        async: false,
        global: false,
        'throws': true
      });
    }
  });
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute('type');
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var l = elems.length, i = 0;
    for (; i < l; i++) {
      data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === 'input' && manipulation_rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === 'input' || nodeName === 'textarea') {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function () {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = jQuery(this), contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function () {
      return this.parent().each(function () {
        if (!jQuery.nodeName(this, 'body')) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  var curCSS, iframe, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp('^(' + core_pnum + ')(.*)$', 'i'), rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i'), rrelNum = new RegExp('^([+-])=(' + core_pnum + ')', 'i'), elemdisplay = { BODY: 'block' }, cssShow = {
      position: 'absolute',
      visibility: 'hidden',
      display: 'block'
    }, cssNormalTransform = {
      letterSpacing: 0,
      fontWeight: 400
    }, cssExpand = [
      'Top',
      'Right',
      'Bottom',
      'Left'
    ], cssPrefixes = [
      'Webkit',
      'O',
      'Moz',
      'ms'
    ];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function isHidden(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
  }
  function getStyles(elem) {
    return window.getComputedStyle(elem, null);
  }
  function showHide(elements, show) {
    var display, elem, hidden, values = [], index = 0, length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, 'olddisplay');
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === 'none') {
          elem.style.display = '';
        }
        if (elem.style.display === '' && isHidden(elem)) {
          values[index] = data_priv.access(elem, 'olddisplay', css_defaultDisplay(elem.nodeName));
        }
      } else {
        if (!values[index]) {
          hidden = isHidden(elem);
          if (display && display !== 'none' || !hidden) {
            data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
          }
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === 'none' || elem.style.display === '') {
        elem.style.display = show ? values[index] || '' : 'none';
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    css: function (name, value) {
      return jQuery.access(this, function (elem, name, value) {
        var styles, len, map = {}, i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === 'boolean') {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            var ret = curCSS(elem, 'opacity');
            return ret === '' ? '1' : ret;
          }
        }
      }
    },
    cssNumber: {
      'columnCount': true,
      'fillOpacity': true,
      'fontWeight': true,
      'lineHeight': true,
      'opacity': true,
      'order': true,
      'orphans': true,
      'widows': true,
      'zIndex': true,
      'zoom': true
    },
    cssProps: { 'float': 'cssFloat' },
    style: function (elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === 'string' && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = 'number';
        }
        if (value == null || type === 'number' && isNaN(value)) {
          return;
        }
        if (type === 'number' && !jQuery.cssNumber[origName]) {
          value += 'px';
        }
        if (!jQuery.support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
          style[name] = 'inherit';
        }
        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val, num, hooks, origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && 'get' in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === 'normal' && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === '' || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  curCSS = function (elem, name, _computed) {
    var width, minWidth, maxWidth, computed = _computed || getStyles(elem), ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined, style = elem.style;
    if (computed) {
      if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret;
  };
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
    for (; i < 4; i += 2) {
      if (extra === 'margin') {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === 'content') {
          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        }
        if (extra !== 'margin') {
          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      } else {
        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        if (extra !== 'padding') {
          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
  }
  function css_defaultDisplay(nodeName) {
    var doc = document, display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === 'none' || !display) {
        iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>').css('cssText', 'display:block !important')).appendTo(doc.documentElement);
        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
        doc.write('<!doctype html><html><body>');
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
    elem.remove();
    return display;
  }
  jQuery.each([
    'height',
    'width'
  ], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
      }
    };
  });
  jQuery(function () {
    if (!jQuery.support.reliableMarginRight) {
      jQuery.cssHooks.marginRight = {
        get: function (elem, computed) {
          if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
              elem,
              'marginRight'
            ]);
          }
        }
      };
    }
    if (!jQuery.support.pixelPosition && jQuery.fn.position) {
      jQuery.each([
        'top',
        'left'
      ], function (i, prop) {
        jQuery.cssHooks[prop] = {
          get: function (elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
          }
        };
      });
    }
  });
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.hidden = function (elem) {
      return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function (elem) {
      return !jQuery.expr.filters.hidden(elem);
    };
  }
  jQuery.each({
    margin: '',
    padding: '',
    border: 'Width'
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        var elements = jQuery.prop(this, 'elements');
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type;
        return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, '\r\n')
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, '\r\n')
        };
      }).get();
    }
  });
  jQuery.param = function (a, traditional) {
    var prefix, s = [], add = function (key, value) {
        value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
      };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join('&').replace(r20, '+');
  };
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === 'object') {
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
    }
  });
  var ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(), ajax_rquery = /\?/, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, _load = jQuery.fn.load, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
  try {
    ajaxLocation = location.href;
  } catch (e) {
    ajaxLocation = document.createElement('a');
    ajaxLocation.href = '';
    ajaxLocation = ajaxLocation.href;
  }
  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== 'string') {
        func = dataTypeExpression;
        dataTypeExpression = '*';
      }
      var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while (dataType = dataTypes[i++]) {
          if (dataType[0] === '+') {
            dataType = dataType.slice(1) || '*';
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {}, seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
  }
  function ajaxExtend(target, src) {
    var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== 'string' && _load) {
      return _load.apply(this, arguments);
    }
    var selector, type, response, self = this, off = url.indexOf(' ');
    if (off >= 0) {
      selector = url.slice(off);
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === 'object') {
      type = 'POST';
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: 'html',
        data: params
      }).done(function (responseText) {
        response = arguments;
        self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function (jqXHR, status) {
        self.each(callback, response || [
          jqXHR.responseText,
          status,
          jqXHR
        ]);
      });
    }
    return this;
  };
  jQuery.each([
    'ajaxStart',
    'ajaxStop',
    'ajaxComplete',
    'ajaxError',
    'ajaxSuccess',
    'ajaxSend'
  ], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: 'GET',
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
      accepts: {
        '*': allTypes,
        text: 'text/plain',
        html: 'text/html',
        xml: 'application/xml, text/xml',
        json: 'application/json, text/javascript'
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: 'responseXML',
        text: 'responseText',
        json: 'responseJSON'
      },
      converters: {
        '* text': String,
        'text html': true,
        'text json': jQuery.parseJSON,
        'text xml': jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function (target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function (url, options) {
      if (typeof url === 'object') {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
          readyState: 0,
          getResponseHeader: function (key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function () {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function (name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function (type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function (map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  statusCode[code] = [
                    statusCode[code],
                    map[code]
                  ];
                }
              } else {
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function (statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(core_rnotwhite) || [''];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
      }
      if (s.data && s.processData && typeof s.data !== 'string') {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger('ajaxStart');
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = s.url += (ajax_rquery.test(cacheURL) ? '&' : '?') + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? '&' : '?') + '_=' + ajax_nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader('Content-Type', s.contentType);
      }
      jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = 'abort';
      for (i in {
          success: 1,
          error: 1,
          complete: 1
        }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, 'No Transport');
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger('ajaxSend', [
            jqXHR,
            s
          ]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort('timeout');
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || '';
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader('Last-Modified');
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader('etag');
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === 'HEAD') {
            statusText = 'nocontent';
          } else if (status === 304) {
            statusText = 'notmodified';
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = 'error';
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + '';
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [
            success,
            statusText,
            jqXHR
          ]);
        } else {
          deferred.rejectWith(callbackContext, [
            jqXHR,
            statusText,
            error
          ]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
            jqXHR,
            s,
            isSuccess ? success : error
          ]);
        }
        completeDeferred.fireWith(callbackContext, [
          jqXHR,
          statusText
        ]);
        if (fireGlobals) {
          globalEventContext.trigger('ajaxComplete', [
            jqXHR,
            s
          ]);
          if (!--jQuery.active) {
            jQuery.event.trigger('ajaxStop');
          }
        }
      }
      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, 'json');
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, 'script');
    }
  });
  jQuery.each([
    'get',
    'post'
  ], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
    while (dataTypes[0] === '*') {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === '*') {
          current = prev;
        } else if (prev !== '*' && prev !== current) {
          conv = converters[prev + ' ' + current] || converters['* ' + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(' ');
              if (tmp[1] === current) {
                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s['throws']) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: 'parsererror',
                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: 'success',
      data: response
    };
  }
  jQuery.ajaxSetup({
    accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
    contents: { script: /(?:java|ecma)script/ },
    converters: {
      'text script': function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });
  jQuery.ajaxPrefilter('script', function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = 'GET';
    }
  });
  jQuery.ajaxTransport('script', function (s) {
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery('<script>').prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on('load error', callback = function (evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === 'error' ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: 'callback',
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + '_' + ajax_nonce++;
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
    if (jsonProp || s.dataTypes[0] === 'jsonp') {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (ajax_rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
      }
      s.converters['script json'] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + ' was not called');
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = 'json';
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };
      jqXHR.always(function () {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return 'script';
    }
  });
  jQuery.ajaxSettings.xhr = function () {
    try {
      return new XMLHttpRequest();
    } catch (e) {
    }
  };
  var xhrSupported = jQuery.ajaxSettings.xhr(), xhrSuccessStatus = {
      0: 200,
      1223: 204
    }, xhrId = 0, xhrCallbacks = {};
  if (window.ActiveXObject) {
    jQuery(window).on('unload', function () {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
      xhrCallbacks = undefined;
    });
  }
  jQuery.support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
  jQuery.support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback;
    if (jQuery.support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function (headers, complete) {
          var i, id, xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function (type) {
            return function () {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === 'abort') {
                  xhr.abort();
                } else if (type === 'error') {
                  complete(xhr.status || 404, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback('error');
          callback = xhrCallbacks[id = xhrId++] = callback('abort');
          xhr.send(options.hasContent && options.data || null);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + core_pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
      '*': [function (prop, value) {
          var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || '.5';
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]
    };
  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = jQuery.now();
  }
  function createTween(value, prop, animation) {
    var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        return tween;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
        delete tick.elem;
      }), tick = function () {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [
          animation,
          percent,
          remaining
        ]);
        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      }, animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, { specialEasing: {} }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0, length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.resolveWith(elem, [
              animation,
              gotoEnd
            ]);
          } else {
            deferred.rejectWith(elem, [
              animation,
              gotoEnd
            ]);
          }
          return this;
        }
      }), props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && 'expand' in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ['*'];
      } else {
        props = props.split(' ');
      }
      var prop, index = 0, length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function (callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  function defaultPrefilter(elem, props, opts) {
    var prop, value, toggle, tween, hooks, oldfire, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, 'fx');
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, 'fx').length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
      opts.overflow = [
        style.overflow,
        style.overflowX,
        style.overflowY
      ];
      if (jQuery.css(elem, 'display') === 'inline' && jQuery.css(elem, 'float') === 'none') {
        style.display = 'inline-block';
      }
    }
    if (opts.overflow) {
      style.overflow = 'hidden';
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === 'toggle';
        if (value === (hidden ? 'hide' : 'show')) {
          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ('hidden' in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, 'fxshow', {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }
      anim.done(function () {
        var prop;
        data_priv.remove(elem, 'fxshow');
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
          }
        }
      }
    }
  }
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || 'swing';
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased, hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, '');
        return !result || result === 'auto' ? 0 : result;
      },
      set: function (tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.each([
    'toggle',
    'show',
    'hide'
  ], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || data_priv.get(this, 'finish')) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== 'string') {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || 'fx', []);
      }
      return this.each(function () {
        var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || 'fx';
      }
      return this.each(function () {
        var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  function genFx(type, includeWidth) {
    var which, attrs = { height: type }, i = 0;
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs['margin' + which] = attrs['padding' + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  jQuery.each({
    slideDown: genFx('show'),
    slideUp: genFx('hide'),
    slideToggle: genFx('toggle'),
    fadeIn: { opacity: 'show' },
    fadeOut: { opacity: 'hide' },
    fadeToggle: { opacity: 'toggle' }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
      };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = 'fx';
    }
    opt.old = opt.complete;
    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.timers = [];
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.tick = function () {
    var timer, timers = jQuery.timers, i = 0;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function (timer) {
    if (timer() && jQuery.timers.push(timer)) {
      jQuery.fx.start();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fx.step = {};
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };
  }
  jQuery.fn.offset = function (options) {
    if (arguments.length) {
      return options === undefined ? this : this.each(function (i) {
        jQuery.offset.setOffset(this, options, i);
      });
    }
    var docElem, win, elem = this[0], box = {
        top: 0,
        left: 0
      }, doc = elem && elem.ownerDocument;
    if (!doc) {
      return;
    }
    docElem = doc.documentElement;
    if (!jQuery.contains(docElem, elem)) {
      return box;
    }
    if (typeof elem.getBoundingClientRect !== core_strundefined) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow(doc);
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  };
  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
      if (position === 'static') {
        elem.style.position = 'relative';
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, 'top');
      curCSSLeft = jQuery.css(elem, 'left');
      calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ('using' in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    position: function () {
      if (!this[0]) {
        return;
      }
      var offsetParent, offset, elem = this[0], parentOffset = {
          top: 0,
          left: 0
        };
      if (jQuery.css(elem, 'position') === 'fixed') {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], 'html')) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: 'pageXOffset',
    scrollTop: 'pageYOffset'
  }, function (method, prop) {
    var top = 'pageYOffset' === prop;
    jQuery.fn[method] = function (val) {
      return jQuery.access(this, function (elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.each({
    Height: 'height',
    Width: 'width'
  }, function (name, type) {
    jQuery.each({
      padding: 'inner' + name,
      content: type,
      '': 'outer' + name
    }, function (defaultExtra, funcName) {
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
        return jQuery.access(this, function (elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement['client' + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function () {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof module === 'object' && module && typeof module.exports === 'object') {
    module.exports = jQuery;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jquery', [], function () {
        return jQuery;
      });
    }
  }
  if (typeof window === 'object' && typeof window.document === 'object') {
    window.jQuery = window.$ = jQuery;
  }
}(window));
(function () {
  var COMPILED = !0, goog = goog || {};
  goog.global = this;
  goog.exportPath_ = function (a, b, c) {
    a = a.split('.');
    c = c || goog.global;
    a[0] in c || !c.execScript || c.execScript('var ' + a[0]);
    for (var d; a.length && (d = a.shift());)
      a.length || void 0 === b ? c = c[d] ? c[d] : c[d] = {} : c[d] = b;
  };
  goog.define = function (a, b) {
    var c = b;
    COMPILED || goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]);
    goog.exportPath_(a, c);
  };
  goog.DEBUG = !1;
  goog.LOCALE = 'en';
  goog.TRUSTED_SITE = !0;
  goog.provide = function (a) {
    if (!COMPILED) {
      if (goog.isProvided_(a))
        throw Error('Namespace "' + a + '" already declared.');
      delete goog.implicitNamespaces_[a];
      for (var b = a; (b = b.substring(0, b.lastIndexOf('.'))) && !goog.getObjectByName(b);)
        goog.implicitNamespaces_[b] = !0;
    }
    goog.exportPath_(a);
  };
  goog.setTestOnly = function (a) {
    if (COMPILED && !goog.DEBUG)
      throw a = a || '', Error('Importing test-only code into non-debug environment' + a ? ': ' + a : '.');
  };
  COMPILED || (goog.isProvided_ = function (a) {
    return !goog.implicitNamespaces_[a] && !!goog.getObjectByName(a);
  }, goog.implicitNamespaces_ = {});
  goog.getObjectByName = function (a, b) {
    for (var c = a.split('.'), d = b || goog.global, e; e = c.shift();)
      if (goog.isDefAndNotNull(d[e]))
        d = d[e];
      else
        return null;
    return d;
  };
  goog.globalize = function (a, b) {
    var c = b || goog.global, d;
    for (d in a)
      c[d] = a[d];
  };
  goog.addDependency = function (a, b, c) {
    if (goog.DEPENDENCIES_ENABLED) {
      var d;
      a = a.replace(/\\/g, '/');
      for (var e = goog.dependencies_, f = 0; d = b[f]; f++)
        e.nameToPath[d] = a, a in e.pathToNames || (e.pathToNames[a] = {}), e.pathToNames[a][d] = !0;
      for (d = 0; b = c[d]; d++)
        a in e.requires || (e.requires[a] = {}), e.requires[a][b] = !0;
    }
  };
  goog.ENABLE_DEBUG_LOADER = !0;
  goog.require = function (a) {
    if (!COMPILED && !goog.isProvided_(a)) {
      if (goog.ENABLE_DEBUG_LOADER) {
        var b = goog.getPathFromDeps_(a);
        if (b) {
          goog.included_[b] = !0;
          goog.writeScripts_();
          return;
        }
      }
      a = 'goog.require could not find: ' + a;
      goog.global.console && goog.global.console.error(a);
      throw Error(a);
    }
  };
  goog.basePath = '';
  goog.nullFunction = function () {
  };
  goog.identityFunction = function (a, b) {
    return a;
  };
  goog.abstractMethod = function () {
    throw Error('unimplemented abstract method');
  };
  goog.addSingletonGetter = function (a) {
    a.getInstance = function () {
      if (a.instance_)
        return a.instance_;
      goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
      return a.instance_ = new a();
    };
  };
  goog.instantiatedSingletons_ = [];
  goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
  goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {
    pathToNames: {},
    nameToPath: {},
    requires: {},
    visited: {},
    written: {}
  }, goog.inHtmlDocument_ = function () {
    var a = goog.global.document;
    return 'undefined' != typeof a && 'write' in a;
  }, goog.findBasePath_ = function () {
    if (goog.global.CLOSURE_BASE_PATH)
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
    else if (goog.inHtmlDocument_())
      for (var a = goog.global.document.getElementsByTagName('script'), b = a.length - 1; 0 <= b; --b) {
        var c = a[b].src, d = c.lastIndexOf('?'), d = -1 == d ? c.length : d;
        if ('base.js' == c.substr(d - 7, 7)) {
          goog.basePath = c.substr(0, d - 7);
          break;
        }
      }
  }, goog.importScript_ = function (a) {
    var b = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    !goog.dependencies_.written[a] && b(a) && (goog.dependencies_.written[a] = !0);
  }, goog.writeScriptTag_ = function (a) {
    if (goog.inHtmlDocument_()) {
      var b = goog.global.document;
      if ('complete' == b.readyState) {
        if (/\bdeps.js$/.test(a))
          return !1;
        throw Error('Cannot write "' + a + '" after document load');
      }
      b.write('<script type="text/javascript" src="' + a + '"></script>');
      return !0;
    }
    return !1;
  }, goog.writeScripts_ = function () {
    function a(e) {
      if (!(e in d.written)) {
        if (!(e in d.visited) && (d.visited[e] = !0, e in d.requires))
          for (var g in d.requires[e])
            if (!goog.isProvided_(g))
              if (g in d.nameToPath)
                a(d.nameToPath[g]);
              else
                throw Error('Undefined nameToPath for ' + g);
        e in c || (c[e] = !0, b.push(e));
      }
    }
    var b = [], c = {}, d = goog.dependencies_, e;
    for (e in goog.included_)
      d.written[e] || a(e);
    for (e = 0; e < b.length; e++)
      if (b[e])
        goog.importScript_(goog.basePath + b[e]);
      else
        throw Error('Undefined script input');
  }, goog.getPathFromDeps_ = function (a) {
    return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
  }, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + 'deps.js'));
  goog.typeOf = function (a) {
    var b = typeof a;
    if ('object' == b)
      if (a) {
        if (a instanceof Array)
          return 'array';
        if (a instanceof Object)
          return b;
        var c = Object.prototype.toString.call(a);
        if ('[object Window]' == c)
          return 'object';
        if ('[object Array]' == c || 'number' == typeof a.length && 'undefined' != typeof a.splice && 'undefined' != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable('splice'))
          return 'array';
        if ('[object Function]' == c || 'undefined' != typeof a.call && 'undefined' != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable('call'))
          return 'function';
      } else
        return 'null';
    else if ('function' == b && 'undefined' == typeof a.call)
      return 'object';
    return b;
  };
  goog.isDef = function (a) {
    return void 0 !== a;
  };
  goog.isNull = function (a) {
    return null === a;
  };
  goog.isDefAndNotNull = function (a) {
    return null != a;
  };
  goog.isArray = function (a) {
    return 'array' == goog.typeOf(a);
  };
  goog.isArrayLike = function (a) {
    var b = goog.typeOf(a);
    return 'array' == b || 'object' == b && 'number' == typeof a.length;
  };
  goog.isDateLike = function (a) {
    return goog.isObject(a) && 'function' == typeof a.getFullYear;
  };
  goog.isString = function (a) {
    return 'string' == typeof a;
  };
  goog.isBoolean = function (a) {
    return 'boolean' == typeof a;
  };
  goog.isNumber = function (a) {
    return 'number' == typeof a;
  };
  goog.isFunction = function (a) {
    return 'function' == goog.typeOf(a);
  };
  goog.isObject = function (a) {
    var b = typeof a;
    return 'object' == b && null != a || 'function' == b;
  };
  goog.getUid = function (a) {
    return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
  };
  goog.removeUid = function (a) {
    'removeAttribute' in a && a.removeAttribute(goog.UID_PROPERTY_);
    try {
      delete a[goog.UID_PROPERTY_];
    } catch (b) {
    }
  };
  goog.UID_PROPERTY_ = 'closure_uid_' + (1000000000 * Math.random() >>> 0);
  goog.uidCounter_ = 0;
  goog.getHashCode = goog.getUid;
  goog.removeHashCode = goog.removeUid;
  goog.cloneObject = function (a) {
    var b = goog.typeOf(a);
    if ('object' == b || 'array' == b) {
      if (a.clone)
        return a.clone();
      var b = 'array' == b ? [] : {}, c;
      for (c in a)
        b[c] = goog.cloneObject(a[c]);
      return b;
    }
    return a;
  };
  goog.bindNative_ = function (a, b, c) {
    return a.call.apply(a.bind, arguments);
  };
  goog.bindJs_ = function (a, b, c) {
    if (!a)
      throw Error();
    if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);
      return function () {
        var c = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(c, d);
        return a.apply(b, c);
      };
    }
    return function () {
      return a.apply(b, arguments);
    };
  };
  goog.bind = function (a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf('native code') ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
    return goog.bind.apply(null, arguments);
  };
  goog.partial = function (a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function () {
      var b = Array.prototype.slice.call(arguments);
      b.unshift.apply(b, c);
      return a.apply(this, b);
    };
  };
  goog.mixin = function (a, b) {
    for (var c in b)
      a[c] = b[c];
  };
  goog.now = goog.TRUSTED_SITE && Date.now || function () {
    return +new Date();
  };
  goog.globalEval = function (a) {
    if (goog.global.execScript)
      goog.global.execScript(a, 'JavaScript');
    else if (goog.global.eval)
      if (null == goog.evalWorksForGlobals_ && (goog.global.eval('var _et_ = 1;'), 'undefined' != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_)
        goog.global.eval(a);
      else {
        var b = goog.global.document, c = b.createElement('script');
        c.type = 'text/javascript';
        c.defer = !1;
        c.appendChild(b.createTextNode(a));
        b.body.appendChild(c);
        b.body.removeChild(c);
      }
    else
      throw Error('goog.globalEval not available');
  };
  goog.evalWorksForGlobals_ = null;
  goog.getCssName = function (a, b) {
    var c = function (a) {
        return goog.cssNameMapping_[a] || a;
      }, d = function (a) {
        a = a.split('-');
        for (var b = [], d = 0; d < a.length; d++)
          b.push(c(a[d]));
        return b.join('-');
      }, d = goog.cssNameMapping_ ? 'BY_WHOLE' == goog.cssNameMappingStyle_ ? c : d : function (a) {
        return a;
      };
    return b ? a + '-' + d(b) : d(a);
  };
  goog.setCssNameMapping = function (a, b) {
    goog.cssNameMapping_ = a;
    goog.cssNameMappingStyle_ = b;
  };
  !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
  goog.getMsg = function (a, b) {
    var c = b || {}, d;
    for (d in c) {
      var e = ('' + c[d]).replace(/\$/g, '$$$$');
      a = a.replace(RegExp('\\{\\$' + d + '\\}', 'gi'), e);
    }
    return a;
  };
  goog.getMsgWithFallback = function (a, b) {
    return a;
  };
  goog.exportSymbol = function (a, b, c) {
    goog.exportPath_(a, b, c);
  };
  goog.exportProperty = function (a, b, c) {
    a[b] = c;
  };
  goog.inherits = function (a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c();
    a.prototype.constructor = a;
  };
  goog.base = function (a, b, c) {
    var d = arguments.callee.caller;
    if (goog.DEBUG && !d)
      throw Error('arguments.caller not defined.  goog.base() expects not to be running in strict mode. See http://www.ecma-international.org/ecma-262/5.1/#sec-C');
    if (d.superClass_)
      return d.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var e = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
      if (g.prototype[b] === d)
        f = !0;
      else if (f)
        return g.prototype[b].apply(a, e);
    if (a[b] === d)
      return a.constructor.prototype[b].apply(a, e);
    throw Error('goog.base called from a method of one name to a method of a different name');
  };
  goog.scope = function (a) {
    a.call(goog.global);
  };
  goog.string = {};
  goog.string.Unicode = { NBSP: '\xa0' };
  goog.string.startsWith = function (a, b) {
    return 0 == a.lastIndexOf(b, 0);
  };
  goog.string.endsWith = function (a, b) {
    var c = a.length - b.length;
    return 0 <= c && a.indexOf(b, c) == c;
  };
  goog.string.caseInsensitiveStartsWith = function (a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(0, b.length));
  };
  goog.string.caseInsensitiveEndsWith = function (a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(a.length - b.length, b.length));
  };
  goog.string.caseInsensitiveEquals = function (a, b) {
    return a.toLowerCase() == b.toLowerCase();
  };
  goog.string.subs = function (a, b) {
    for (var c = a.split('%s'), d = '', e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length;)
      d += c.shift() + e.shift();
    return d + c.join('%s');
  };
  goog.string.collapseWhitespace = function (a) {
    return a.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
  };
  goog.string.isEmpty = function (a) {
    return /^[\s\xa0]*$/.test(a);
  };
  goog.string.isEmptySafe = function (a) {
    return goog.string.isEmpty(goog.string.makeSafe(a));
  };
  goog.string.isBreakingWhitespace = function (a) {
    return !/[^\t\n\r ]/.test(a);
  };
  goog.string.isAlpha = function (a) {
    return !/[^a-zA-Z]/.test(a);
  };
  goog.string.isNumeric = function (a) {
    return !/[^0-9]/.test(a);
  };
  goog.string.isAlphaNumeric = function (a) {
    return !/[^a-zA-Z0-9]/.test(a);
  };
  goog.string.isSpace = function (a) {
    return ' ' == a;
  };
  goog.string.isUnicodeChar = function (a) {
    return 1 == a.length && ' ' <= a && '~' >= a || '\x80' <= a && '\ufffd' >= a;
  };
  goog.string.stripNewlines = function (a) {
    return a.replace(/(\r\n|\r|\n)+/g, ' ');
  };
  goog.string.canonicalizeNewlines = function (a) {
    return a.replace(/(\r\n|\r|\n)/g, '\n');
  };
  goog.string.normalizeWhitespace = function (a) {
    return a.replace(/\xa0|\s/g, ' ');
  };
  goog.string.normalizeSpaces = function (a) {
    return a.replace(/\xa0|[ \t]+/g, ' ');
  };
  goog.string.collapseBreakingSpaces = function (a) {
    return a.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
  };
  goog.string.trim = function (a) {
    return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
  };
  goog.string.trimLeft = function (a) {
    return a.replace(/^[\s\xa0]+/, '');
  };
  goog.string.trimRight = function (a) {
    return a.replace(/[\s\xa0]+$/, '');
  };
  goog.string.caseInsensitiveCompare = function (a, b) {
    var c = String(a).toLowerCase(), d = String(b).toLowerCase();
    return c < d ? -1 : c == d ? 0 : 1;
  };
  goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
  goog.string.numerateCompare = function (a, b) {
    if (a == b)
      return 0;
    if (!a)
      return -1;
    if (!b)
      return 1;
    for (var c = a.toLowerCase().match(goog.string.numerateCompareRegExp_), d = b.toLowerCase().match(goog.string.numerateCompareRegExp_), e = Math.min(c.length, d.length), f = 0; f < e; f++) {
      var g = c[f], h = d[f];
      if (g != h)
        return c = parseInt(g, 10), !isNaN(c) && (d = parseInt(h, 10), !isNaN(d) && c - d) ? c - d : g < h ? -1 : 1;
    }
    return c.length != d.length ? c.length - d.length : a < b ? -1 : 1;
  };
  goog.string.urlEncode = function (a) {
    return encodeURIComponent(String(a));
  };
  goog.string.urlDecode = function (a) {
    return decodeURIComponent(a.replace(/\+/g, ' '));
  };
  goog.string.newLineToBr = function (a, b) {
    return a.replace(/(\r\n|\r|\n)/g, b ? '<br />' : '<br>');
  };
  goog.string.htmlEscape = function (a, b) {
    if (b)
      return a.replace(goog.string.amperRe_, '&amp;').replace(goog.string.ltRe_, '&lt;').replace(goog.string.gtRe_, '&gt;').replace(goog.string.quotRe_, '&quot;');
    if (!goog.string.allRe_.test(a))
      return a;
    -1 != a.indexOf('&') && (a = a.replace(goog.string.amperRe_, '&amp;'));
    -1 != a.indexOf('<') && (a = a.replace(goog.string.ltRe_, '&lt;'));
    -1 != a.indexOf('>') && (a = a.replace(goog.string.gtRe_, '&gt;'));
    -1 != a.indexOf('"') && (a = a.replace(goog.string.quotRe_, '&quot;'));
    return a;
  };
  goog.string.amperRe_ = /&/g;
  goog.string.ltRe_ = /</g;
  goog.string.gtRe_ = />/g;
  goog.string.quotRe_ = /\"/g;
  goog.string.allRe_ = /[&<>\"]/;
  goog.string.unescapeEntities = function (a) {
    return goog.string.contains(a, '&') ? 'document' in goog.global ? goog.string.unescapeEntitiesUsingDom_(a) : goog.string.unescapePureXmlEntities_(a) : a;
  };
  goog.string.unescapeEntitiesUsingDom_ = function (a) {
    var b = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"'
      }, c = document.createElement('div');
    return a.replace(goog.string.HTML_ENTITY_PATTERN_, function (a, e) {
      var f = b[a];
      if (f)
        return f;
      if ('#' == e.charAt(0)) {
        var g = Number('0' + e.substr(1));
        isNaN(g) || (f = String.fromCharCode(g));
      }
      f || (c.innerHTML = a + ' ', f = c.firstChild.nodeValue.slice(0, -1));
      return b[a] = f;
    });
  };
  goog.string.unescapePureXmlEntities_ = function (a) {
    return a.replace(/&([^;]+);/g, function (a, c) {
      switch (c) {
      case 'amp':
        return '&';
      case 'lt':
        return '<';
      case 'gt':
        return '>';
      case 'quot':
        return '"';
      default:
        if ('#' == c.charAt(0)) {
          var d = Number('0' + c.substr(1));
          if (!isNaN(d))
            return String.fromCharCode(d);
        }
        return a;
      }
    });
  };
  goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
  goog.string.whitespaceEscape = function (a, b) {
    return goog.string.newLineToBr(a.replace(/  /g, ' &#160;'), b);
  };
  goog.string.stripQuotes = function (a, b) {
    for (var c = b.length, d = 0; d < c; d++) {
      var e = 1 == c ? b : b.charAt(d);
      if (a.charAt(0) == e && a.charAt(a.length - 1) == e)
        return a.substring(1, a.length - 1);
    }
    return a;
  };
  goog.string.truncate = function (a, b, c) {
    c && (a = goog.string.unescapeEntities(a));
    a.length > b && (a = a.substring(0, b - 3) + '...');
    c && (a = goog.string.htmlEscape(a));
    return a;
  };
  goog.string.truncateMiddle = function (a, b, c, d) {
    c && (a = goog.string.unescapeEntities(a));
    if (d && a.length > b) {
      d > b && (d = b);
      var e = a.length - d;
      a = a.substring(0, b - d) + '...' + a.substring(e);
    } else
      a.length > b && (d = Math.floor(b / 2), e = a.length - d, a = a.substring(0, d + b % 2) + '...' + a.substring(e));
    c && (a = goog.string.htmlEscape(a));
    return a;
  };
  goog.string.specialEscapeChars_ = {
    '\0': '\\0',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
    '\x0B': '\\x0B',
    '"': '\\"',
    '\\': '\\\\'
  };
  goog.string.jsEscapeCache_ = { '\'': '\\\'' };
  goog.string.quote = function (a) {
    a = String(a);
    if (a.quote)
      return a.quote();
    for (var b = ['"'], c = 0; c < a.length; c++) {
      var d = a.charAt(c), e = d.charCodeAt(0);
      b[c + 1] = goog.string.specialEscapeChars_[d] || (31 < e && 127 > e ? d : goog.string.escapeChar(d));
    }
    b.push('"');
    return b.join('');
  };
  goog.string.escapeString = function (a) {
    for (var b = [], c = 0; c < a.length; c++)
      b[c] = goog.string.escapeChar(a.charAt(c));
    return b.join('');
  };
  goog.string.escapeChar = function (a) {
    if (a in goog.string.jsEscapeCache_)
      return goog.string.jsEscapeCache_[a];
    if (a in goog.string.specialEscapeChars_)
      return goog.string.jsEscapeCache_[a] = goog.string.specialEscapeChars_[a];
    var b = a, c = a.charCodeAt(0);
    if (31 < c && 127 > c)
      b = a;
    else {
      if (256 > c) {
        if (b = '\\x', 16 > c || 256 < c)
          b += '0';
      } else
        b = '\\u', 4096 > c && (b += '0');
      b += c.toString(16).toUpperCase();
    }
    return goog.string.jsEscapeCache_[a] = b;
  };
  goog.string.toMap = function (a) {
    for (var b = {}, c = 0; c < a.length; c++)
      b[a.charAt(c)] = !0;
    return b;
  };
  goog.string.contains = function (a, b) {
    return -1 != a.indexOf(b);
  };
  goog.string.countOf = function (a, b) {
    return a && b ? a.split(b).length - 1 : 0;
  };
  goog.string.removeAt = function (a, b, c) {
    var d = a;
    0 <= b && (b < a.length && 0 < c) && (d = a.substr(0, b) + a.substr(b + c, a.length - b - c));
    return d;
  };
  goog.string.remove = function (a, b) {
    var c = RegExp(goog.string.regExpEscape(b), '');
    return a.replace(c, '');
  };
  goog.string.removeAll = function (a, b) {
    var c = RegExp(goog.string.regExpEscape(b), 'g');
    return a.replace(c, '');
  };
  goog.string.regExpEscape = function (a) {
    return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
  };
  goog.string.repeat = function (a, b) {
    return Array(b + 1).join(a);
  };
  goog.string.padNumber = function (a, b, c) {
    a = goog.isDef(c) ? a.toFixed(c) : String(a);
    c = a.indexOf('.');
    -1 == c && (c = a.length);
    return goog.string.repeat('0', Math.max(0, b - c)) + a;
  };
  goog.string.makeSafe = function (a) {
    return null == a ? '' : String(a);
  };
  goog.string.buildString = function (a) {
    return Array.prototype.join.call(arguments, '');
  };
  goog.string.getRandomString = function () {
    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);
  };
  goog.string.compareVersions = function (a, b) {
    for (var c = 0, d = goog.string.trim(String(a)).split('.'), e = goog.string.trim(String(b)).split('.'), f = Math.max(d.length, e.length), g = 0; 0 == c && g < f; g++) {
      var h = d[g] || '', k = e[g] || '', l = /(\d*)(\D*)/g, m = /(\d*)(\D*)/g;
      do {
        var n = l.exec(h) || [
            '',
            '',
            ''
          ], p = m.exec(k) || [
            '',
            '',
            ''
          ];
        if (0 == n[0].length && 0 == p[0].length)
          break;
        var c = 0 == n[1].length ? 0 : parseInt(n[1], 10), q = 0 == p[1].length ? 0 : parseInt(p[1], 10), c = goog.string.compareElements_(c, q) || goog.string.compareElements_(0 == n[2].length, 0 == p[2].length) || goog.string.compareElements_(n[2], p[2]);
      } while (0 == c);
    }
    return c;
  };
  goog.string.compareElements_ = function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  };
  goog.string.HASHCODE_MAX_ = 4294967296;
  goog.string.hashCode = function (a) {
    for (var b = 0, c = 0; c < a.length; ++c)
      b = 31 * b + a.charCodeAt(c), b %= goog.string.HASHCODE_MAX_;
    return b;
  };
  goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;
  goog.string.createUniqueString = function () {
    return 'goog_' + goog.string.uniqueStringCounter_++;
  };
  goog.string.toNumber = function (a) {
    var b = Number(a);
    return 0 == b && goog.string.isEmpty(a) ? NaN : b;
  };
  goog.string.isLowerCamelCase = function (a) {
    return /^[a-z]+([A-Z][a-z]*)*$/.test(a);
  };
  goog.string.isUpperCamelCase = function (a) {
    return /^([A-Z][a-z]*)+$/.test(a);
  };
  goog.string.toCamelCase = function (a) {
    return String(a).replace(/\-([a-z])/g, function (a, c) {
      return c.toUpperCase();
    });
  };
  goog.string.toSelectorCase = function (a) {
    return String(a).replace(/([A-Z])/g, '-$1').toLowerCase();
  };
  goog.string.toTitleCase = function (a, b) {
    var c = goog.isString(b) ? goog.string.regExpEscape(b) : '\\s';
    return a.replace(RegExp('(^' + (c ? '|[' + c + ']+' : '') + ')([a-z])', 'g'), function (a, b, c) {
      return b + c.toUpperCase();
    });
  };
  goog.string.parseInt = function (a) {
    isFinite(a) && (a = String(a));
    return goog.isString(a) ? /^\s*-?0x/i.test(a) ? parseInt(a, 16) : parseInt(a, 10) : NaN;
  };
  goog.string.splitLimit = function (a, b, c) {
    a = a.split(b);
    for (var d = []; 0 < c && a.length;)
      d.push(a.shift()), c--;
    a.length && d.push(a.join(b));
    return d;
  };
  goog.debug = {};
  goog.debug.Error = function (a) {
    Error.captureStackTrace ? Error.captureStackTrace(this, goog.debug.Error) : this.stack = Error().stack || '';
    a && (this.message = String(a));
  };
  goog.inherits(goog.debug.Error, Error);
  goog.debug.Error.prototype.name = 'CustomError';
  goog.asserts = {};
  goog.asserts.ENABLE_ASSERTS = goog.DEBUG;
  goog.asserts.AssertionError = function (a, b) {
    b.unshift(a);
    goog.debug.Error.call(this, goog.string.subs.apply(null, b));
    b.shift();
    this.messagePattern = a;
  };
  goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
  goog.asserts.AssertionError.prototype.name = 'AssertionError';
  goog.asserts.doAssertFailure_ = function (a, b, c, d) {
    var e = 'Assertion failed';
    if (c)
      var e = e + (': ' + c), f = d;
    else
      a && (e += ': ' + a, f = b);
    throw new goog.asserts.AssertionError('' + e, f || []);
  };
  goog.asserts.assert = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !a && goog.asserts.doAssertFailure_('', null, b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.fail = function (a, b) {
    if (goog.asserts.ENABLE_ASSERTS)
      throw new goog.asserts.AssertionError('Failure' + (a ? ': ' + a : ''), Array.prototype.slice.call(arguments, 1));
  };
  goog.asserts.assertNumber = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isNumber(a) && goog.asserts.doAssertFailure_('Expected number but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertString = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isString(a) && goog.asserts.doAssertFailure_('Expected string but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertFunction = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isFunction(a) && goog.asserts.doAssertFailure_('Expected function but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertObject = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isObject(a) && goog.asserts.doAssertFailure_('Expected object but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertArray = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isArray(a) && goog.asserts.doAssertFailure_('Expected array but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertBoolean = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(a) && goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertInstanceof = function (a, b, c, d) {
    !goog.asserts.ENABLE_ASSERTS || a instanceof b || goog.asserts.doAssertFailure_('instanceof check failed.', null, c, Array.prototype.slice.call(arguments, 3));
    return a;
  };
  goog.asserts.assertObjectPrototypeIsIntact = function () {
    for (var a in Object.prototype)
      goog.asserts.fail(a + ' should not be enumerable in Object.prototype.');
  };
  var Sk = Sk || {};
  Sk.configure = function (a) {
    Sk.output = a.output || Sk.output;
    goog.asserts.assert('function' === typeof Sk.output);
    Sk.debugout = a.debugout || Sk.debugout;
    goog.asserts.assert('function' === typeof Sk.debugout);
    Sk.read = a.read || Sk.read;
    goog.asserts.assert('function' === typeof Sk.read);
    Sk.timeoutMsg = a.timeoutMsg || Sk.timeoutMsg;
    goog.asserts.assert('function' === typeof Sk.timeoutMsg);
    goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
    Sk.sysargv = a.sysargv || Sk.sysargv;
    goog.asserts.assert(goog.isArrayLike(Sk.sysargv));
    Sk.python3 = a.python3 || Sk.python3;
    goog.asserts.assert('boolean' === typeof Sk.python3);
    Sk.inputfun = a.inputfun || Sk.inputfun;
    goog.asserts.assert('function' === typeof Sk.inputfun);
    Sk.throwSystemExit = a.systemexit || !1;
    goog.asserts.assert('boolean' === typeof Sk.throwSystemExit);
    a.syspath && (Sk.syspath = a.syspath, goog.asserts.assert(goog.isArrayLike(Sk.syspath)), Sk.realsyspath = void 0, Sk.sysmodules = new Sk.builtin.dict([]));
    Sk.misceval.softspace_ = !1;
  };
  goog.exportSymbol('Sk.configure', Sk.configure);
  Sk.timeoutMsg = function () {
    return 'Program exceeded run time limit.';
  };
  goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
  Sk.output = function (a) {
  };
  Sk.read = function (a) {
    throw 'Sk.read has not been implemented';
  };
  Sk.sysargv = [];
  Sk.getSysArgv = function () {
    return Sk.sysargv;
  };
  goog.exportSymbol('Sk.getSysArgv', Sk.getSysArgv);
  Sk.syspath = [];
  Sk.inBrowser = void 0 !== goog.global.document;
  Sk.debugout = function (a) {
  };
  (function () {
    void 0 !== goog.global.write ? Sk.output = goog.global.write : void 0 !== goog.global.console && void 0 !== goog.global.console.log ? Sk.output = function (a) {
      goog.global.console.log(a);
    } : void 0 !== goog.global.print && (Sk.output = goog.global.print);
    void 0 !== goog.global.print && (Sk.debugout = goog.global.print);
  }());
  Sk.inBrowser || (goog.global.CLOSURE_IMPORT_SCRIPT = function (a) {
    goog.global.eval(goog.global.read('support/closure-library/closure/goog/' + a));
    return !0;
  });
  Sk.python3 = !1;
  Sk.inputfun = function (a) {
    return prompt(a);
  };
  goog.exportSymbol('Sk.python3', Sk.python3);
  goog.exportSymbol('Sk.inputfun', Sk.inputfun);
  Sk.builtin = {};
  Sk.builtin.range = function (a, b, c) {
    var d = [], e;
    Sk.builtin.pyCheckArgs('range', arguments, 1, 3);
    Sk.builtin.pyCheckType('start', 'integer', Sk.builtin.checkInt(a));
    void 0 !== b && Sk.builtin.pyCheckType('stop', 'integer', Sk.builtin.checkInt(b));
    void 0 !== c && Sk.builtin.pyCheckType('step', 'integer', Sk.builtin.checkInt(c));
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    c = Sk.builtin.asnum$(c);
    void 0 === b && void 0 === c ? (b = a, a = 0, c = 1) : void 0 === c && (c = 1);
    if (0 === c)
      throw new Sk.builtin.ValueError('range() step argument must not be zero');
    if (0 < c)
      for (e = a; e < b; e += c)
        d.push(new Sk.builtin.nmber(e, Sk.builtin.nmber.int$));
    else
      for (e = a; e > b; e += c)
        d.push(new Sk.builtin.nmber(e, Sk.builtin.nmber.int$));
    return new Sk.builtin.list(d);
  };
  Sk.builtin.asnum$ = function (a) {
    return void 0 === a || null === a ? a : a.constructor === Sk.builtin.none ? null : a.constructor === Sk.builtin.bool ? a.v ? 1 : 0 : 'number' === typeof a ? a : 'string' === typeof a ? a : a.constructor === Sk.builtin.nmber ? a.v : a.constructor === Sk.builtin.lng ? a.cantBeInt() ? a.str$(10, !0) : a.toInt$() : a.constructor === Sk.builtin.biginteger ? 0 < a.trueCompare(new Sk.builtin.biginteger(Sk.builtin.lng.threshold$)) || 0 > a.trueCompare(new Sk.builtin.biginteger(-Sk.builtin.lng.threshold$)) ? a.toString() : a.intValue() : a;
  };
  goog.exportSymbol('Sk.builtin.asnum$', Sk.builtin.asnum$);
  Sk.builtin.assk$ = function (a, b) {
    return new Sk.builtin.nmber(a, b);
  };
  goog.exportSymbol('Sk.builtin.assk$', Sk.builtin.assk$);
  Sk.builtin.asnum$nofloat = function (a) {
    if (void 0 === a || null === a)
      return a;
    if (a.constructor === Sk.builtin.none)
      return null;
    if (a.constructor === Sk.builtin.bool)
      return a.v ? 1 : 0;
    'number' === typeof a && (a = a.toString());
    a.constructor === Sk.builtin.nmber && (a = a.v.toString());
    a.constructor === Sk.builtin.lng && (a = a.str$(10, !0));
    a.constructor === Sk.builtin.biginteger && (a = a.toString());
    if (0 > a.indexOf('.') && 0 > a.indexOf('e') && 0 > a.indexOf('E'))
      return a;
    var b = 0, c;
    0 <= a.indexOf('e') ? (c = a.substr(0, a.indexOf('e')), b = a.substr(a.indexOf('e') + 1)) : 0 <= a.indexOf('E') ? (c = a.substr(0, a.indexOf('e')), b = a.substr(a.indexOf('E') + 1)) : c = a;
    b = parseInt(b, 10);
    a = c.indexOf('.');
    if (0 > a) {
      if (0 <= b) {
        for (; 0 < b--;)
          c += '0';
        return c;
      }
      return c.length > -b ? c.substr(0, c.length + b) : 0;
    }
    c = 0 == a ? c.substr(1) : a < c.length ? c.substr(0, a) + c.substr(a + 1) : c.substr(0, a);
    for (a += b; a > c.length;)
      c += '0';
    return c = 0 >= a ? 0 : c.substr(0, a);
  };
  goog.exportSymbol('Sk.builtin.asnum$nofloat', Sk.builtin.asnum$nofloat);
  Sk.builtin.round = function (a, b) {
    var c;
    Sk.builtin.pyCheckArgs('round', arguments, 1, 2);
    if (!Sk.builtin.checkNumber(a))
      throw new Sk.builtin.TypeError('a float is required');
    if (void 0 !== b && !Sk.misceval.isIndex(b))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object cannot be interpreted as an index');
    void 0 === b && (b = 0);
    a = Sk.builtin.asnum$(a);
    b = Sk.misceval.asIndex(b);
    c = Math.pow(10, b);
    c = Math.round(a * c) / c;
    return new Sk.builtin.nmber(c, Sk.builtin.nmber.float$);
  };
  Sk.builtin.len = function (a) {
    Sk.builtin.pyCheckArgs('len', arguments, 1, 1);
    if (a.sq$length)
      return new Sk.builtin.nmber(a.sq$length(), Sk.builtin.nmber.int$);
    if (a.mp$length)
      return new Sk.builtin.nmber(a.mp$length(), Sk.builtin.nmber.int$);
    if (a.tp$length)
      return new Sk.builtin.nmber(a.tp$length(), Sk.builtin.nmber.int$);
    throw new Sk.builtin.TypeError('object of type \'' + Sk.abstr.typeName(a) + '\' has no len()');
  };
  Sk.builtin.min = function () {
    Sk.builtin.pyCheckArgs('min', arguments, 1);
    for (var a = Sk.misceval.arrayFromArguments(arguments), b = a[0], c = 1; c < a.length; ++c)
      Sk.misceval.richCompareBool(a[c], b, 'Lt') && (b = a[c]);
    return b;
  };
  Sk.builtin.max = function () {
    Sk.builtin.pyCheckArgs('max', arguments, 1);
    for (var a = Sk.misceval.arrayFromArguments(arguments), b = a[0], c = 1; c < a.length; ++c)
      Sk.misceval.richCompareBool(a[c], b, 'Gt') && (b = a[c]);
    return b;
  };
  Sk.builtin.any = function (a) {
    var b, c;
    Sk.builtin.pyCheckArgs('any', arguments, 1);
    if (!Sk.builtin.checkIterable(a))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not iterable');
    b = a.tp$iter();
    for (c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      if (Sk.misceval.isTrue(c))
        return !0;
    return !1;
  };
  Sk.builtin.all = function (a) {
    var b, c;
    Sk.builtin.pyCheckArgs('all', arguments, 1);
    if (!Sk.builtin.checkIterable(a))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not iterable');
    b = a.tp$iter();
    for (c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      if (!Sk.misceval.isTrue(c))
        return !1;
    return !0;
  };
  Sk.builtin.sum = function (a, b) {
    var c, d, e, f;
    Sk.builtin.pyCheckArgs('sum', arguments, 1, 2);
    Sk.builtin.pyCheckType('iter', 'iterable', Sk.builtin.checkIterable(a));
    if (void 0 !== b && Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('sum() can\'t sum strings [use \'\'.join(seq) instead]');
    c = void 0 === b ? new Sk.builtin.nmber(0, Sk.builtin.nmber.int$) : b;
    d = a.tp$iter();
    for (e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      if (e.skType === Sk.builtin.nmber.float$ ? (f = !0, c.skType !== Sk.builtin.nmber.float$ && (c = new Sk.builtin.nmber(Sk.builtin.asnum$(c), Sk.builtin.nmber.float$))) : e instanceof Sk.builtin.lng && (f || c instanceof Sk.builtin.lng || (c = new Sk.builtin.lng(c))), void 0 !== c.nb$add(e))
        c = c.nb$add(e);
      else
        throw new Sk.builtin.TypeError('unsupported operand type(s) for +: \'' + Sk.abstr.typeName(c) + '\' and \'' + Sk.abstr.typeName(e) + '\'');
    return c;
  };
  Sk.builtin.zip = function () {
    if (0 === arguments.length)
      return new Sk.builtin.list([]);
    for (var a = [], b = 0; b < arguments.length; b++)
      if (arguments[b].tp$iter)
        a.push(arguments[b].tp$iter());
      else
        throw 'TypeError: argument ' + b + ' must support iteration';
    for (var c = [], d = !1; !d;) {
      for (var e = [], b = 0; b < arguments.length; b++) {
        var f = a[b].tp$iternext();
        if (void 0 === f) {
          d = !0;
          break;
        }
        e.push(f);
      }
      d || c.push(new Sk.builtin.tuple(e));
    }
    return new Sk.builtin.list(c);
  };
  Sk.builtin.abs = function (a) {
    Sk.ffi.checkFunctionArgs('abs', arguments, 1, 1);
    if (Sk.ffi.isNum(a))
      return Sk.ffi.numberToPy(Math.abs(Sk.ffi.remapToJs(a)), Sk.ffi.getType(a));
    try {
      var b = a.__abs__;
      if (b)
        return Sk.ffi.callsim(b, a);
      throw new Sk.builtin.NotImplementedError('abs');
    } catch (c) {
      throw Sk.ffi.err.argument('x').inFunction('abs').mustHaveType('number');
    }
  };
  Sk.builtin.ord = function (a) {
    Sk.builtin.pyCheckArgs('ord', arguments, 1, 1);
    if (!Sk.builtin.checkString(a))
      throw new Sk.builtin.TypeError('ord() expected a string of length 1, but ' + Sk.abstr.typeName(a) + ' found');
    if (1 !== a.v.length)
      throw new Sk.builtin.TypeError('ord() expected a character, but string of length ' + a.v.length + ' found');
    return new Sk.builtin.nmber(a.v.charCodeAt(0), Sk.builtin.nmber.int$);
  };
  Sk.builtin.chr = function (a) {
    Sk.builtin.pyCheckArgs('chr', arguments, 1, 1);
    if (!Sk.builtin.checkInt(a))
      throw new Sk.builtin.TypeError('an integer is required');
    a = Sk.builtin.asnum$(a);
    if (0 > a || 255 < a)
      throw new Sk.builtin.ValueError('chr() arg not in range(256)');
    return new Sk.builtin.str(String.fromCharCode(a));
  };
  Sk.builtin.int2str_ = function (a, b, c) {
    var d = '';
    if (a instanceof Sk.builtin.lng) {
      var e = '';
      2 !== b && (e = 'L');
      d = a.str$(b, !1);
      return a.nb$isnegative() ? new Sk.builtin.str('-' + c + d + e) : new Sk.builtin.str(c + d + e);
    }
    a = Sk.misceval.asIndex(a);
    d = a.toString(b);
    return 0 > a ? new Sk.builtin.str('-' + c + d.slice(1)) : new Sk.builtin.str(c + d);
  };
  Sk.builtin.hex = function (a) {
    Sk.builtin.pyCheckArgs('hex', arguments, 1, 1);
    if (!Sk.misceval.isIndex(a))
      throw new Sk.builtin.TypeError('hex() argument can\'t be converted to hex');
    return Sk.builtin.int2str_(a, 16, '0x');
  };
  Sk.builtin.oct = function (a) {
    Sk.builtin.pyCheckArgs('oct', arguments, 1, 1);
    if (!Sk.misceval.isIndex(a))
      throw new Sk.builtin.TypeError('oct() argument can\'t be converted to hex');
    return Sk.builtin.int2str_(a, 8, '0');
  };
  Sk.builtin.bin = function (a) {
    Sk.builtin.pyCheckArgs('bin', arguments, 1, 1);
    if (!Sk.misceval.isIndex(a))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object can\'t be interpreted as an index');
    return Sk.builtin.int2str_(a, 2, '0b');
  };
  Sk.builtin.dir = function (a) {
    Sk.builtin.pyCheckArgs('dir', arguments, 1, 1);
    var b = function (a) {
        var b = null;
        if (-1 !== [
            '__bases__',
            '__mro__',
            '__class__'
          ].indexOf(a))
          return null;
        -1 !== a.indexOf('$') ? b = Sk.builtin.dir.slotNameToRichName(a) : '_' !== a.charAt(a.length - 1) ? b = a : '_' === a.charAt(0) && (b = a);
        return b;
      }, c = [], d, e, f, g, h;
    for (d in a.constructor.prototype)
      (e = b(d)) && c.push(new Sk.builtin.str(e));
    if (a.$d)
      if (a.$d.tp$iter)
        for (f = a.$d.tp$iter(), d = f.tp$iternext(); void 0 !== d; d = f.tp$iternext())
          e = new Sk.builtin.str(d), (e = b(e.v)) && c.push(new Sk.builtin.str(e));
      else
        for (e in a.$d)
          c.push(new Sk.builtin.str(e));
    if (f = a.tp$mro)
      for (f = a.tp$mro, d = 0; d < f.v.length; ++d)
        for (h in g = f.v[d], g)
          g.hasOwnProperty(h) && (e = b(h)) && c.push(new Sk.builtin.str(e));
    c.sort(function (a, b) {
      return (a.v > b.v) - (a.v < b.v);
    });
    return new Sk.builtin.list(c.filter(function (a, b, c) {
      return a !== c[b + 1];
    }));
  };
  Sk.builtin.dir.slotNameToRichName = function (a) {
  };
  Sk.builtin.repr = function (a) {
    Sk.builtin.pyCheckArgs('repr', arguments, 1, 1);
    return Sk.misceval.objectRepr(a);
  };
  Sk.builtin.open = function (a, b, c) {
    Sk.builtin.pyCheckArgs('open', arguments, 1, 3);
    void 0 === b && (b = new Sk.builtin.str('r'));
    if ('r' !== b.v && 'rb' !== b.v)
      throw 'todo; haven\'t implemented non-read opens';
    return new Sk.builtin.file(a, b, c);
  };
  Sk.builtin.isinstance = function (a, b) {
    Sk.builtin.pyCheckArgs('isinstance', arguments, 2, 2);
    if (!(Sk.builtin.checkClass(b) || b instanceof Sk.builtin.tuple))
      throw new Sk.builtin.TypeError('isinstance() arg 2 must be a class, type, or tuple of classes and types');
    if (b === Sk.builtin.int_.prototype.ob$type)
      return 'number' === a.tp$name && a.skType === Sk.builtin.nmber.int$;
    if (b === Sk.builtin.float_.prototype.ob$type)
      return 'number' === a.tp$name && a.skType === Sk.builtin.nmber.float$;
    if (b === Sk.builtin.none.prototype.ob$type)
      return a instanceof Sk.builtin.none;
    if (a.ob$type === b)
      return !0;
    if (b instanceof Sk.builtin.tuple) {
      for (var c = 0; c < b.v.length; ++c)
        if (Sk.builtin.isinstance(a, b.v[c]))
          return !0;
      return !1;
    }
    var d = function (a, b) {
      if (a === b)
        return !0;
      if (void 0 === a.$d)
        return !1;
      for (var c = a.$d.mp$subscript(Sk.builtin.type.basesStr_), h = 0; h < c.v.length; ++h)
        if (d(c.v[h], b))
          return !0;
      return !1;
    };
    return d(a.ob$type, b);
  };
  Sk.builtin.hashCount = 0;
  Sk.builtin.hash = function (a) {
    Sk.builtin.pyCheckArgs('hash', arguments, 1, 1);
    if (a instanceof Object && void 0 !== a.tp$hash) {
      if (a.$savedHash_)
        return a.$savedHash_;
      a.$savedHash_ = a.tp$hash();
      return a.$savedHash_;
    }
    return a instanceof Object && void 0 !== a.__hash__ ? Sk.misceval.callsim(a.__hash__, a) : a instanceof Sk.builtin.bool ? a.v ? 1 : 0 : a instanceof Sk.builtin.none ? 0 : a instanceof Object ? (void 0 === a.__id && (Sk.builtin.hashCount += 1, a.__id = Sk.builtin.hashCount), a.__id) : 'number' === typeof a ? a : null === a ? 0 : !0 === a ? 1 : !1 === a ? 0 : typeof a + ' ' + String(a);
  };
  Sk.builtin.getattr = function (a, b, c) {
    Sk.builtin.pyCheckArgs('getattr', arguments, 2, 3);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('attribute name must be string');
    var d = a.tp$getattr(b.v);
    if (void 0 === d) {
      if (void 0 !== c)
        return c;
      throw new Sk.builtin.AttributeError('\'' + Sk.abstr.typeName(a) + '\' object has no attribute \'' + b.v + '\'');
    }
    return d;
  };
  Sk.builtin.raw_input = function (a, b, c) {
    a = Sk.inputfun(a.v);
    return new Sk.builtin.str(a);
  };
  Sk.builtin.input = function (a, b, c) {
    a = Sk.inputfun(a.v);
    return new Sk.builtin.str(a);
  };
  Sk.builtin.jseval = function (a) {
    goog.global.eval(a);
  };
  Sk.builtin.jsmillis = function () {
    return new Date().valueOf();
  };
  Sk.builtin.superbi = function () {
    throw new Sk.builtin.NotImplementedError('super is not yet implemented, please report your use case as a github issue.');
  };
  Sk.builtin.eval_ = function () {
    throw new Sk.builtin.NotImplementedError('eval is not yet implemented');
  };
  Sk.builtin.map = function (a, b) {
    Sk.builtin.pyCheckArgs('map', arguments, 2);
    a instanceof Sk.builtin.none && (a = {
      func_code: function (a) {
        return a;
      }
    });
    if (2 < arguments.length) {
      var c = [], d = Array.prototype.slice.apply(arguments).slice(1), e;
      for (e in d) {
        if (void 0 === d[e].tp$iter) {
          var f = parseInt(e, 10) + 2;
          throw new Sk.builtin.TypeError('argument ' + f + ' to map() must support iteration');
        }
        d[e] = d[e].tp$iter();
      }
      for (;;) {
        var g = [], h = 0;
        for (e in d)
          f = d[e].tp$iternext(), void 0 === f ? (g.push(Sk.builtin.none.none$), h++) : g.push(f);
        if (h !== d.length)
          c.push(g);
        else
          break;
      }
      b = new Sk.builtin.list(c);
    }
    if (void 0 === b.tp$iter)
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object is not iterable');
    c = [];
    d = b.tp$iter();
    for (f = d.tp$iternext(); void 0 !== f;)
      f instanceof Array || (f = [f]), c.push(a.func_code.apply(this, f)), f = d.tp$iternext();
    return new Sk.builtin.list(c);
  };
  Sk.builtin.reduce = function (a, b, c) {
    Sk.builtin.pyCheckArgs('reduce', arguments, 2, 3);
    var d = b.tp$iter();
    if (void 0 === c && (c = d.tp$iternext(), void 0 === c))
      throw new Sk.builtin.TypeError('reduce() of empty sequence with no initial value');
    for (var e = c, f = d.tp$iternext(); void 0 !== f;)
      e = a.func_code(e, f), f = d.tp$iternext();
    return e;
  };
  Sk.builtin.filter = function (a, b) {
    Sk.builtin.pyCheckArgs('filter', arguments, 2, 2);
    if (void 0 === b.tp$iter)
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object is not iterable');
    a instanceof Sk.builtin.none && (a = {
      func_code: function (a) {
        return Sk.builtin.bool(a);
      }
    });
    var c = function () {
        return [];
      }, d = function (a, b) {
        a.push(b);
        return a;
      }, e = function (a) {
        return new Sk.builtin.list(a);
      };
    b.__class__ === Sk.builtin.str ? (c = function () {
      return new Sk.builtin.str('');
    }, d = function (a, b) {
      return a.sq$concat(b);
    }, e = function (a) {
      return a;
    }) : b.__class__ === Sk.builtin.tuple && (e = function (a) {
      return new Sk.builtin.tuple(a);
    });
    var f = b.tp$iter(), g = f.tp$iternext(), c = c();
    if (void 0 === g)
      return e(c);
    for (; void 0 !== g;)
      Sk.misceval.isTrue(a.func_code(g)) && (c = d(c, g)), g = f.tp$iternext();
    return e(c);
  };
  Sk.builtin.hasattr = function (a, b) {
    Sk.builtin.pyCheckArgs('hasattr', arguments, 2, 2);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('hasattr(): attribute name must be string');
    if (a.tp$getattr)
      return a.tp$getattr(b.v) ? !0 : !1;
    throw new Sk.builtin.AttributeError('Object has no tp$getattr method');
  };
  Sk.builtin.pow = function (a, b, c) {
    Sk.builtin.pyCheckArgs('pow', arguments, 2, 3);
    var d = Sk.builtin.asnum$(a), e = Sk.builtin.asnum$(b);
    Sk.builtin.asnum$(c);
    if (!Sk.builtin.checkNumber(a) || !Sk.builtin.checkNumber(b)) {
      if (void 0 === c)
        throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.abstr.typeName(a) + '\' and \'' + Sk.abstr.typeName(b) + '\'');
      throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.abstr.typeName(a) + '\', \'' + Sk.abstr.typeName(b) + '\', \'' + Sk.abstr.typeName(c) + '\'');
    }
    if (0 > d && b.skType === Sk.builtin.nmber.float$)
      throw new Sk.builtin.ValueError('negative number cannot be raised to a fractional power');
    if (void 0 === c)
      return d = Math.pow(d, e), a.skType === Sk.builtin.nmber.float$ || b.skType === Sk.builtin.nmber.float$ || 0 > e ? new Sk.builtin.nmber(d, Sk.builtin.nmber.float$) : a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng ? new Sk.builtin.lng(d) : new Sk.builtin.nmber(d, Sk.builtin.nmber.int$);
    if (!Sk.builtin.checkInt(a) || !Sk.builtin.checkInt(b) || !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('pow() 3rd argument not allowed unless all arguments are integers');
    if (0 > e)
      throw new Sk.builtin.TypeError('pow() 2nd argument cannot be negative when 3rd argument specified');
    return a instanceof Sk.builtin.lng || (b instanceof Sk.builtin.lng || c instanceof Sk.builtin.lng) || Infinity === Math.pow(d, e) ? (a = new Sk.builtin.lng(a), a.nb$power(b, c)) : new Sk.builtin.nmber(Math.pow(d, e), Sk.builtin.nmber.int$).nb$remainder(c);
  };
  Sk.builtin.quit = function (a) {
    a = new Sk.builtin.str(a).v;
    throw new Sk.builtin.SystemExit(a);
  };
  Sk.builtin.sorted = function (a, b, c, d) {
    var e;
    if (void 0 === c || c instanceof Sk.builtin.none)
      b instanceof Sk.builtin.none || void 0 === b || (e = b), a = new Sk.builtin.list(a);
    else {
      e = b instanceof Sk.builtin.none ? {
        func_code: function (a, b) {
          return Sk.misceval.richCompareBool(a[0], b[0], 'Lt') ? new Sk.builtin.nmber(-1, Sk.builtin.nmber.int$) : new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
        }
      } : {
        func_code: function (a, c) {
          return b.func_code(a[0], c[0]);
        }
      };
      a = a.tp$iter();
      for (var f = a.tp$iternext(), g = []; void 0 !== f;)
        g.push([
          c.func_code(f),
          f
        ]), f = a.tp$iternext();
      a = new Sk.builtin.list(g);
    }
    void 0 !== e ? a.list_sort_(a, e) : a.list_sort_(a);
    d && a.list_reverse_(a);
    if (void 0 !== c && !(c instanceof Sk.builtin.none)) {
      a = a.tp$iter();
      f = a.tp$iternext();
      for (g = []; void 0 !== f;)
        g.push(f[1]), f = a.tp$iternext();
      a = new Sk.builtin.list(g);
    }
    return a;
  };
  Sk.builtin.bytearray = function () {
    throw new Sk.builtin.NotImplementedError('bytearray is not yet implemented');
  };
  Sk.builtin.callable = function () {
    throw new Sk.builtin.NotImplementedError('callable is not yet implemented');
  };
  Sk.builtin.complex = function () {
    throw new Sk.builtin.NotImplementedError('complex is not yet implemented');
  };
  Sk.builtin.delattr = function () {
    throw new Sk.builtin.NotImplementedError('delattr is not yet implemented');
  };
  Sk.builtin.divmod = function () {
    throw new Sk.builtin.NotImplementedError('divmod is not yet implemented');
  };
  Sk.builtin.execfile = function () {
    throw new Sk.builtin.NotImplementedError('execfile is not yet implemented');
  };
  Sk.builtin.format = function () {
    throw new Sk.builtin.NotImplementedError('format is not yet implemented');
  };
  Sk.builtin.frozenset = function () {
    throw new Sk.builtin.NotImplementedError('frozenset is not yet implemented');
  };
  Sk.builtin.globals = function () {
    throw new Sk.builtin.NotImplementedError('globals is not yet implemented');
  };
  Sk.builtin.help = function () {
    throw new Sk.builtin.NotImplementedError('help is not yet implemented');
  };
  Sk.builtin.issubclass = function () {
    throw new Sk.builtin.NotImplementedError('issubclass is not yet implemented');
  };
  Sk.builtin.iter = function () {
    throw new Sk.builtin.NotImplementedError('iter is not yet implemented');
  };
  Sk.builtin.locals = function () {
    throw new Sk.builtin.NotImplementedError('locals is not yet implemented');
  };
  Sk.builtin.memoryview = function () {
    throw new Sk.builtin.NotImplementedError('memoryview is not yet implemented');
  };
  Sk.builtin.next_ = function () {
    throw new Sk.builtin.NotImplementedError('next is not yet implemented');
  };
  Sk.builtin.property = function () {
    throw new Sk.builtin.NotImplementedError('property is not yet implemented');
  };
  Sk.builtin.reload = function () {
    throw new Sk.builtin.NotImplementedError('reload is not yet implemented');
  };
  Sk.builtin.reversed = function () {
    throw new Sk.builtin.NotImplementedError('reversed is not yet implemented');
  };
  Sk.builtin.unichr = function () {
    throw new Sk.builtin.NotImplementedError('unichr is not yet implemented');
  };
  Sk.builtin.vars = function () {
    throw new Sk.builtin.NotImplementedError('vars is not yet implemented');
  };
  Sk.builtin.xrange = Sk.builtin.range;
  Sk.builtin.apply_ = function () {
    throw new Sk.builtin.NotImplementedError('apply is not yet implemented');
  };
  Sk.builtin.buffer = function () {
    throw new Sk.builtin.NotImplementedError('buffer is not yet implemented');
  };
  Sk.builtin.coerce = function () {
    throw new Sk.builtin.NotImplementedError('coerce is not yet implemented');
  };
  Sk.builtin.intern = function () {
    throw new Sk.builtin.NotImplementedError('intern is not yet implemented');
  };
  Sk.builtin.Exception = function (a) {
    a = Array.prototype.slice.call(arguments);
    for (var b = 0; b < a.length; ++b)
      'string' === typeof a[b] && (a[b] = new Sk.builtin.str(a[b]));
    this.args = new Sk.builtin.tuple(a);
    Sk.currFilename ? this.filename = Sk.currFilename : 3 <= this.args.sq$length() ? this.filename = this.args.v[1].v ? this.args.v[1].v : '<unknown>' : this.filename = '<unknown>';
    3 <= this.args.sq$length() ? this.lineno = this.args.v[2] : this.lineno = 0 < Sk.currLineNo ? Sk.currLineNo : '<unknown>';
    this.colno = 0 < Sk.currColNo ? Sk.currColNo : '<unknown>';
  };
  Sk.builtin.Exception.prototype.tp$name = 'Exception';
  Sk.builtin.Exception.prototype.tp$str = function () {
    var a;
    a = '' + this.tp$name;
    this.args && (a += ': ' + (0 < this.args.v.length ? this.args.v[0].v : ''));
    a += ' on line ' + this.lineno;
    if (4 < this.args.v.length) {
      a += '\n' + this.args.v[4].v + '\n';
      for (var b = 0; b < this.args.v[3]; ++b)
        a += ' ';
      a += '^\n';
    }
    return new Sk.builtin.str(a);
  };
  Sk.builtin.Exception.prototype.toString = function () {
    return this.tp$str().v;
  };
  goog.exportSymbol('Sk.builtin.Exception', Sk.builtin.Exception);
  Sk.builtin.AssertionError = function (a) {
    if (!(this instanceof Sk.builtin.AssertionError)) {
      var b = Object.create(Sk.builtin.AssertionError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.AssertionError, Sk.builtin.Exception);
  Sk.builtin.AssertionError.prototype.tp$name = 'AssertionError';
  goog.exportSymbol('Sk.builtin.AssertionError', Sk.builtin.AssertionError);
  Sk.builtin.AttributeError = function (a) {
    if (!(this instanceof Sk.builtin.AttributeError)) {
      var b = Object.create(Sk.builtin.AttributeError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.AttributeError, Sk.builtin.Exception);
  Sk.builtin.AttributeError.prototype.tp$name = 'AttributeError';
  Sk.builtin.ImportError = function (a) {
    if (!(this instanceof Sk.builtin.ImportError)) {
      var b = Object.create(Sk.builtin.ImportError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ImportError, Sk.builtin.Exception);
  Sk.builtin.ImportError.prototype.tp$name = 'ImportError';
  Sk.builtin.IndentationError = function (a) {
    if (!(this instanceof Sk.builtin.IndentationError)) {
      var b = Object.create(Sk.builtin.IndentationError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.IndentationError, Sk.builtin.Exception);
  Sk.builtin.IndentationError.prototype.tp$name = 'IndentationError';
  Sk.builtin.IndexError = function (a) {
    if (!(this instanceof Sk.builtin.IndexError)) {
      var b = Object.create(Sk.builtin.IndexError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.IndexError, Sk.builtin.Exception);
  Sk.builtin.IndexError.prototype.tp$name = 'IndexError';
  Sk.builtin.KeyError = function (a) {
    if (!(this instanceof Sk.builtin.KeyError)) {
      var b = Object.create(Sk.builtin.KeyError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.KeyError, Sk.builtin.Exception);
  Sk.builtin.KeyError.prototype.tp$name = 'KeyError';
  Sk.builtin.NameError = function (a) {
    if (!(this instanceof Sk.builtin.NameError)) {
      var b = Object.create(Sk.builtin.NameError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.NameError, Sk.builtin.Exception);
  Sk.builtin.NameError.prototype.tp$name = 'NameError';
  Sk.builtin.OverflowError = function (a) {
    if (!(this instanceof Sk.builtin.OverflowError)) {
      var b = Object.create(Sk.builtin.OverflowError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.OverflowError, Sk.builtin.Exception);
  Sk.builtin.OverflowError.prototype.tp$name = 'OverflowError';
  Sk.builtin.ParseError = function (a) {
    if (!(this instanceof Sk.builtin.ParseError)) {
      var b = Object.create(Sk.builtin.ParseError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ParseError, Sk.builtin.Exception);
  Sk.builtin.ParseError.prototype.tp$name = 'ParseError';
  Sk.builtin.SystemExit = function (a) {
    if (!(this instanceof Sk.builtin.SystemExit)) {
      var b = Object.create(Sk.builtin.SystemExit.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.SystemExit, Sk.builtin.Exception);
  Sk.builtin.SystemExit.prototype.tp$name = 'SystemExit';
  goog.exportSymbol('Sk.builtin.SystemExit', Sk.builtin.SystemExit);
  Sk.builtin.SyntaxError = function (a) {
    if (!(this instanceof Sk.builtin.SyntaxError)) {
      var b = Object.create(Sk.builtin.SyntaxError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.SyntaxError, Sk.builtin.Exception);
  Sk.builtin.SyntaxError.prototype.tp$name = 'SyntaxError';
  Sk.builtin.TokenError = function (a) {
    if (!(this instanceof Sk.builtin.TokenError)) {
      var b = Object.create(Sk.builtin.TokenError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.TokenError, Sk.builtin.Exception);
  Sk.builtin.TokenError.prototype.tp$name = 'TokenError';
  Sk.builtin.TypeError = function (a) {
    if (!(this instanceof Sk.builtin.TypeError)) {
      var b = Object.create(Sk.builtin.TypeError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.TypeError, Sk.builtin.Exception);
  Sk.builtin.TypeError.prototype.tp$name = 'TypeError';
  goog.exportSymbol('Sk.builtin.TypeError', Sk.builtin.TypeError);
  Sk.builtin.ValueError = function (a) {
    if (!(this instanceof Sk.builtin.ValueError)) {
      var b = Object.create(Sk.builtin.ValueError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ValueError, Sk.builtin.Exception);
  Sk.builtin.ValueError.prototype.tp$name = 'ValueError';
  goog.exportSymbol('Sk.builtin.ValueError', Sk.builtin.ValueError);
  Sk.builtin.ZeroDivisionError = function (a) {
    if (!(this instanceof Sk.builtin.ZeroDivisionError)) {
      var b = Object.create(Sk.builtin.ZeroDivisionError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ZeroDivisionError, Sk.builtin.Exception);
  Sk.builtin.ZeroDivisionError.prototype.tp$name = 'ZeroDivisionError';
  Sk.builtin.TimeLimitError = function (a) {
    if (!(this instanceof Sk.builtin.TimeLimitError)) {
      var b = Object.create(Sk.builtin.TimeLimitError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.TimeLimitError, Sk.builtin.Exception);
  Sk.builtin.TimeLimitError.prototype.tp$name = 'TimeLimitError';
  goog.exportSymbol('Sk.builtin.TimeLimitError', Sk.builtin.TimeLimitError);
  Sk.builtin.IOError = function (a) {
    if (!(this instanceof Sk.builtin.IOError)) {
      var b = Object.create(Sk.builtin.IOError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.IOError, Sk.builtin.Exception);
  Sk.builtin.IOError.prototype.tp$name = 'IOError';
  goog.exportSymbol('Sk.builtin.IOError', Sk.builtin.IOError);
  Sk.builtin.NotImplementedError = function (a) {
    if (!(this instanceof Sk.builtin.NotImplementedError)) {
      var b = Object.create(Sk.builtin.NotImplementedError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.NotImplementedError, Sk.builtin.Exception);
  Sk.builtin.NotImplementedError.prototype.tp$name = 'NotImplementedError';
  goog.exportSymbol('Sk.builtin.NotImplementedError', Sk.builtin.NotImplementedError);
  Sk.builtin.NegativePowerError = function (a) {
    if (!(this instanceof Sk.builtin.NegativePowerError)) {
      var b = Object.create(Sk.builtin.NegativePowerError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.NegativePowerError, Sk.builtin.Exception);
  Sk.builtin.NegativePowerError.prototype.tp$name = 'NegativePowerError';
  goog.exportSymbol('Sk.builtin.NegativePowerError', Sk.builtin.NegativePowerError);
  Sk.builtin.OperationError = function (a) {
    if (!(this instanceof Sk.builtin.OperationError)) {
      var b = Object.create(Sk.builtin.OperationError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.OperationError, Sk.builtin.Exception);
  Sk.builtin.OperationError.prototype.tp$name = 'OperationError';
  goog.exportSymbol('Sk.builtin.OperationError', Sk.builtin.OperationError);
  Sk.builtin.SystemError = function (a) {
    if (!(this instanceof Sk.builtin.SystemError)) {
      var b = Object.create(Sk.builtin.SystemError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.SystemError, Sk.builtin.Exception);
  Sk.builtin.SystemError.prototype.tp$name = 'SystemError';
  goog.exportSymbol('Sk.builtin.SystemError', Sk.builtin.SystemError);
  Sk.currLineNo = -1;
  Sk.currColNo = -1;
  Sk.currFilename = '';
  goog.exportSymbol('Sk', Sk);
  goog.exportProperty(Sk, 'currLineNo', Sk.currLineNo);
  goog.exportProperty(Sk, 'currColNo', Sk.currColNo);
  goog.exportProperty(Sk, 'currFilename', Sk.currFilename);
  Sk.builtin.type = function (a, b, c) {
    if (void 0 === b && void 0 === c)
      return a.constructor === Sk.builtin.nmber ? a.skType === Sk.builtin.nmber.int$ ? Sk.builtin.int_.prototype.ob$type : Sk.builtin.float_.prototype.ob$type : a.ob$type;
    var d = function (a, b, c, e) {
        if (!(this instanceof d))
          return new d(a, b, c, e);
        e = e || [];
        this.$d = new Sk.builtin.dict([]);
        var l = Sk.builtin.type.typeLookup(this.ob$type, '__init__');
        void 0 !== l && (e.unshift(this), Sk.misceval.apply(l, a, b, c, e));
        return this;
      }, e;
    for (e in c)
      d.prototype[e] = c[e], d[e] = c[e];
    d.__class__ = d;
    d.sk$klass = !0;
    d.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
    d.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
    d.prototype.tp$descr_get = function () {
      goog.asserts.fail('in type tp$descr_get');
    };
    d.prototype.$r = function () {
      var b = this.tp$getattr('__repr__');
      if (void 0 !== b)
        return Sk.misceval.apply(b, void 0, void 0, void 0, []);
      var b = c.__module__, d = '';
      b && (d = b.v + '.');
      return new Sk.builtin.str('<' + d + a + ' object>');
    };
    d.prototype.tp$str = function () {
      var a = this.tp$getattr('__str__');
      return void 0 !== a ? Sk.misceval.apply(a, void 0, void 0, void 0, []) : this.$r();
    };
    d.prototype.tp$length = function () {
      var a = this.tp$getattr('__len__');
      if (void 0 !== a)
        return Sk.misceval.apply(a, void 0, void 0, void 0, []);
      a = Sk.abstr.typeName(this);
      throw new Sk.builtin.AttributeError(a + ' instance has no attribute \'__len__\'');
    };
    d.prototype.tp$call = function (a, b) {
      var c = this.tp$getattr('__call__');
      if (c)
        return Sk.misceval.apply(c, void 0, void 0, b, a);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object is not callable');
    };
    d.prototype.tp$iter = function () {
      var a = this.tp$getattr('__iter__'), b = Sk.abstr.typeName(this);
      if (a)
        return Sk.misceval.callsim(a);
      throw new Sk.builtin.TypeError('\'' + b + '\' object is not iterable');
    };
    d.prototype.tp$iternext = function () {
      var a = this.tp$getattr('next');
      goog.asserts.assert(void 0 !== a, 'iter() should have caught this');
      return Sk.misceval.callsim(a);
    };
    d.prototype.tp$getitem = function (a) {
      var b = this.tp$getattr('__getitem__');
      if (void 0 !== b)
        return Sk.misceval.apply(b, void 0, void 0, void 0, [a]);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object does not support indexing');
    };
    d.prototype.tp$setitem = function (a, b) {
      var c = this.tp$getattr('__setitem__');
      if (void 0 !== c)
        return Sk.misceval.apply(c, void 0, void 0, void 0, [
          a,
          b
        ]);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object does not support item assignment');
    };
    d.prototype.tp$name = a;
    b && (d.$d = new Sk.builtin.dict([]), d.$d.mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple(b)), b = Sk.builtin.type.buildMRO(d), d.$d.mp$ass_subscript(Sk.builtin.type.mroStr_, b), d.tp$mro = b);
    d.prototype.ob$type = d;
    Sk.builtin.type.makeIntoTypeObj(a, d);
    d.tp$setattr = Sk.builtin.type.prototype.tp$setattr;
    return d;
  };
  Sk.builtin.type.makeTypeObj = function (a, b) {
    Sk.builtin.type.makeIntoTypeObj(a, b);
    return b;
  };
  Sk.builtin.type.makeIntoTypeObj = function (a, b) {
    goog.asserts.assert(void 0 !== a);
    goog.asserts.assert(void 0 !== b);
    b.ob$type = Sk.builtin.type;
    b.tp$name = a;
    b.$r = function () {
      var a = b.__module__, d = '';
      a && (d = a.v + '.');
      var e = 'class';
      a || b.sk$klass || (e = 'type');
      return new Sk.builtin.str('<' + e + ' \'' + d + b.tp$name + '\'>');
    };
    b.tp$str = void 0;
    b.tp$getattr = Sk.builtin.type.prototype.tp$getattr;
    b.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
    b.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;
    b.sk$type = !0;
    return b;
  };
  Sk.builtin.type.ob$type = Sk.builtin.type;
  Sk.builtin.type.tp$name = 'type';
  Sk.builtin.type.$r = function () {
    return new Sk.builtin.str('<type \'type\'>');
  };
  Sk.builtin.type.prototype.tp$getattr = function (a) {
    var b = Sk.builtin.type.typeLookup(this, a), c;
    void 0 !== b && (null !== b && void 0 !== b.ob$type) && (c = b.ob$type.tp$descr_get);
    if (this.$d && (a = this.$d.mp$lookup(new Sk.builtin.str(a)), void 0 !== a))
      return a;
    if (c)
      return c.call(b, null, this);
    if (void 0 !== b)
      return b;
  };
  Sk.builtin.type.prototype.tp$setattr = function (a, b) {
    this[a] = b;
  };
  Sk.builtin.type.typeLookup = function (a, b) {
    var c = a.tp$mro, d = new Sk.builtin.str(b), e, f;
    if (!c)
      return a.prototype[b];
    for (f = 0; f < c.v.length; ++f) {
      e = c.v[f];
      if (e.hasOwnProperty(b))
        return e[b];
      e = e.$d.mp$lookup(d);
      if (void 0 !== e)
        return e;
    }
  };
  Sk.builtin.type.mroMerge_ = function (a) {
    for (var b = [];;) {
      for (var c = 0; c < a.length; ++c) {
        var d = a[c];
        if (0 !== d.length)
          break;
      }
      if (c === a.length)
        return b;
      for (var e = [], c = 0; c < a.length; ++c)
        if (d = a[c], 0 !== d.length) {
          var d = d[0], f = 0;
          a:
            for (; f < a.length; ++f)
              for (var g = a[f], h = 1; h < g.length; ++h)
                if (g[h] === d)
                  break a;
          f === a.length && e.push(d);
        }
      if (0 === e.length)
        throw new Sk.builtin.TypeError('Inconsistent precedences in type hierarchy');
      e = e[0];
      b.push(e);
      for (c = 0; c < a.length; ++c)
        d = a[c], 0 < d.length && d[0] === e && d.splice(0, 1);
    }
  };
  Sk.builtin.type.buildMRO_ = function (a) {
    var b = [[a]];
    a = a.$d.mp$subscript(Sk.builtin.type.basesStr_);
    for (var c = 0; c < a.v.length; ++c)
      b.push(Sk.builtin.type.buildMRO_(a.v[c]));
    for (var d = [], c = 0; c < a.v.length; ++c)
      d.push(a.v[c]);
    b.push(d);
    return Sk.builtin.type.mroMerge_(b);
  };
  Sk.builtin.type.buildMRO = function (a) {
    return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(a));
  };
  Sk.builtin.type.prototype.tp$richcompare = function (a, b) {
    if (a.ob$type == Sk.builtin.type && this.$r && a.$r) {
      var c = this.$r(), d = a.$r();
      return c.tp$richcompare(d, b);
    }
  };
  Sk.builtin.object = function () {
    if (!(this instanceof Sk.builtin.object))
      return new Sk.builtin.object();
    this.$d = new Sk.builtin.dict([]);
    return this;
  };
  Sk.builtin.object.prototype.GenericGetAttr = function (a) {
    goog.asserts.assert('string' === typeof a);
    var b = this.ob$type;
    goog.asserts.assert(void 0 !== b, 'object has no ob$type!');
    var b = Sk.builtin.type.typeLookup(b, a), c;
    void 0 !== b && (null !== b && void 0 !== b.ob$type) && (c = b.ob$type.tp$descr_get);
    if (this.$d) {
      var d;
      if (this.$d.mp$lookup)
        d = this.$d.mp$lookup(new Sk.builtin.str(a));
      else if (this.$d.mp$subscript)
        try {
          d = this.$d.mp$subscript(new Sk.builtin.str(a));
        } catch (e) {
          d = void 0;
        }
      else
        'object' === typeof this.$d && (d = this.$d[a]);
      if (void 0 !== d)
        return d;
    }
    if (c)
      return c.call(b, this, this.ob$type);
    if (void 0 !== b)
      return b;
  };
  goog.exportSymbol('Sk.builtin.object.prototype.GenericGetAttr', Sk.builtin.object.prototype.GenericGetAttr);
  Sk.builtin.object.prototype.GenericSetAttr = function (a, b) {
    goog.asserts.assert('string' === typeof a);
    this.$d.mp$ass_subscript ? this.$d.mp$ass_subscript(new Sk.builtin.str(a), b) : 'object' === typeof this.$d && (this.$d[a] = b);
  };
  goog.exportSymbol('Sk.builtin.object.prototype.GenericSetAttr', Sk.builtin.object.prototype.GenericSetAttr);
  Sk.builtin.object.prototype.HashNotImplemented = function () {
    throw new Sk.builtin.TypeError('unhashable type: \'' + Sk.abstr.typeName(this) + '\'');
  };
  Sk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
  Sk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('object', Sk.builtin.object);
  Sk.builtin.none = function () {
  };
  Sk.builtin.none.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('NoneType', Sk.builtin.none);
  Sk.builtin.none.prototype.tp$name = 'NoneType';
  Sk.builtin.none.none$ = Object.create(Sk.builtin.none.prototype, {
    v: {
      value: null,
      enumerable: !0
    }
  });
  goog.exportSymbol('Sk.builtin.none', Sk.builtin.none);
  Sk.builtin.bool = function (a) {
    Sk.builtin.pyCheckArgs('bool', arguments, 1);
    return Sk.misceval.isTrue(a) ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
  };
  Sk.builtin.bool.prototype.tp$name = 'bool';
  Sk.builtin.bool.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('bool', Sk.builtin.bool);
  Sk.builtin.bool.prototype.$r = function () {
    return this.v ? new Sk.builtin.str('True') : new Sk.builtin.str('False');
  };
  Sk.builtin.bool.true$ = Object.create(Sk.builtin.bool.prototype, {
    v: {
      value: !0,
      enumerable: !0
    }
  });
  Sk.builtin.bool.false$ = Object.create(Sk.builtin.bool.prototype, {
    v: {
      value: !1,
      enumerable: !0
    }
  });
  goog.exportSymbol('Sk.builtin.bool', Sk.builtin.bool);
  Sk.builtin.pyCheckArgs = function (a, b, c, d, e, f) {
    b = b.length;
    var g = '';
    void 0 === d && (d = Infinity);
    e && (b -= 1);
    f && (b -= 1);
    if (b < c || b > d)
      throw g = (c === d ? a + '() takes exactly ' + c + ' arguments' : b < c ? a + '() takes at least ' + c + ' arguments' : a + '() takes at most ' + d + ' arguments') + (' (' + b + ' given)'), new Sk.builtin.TypeError(g);
  };
  goog.exportSymbol('Sk.builtin.pyCheckArgs', Sk.builtin.pyCheckArgs);
  Sk.builtin.pyCheckType = function (a, b, c) {
    if (!c)
      throw new Sk.builtin.TypeError(a + ' must be a ' + b);
  };
  goog.exportSymbol('Sk.builtin.pyCheckType', Sk.builtin.pyCheckType);
  Sk.builtin.checkSequence = function (a) {
    return null !== a && void 0 !== a.mp$subscript;
  };
  goog.exportSymbol('Sk.builtin.checkSequence', Sk.builtin.checkSequence);
  Sk.builtin.checkIterable = function (a) {
    return null !== a && void 0 !== a.tp$iter;
  };
  goog.exportSymbol('Sk.builtin.checkIterable', Sk.builtin.checkIterable);
  Sk.builtin.checkNumber = function (a) {
    return null !== a && ('number' === typeof a || a instanceof Sk.builtin.nmber || a instanceof Sk.builtin.lng);
  };
  goog.exportSymbol('Sk.builtin.checkNumber', Sk.builtin.checkNumber);
  Sk.builtin.checkInt = function (a) {
    return null !== a && ('number' === typeof a && a === (a | 0) || a instanceof Sk.builtin.nmber && a.skType === Sk.builtin.nmber.int$ || a instanceof Sk.builtin.lng);
  };
  goog.exportSymbol('Sk.builtin.checkInt', Sk.builtin.checkInt);
  Sk.builtin.checkString = function (a) {
    return null !== a && a.__class__ == Sk.builtin.str;
  };
  goog.exportSymbol('Sk.builtin.checkString', Sk.builtin.checkString);
  Sk.builtin.checkClass = function (a) {
    return null !== a && a.sk$type;
  };
  goog.exportSymbol('Sk.builtin.checkClass', Sk.builtin.checkClass);
  Sk.builtin.checkBool = function (a) {
    return a instanceof Sk.builtin.bool;
  };
  goog.exportSymbol('Sk.builtin.checkBool', Sk.builtin.checkBool);
  Sk.builtin.checkFunction = function (a) {
    return null !== a && void 0 !== a.tp$call;
  };
  goog.exportSymbol('Sk.builtin.checkFunction', Sk.builtin.checkFunction);
  Sk.builtin.func = function (a, b, c, d) {
    this.func_code = a;
    this.func_globals = b || null;
    if (void 0 !== d)
      for (var e in d)
        c[e] = d[e];
    this.func_closure = c;
    return this;
  };
  goog.exportSymbol('Sk.builtin.func', Sk.builtin.func);
  Sk.builtin.func.prototype.tp$name = 'function';
  Sk.builtin.func.prototype.tp$descr_get = function (a, b) {
    goog.asserts.assert(void 0 !== a && void 0 !== b);
    return null == a ? this : new Sk.builtin.method(this, a);
  };
  Sk.builtin.func.prototype.tp$call = function (a, b) {
    var c;
    this.func_closure && a.push(this.func_closure);
    c = this.func_code.co_kwargs;
    var d = [];
    if (this.func_code.no_kw && b)
      throw c = this.func_code && this.func_code.co_name && this.func_code.co_name.v || '<native JS>', new Sk.builtin.TypeError(c + '() takes no keyword arguments');
    if (b)
      for (var e = b.length, f = this.func_code.co_varnames, g = f && f.length, h = 0; h < e; h += 2) {
        for (var k = 0; k < g && b[h] !== f[k]; ++k);
        if (f && k !== g)
          a[k] = b[h + 1];
        else if (c)
          d.push(new Sk.builtin.str(b[h])), d.push(b[h + 1]);
        else
          throw c = this.func_code && this.func_code.co_name && this.func_code.co_name.v || '<native JS>', new Sk.builtin.TypeError(c + '() got an unexpected keyword argument \'' + b[h] + '\'');
      }
    c && a.unshift(d);
    return this.func_code.apply(this.func_globals, a);
  };
  Sk.builtin.func.prototype.tp$getattr = function (a) {
    return this[a];
  };
  Sk.builtin.func.prototype.tp$setattr = function (a, b) {
    this[a] = b;
  };
  Sk.builtin.func.prototype.ob$type = Sk.builtin.type.makeTypeObj('function', new Sk.builtin.func(null, null));
  Sk.builtin.func.prototype.$r = function () {
    return new Sk.builtin.str('<function ' + (this.func_code && this.func_code.co_name && this.func_code.co_name.v || '<native JS>') + '>');
  };
  Sk.nativejs = {
    FN_ARGS: /^function\s*[^\(]*\(\s*([^\)]*)\)/m,
    FN_ARG_SPLIT: /,/,
    FN_ARG: /^\s*(_?)(\S+?)\1\s*$/,
    STRIP_COMMENTS: /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
    formalParameterList: function (a) {
      var b = [];
      a = a.toString().replace(this.STRIP_COMMENTS, '').match(this.FN_ARGS)[1].split(this.FN_ARG_SPLIT);
      for (var c in a)
        a[c].replace(this.FN_ARG, function (a, c, f) {
          b.push(f);
        });
      return b;
    },
    func: function (a) {
      a.co_name = new Sk.builtin.str(a.name);
      a.co_varnames = Sk.nativejs.formalParameterList(a);
      return new Sk.builtin.func(a);
    },
    func_nokw: function (a) {
      a.co_name = new Sk.builtin.str(a.name);
      a.co_varnames = Sk.nativejs.formalParameterList(a);
      a.no_kw = !0;
      return new Sk.builtin.func(a);
    }
  };
  goog.exportSymbol('Sk.nativejs.func', Sk.nativejs.func);
  goog.exportSymbol('Sk.nativejs.func_nokw', Sk.nativejs.func_nokw);
  Sk.builtin.method = function (a, b) {
    this.im_func = a;
    this.im_self = b;
  };
  goog.exportSymbol('Sk.builtin.method', Sk.builtin.method);
  Sk.builtin.method.prototype.tp$call = function (a, b) {
    goog.asserts.assert(this.im_self, 'should just be a function, not a method since there\'s no self?');
    goog.asserts.assert(this.im_func instanceof Sk.builtin.func);
    a.unshift(this.im_self);
    if (b)
      for (var c = b.length, d = 0; d < c; d += 2) {
        for (var e = this.im_func.func_code.co_varnames, f = e && e.length, g = 0; g < f && b[d] !== e[g]; ++g);
        a[g] = b[d + 1];
      }
    return this.im_func.func_code.apply(this.im_func.func_globals, a);
  };
  Sk.builtin.method.prototype.$r = function () {
    return new Sk.builtin.str('<bound method ' + this.im_self.ob$type.tp$name + '.' + (this.im_func.func_code && this.im_func.func_code.co_name && this.im_func.func_code.co_name.v || '<native JS>') + ' of ' + this.im_self.$r().v + '>');
  };
  Sk.misceval = {};
  Sk.misceval.isIndex = function (a) {
    return null === a || a.constructor === Sk.builtin.lng || a.tp$index || !0 === a || !1 === a ? !0 : Sk.builtin.checkInt(a);
  };
  goog.exportSymbol('Sk.misceval.isIndex', Sk.misceval.isIndex);
  Sk.misceval.asIndex = function (a) {
    if (Sk.misceval.isIndex(a) && null !== a) {
      if (!0 === a)
        return 1;
      if (!1 === a)
        return 0;
      if ('number' === typeof a)
        return a;
      if (a.constructor === Sk.builtin.nmber)
        return a.v;
      if (a.constructor === Sk.builtin.lng)
        return a.tp$index();
      goog.asserts.fail('todo;');
    }
  };
  Sk.misceval.applySlice = function (a, b, c) {
    return a.sq$slice && Sk.misceval.isIndex(b) && Sk.misceval.isIndex(c) ? (b = Sk.misceval.asIndex(b), void 0 === b && (b = 0), c = Sk.misceval.asIndex(c), void 0 === c && (c = 1e+100), Sk.abstr.sequenceGetSlice(a, b, c)) : Sk.abstr.objectGetItem(a, new Sk.builtin.slice(b, c, null));
  };
  goog.exportSymbol('Sk.misceval.applySlice', Sk.misceval.applySlice);
  Sk.misceval.assignSlice = function (a, b, c, d) {
    if (a.sq$ass_slice && Sk.misceval.isIndex(b) && Sk.misceval.isIndex(c))
      b = Sk.misceval.asIndex(b) || 0, c = Sk.misceval.asIndex(c) || 1e+100, null === d ? Sk.abstr.sequenceDelSlice(a, b, c) : Sk.abstr.sequenceSetSlice(a, b, c, d);
    else
      return c = new Sk.builtin.slice(b, c), null === d ? Sk.abstr.objectDelItem(a, c) : Sk.abstr.objectSetItem(a, c, d);
  };
  goog.exportSymbol('Sk.misceval.assignSlice', Sk.misceval.assignSlice);
  Sk.misceval.arrayFromArguments = function (a) {
    if (1 != a.length)
      return a;
    var b = a[0];
    if (b instanceof Sk.builtin.set)
      b = b.tp$iter().$obj;
    else if (b instanceof Sk.builtin.dict)
      b = Sk.builtin.dict.prototype.keys.func_code(b);
    else if (b instanceof Sk.builtin.str) {
      a = [];
      for (var b = b.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
        a.push(c);
      return a;
    }
    return b instanceof Sk.builtin.list || b instanceof Sk.builtin.tuple ? b.v : a;
  };
  goog.exportSymbol('Sk.misceval.arrayFromArguments', Sk.misceval.arrayFromArguments);
  Sk.misceval.swappedOp_ = {
    Eq: 'Eq',
    NotEq: 'NotEq',
    Lt: 'GtE',
    LtE: 'Gt',
    Gt: 'LtE',
    GtE: 'Lt',
    Is: 'IsNot',
    IsNot: 'Is',
    In_: 'NotIn',
    NotIn: 'In_'
  };
  Sk.misceval.richCompareBool = function (a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
    goog.asserts.assert(null !== b && void 0 !== b, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
    var d = new Sk.builtin.type(a), e = new Sk.builtin.type(b);
    if (d !== e && ('GtE' === c || 'Gt' === c || 'LtE' === c || 'Lt' === c)) {
      var f = [
          Sk.builtin.float_.prototype.ob$type,
          Sk.builtin.int_.prototype.ob$type,
          Sk.builtin.lng.prototype.ob$type,
          Sk.builtin.bool.prototype.ob$type
        ], g = [
          Sk.builtin.dict.prototype.ob$type,
          Sk.builtin.enumerate.prototype.ob$type,
          Sk.builtin.list.prototype.ob$type,
          Sk.builtin.str.prototype.ob$type,
          Sk.builtin.tuple.prototype.ob$type
        ], h = f.indexOf(d), k = g.indexOf(d), f = f.indexOf(e), g = g.indexOf(e);
      if (d === Sk.builtin.none.prototype.ob$type)
        switch (c) {
        case 'Lt':
          return !0;
        case 'LtE':
          return !0;
        case 'Gt':
          return !1;
        case 'GtE':
          return !1;
        }
      if (e === Sk.builtin.none.prototype.ob$type)
        switch (c) {
        case 'Lt':
          return !1;
        case 'LtE':
          return !1;
        case 'Gt':
          return !0;
        case 'GtE':
          return !0;
        }
      if (-1 !== h && -1 !== g)
        switch (c) {
        case 'Lt':
          return !0;
        case 'LtE':
          return !0;
        case 'Gt':
          return !1;
        case 'GtE':
          return !1;
        }
      if (-1 !== k && -1 !== f)
        switch (c) {
        case 'Lt':
          return !1;
        case 'LtE':
          return !1;
        case 'Gt':
          return !0;
        case 'GtE':
          return !0;
        }
      if (-1 !== k && -1 !== g)
        switch (c) {
        case 'Lt':
          return k < g;
        case 'LtE':
          return k <= g;
        case 'Gt':
          return k > g;
        case 'GtE':
          return k >= g;
        }
    }
    if ('Is' === c)
      return a instanceof Sk.builtin.nmber && b instanceof Sk.builtin.nmber ? 0 === a.numberCompare(b) && a.skType === b.skType : a instanceof Sk.builtin.lng && b instanceof Sk.builtin.lng ? 0 === a.longCompare(b) : a === b;
    if ('IsNot' === c)
      return a instanceof Sk.builtin.nmber && b instanceof Sk.builtin.nmber ? 0 !== a.numberCompare(b) || a.skType !== b.skType : a instanceof Sk.builtin.lng && b instanceof Sk.builtin.lng ? 0 !== a.longCompare(b) : a !== b;
    if ('In' === c)
      return Sk.abstr.sequenceContains(b, a);
    if ('NotIn' === c)
      return !Sk.abstr.sequenceContains(b, a);
    var l;
    if (a.tp$richcompare && void 0 !== (l = a.tp$richcompare(b, c)) || b.tp$richcompare && void 0 !== (l = b.tp$richcompare(a, Sk.misceval.swappedOp_[c])))
      return l;
    e = {
      Eq: '__eq__',
      NotEq: '__ne__',
      Gt: '__gt__',
      GtE: '__ge__',
      Lt: '__lt__',
      LtE: '__le__'
    };
    d = e[c];
    e = e[Sk.misceval.swappedOp_[c]];
    if (a[d])
      return Sk.misceval.callsim(a[d], a, b);
    if (b[e])
      return Sk.misceval.callsim(b[e], b, a);
    if (a.__cmp__) {
      d = Sk.misceval.callsim(a.__cmp__, a, b);
      d = Sk.builtin.asnum$(d);
      if ('Eq' === c)
        return 0 === d;
      if ('NotEq' === c)
        return 0 !== d;
      if ('Lt' === c)
        return 0 > d;
      if ('Gt' === c)
        return 0 < d;
      if ('LtE' === c)
        return 0 >= d;
      if ('GtE' === c)
        return 0 <= d;
    }
    if (b.__cmp__) {
      d = Sk.misceval.callsim(b.__cmp__, b, a);
      d = Sk.builtin.asnum$(d);
      if ('Eq' === c)
        return 0 === d;
      if ('NotEq' === c)
        return 0 !== d;
      if ('Lt' === c)
        return 0 < d;
      if ('Gt' === c)
        return 0 > d;
      if ('LtE' === c)
        return 0 <= d;
      if ('GtE' === c)
        return 0 >= d;
    }
    if (a instanceof Sk.builtin.none && b instanceof Sk.builtin.none || a instanceof Sk.builtin.bool && b instanceof Sk.builtin.bool) {
      if ('Eq' === c)
        return a.v === b.v;
      if ('NotEq' === c)
        return a.v !== b.v;
      if ('Gt' === c)
        return a.v > b.v;
      if ('GtE' === c)
        return a.v >= b.v;
      if ('Lt' === c)
        return a.v < b.v;
      if ('LtE' === c)
        return a.v <= b.v;
    }
    if ('Eq' === c)
      return a instanceof Sk.builtin.str && b instanceof Sk.builtin.str ? a.v === b.v : a === b;
    if ('NotEq' === c)
      return a instanceof Sk.builtin.str && b instanceof Sk.builtin.str ? a.v !== b.v : a !== b;
    a = Sk.abstr.typeName(a);
    b = Sk.abstr.typeName(b);
    throw new Sk.builtin.ValueError('don\'t know how to compare \'' + a + '\' and \'' + b + '\'');
  };
  goog.exportSymbol('Sk.misceval.richCompareBool', Sk.misceval.richCompareBool);
  Sk.misceval.objectRepr = function (a) {
    goog.asserts.assert(void 0 !== a, 'trying to repr undefined');
    return null === a || a instanceof Sk.builtin.none ? new Sk.builtin.str('None') : !0 === a ? new Sk.builtin.str('True') : !1 === a ? new Sk.builtin.str('False') : 'number' === typeof a ? new Sk.builtin.str('' + a) : a.$r ? a.constructor === Sk.builtin.nmber ? Infinity === a.v ? new Sk.builtin.str('inf') : -Infinity === a.v ? new Sk.builtin.str('-inf') : new Sk.builtin.str('' + a.v) : a.$r() : a.tp$name ? new Sk.builtin.str('<' + a.tp$name + ' object>') : new Sk.builtin.str('<unknown>');
  };
  goog.exportSymbol('Sk.misceval.objectRepr', Sk.misceval.objectRepr);
  Sk.misceval.opAllowsEquality = function (a) {
    switch (a) {
    case 'LtE':
    case 'Eq':
    case 'GtE':
      return !0;
    }
    return !1;
  };
  goog.exportSymbol('Sk.misceval.opAllowsEquality', Sk.misceval.opAllowsEquality);
  Sk.misceval.isTrue = function (a) {
    return !0 === a ? !0 : !1 === a || null === a || a.constructor === Sk.builtin.none ? !1 : a.constructor === Sk.builtin.bool ? a.v : 'number' === typeof a ? 0 !== a : a instanceof Sk.builtin.lng ? a.nb$nonzero() : a.constructor === Sk.builtin.nmber ? 0 !== a.v : a.mp$length ? 0 !== a.mp$length() : a.sq$length ? 0 !== a.sq$length() : !0;
  };
  goog.exportSymbol('Sk.misceval.isTrue', Sk.misceval.isTrue);
  Sk.misceval.softspace_ = !1;
  Sk.misceval.print_ = function (a) {
    Sk.misceval.softspace_ && ('\n' !== a && Sk.output(' '), Sk.misceval.softspace_ = !1);
    a = new Sk.builtin.str(a);
    Sk.output(a.v);
    if (0 === a.v.length || '\n' !== a.v[a.v.length - 1] && '\t' !== a.v[a.v.length - 1] && '\r' !== a.v[a.v.length - 1] || ' ' === a.v[a.v.length - 1])
      Sk.misceval.softspace_ = !0;
  };
  goog.exportSymbol('Sk.misceval.print_', Sk.misceval.print_);
  Sk.misceval.loadname = function (a, b) {
    var c = b[a];
    if (void 0 !== c)
      return c;
    c = Sk.builtins[a];
    if (void 0 !== c)
      return c;
    a = a.replace('_$rw$', '');
    a = a.replace('_$rn$', '');
    throw new Sk.builtin.NameError('name \'' + a + '\' is not defined');
  };
  goog.exportSymbol('Sk.misceval.loadname', Sk.misceval.loadname);
  Sk.misceval.call = function (a, b, c, d, e) {
    e = Array.prototype.slice.call(arguments, 4);
    return Sk.misceval.apply(a, b, c, d, e);
  };
  goog.exportSymbol('Sk.misceval.call', Sk.misceval.call);
  Sk.misceval.callsim = function (a, b) {
    b = Array.prototype.slice.call(arguments, 1);
    return Sk.misceval.apply(a, void 0, void 0, void 0, b);
  };
  goog.exportSymbol('Sk.misceval.callsim', Sk.misceval.callsim);
  Sk.misceval.apply = function (a, b, c, d, e) {
    if (null === a || a instanceof Sk.builtin.none)
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not callable');
    if ('function' === typeof a) {
      if (a.sk$klass)
        return a.apply(null, [
          b,
          c,
          d,
          e
        ]);
      if (c) {
        c = c.tp$iter();
        for (var f = c.tp$iternext(); void 0 !== f; f = c.tp$iternext())
          e.push(f);
      }
      b && goog.asserts.fail('kwdict not implemented;');
      goog.asserts.assert(void 0 === d || 0 === d.length);
      return a.apply(null, e);
    }
    var g = a.tp$call;
    if (void 0 !== g) {
      if (c)
        for (c = c.tp$iter(), f = c.tp$iternext(); void 0 !== f; f = c.tp$iternext())
          e.push(f);
      b && goog.asserts.fail('kwdict not implemented;');
      return g.call(a, e, d, b);
    }
    g = a.__call__;
    if (void 0 !== g)
      return e.unshift(a), Sk.misceval.apply(g, d, e, b, c);
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not callable');
  };
  goog.exportSymbol('Sk.misceval.apply', Sk.misceval.apply);
  Sk.misceval.buildClass = function (a, b, c, d) {
    var e = Sk.builtin.type, f = {};
    b(a, f, []);
    f.__module__ = a.__name__;
    return Sk.misceval.callsim(e, c, d, f);
  };
  goog.exportSymbol('Sk.misceval.buildClass', Sk.misceval.buildClass);
  Sk.abstr = {};
  Sk.abstr.typeName = function (a) {
    return a instanceof Sk.builtin.nmber ? a.skType : void 0 !== a.tp$name ? a.tp$name : '<invalid type>';
  };
  Sk.abstr.binop_type_error = function (a, b, c) {
    a = Sk.abstr.typeName(a);
    b = Sk.abstr.typeName(b);
    throw new Sk.builtin.TypeError('unsupported operand type(s) for ' + c + ': \'' + a + '\' and \'' + b + '\'');
  };
  Sk.abstr.boNameToSlotFuncLhs_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'Add':
        return a.nb$add ? a.nb$add : a.__add__;
      case 'Sub':
        return a.nb$subtract ? a.nb$subtract : a.__sub__;
      case 'Mult':
        return a.nb$multiply ? a.nb$multiply : a.__mul__;
      case 'Div':
        return a.nb$divide ? a.nb$divide : a.__div__;
      case 'FloorDiv':
        return a.nb$floor_divide ? a.nb$floor_divide : a.__floordiv__;
      case 'Mod':
        return a.nb$remainder ? a.nb$remainder : a.__mod__;
      case 'Pow':
        return a.nb$power ? a.nb$power : a.__pow__;
      case 'LShift':
        return a.nb$lshift ? a.nb$lshift : a.__lshift__;
      case 'RShift':
        return a.nb$rshift ? a.nb$rshift : a.__rshift__;
      case 'BitAnd':
        return a.nb$and ? a.nb$and : a.__and__;
      case 'BitXor':
        return a.nb$xor ? a.nb$xor : a.__xor__;
      case 'BitOr':
        return a.nb$or ? a.nb$or : a.__or__;
      }
  };
  Sk.abstr.boNameToSlotFuncRhs_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'Add':
        return a.nb$add ? a.nb$add : a.__radd__;
      case 'Sub':
        return a.nb$subtract ? a.nb$subtract : a.__rsub__;
      case 'Mult':
        return a.nb$multiply ? a.nb$multiply : a.__rmul__;
      case 'Div':
        return a.nb$divide ? a.nb$divide : a.__rdiv__;
      case 'FloorDiv':
        return a.nb$floor_divide ? a.nb$floor_divide : a.__rfloordiv__;
      case 'Mod':
        return a.nb$remainder ? a.nb$remainder : a.__rmod__;
      case 'Pow':
        return a.nb$power ? a.nb$power : a.__rpow__;
      case 'LShift':
        return a.nb$lshift ? a.nb$lshift : a.__rlshift__;
      case 'RShift':
        return a.nb$rshift ? a.nb$rshift : a.__rrshift__;
      case 'BitAnd':
        return a.nb$and ? a.nb$and : a.__rand__;
      case 'BitXor':
        return a.nb$xor ? a.nb$xor : a.__rxor__;
      case 'BitOr':
        return a.nb$or ? a.nb$or : a.__ror__;
      }
  };
  Sk.abstr.iboNameToSlotFunc_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'Add':
        return a.nb$inplace_add ? a.nb$inplace_add : a.__iadd__;
      case 'Sub':
        return a.nb$inplace_subtract ? a.nb$inplace_subtract : a.__isub__;
      case 'Mult':
        return a.nb$inplace_multiply ? a.nb$inplace_multiply : a.__imul__;
      case 'Div':
        return a.nb$inplace_divide ? a.nb$inplace_divide : a.__idiv__;
      case 'FloorDiv':
        return a.nb$inplace_floor_divide ? a.nb$inplace_floor_divide : a.__ifloordiv__;
      case 'Mod':
        return a.nb$inplace_remainder;
      case 'Pow':
        return a.nb$inplace_power;
      case 'LShift':
        return a.nb$inplace_lshift ? a.nb$inplace_lshift : a.__ilshift__;
      case 'RShift':
        return a.nb$inplace_rshift ? a.nb$inplace_rshift : a.__irshift__;
      case 'BitAnd':
        return a.nb$inplace_and;
      case 'BitOr':
        return a.nb$inplace_or;
      case 'BitXor':
        return a.nb$inplace_xor ? a.nb$inplace_xor : a.__ixor__;
      }
  };
  Sk.abstr.binary_op_ = function (a, b, c) {
    var d;
    d = Sk.abstr.boNameToSlotFuncLhs_(a, c);
    if (void 0 !== d && (d = d.call ? d.call(a, b) : Sk.misceval.callsim(d, a, b), void 0 !== d))
      return d;
    d = Sk.abstr.boNameToSlotFuncRhs_(b, c);
    if (void 0 !== d && (d = d.call ? d.call(b, a) : Sk.misceval.callsim(d, b, a), void 0 !== d))
      return d;
    Sk.abstr.binop_type_error(a, b, c);
  };
  Sk.abstr.binary_iop_ = function (a, b, c) {
    var d;
    d = Sk.abstr.iboNameToSlotFunc_(a, c);
    if (void 0 !== d && (d = d.call ? d.call(a, b) : Sk.misceval.callsim(d, a, b), void 0 !== d))
      return d;
    d = Sk.abstr.iboNameToSlotFunc_(b, c);
    if (void 0 !== d && (d = d.call ? d.call(b, a) : Sk.misceval.callsim(d, b, a), void 0 !== d))
      return d;
    Sk.abstr.binop_type_error(a, b, c);
  };
  Sk.abstr.numOpAndPromote = function (a, b, c) {
    if (null !== a && null !== b) {
      if ('number' === typeof a && 'number' === typeof b)
        return c = c(a, b), (c > Sk.builtin.lng.threshold$ || c < -Sk.builtin.lng.threshold$) && Math.floor(c) === c ? [
          Sk.builtin.lng.fromInt$(a),
          Sk.builtin.lng.fromInt$(b)
        ] : c;
      if (void 0 === a || void 0 === b)
        throw new Sk.builtin.NameError('Undefined variable in expression');
      if (a.constructor === Sk.builtin.lng || a.constructor === Sk.builtin.nmber)
        return [
          a,
          b
        ];
      if ('number' === typeof a)
        return [
          new Sk.builtin.nmber(a, void 0),
          b
        ];
    }
  };
  Sk.abstr.boNumPromote_ = {
    Add: function (a, b) {
      return a + b;
    },
    Sub: function (a, b) {
      return a - b;
    },
    Mult: function (a, b) {
      return a * b;
    },
    Mod: function (a, b) {
      if (0 === b)
        throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
      var c = a % b;
      return 0 > c * b ? c + b : c;
    },
    Div: function (a, b) {
      if (0 === b)
        throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
      return a / b;
    },
    FloorDiv: function (a, b) {
      if (0 === b)
        throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
      return Math.floor(a / b);
    },
    Pow: Math.pow,
    BitAnd: function (a, b) {
      var c = a & b;
      0 > c && (c += 4294967296);
      return c;
    },
    BitOr: function (a, b) {
      var c = a | b;
      0 > c && (c += 4294967296);
      return c;
    },
    BitXor: function (a, b) {
      var c = a ^ b;
      0 > c && (c += 4294967296);
      return c;
    },
    LShift: function (a, b) {
      if (0 > b)
        throw new Sk.builtin.ValueError('negative shift count');
      var c = a << b;
      return c > a ? c : a * Math.pow(2, b);
    },
    RShift: function (a, b) {
      if (0 > b)
        throw new Sk.builtin.ValueError('negative shift count');
      var c = a >> b;
      0 < a && 0 > c && (c &= Math.pow(2, 32 - b) - 1);
      return c;
    }
  };
  Sk.abstr.numberBinOp = function (a, b, c) {
    var d = Sk.abstr.boNumPromote_[c];
    if (void 0 !== d) {
      d = Sk.abstr.numOpAndPromote(a, b, d);
      if ('number' === typeof d)
        return d;
      if (void 0 !== d && d.constructor === Sk.builtin.nmber || void 0 !== d && d.constructor === Sk.builtin.lng)
        return d;
      void 0 !== d && (a = d[0], b = d[1]);
    }
    return Sk.abstr.binary_op_(a, b, c);
  };
  goog.exportSymbol('Sk.abstr.numberBinOp', Sk.abstr.numberBinOp);
  Sk.abstr.numberInplaceBinOp = function (a, b, c) {
    var d = Sk.abstr.boNumPromote_[c];
    if (void 0 !== d) {
      d = Sk.abstr.numOpAndPromote(a, b, d);
      if ('number' === typeof d)
        return d;
      if (void 0 !== d && d.constructor === Sk.builtin.nmber || void 0 !== d && d.constructor === Sk.builtin.lng)
        return d;
      void 0 !== d && (a = d[0], b = d[1]);
    }
    return Sk.abstr.binary_iop_(a, b, c);
  };
  goog.exportSymbol('Sk.abstr.numberInplaceBinOp', Sk.abstr.numberInplaceBinOp);
  Sk.abstr.uboNameToSlotFunc_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'USub':
        return a.nb$negative ? a.nb$negative : a.__neg__;
      case 'Invert':
        return a.nb$invert ? a.nb$invert : a.__invert__;
      case 'UAdd':
        return a.nb$positive ? a.nb$positive : a.__pos__;
      default:
        throw new Sk.builtin.AssertionError('7fb8237f-879b-4192-89ce-13ad6fa3b2d8 ' + b);
      }
  };
  Sk.abstr.numberUnaryOp = function (a, b) {
    if ('Not' === b)
      return Sk.misceval.isTrue(a) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;
    if (a instanceof Sk.builtin.nmber || a instanceof Sk.builtin.bool) {
      var c = Sk.builtin.asnum$(a);
      if ('USub' === b)
        return new Sk.builtin.nmber(-c, c.skType);
      if ('Invert' === b)
        return new Sk.builtin.nmber(~c, c.skType);
      if ('UAdd' === b)
        return new Sk.builtin.nmber(c, c.skType);
    } else if (c = Sk.abstr.uboNameToSlotFunc_(a, b), void 0 != c)
      return c.call ? c.call(a) : Sk.misceval.callsim(c, a);
    c = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('unsupported operand type for ' + b + ' \'' + c + '\'');
  };
  goog.exportSymbol('Sk.abstr.numberUnaryOp', Sk.abstr.numberUnaryOp);
  Sk.abstr.fixSeqIndex_ = function (a, b) {
    b = Sk.builtin.asnum$(b);
    0 > b && a.sq$length && (b += a.sq$length());
    return b;
  };
  Sk.abstr.sequenceContains = function (a, b) {
    if (a.sq$contains)
      return a.sq$contains(b);
    var c = Sk.abstr.typeName(a);
    if (!a.tp$iter)
      throw new Sk.builtin.TypeError('argument of type \'' + c + '\' is not iterable');
    for (var c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      if (Sk.misceval.richCompareBool(d, b, 'Eq'))
        return !0;
    return !1;
  };
  Sk.abstr.sequenceGetItem = function (a, b) {
    goog.asserts.fail();
  };
  Sk.abstr.sequenceSetItem = function (a, b, c) {
    goog.asserts.fail();
  };
  Sk.abstr.sequenceDelItem = function (a, b) {
    if (a.sq$del_item)
      b = Sk.abstr.fixSeqIndex_(a, b), a.sq$del_item(b);
    else {
      var c = Sk.abstr.typeName(a);
      throw new Sk.builtin.TypeError('\'' + c + '\' object does not support item deletion');
    }
  };
  Sk.abstr.sequenceRepeat = function (a, b, c) {
    c = Sk.builtin.asnum$(c);
    if (void 0 === Sk.misceval.asIndex(c))
      throw a = Sk.abstr.typeName(c), new Sk.builtin.TypeError('can\'t multiply sequence by non-int of type \'' + a + '\'');
    return a.call(b, c);
  };
  Sk.abstr.sequenceGetSlice = function (a, b, c) {
    if (a.sq$slice)
      return b = Sk.abstr.fixSeqIndex_(a, b), c = Sk.abstr.fixSeqIndex_(a, c), a.sq$slice(b, c);
    if (a.mp$subscript)
      return a.mp$subscript(new Sk.builtin.slice(b, c));
    a = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('\'' + a + '\' object is unsliceable');
  };
  Sk.abstr.sequenceDelSlice = function (a, b, c) {
    if (a.sq$del_slice)
      b = Sk.abstr.fixSeqIndex_(a, b), c = Sk.abstr.fixSeqIndex_(a, c), a.sq$del_slice(b, c);
    else
      throw a = Sk.abstr.typeName(a), new Sk.builtin.TypeError('\'' + a + '\' doesn\'t support slice deletion');
  };
  Sk.abstr.sequenceSetSlice = function (a, b, c, d) {
    if (a.sq$ass_slice)
      b = Sk.abstr.fixSeqIndex_(a, b), c = Sk.abstr.fixSeqIndex_(a, c), a.sq$ass_slice(b, c, d);
    else if (a.mp$ass_subscript)
      a.mp$ass_subscript(new Sk.builtin.slice(b, c), d);
    else
      throw a = Sk.abstr.typeName(a), new Sk.builtin.TypeError('\'' + a + '\' object doesn\'t support slice assignment');
  };
  Sk.abstr.objectDelItem = function (a, b) {
    if (null !== a) {
      if (a.mp$del_subscript) {
        a.mp$del_subscript(b);
        return;
      }
      if (a.sq$ass_item) {
        var c = Sk.misceval.asIndex(b);
        if (void 0 === c)
          throw c = Sk.abstr.typeName(b), new Sk.builtin.TypeError('sequence index must be integer, not \'' + c + '\'');
        Sk.abstr.sequenceDelItem(a, c);
        return;
      }
    }
    c = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('\'' + c + '\' object does not support item deletion');
  };
  goog.exportSymbol('Sk.abstr.objectDelItem', Sk.abstr.objectDelItem);
  Sk.abstr.objectGetItem = function (a, b) {
    if (null !== a) {
      if (a.mp$subscript)
        return a.mp$subscript(b);
      if (Sk.misceval.isIndex(b) && a.sq$item)
        return Sk.abstr.sequenceGetItem(a, Sk.misceval.asIndex(b));
      if (a.tp$getitem)
        return a.tp$getitem(b);
    }
    var c = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('\'' + c + '\' does not support indexing');
  };
  goog.exportSymbol('Sk.abstr.objectGetItem', Sk.abstr.objectGetItem);
  Sk.abstr.objectSetItem = function (a, b, c) {
    if (null !== a) {
      if (a.mp$ass_subscript)
        return a.mp$ass_subscript(b, c);
      if (Sk.misceval.isIndex(b) && a.sq$ass_item)
        return Sk.abstr.sequenceSetItem(a, Sk.misceval.asIndex(b), c);
      if (a.tp$setitem)
        return a.tp$setitem(b, c);
    }
    a = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('\'' + a + '\' does not support item assignment');
  };
  goog.exportSymbol('Sk.abstr.objectSetItem', Sk.abstr.objectSetItem);
  Sk.abstr.gattr = function (a, b) {
    var c = Sk.abstr.typeName(a);
    if (null === a)
      throw new Sk.builtin.AttributeError('\'' + c + '\' object has no attribute \'' + b + '\'');
    var d = void 0;
    a.__getattr__ ? d = Sk.misceval.callsim(a.__getattr__, a, b) : void 0 !== a.tp$getattr && (d = a.tp$getattr(b));
    if (void 0 === d)
      throw new Sk.builtin.AttributeError('\'' + c + '\' object has no attribute \'' + b + '\'');
    return d;
  };
  goog.exportSymbol('Sk.abstr.gattr', Sk.abstr.gattr);
  Sk.abstr.sattr = function (a, b, c) {
    var d = Sk.abstr.typeName(a);
    if (null === a)
      throw new Sk.builtin.AttributeError('\'' + d + '\' object has no attribute \'' + b + '\'');
    if (a.__setattr__)
      Sk.misceval.callsim(a.__setattr__, a, b, c);
    else if (void 0 !== a.tp$setattr)
      a.tp$setattr(b, c);
    else
      throw new Sk.builtin.AttributeError('\'' + d + '\' object has no attribute \'' + b + '\'');
  };
  goog.exportSymbol('Sk.abstr.sattr', Sk.abstr.sattr);
  Sk.abstr.iter = function (a) {
    if (a.tp$iter)
      return a.tp$iter();
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not iterable');
  };
  goog.exportSymbol('Sk.abstr.iter', Sk.abstr.iter);
  Sk.abstr.iternext = function (a) {
    return a.tp$iternext();
  };
  goog.exportSymbol('Sk.abstr.iternext', Sk.abstr.iternext);
  Sk.mergeSort = function (a, b, c, d) {
    Sk.quickSort(a, b, c, d);
  };
  Sk.quickSort = function (a, b, c, d) {
    goog.asserts.assert(!c, 'todo;');
    b || (b = Sk.mergeSort.stdCmp);
    var e = function (a, c, d, k) {
      if (d - 1 > c) {
        var l = c + Math.floor(Math.random() * (d - c)), m, n = a[l];
        m = a[l];
        a[l] = a[d - 1];
        a[d - 1] = m;
        var l = c, p;
        for (p = c; p < d - 1; ++p)
          m = k ? Sk.misceval.callsim(b, n, a[p]) : Sk.misceval.callsim(b, a[p], n), 0 > Sk.builtin.asnum$(m) && (m = a[l], a[l] = a[p], a[p] = m, ++l);
        m = a[d - 1];
        a[d - 1] = a[l];
        a[l] = m;
        e(a, c, l, k);
        e(a, l + 1, d, k);
      }
    };
    e(a, 0, a.length, d);
    return null;
  };
  Sk.mergeSort.stdCmp = new Sk.builtin.func(function (a, b) {
    return Sk.misceval.richCompareBool(a, b, 'Lt') ? -1 : 0;
  });
  Sk.builtin.list = function (a) {
    if (!(this instanceof Sk.builtin.list))
      return new Sk.builtin.list(a);
    if (void 0 === a)
      this.v = [];
    else if ('[object Array]' === Object.prototype.toString.apply(a))
      this.v = a;
    else if (a.tp$iter) {
      this.v = [];
      a = a.tp$iter();
      for (var b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext())
        this.v.push(b);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
    this.__class__ = Sk.builtin.list;
    this.v = this.v;
    return this;
  };
  Sk.builtin.list.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('list', Sk.builtin.list);
  Sk.builtin.list.prototype.list_iter_ = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : a.$obj.v[a.$index++];
        }
      };
    return a;
  };
  Sk.builtin.list.prototype.list_concat_ = function (a) {
    if (!a.__class__ || a.__class__ != Sk.builtin.list)
      throw new Sk.builtin.TypeError('can only concatenate list to list');
    for (var b = this.v.slice(), c = 0; c < a.v.length; ++c)
      b.push(a.v[c]);
    return new Sk.builtin.list(b);
  };
  Sk.builtin.list.prototype.list_del_item_ = function (a) {
    a = Sk.builtin.asnum$(a);
    if (0 > a || a >= this.v.length)
      throw new Sk.builtin.IndexError('list assignment index out of range');
    this.list_del_slice_(a, a + 1);
  };
  Sk.builtin.list.prototype.list_del_slice_ = function (a, b) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    var c = [];
    c.unshift(b - a);
    c.unshift(a);
    this.v.splice.apply(this.v, c);
  };
  Sk.builtin.list.prototype.list_ass_item_ = function (a, b) {
    a = Sk.builtin.asnum$(a);
    if (0 > a || a >= this.v.length)
      throw new Sk.builtin.IndexError('list assignment index out of range');
    this.v[a] = b;
  };
  Sk.builtin.list.prototype.list_ass_slice_ = function (a, b, c) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    c = c.v.slice(0);
    c.unshift(b - a);
    c.unshift(a);
    this.v.splice.apply(this.v, c);
  };
  Sk.builtin.list.prototype.tp$name = 'list';
  Sk.builtin.list.prototype.$r = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      a.push(Sk.misceval.objectRepr(c).v);
    return new Sk.builtin.str('[' + a.join(', ') + ']');
  };
  Sk.builtin.list.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.list.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
  Sk.builtin.list.prototype.tp$richcompare = function (a, b) {
    if (this === a && Sk.misceval.opAllowsEquality(b))
      return !0;
    if (!a.__class__ || a.__class__ != Sk.builtin.list)
      return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : !1;
    var c = this.v;
    a = a.v;
    var d = c.length, e = a.length, f;
    for (f = 0; f < d && f < e && Sk.misceval.richCompareBool(c[f], a[f], 'Eq'); ++f);
    if (f >= d || f >= e)
      switch (b) {
      case 'Lt':
        return d < e;
      case 'LtE':
        return d <= e;
      case 'Eq':
        return d === e;
      case 'NotEq':
        return d !== e;
      case 'Gt':
        return d > e;
      case 'GtE':
        return d >= e;
      default:
        goog.asserts.fail();
      }
    return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : Sk.misceval.richCompareBool(c[f], a[f], b);
  };
  Sk.builtin.list.prototype.tp$iter = Sk.builtin.list.prototype.list_iter_;
  Sk.builtin.list.prototype.sq$length = function () {
    return this.v.length;
  };
  Sk.builtin.list.prototype.sq$concat = Sk.builtin.list.prototype.list_concat_;
  Sk.builtin.list.prototype.nb$add = Sk.builtin.list.prototype.list_concat_;
  Sk.builtin.list.prototype.nb$inplace_add = Sk.builtin.list.prototype.list_concat_;
  Sk.builtin.list.prototype.sq$repeat = function (a) {
    a = Sk.builtin.asnum$(a);
    for (var b = [], c = 0; c < a; ++c)
      for (var d = 0; d < this.v.length; ++d)
        b.push(this.v[d]);
    return new Sk.builtin.list(b);
  };
  Sk.builtin.list.prototype.nb$multiply = Sk.builtin.list.prototype.sq$repeat;
  Sk.builtin.list.prototype.nb$inplace_multiply = Sk.builtin.list.prototype.sq$repeat;
  Sk.builtin.list.prototype.sq$ass_item = Sk.builtin.list.prototype.list_ass_item_;
  Sk.builtin.list.prototype.sq$del_item = Sk.builtin.list.prototype.list_del_item_;
  Sk.builtin.list.prototype.sq$ass_slice = Sk.builtin.list.prototype.list_ass_slice_;
  Sk.builtin.list.prototype.sq$del_slice = Sk.builtin.list.prototype.list_del_slice_;
  Sk.builtin.list.prototype.list_subscript_ = function (a) {
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        if (0 > b || b >= this.v.length)
          throw new Sk.builtin.IndexError('list index out of range');
        return this.v[b];
      }
    } else if (a instanceof Sk.builtin.slice) {
      var c = [];
      a.sssiter$(this, function (a, b) {
        c.push(b.v[a]);
      });
      return new Sk.builtin.list(c);
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.abstr.typeName(a));
  };
  Sk.builtin.list.prototype.list_ass_subscript_ = function (a, b) {
    if (Sk.misceval.isIndex(a)) {
      var c = Sk.misceval.asIndex(a);
      if (void 0 !== c) {
        0 > c && (c = this.v.length + c);
        this.list_ass_item_(c, b);
        return;
      }
    } else if (a instanceof Sk.builtin.slice) {
      if (1 === (null !== a.step ? a.step : 1))
        this.list_ass_slice_(a.start, a.stop, b);
      else {
        var d = [];
        a.sssiter$(this, function (a, b) {
          d.push(a);
        });
        var e = 0;
        if (d.length !== b.v.length)
          throw new Sk.builtin.ValueError('attempt to assign sequence of size ' + b.v.length + ' to extended slice of size ' + d.length);
        for (c = 0; c < d.length; ++c)
          this.v.splice(d[c], 1, b.v[e]), e += 1;
      }
      return;
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.abstr.typeName(a));
  };
  Sk.builtin.list.prototype.list_del_subscript_ = function (a) {
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        this.list_del_item_(b);
        return;
      }
    } else if (a instanceof Sk.builtin.slice) {
      if (1 === a.step)
        this.list_del_slice_(a.start, a.stop);
      else {
        var c = this, d = 0, e = 0 < (null === a.step ? 1 : a.step) ? 1 : 0;
        a.sssiter$(this, function (a, b) {
          c.v.splice(a - d, 1);
          d += e;
        });
      }
      return;
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + typeof a);
  };
  Sk.builtin.list.prototype.mp$subscript = Sk.builtin.list.prototype.list_subscript_;
  Sk.builtin.list.prototype.mp$ass_subscript = Sk.builtin.list.prototype.list_ass_subscript_;
  Sk.builtin.list.prototype.mp$del_subscript = Sk.builtin.list.prototype.list_del_subscript_;
  Sk.builtin.list.prototype.__getitem__ = new Sk.builtin.func(function (a, b) {
    return Sk.builtin.list.prototype.list_subscript_.call(a, b);
  });
  Sk.builtin.list.prototype.list_sort_ = function (a, b, c, d) {
    var e = void 0 !== c && null !== c, f = void 0 !== b && null !== b;
    void 0 == d && (d = !1);
    var g = new Sk.builtin.timSort(a);
    a.v = [];
    var h = new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
    if (e) {
      g.lt = f ? function (a, c) {
        return Sk.misceval.richCompareBool(b.func_code(a[0], c[0]), h, 'Lt');
      } : function (a, b) {
        return Sk.misceval.richCompareBool(a[0], b[0], 'Lt');
      };
      for (var k = 0; k < g.listlength; k++) {
        var f = g.list.v[k], l = c.func_code(f);
        g.list.v[k] = [
          l,
          f
        ];
      }
    } else
      f && (g.lt = function (a, c) {
        return Sk.misceval.richCompareBool(b.func_code(a, c), h, 'Lt');
      });
    d && g.list.list_reverse_(g.list);
    g.sort();
    d && g.list.list_reverse_(g.list);
    if (e)
      for (c = 0; c < g.listlength; c++)
        f = g.list.v[c][1], g.list.v[c] = f;
    c = 0 < a.sq$length();
    a.v = g.list.v;
    if (c)
      throw new Sk.builtin.OperationError('list modified during sort');
  };
  Sk.builtin.list.prototype.list_reverse_ = function (a) {
    Sk.builtin.pyCheckArgs('reverse', arguments, 1, 1);
    for (var b = a.v, c = [], d = a.v.length - 1; -1 < d; --d)
      c.push(b[d]);
    a.v = c;
    return null;
  };
  Sk.builtin.list.prototype.__iter__ = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
    return a.list_iter_();
  });
  Sk.builtin.list.prototype.append = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('append', arguments, 2, 2);
    a.v.push(b);
    return null;
  });
  Sk.builtin.list.prototype.insert = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('insert', arguments, 3, 3);
    if (!Sk.builtin.checkNumber(b))
      throw new Sk.builtin.TypeError('an integer is required');
    b = Sk.builtin.asnum$(b);
    0 > b ? b = 0 : b > a.v.length && (b = a.v.length);
    a.v.splice(b, 0, c);
  });
  Sk.builtin.list.prototype.extend = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('extend', arguments, 2, 2);
    if (!Sk.builtin.checkIterable(b))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object is not iterable');
    if (a == b) {
      for (var c = [], d = b.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
        c.push(e);
      a.v.push.apply(a.v, c);
      return null;
    }
    d = b.tp$iter();
    for (e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      a.v.push(e);
    return null;
  });
  Sk.builtin.list.prototype.pop = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('pop', arguments, 1, 2);
    void 0 === b && (b = a.v.length - 1);
    if (!Sk.builtin.checkNumber(b))
      throw new Sk.builtin.TypeError('an integer is required');
    b = Sk.builtin.asnum$(b);
    if (0 > b || b >= a.v.length)
      throw new Sk.builtin.IndexError('pop index out of range');
    var c = a.v[b];
    a.v.splice(b, 1);
    return c;
  });
  Sk.builtin.list.prototype.remove = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('remove', arguments, 2, 2);
    var c = Sk.builtin.list.prototype.index.func_code(a, b);
    a.v.splice(c, 1);
    return null;
  });
  Sk.builtin.list.prototype.index = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('index', arguments, 2, 2);
    for (var c = a.v.length, d = a.v, e = 0; e < c; ++e)
      if (Sk.misceval.richCompareBool(d[e], b, 'Eq'))
        return e;
    throw new Sk.builtin.ValueError('list.index(x): x not in list');
  });
  Sk.builtin.list.prototype.count = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('count', arguments, 2, 2);
    for (var c = a.v.length, d = a.v, e = 0, f = 0; f < c; ++f)
      Sk.misceval.richCompareBool(d[f], b, 'Eq') && (e += 1);
    return e;
  });
  Sk.builtin.list.prototype.reverse = new Sk.builtin.func(Sk.builtin.list.prototype.list_reverse_);
  Sk.builtin.list.prototype.sort = new Sk.builtin.func(Sk.builtin.list.prototype.list_sort_);
  Sk.builtin.list.prototype.sort.func_code.co_varnames = [
    '__self__',
    'cmp',
    'key',
    'reverse'
  ];
  goog.exportSymbol('Sk.builtin.list', Sk.builtin.list);
  var interned = {};
  Sk.builtin.str = function (a) {
    void 0 === a && (a = '');
    if (a instanceof Sk.builtin.str && a !== Sk.builtin.str.prototype.ob$type)
      return a;
    if (!(this instanceof Sk.builtin.str))
      return new Sk.builtin.str(a);
    if (!0 === a)
      a = 'True';
    else if (!1 === a)
      a = 'False';
    else if (null === a || a instanceof Sk.builtin.none)
      a = 'None';
    else if (a instanceof Sk.builtin.bool)
      a = a.v ? 'True' : 'False';
    else if ('number' === typeof a)
      a = a.toString(), 'Infinity' === a ? a = 'inf' : '-Infinity' === a && (a = '-inf');
    else if ('string' !== typeof a) {
      if (void 0 !== a.tp$str) {
        a = a.tp$str();
        if (!(a instanceof Sk.builtin.str))
          throw new Sk.builtin.ValueError('__str__ didn\'t return a str');
        return a;
      }
      return Sk.misceval.objectRepr(a);
    }
    if (Object.prototype.hasOwnProperty.call(interned, '1' + a))
      return interned['1' + a];
    this.__class__ = Sk.builtin.str;
    this.v = this.v = a;
    interned['1' + a] = this;
    return this;
  };
  goog.exportSymbol('Sk.builtin.str', Sk.builtin.str);
  Sk.builtin.str.$emptystr = new Sk.builtin.str('');
  Sk.builtin.str.prototype.mp$subscript = function (a) {
    a = Sk.builtin.asnum$(a);
    if ('number' === typeof a && Math.floor(a) === a) {
      0 > a && (a = this.v.length + a);
      if (0 > a || a >= this.v.length)
        throw new Sk.builtin.IndexError('string index out of range');
      return new Sk.builtin.str(this.v.charAt(a));
    }
    if (a instanceof Sk.builtin.slice) {
      var b = '';
      a.sssiter$(this, function (a, d) {
        0 <= a && a < d.v.length && (b += d.v.charAt(a));
      });
      return new Sk.builtin.str(b);
    }
    throw new Sk.builtin.TypeError('string indices must be numbers, not ' + typeof a);
  };
  Sk.builtin.str.prototype.sq$length = function () {
    return this.v.length;
  };
  Sk.builtin.str.prototype.sq$concat = function (a) {
    if (!a || !Sk.builtin.checkString(a))
      throw a = Sk.abstr.typeName(a), new Sk.builtin.TypeError('cannot concatenate \'str\' and \'' + a + '\' objects');
    return new Sk.builtin.str(this.v + a.v);
  };
  Sk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;
  Sk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;
  Sk.builtin.str.prototype.sq$repeat = function (a) {
    a = Sk.builtin.asnum$(a);
    for (var b = '', c = 0; c < a; ++c)
      b += this.v;
    return new Sk.builtin.str(b);
  };
  Sk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;
  Sk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;
  Sk.builtin.str.prototype.sq$item = function () {
    goog.asserts.fail();
  };
  Sk.builtin.str.prototype.sq$slice = function (a, b) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    0 > a && (a = 0);
    return new Sk.builtin.str(this.v.substr(a, b - a));
  };
  Sk.builtin.str.prototype.sq$contains = function (a) {
    if (void 0 === a.v || a.v.constructor != String)
      throw new Sk.builtin.TypeError('TypeError: \'In <string> requires string as left operand');
    return -1 != this.v.indexOf(a.v) ? !0 : !1;
  };
  Sk.builtin.str.prototype.tp$name = 'str';
  Sk.builtin.str.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.str.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : new Sk.builtin.str(a.$obj.v.substr(a.$index++, 1));
        }
      };
    return a;
  };
  Sk.builtin.str.prototype.tp$richcompare = function (a, b) {
    if (a instanceof Sk.builtin.str) {
      if (this === a)
        switch (b) {
        case 'Eq':
        case 'LtE':
        case 'GtE':
          return !0;
        case 'NotEq':
        case 'Lt':
        case 'Gt':
          return !1;
        }
      var c = this.v.length, d = a.v.length, e = Math.min(c, d), f = 0;
      if (0 < e)
        for (var g = 0; g < e; ++g) {
          if (this.v[g] != a.v[g]) {
            f = this.v[g].charCodeAt(0) - a.v[g].charCodeAt(0);
            break;
          }
        }
      else
        f = 0;
      0 == f && (f = c < d ? -1 : c > d ? 1 : 0);
      switch (b) {
      case 'Lt':
        return 0 > f;
      case 'LtE':
        return 0 >= f;
      case 'Eq':
        return 0 == f;
      case 'NotEq':
        return 0 != f;
      case 'Gt':
        return 0 < f;
      case 'GtE':
        return 0 <= f;
      default:
        goog.asserts.fail();
      }
    }
  };
  Sk.builtin.str.prototype.$r = function () {
    var a = '\'';
    -1 !== this.v.indexOf('\'') && -1 === this.v.indexOf('"') && (a = '"');
    for (var b = this.v.length, c = a, d = 0; d < b; ++d) {
      var e = this.v.charAt(d);
      e === a || '\\' === e ? c += '\\' + e : '\t' === e ? c += '\\t' : '\n' === e ? c += '\\n' : '\r' === e ? c += '\\r' : ' ' > e || 127 <= e ? (e = e.charCodeAt(0).toString(16), 2 > e.length && (e = '0' + e), c += '\\x' + e) : c += e;
    }
    return new Sk.builtin.str(c + a);
  };
  Sk.builtin.str.re_escape_ = function (a) {
    for (var b = [], c = /^[A-Za-z0-9]+$/, d = 0; d < a.length; ++d) {
      var e = a.charAt(d);
      c.test(e) ? b.push(e) : '\\000' === e ? b.push('\\000') : b.push('\\' + e);
    }
    return b.join('');
  };
  Sk.builtin.str.prototype.lower = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('lower', arguments, 1, 1);
    return new Sk.builtin.str(a.v.toLowerCase());
  });
  Sk.builtin.str.prototype.upper = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('upper', arguments, 1, 1);
    return new Sk.builtin.str(a.v.toUpperCase());
  });
  Sk.builtin.str.prototype.capitalize = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('capitalize', arguments, 1, 1);
    var b = a.v, c, d;
    if (0 === b.length)
      return new Sk.builtin.str('');
    c = b.charAt(0).toUpperCase();
    for (d = 1; d < b.length; d++)
      c += b.charAt(d).toLowerCase();
    return new Sk.builtin.str(c);
  });
  Sk.builtin.str.prototype.join = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('join', arguments, 2, 2);
    Sk.builtin.pyCheckType('seq', 'iterable', Sk.builtin.checkIterable(b));
    for (var c = [], d = b.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext()) {
      if (e.constructor !== Sk.builtin.str)
        throw 'TypeError: sequence item ' + c.length + ': expected string, ' + typeof e + ' found';
      c.push(e.v);
    }
    return new Sk.builtin.str(c.join(a.v));
  });
  Sk.builtin.str.prototype.split = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('split', arguments, 1, 3);
    if (void 0 === b || b instanceof Sk.builtin.none)
      b = null;
    if (null !== b && !Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('expected a string');
    if (null !== b && '' === b.v)
      throw new Sk.builtin.ValueError('empty separator');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('an integer is required');
    c = Sk.builtin.asnum$(c);
    var d = /[\s]+/g, e = a.v;
    null === b ? e = e.trimLeft() : (d = b.v.replace(/([.*+?=|\\\/()\[\]\{\}^$])/g, '\\$1'), d = RegExp(d, 'g'));
    for (var f = [], g, h = 0, k = 0; null != (g = d.exec(e)) && g.index !== d.lastIndex && !(f.push(new Sk.builtin.str(e.substring(h, g.index))), h = d.lastIndex, k += 1, c && k >= c););
    e = e.substring(h);
    (null !== b || 0 < e.length) && f.push(new Sk.builtin.str(e));
    return new Sk.builtin.list(f);
  });
  Sk.builtin.str.prototype.strip = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('strip', arguments, 1, 2);
    if (void 0 !== b && !Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('strip arg must be None or str');
    var c;
    void 0 === b ? c = /^\s+|\s+$/g : (c = Sk.builtin.str.re_escape_(b.v), c = RegExp('^[' + c + ']+|[' + c + ']+$', 'g'));
    return new Sk.builtin.str(a.v.replace(c, ''));
  });
  Sk.builtin.str.prototype.lstrip = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('lstrip', arguments, 1, 2);
    if (void 0 !== b && !Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('lstrip arg must be None or str');
    var c;
    void 0 === b ? c = /^\s+/g : (c = Sk.builtin.str.re_escape_(b.v), c = RegExp('^[' + c + ']+', 'g'));
    return new Sk.builtin.str(a.v.replace(c, ''));
  });
  Sk.builtin.str.prototype.rstrip = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('rstrip', arguments, 1, 2);
    if (void 0 !== b && !Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('rstrip arg must be None or str');
    var c;
    void 0 === b ? c = /\s+$/g : (c = Sk.builtin.str.re_escape_(b.v), c = RegExp('[' + c + ']+$', 'g'));
    return new Sk.builtin.str(a.v.replace(c, ''));
  });
  Sk.builtin.str.prototype.partition = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('partition', arguments, 2, 2);
    Sk.builtin.pyCheckType('sep', 'string', Sk.builtin.checkString(b));
    var c = new Sk.builtin.str(b), d = a.v.indexOf(c.v);
    return 0 > d ? new Sk.builtin.tuple([
      a,
      Sk.builtin.str.$emptystr,
      Sk.builtin.str.$emptystr
    ]) : new Sk.builtin.tuple([
      new Sk.builtin.str(a.v.substring(0, d)),
      c,
      new Sk.builtin.str(a.v.substring(d + c.v.length))
    ]);
  });
  Sk.builtin.str.prototype.rpartition = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('rpartition', arguments, 2, 2);
    Sk.builtin.pyCheckType('sep', 'string', Sk.builtin.checkString(b));
    var c = new Sk.builtin.str(b), d = a.v.lastIndexOf(c.v);
    return 0 > d ? new Sk.builtin.tuple([
      Sk.builtin.str.$emptystr,
      Sk.builtin.str.$emptystr,
      a
    ]) : new Sk.builtin.tuple([
      new Sk.builtin.str(a.v.substring(0, d)),
      c,
      new Sk.builtin.str(a.v.substring(d + c.v.length))
    ]);
  });
  Sk.builtin.str.prototype.count = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('count', arguments, 2, 4);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('expected a character buffer object');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    void 0 === c ? c = 0 : (c = Sk.builtin.asnum$(c), c = 0 <= c ? c : a.v.length + c);
    void 0 === d ? d = a.v.length : (d = Sk.builtin.asnum$(d), d = 0 <= d ? d : a.v.length + d);
    var e = RegExp(b.v, 'g');
    return (e = a.v.slice(c, d).match(e)) ? e.length : 0;
  });
  Sk.builtin.str.prototype.ljust = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('ljust', arguments, 2, 3);
    if (!Sk.builtin.checkInt(b))
      throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(b));
    if (void 0 !== c && (!Sk.builtin.checkString(c) || 1 !== c.v.length))
      throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(c));
    c = void 0 === c ? ' ' : c.v;
    b = Sk.builtin.asnum$(b);
    if (a.v.length >= b)
      return a;
    var d = Array.prototype.join.call({ length: Math.floor(b - a.v.length) + 1 }, c);
    return new Sk.builtin.str(a.v + d);
  });
  Sk.builtin.str.prototype.rjust = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('rjust', arguments, 2, 3);
    if (!Sk.builtin.checkInt(b))
      throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(b));
    if (void 0 !== c && (!Sk.builtin.checkString(c) || 1 !== c.v.length))
      throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(c));
    c = void 0 === c ? ' ' : c.v;
    b = Sk.builtin.asnum$(b);
    if (a.v.length >= b)
      return a;
    var d = Array.prototype.join.call({ length: Math.floor(b - a.v.length) + 1 }, c);
    return new Sk.builtin.str(d + a.v);
  });
  Sk.builtin.str.prototype.center = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('center', arguments, 2, 3);
    if (!Sk.builtin.checkInt(b))
      throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(b));
    if (void 0 !== c && (!Sk.builtin.checkString(c) || 1 !== c.v.length))
      throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(c));
    c = void 0 === c ? ' ' : c.v;
    b = Sk.builtin.asnum$(b);
    if (a.v.length >= b)
      return a;
    var d = Array.prototype.join.call({ length: Math.floor((b - a.v.length) / 2) + 1 }, c), d = d + a.v + d;
    d.length < b && (d += c);
    return new Sk.builtin.str(d);
  });
  Sk.builtin.str.prototype.find = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('find', arguments, 2, 4);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('expected a character buffer object');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    void 0 === c ? c = 0 : (c = Sk.builtin.asnum$(c), c = 0 <= c ? c : a.v.length + c);
    void 0 === d ? d = a.v.length : (d = Sk.builtin.asnum$(d), d = 0 <= d ? d : a.v.length + d);
    var e = a.v.indexOf(b.v, c);
    return new Sk.builtin.nmber(e >= c && e < d ? e : -1, Sk.builtin.nmber.int$);
  });
  Sk.builtin.str.prototype.index = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('index', arguments, 2, 4);
    var e = Sk.misceval.callsim(a.find, a, b, c, d);
    if (-1 === Sk.builtin.asnum$(e))
      throw new Sk.builtin.ValueError('substring not found');
    return e;
  });
  Sk.builtin.str.prototype.rfind = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('rfind', arguments, 2, 4);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('expected a character buffer object');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    void 0 === c ? c = 0 : (c = Sk.builtin.asnum$(c), c = 0 <= c ? c : a.v.length + c);
    void 0 === d ? d = a.v.length : (d = Sk.builtin.asnum$(d), d = 0 <= d ? d : a.v.length + d);
    var e = a.v.lastIndexOf(b.v, d), e = e !== d ? e : a.v.lastIndexOf(b.v, d - 1);
    return new Sk.builtin.nmber(e >= c && e < d ? e : -1, Sk.builtin.nmber.int$);
  });
  Sk.builtin.str.prototype.rindex = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('rindex', arguments, 2, 4);
    var e = Sk.misceval.callsim(a.rfind, a, b, c, d);
    if (-1 === Sk.builtin.asnum$(e))
      throw new Sk.builtin.ValueError('substring not found');
    return e;
  });
  Sk.builtin.str.prototype.startswith = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('startswith', arguments, 2, 2);
    Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.checkString(b));
    return Sk.builtin.bool(0 == a.v.indexOf(b.v));
  });
  Sk.builtin.str.prototype.endswith = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('endswith', arguments, 2, 2);
    Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.checkString(b));
    return Sk.builtin.bool(-1 !== a.v.indexOf(b.v, a.v.length - b.v.length));
  });
  Sk.builtin.str.prototype.replace = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('replace', arguments, 3, 4);
    Sk.builtin.pyCheckType('oldS', 'string', Sk.builtin.checkString(b));
    Sk.builtin.pyCheckType('newS', 'string', Sk.builtin.checkString(c));
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('integer argument expected, got ' + Sk.abstr.typeName(d));
    d = Sk.builtin.asnum$(d);
    var e = RegExp(Sk.builtin.str.re_escape_(b.v), 'g');
    if (void 0 === d || 0 > d)
      return new Sk.builtin.str(a.v.replace(e, c.v));
    var f = 0;
    return new Sk.builtin.str(a.v.replace(e, function (a) {
      f++;
      return f <= d ? c.v : a;
    }));
  });
  Sk.builtin.str.prototype.isdigit = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('isdigit', arguments, 1, 1);
    if (0 === a.v.length)
      return Sk.builtin.bool(!1);
    var b;
    for (b = 0; b < a.v.length; b++) {
      var c = a.v.charAt(b);
      if ('0' > c || '9' < c)
        return Sk.builtin.bool(!1);
    }
    return Sk.builtin.bool(!0);
  });
  Sk.builtin.str.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('str', Sk.builtin.str);
  Sk.builtin.str.prototype.nb$remainder = function (a) {
    a.constructor === Sk.builtin.tuple || void 0 !== a.mp$subscript && a.constructor !== Sk.builtin.str || (a = new Sk.builtin.tuple([a]));
    var b = 0, c = this.v.replace(/%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g, function (c, e, f, g, h, k, l) {
        g = Sk.builtin.asnum$(g);
        h = Sk.builtin.asnum$(h);
        var m;
        if (void 0 === e || '' === e)
          m = b++;
        var n = !1, p = !1, q = !1, r = !1, v = !1;
        f && (-1 !== f.indexOf('-') ? p = !0 : -1 !== f.indexOf('0') && (n = !0), -1 !== f.indexOf('+') ? r = !0 : -1 !== f.indexOf(' ') && (q = !0), v = -1 !== f.indexOf('#'));
        h && (h = parseInt(h.substr(1), 10));
        f = function (a, b) {
          b = Sk.builtin.asnum$(b);
          var c, d, e = !1;
          'number' === typeof a ? (0 > a && (a = -a, e = !0), d = a.toString(b)) : a instanceof Sk.builtin.nmber ? (d = a.str$(b, !1), 2 < d.length && '.0' === d.substr(-2) && (d = d.substr(0, d.length - 2)), e = a.nb$isnegative()) : a instanceof Sk.builtin.lng && (d = a.str$(b, !1), e = a.nb$isnegative());
          goog.asserts.assert(void 0 !== d, 'unhandled number format');
          var f = !1;
          if (h)
            for (c = d.length; c < h; ++c)
              d = '0' + d, f = !0;
          c = '';
          e ? c = '-' : r ? c = '+' + c : q && (c = ' ' + c);
          v && (16 === b ? c += '0x' : 8 !== b || (f || '0' === d) || (c += '0'));
          return [
            c,
            d
          ];
        };
        c = function (a) {
          var b = a[0];
          a = a[1];
          var c;
          if (g)
            if (g = parseInt(g, 10), c = a.length + b.length, n)
              for (; c < g; ++c)
                a = '0' + a;
            else if (p)
              for (; c < g; ++c)
                a += ' ';
            else
              for (; c < g; ++c)
                b = ' ' + b;
          return b + a;
        };
        if (a.constructor === Sk.builtin.tuple)
          e = a.v[m];
        else if (void 0 !== a.mp$subscript)
          e = e.substring(1, e.length - 1), e = a.mp$subscript(new Sk.builtin.str(e));
        else
          throw new Sk.builtin.AttributeError(a.tp$name + ' instance has no attribute \'mp$subscript\'');
        switch (l) {
        case 'd':
        case 'i':
          return c(f(e, 10));
        case 'o':
          return c(f(e, 8));
        case 'x':
          return c(f(e, 16));
        case 'X':
          return c(f(e, 16)).toUpperCase();
        case 'f':
        case 'F':
        case 'e':
        case 'E':
        case 'g':
        case 'G':
          e = Sk.builtin.asnum$(e);
          'string' === typeof e && (e = Number(e));
          if (Infinity === e)
            return 'inf';
          if (-Infinity === e)
            return '-inf';
          if (isNaN(e))
            return 'nan';
          m = [
            'toExponential',
            'toFixed',
            'toPrecision'
          ]['efg'.indexOf(l.toLowerCase())];
          if (void 0 === h || '' === h)
            if ('e' === l || 'E' === l)
              h = 6;
            else if ('f' === l || 'F' === l)
              h = 7;
          e = e[m](h);
          -1 !== 'EFG'.indexOf(l) && (e = e.toUpperCase());
          return c([
            '',
            e
          ]);
        case 'c':
          if ('number' === typeof e)
            return String.fromCharCode(e);
          if (e instanceof Sk.builtin.nmber)
            return String.fromCharCode(e.v);
          if (e instanceof Sk.builtin.lng)
            return String.fromCharCode(e.str$(10, !1)[0]);
          if (e.constructor === Sk.builtin.str)
            return e.v.substr(0, 1);
          throw new Sk.builtin.TypeError('an integer is required');
        case 'r':
          return l = Sk.builtin.repr(e), h ? l.v.substr(0, h) : l.v;
        case 's':
          return l = new Sk.builtin.str(e), h ? l.v.substr(0, h) : l.v;
        case '%':
          return '%';
        }
      });
    return new Sk.builtin.str(c);
  };
  Sk.builtin.tuple = function (a) {
    if (!(this instanceof Sk.builtin.tuple))
      return new Sk.builtin.tuple(a);
    void 0 === a && (a = []);
    if ('[object Array]' === Object.prototype.toString.apply(a))
      this.v = a;
    else if (a.tp$iter) {
      this.v = [];
      a = a.tp$iter();
      for (var b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext())
        this.v.push(b);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
    this.__class__ = Sk.builtin.tuple;
    this.v = this.v;
    return this;
  };
  Sk.builtin.tuple.prototype.tp$name = 'tuple';
  Sk.builtin.tuple.prototype.$r = function () {
    if (0 === this.v.length)
      return new Sk.builtin.str('()');
    for (var a = [], b = 0; b < this.v.length; ++b)
      a[b] = Sk.misceval.objectRepr(this.v[b]).v;
    a = a.join(', ');
    1 === this.v.length && (a += ',');
    return new Sk.builtin.str('(' + a + ')');
  };
  Sk.builtin.tuple.prototype.mp$subscript = function (a) {
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        if (0 > b || b >= this.v.length)
          throw new Sk.builtin.IndexError('tuple index out of range');
        return this.v[b];
      }
    } else if (a instanceof Sk.builtin.slice) {
      var c = [];
      a.sssiter$(this, function (a, b) {
        c.push(b.v[a]);
      });
      return new Sk.builtin.tuple(c);
    }
    throw new Sk.builtin.TypeError('tuple indices must be integers, not ' + Sk.abstr.typeName(a));
  };
  Sk.builtin.tuple.prototype.tp$hash = function () {
    for (var a = 1000003, b = 3430008, c = this.v.length, d = 0; d < c; ++d) {
      var e = Sk.builtin.hash(this.v[d]);
      if (-1 === e)
        return -1;
      b = (b ^ e) * a;
      a += 82520 + c + c;
    }
    b += 97531;
    -1 === b && (b = -2);
    return b;
  };
  Sk.builtin.tuple.prototype.sq$repeat = function (a) {
    a = Sk.builtin.asnum$(a);
    for (var b = [], c = 0; c < a; ++c)
      for (var d = 0; d < this.v.length; ++d)
        b.push(this.v[d]);
    return new Sk.builtin.tuple(b);
  };
  Sk.builtin.tuple.prototype.nb$multiply = Sk.builtin.tuple.prototype.sq$repeat;
  Sk.builtin.tuple.prototype.nb$inplace_multiply = Sk.builtin.tuple.prototype.sq$repeat;
  Sk.builtin.tuple.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('tuple', Sk.builtin.tuple);
  Sk.builtin.tuple.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : a.$obj.v[a.$index++];
        }
      };
    return a;
  };
  Sk.builtin.tuple.prototype.__iter__ = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
    return a.tp$iter();
  });
  Sk.builtin.tuple.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.tuple.prototype.tp$richcompare = function (a, b) {
    if (!a.__class__ || a.__class__ != Sk.builtin.tuple)
      return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : !1;
    var c = this.v;
    a = a.v;
    var d = c.length, e = a.length, f;
    for (f = 0; f < d && f < e && Sk.misceval.richCompareBool(c[f], a[f], 'Eq'); ++f);
    if (f >= d || f >= e)
      switch (b) {
      case 'Lt':
        return d < e;
      case 'LtE':
        return d <= e;
      case 'Eq':
        return d === e;
      case 'NotEq':
        return d !== e;
      case 'Gt':
        return d > e;
      case 'GtE':
        return d >= e;
      default:
        goog.asserts.fail();
      }
    return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : Sk.misceval.richCompareBool(c[f], a[f], b);
  };
  Sk.builtin.tuple.prototype.sq$concat = function (a) {
    return new Sk.builtin.tuple(this.v.concat(a.v));
  };
  Sk.builtin.tuple.prototype.nb$add = Sk.builtin.tuple.prototype.sq$concat;
  Sk.builtin.tuple.prototype.nb$inplace_add = Sk.builtin.tuple.prototype.sq$concat;
  Sk.builtin.tuple.prototype.sq$length = function () {
    return this.v.length;
  };
  Sk.builtin.tuple.prototype.index = new Sk.builtin.func(function (a, b) {
    for (var c = a.v.length, d = a.v, e = 0; e < c; ++e)
      if (Sk.misceval.richCompareBool(d[e], b, 'Eq'))
        return e;
    throw new Sk.builtin.ValueError('tuple.index(x): x not in tuple');
  });
  Sk.builtin.tuple.prototype.count = new Sk.builtin.func(function (a, b) {
    for (var c = a.v.length, d = a.v, e = 0, f = 0; f < c; ++f)
      Sk.misceval.richCompareBool(d[f], b, 'Eq') && (e += 1);
    return e;
  });
  goog.exportSymbol('Sk.builtin.tuple', Sk.builtin.tuple);
  Sk.builtin.dict = function (a) {
    if (!(this instanceof Sk.builtin.dict))
      return new Sk.builtin.dict(a);
    void 0 === a && (a = []);
    this.size = 0;
    if ('[object Array]' === Object.prototype.toString.apply(a))
      for (var b = 0; b < a.length; b += 2)
        this.mp$ass_subscript(a[b], a[b + 1]);
    else if (a instanceof Sk.builtin.dict)
      for (var c = a.tp$iter(), b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext()) {
        var d = a.mp$subscript(b);
        void 0 === d && (d = null);
        this.mp$ass_subscript(b, d);
      }
    else if (a.tp$iter)
      for (c = a.tp$iter(), b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
        if (b.mp$subscript)
          this.mp$ass_subscript(b.mp$subscript(0), b.mp$subscript(1));
        else
          throw new Sk.builtin.TypeError('element ' + this.size + ' is not a sequence');
    else
      throw new Sk.builtin.TypeError('object is not iterable');
    this.__class__ = Sk.builtin.dict;
    return this;
  };
  Sk.builtin.dict.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('dict', Sk.builtin.dict);
  var kf = Sk.builtin.hash;
  Sk.builtin.dict.prototype.key$lookup = function (a, b) {
    var c, d, e;
    for (e = 0; e < a.items.length; e++)
      if (c = a.items[e], d = Sk.misceval.richCompareBool(c.lhs, b, 'Eq'))
        return c;
    return null;
  };
  Sk.builtin.dict.prototype.key$pop = function (a, b) {
    var c, d, e;
    for (e = 0; e < a.items.length; e++)
      if (c = a.items[e], d = Sk.misceval.richCompareBool(c.lhs, b, 'Eq'))
        return a.items.splice(e, 1), this.size -= 1, c;
  };
  Sk.builtin.dict.prototype.mp$lookup = function (a) {
    var b = this[kf(a)];
    if (void 0 !== b && (a = this.key$lookup(b, a)))
      return a.rhs;
  };
  Sk.builtin.dict.prototype.mp$subscript = function (a) {
    var b = this.mp$lookup(a);
    if (void 0 !== b)
      return b;
    a = new Sk.builtin.str(a);
    throw new Sk.builtin.KeyError(a.v);
  };
  Sk.builtin.dict.prototype.sq$contains = function (a) {
    return void 0 !== this.mp$lookup(a);
  };
  Sk.builtin.dict.prototype.mp$ass_subscript = function (a, b) {
    var c = kf(a), d = this[c];
    void 0 === d ? (d = {
      $hash: c,
      items: [{
          lhs: a,
          rhs: b
        }]
    }, this[c] = d, this.size += 1) : (c = this.key$lookup(d, a)) ? c.rhs = b : (d.items.push({
      lhs: a,
      rhs: b
    }), this.size += 1);
  };
  Sk.builtin.dict.prototype.mp$del_subscript = function (a) {
    var b = this[kf(a)];
    if (void 0 !== b && (b = this.key$pop(b, a), void 0 !== b))
      return;
    a = new Sk.builtin.str(a);
    throw new Sk.builtin.KeyError(a.v);
  };
  Sk.builtin.dict.prototype.tp$iter = function () {
    var a = [], b;
    for (b in this)
      if (this.hasOwnProperty(b)) {
        var c = this[b];
        if (c && void 0 !== c.$hash)
          for (var d = 0; d < c.items.length; d++)
            a.push(c.items[d].lhs);
      }
    var e = {
        tp$iter: function () {
          return e;
        },
        $obj: this,
        $index: 0,
        $keys: a,
        tp$iternext: function () {
          return e.$index >= e.$keys.length ? void 0 : e.$keys[e.$index++];
        }
      };
    return e;
  };
  Sk.builtin.dict.prototype.__iter__ = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
    return a.tp$iter();
  });
  Sk.builtin.dict.prototype.$r = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext()) {
      var d = this.mp$subscript(c);
      void 0 === d && (d = null);
      a.push(Sk.misceval.objectRepr(c).v + ': ' + Sk.misceval.objectRepr(d).v);
    }
    return new Sk.builtin.str('{' + a.join(', ') + '}');
  };
  Sk.builtin.dict.prototype.mp$length = function () {
    return this.size;
  };
  Sk.builtin.dict.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.dict.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
  Sk.builtin.dict.prototype.tp$richcompare = function (a, b) {
    if (this === a && Sk.misceval.opAllowsEquality(b))
      return !0;
    switch (b) {
    case 'Lt':
      return;
    case 'LtE':
      return;
    case 'Eq':
      break;
    case 'NotEq':
      break;
    case 'Gt':
      return;
    case 'GtE':
      return;
    default:
      goog.asserts.fail();
    }
    if (!(a instanceof Sk.builtin.dict) || this.size !== a.size)
      return 'Eq' === b ? !1 : !0;
    for (var c = this.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext()) {
      var e = this.mp$subscript(d), d = a.mp$subscript(d);
      if (!Sk.misceval.richCompareBool(e, d, 'Eq'))
        return 'Eq' === b ? !1 : !0;
    }
    return 'Eq' === b ? !0 : !1;
  };
  Sk.builtin.dict.prototype.get = new Sk.builtin.func(function (a, b, c) {
    void 0 === c && (c = null);
    a = a.mp$lookup(b);
    void 0 === a && (a = c);
    return a;
  });
  Sk.builtin.dict.prototype.has_key = new Sk.builtin.func(function (a, b) {
    return a.sq$contains(b);
  });
  Sk.builtin.dict.prototype.items = new Sk.builtin.func(function (a) {
    for (var b = [], c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext()) {
      var e = a.mp$subscript(d);
      void 0 === e && (e = null);
      b.push(new Sk.builtin.tuple([
        d,
        e
      ]));
    }
    return new Sk.builtin.list(b);
  });
  Sk.builtin.dict.prototype.keys = new Sk.builtin.func(function (a) {
    var b = [];
    a = a.tp$iter();
    for (var c = a.tp$iternext(); void 0 !== c; c = a.tp$iternext())
      b.push(c);
    return new Sk.builtin.list(b);
  });
  Sk.builtin.dict.prototype.values = new Sk.builtin.func(function (a) {
    for (var b = [], c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      d = a.mp$subscript(d), void 0 === d && (d = null), b.push(d);
    return new Sk.builtin.list(b);
  });
  Sk.builtin.dict.prototype.tp$name = 'dict';
  goog.exportSymbol('Sk.builtin.dict', Sk.builtin.dict);
  Sk.builtin.biginteger = function (a, b, c) {
    null != a && ('number' == typeof a ? this.fromNumber(a, b, c) : null == b && 'string' != typeof a ? this.fromString(a, 256) : this.fromString(a, b));
  };
  Sk.builtin.biginteger.canary = 244837814094590;
  Sk.builtin.biginteger.j_lm = 15715070 == (Sk.builtin.biginteger.canary & 16777215);
  Sk.builtin.biginteger.nbi = function () {
    return new Sk.builtin.biginteger(null);
  };
  Sk.builtin.biginteger.prototype.am1 = function (a, b, c, d, e, f) {
    for (; 0 <= --f;) {
      var g = b * this[a++] + c[d] + e;
      e = Math.floor(g / 67108864);
      c[d++] = g & 67108863;
    }
    return e;
  };
  Sk.builtin.biginteger.prototype.am2 = function (a, b, c, d, e, f) {
    var g = b & 32767;
    for (b >>= 15; 0 <= --f;) {
      var h = this[a] & 32767, k = this[a++] >> 15, l = b * h + k * g, h = g * h + ((l & 32767) << 15) + c[d] + (e & 1073741823);
      e = (h >>> 30) + (l >>> 15) + b * k + (e >>> 30);
      c[d++] = h & 1073741823;
    }
    return e;
  };
  Sk.builtin.biginteger.prototype.am3 = function (a, b, c, d, e, f) {
    var g = b & 16383;
    for (b >>= 14; 0 <= --f;) {
      var h = this[a] & 16383, k = this[a++] >> 14, l = b * h + k * g, h = g * h + ((l & 16383) << 14) + c[d] + e;
      e = (h >> 28) + (l >> 14) + b * k;
      c[d++] = h & 268435455;
    }
    return e;
  };
  Sk.builtin.biginteger.prototype.am = Sk.builtin.biginteger.prototype.am3;
  Sk.builtin.biginteger.dbits = 28;
  Sk.builtin.biginteger.prototype.DB = Sk.builtin.biginteger.dbits;
  Sk.builtin.biginteger.prototype.DM = (1 << Sk.builtin.biginteger.dbits) - 1;
  Sk.builtin.biginteger.prototype.DV = 1 << Sk.builtin.biginteger.dbits;
  Sk.builtin.biginteger.BI_FP = 52;
  Sk.builtin.biginteger.prototype.FV = Math.pow(2, Sk.builtin.biginteger.BI_FP);
  Sk.builtin.biginteger.prototype.F1 = Sk.builtin.biginteger.BI_FP - Sk.builtin.biginteger.dbits;
  Sk.builtin.biginteger.prototype.F2 = 2 * Sk.builtin.biginteger.dbits - Sk.builtin.biginteger.BI_FP;
  Sk.builtin.biginteger.BI_RM = '0123456789abcdefghijklmnopqrstuvwxyz';
  Sk.builtin.biginteger.BI_RC = [];
  var rr, vv;
  rr = 48;
  for (vv = 0; 9 >= vv; ++vv)
    Sk.builtin.biginteger.BI_RC[rr++] = vv;
  rr = 97;
  for (vv = 10; 36 > vv; ++vv)
    Sk.builtin.biginteger.BI_RC[rr++] = vv;
  rr = 65;
  for (vv = 10; 36 > vv; ++vv)
    Sk.builtin.biginteger.BI_RC[rr++] = vv;
  Sk.builtin.biginteger.int2char = function (a) {
    return Sk.builtin.biginteger.BI_RM.charAt(a);
  };
  Sk.builtin.biginteger.intAt = function (a, b) {
    var c = Sk.builtin.biginteger.BI_RC[a.charCodeAt(b)];
    return null == c ? -1 : c;
  };
  Sk.builtin.biginteger.prototype.bnpCopyTo = function (a) {
    for (var b = this.t - 1; 0 <= b; --b)
      a[b] = this[b];
    a.t = this.t;
    a.s = this.s;
  };
  Sk.builtin.biginteger.prototype.bnpFromInt = function (a) {
    this.t = 1;
    this.s = 0 > a ? -1 : 0;
    0 < a ? this[0] = a : -1 > a ? this[0] = a + this.DV : this.t = 0;
  };
  Sk.builtin.biginteger.nbv = function (a) {
    var b = new Sk.builtin.biginteger(null);
    b.bnpFromInt(a);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnpFromString = function (a, b) {
    var c;
    if (16 == b)
      c = 4;
    else if (8 == b)
      c = 3;
    else if (256 == b)
      c = 8;
    else if (2 == b)
      c = 1;
    else if (32 == b)
      c = 5;
    else if (4 == b)
      c = 2;
    else {
      this.fromRadix(a, b);
      return;
    }
    this.s = this.t = 0;
    for (var d = a.length, e = !1, f = 0; 0 <= --d;) {
      var g = 8 == c ? a[d] & 255 : Sk.builtin.biginteger.intAt(a, d);
      0 > g ? '-' == a.charAt(d) && (e = !0) : (e = !1, 0 == f ? this[this.t++] = g : f + c > this.DB ? (this[this.t - 1] |= (g & (1 << this.DB - f) - 1) << f, this[this.t++] = g >> this.DB - f) : this[this.t - 1] |= g << f, f += c, f >= this.DB && (f -= this.DB));
    }
    8 == c && 0 != (a[0] & 128) && (this.s = -1, 0 < f && (this[this.t - 1] |= (1 << this.DB - f) - 1 << f));
    this.clamp();
    e && Sk.builtin.biginteger.ZERO.subTo(this, this);
  };
  Sk.builtin.biginteger.prototype.bnpClamp = function () {
    for (var a = this.s & this.DM; 0 < this.t && this[this.t - 1] == a;)
      --this.t;
  };
  Sk.builtin.biginteger.prototype.bnToString = function (a) {
    if (0 > this.s)
      return '-' + this.negate().toString(a);
    if (16 == a)
      a = 4;
    else if (8 == a)
      a = 3;
    else if (2 == a)
      a = 1;
    else if (32 == a)
      a = 5;
    else if (4 == a)
      a = 2;
    else
      return this.toRadix(a);
    var b = (1 << a) - 1, c, d = !1, e = '', f = this.t, g = this.DB - f * this.DB % a;
    if (0 < f--)
      for (g < this.DB && 0 < (c = this[f] >> g) && (d = !0, e = Sk.builtin.biginteger.int2char(c)); 0 <= f;)
        g < a ? (c = (this[f] & (1 << g) - 1) << a - g, c |= this[--f] >> (g += this.DB - a)) : (c = this[f] >> (g -= a) & b, 0 >= g && (g += this.DB, --f)), 0 < c && (d = !0), d && (e += Sk.builtin.biginteger.int2char(c));
    return d ? e : '0';
  };
  Sk.builtin.biginteger.prototype.bnNegate = function () {
    var a = Sk.builtin.biginteger.nbi();
    Sk.builtin.biginteger.ZERO.subTo(this, a);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnAbs = function () {
    return 0 > this.s ? this.negate() : this;
  };
  Sk.builtin.biginteger.prototype.bnCompareTo = function (a) {
    var b = this.s - a.s;
    if (0 != b)
      return b;
    var c = this.t, b = c - a.t;
    if (0 != b)
      return 0 > this.s ? -b : b;
    for (; 0 <= --c;)
      if (0 != (b = this[c] - a[c]))
        return b;
    return 0;
  };
  Sk.builtin.biginteger.nbits = function (a) {
    var b = 1, c;
    0 != (c = a >>> 16) && (a = c, b += 16);
    0 != (c = a >> 8) && (a = c, b += 8);
    0 != (c = a >> 4) && (a = c, b += 4);
    0 != (c = a >> 2) && (a = c, b += 2);
    0 != a >> 1 && (b += 1);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnBitLength = function () {
    return 0 >= this.t ? 0 : this.DB * (this.t - 1) + Sk.builtin.biginteger.nbits(this[this.t - 1] ^ this.s & this.DM);
  };
  Sk.builtin.biginteger.prototype.bnpDLShiftTo = function (a, b) {
    var c;
    for (c = this.t - 1; 0 <= c; --c)
      b[c + a] = this[c];
    for (c = a - 1; 0 <= c; --c)
      b[c] = 0;
    b.t = this.t + a;
    b.s = this.s;
  };
  Sk.builtin.biginteger.prototype.bnpDRShiftTo = function (a, b) {
    for (var c = a; c < this.t; ++c)
      b[c - a] = this[c];
    b.t = Math.max(this.t - a, 0);
    b.s = this.s;
  };
  Sk.builtin.biginteger.prototype.bnpLShiftTo = function (a, b) {
    var c = a % this.DB, d = this.DB - c, e = (1 << d) - 1, f = Math.floor(a / this.DB), g = this.s << c & this.DM, h;
    for (h = this.t - 1; 0 <= h; --h)
      b[h + f + 1] = this[h] >> d | g, g = (this[h] & e) << c;
    for (h = f - 1; 0 <= h; --h)
      b[h] = 0;
    b[f] = g;
    b.t = this.t + f + 1;
    b.s = this.s;
    b.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpRShiftTo = function (a, b) {
    b.s = this.s;
    var c = Math.floor(a / this.DB);
    if (c >= this.t)
      b.t = 0;
    else {
      var d = a % this.DB, e = this.DB - d, f = (1 << d) - 1;
      b[0] = this[c] >> d;
      for (var g = c + 1; g < this.t; ++g)
        b[g - c - 1] |= (this[g] & f) << e, b[g - c] = this[g] >> d;
      0 < d && (b[this.t - c - 1] |= (this.s & f) << e);
      b.t = this.t - c;
      b.clamp();
    }
  };
  Sk.builtin.biginteger.prototype.bnpSubTo = function (a, b) {
    for (var c = 0, d = 0, e = Math.min(a.t, this.t); c < e;)
      d += this[c] - a[c], b[c++] = d & this.DM, d >>= this.DB;
    if (a.t < this.t) {
      for (d -= a.s; c < this.t;)
        d += this[c], b[c++] = d & this.DM, d >>= this.DB;
      d += this.s;
    } else {
      for (d += this.s; c < a.t;)
        d -= a[c], b[c++] = d & this.DM, d >>= this.DB;
      d -= a.s;
    }
    b.s = 0 > d ? -1 : 0;
    -1 > d ? b[c++] = this.DV + d : 0 < d && (b[c++] = d);
    b.t = c;
    b.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpMultiplyTo = function (a, b) {
    var c = this.abs(), d = a.abs(), e = c.t;
    for (b.t = e + d.t; 0 <= --e;)
      b[e] = 0;
    for (e = 0; e < d.t; ++e)
      b[e + c.t] = c.am(0, d[e], b, e, 0, c.t);
    b.s = 0;
    b.clamp();
    this.s != a.s && Sk.builtin.biginteger.ZERO.subTo(b, b);
  };
  Sk.builtin.biginteger.prototype.bnpSquareTo = function (a) {
    for (var b = this.abs(), c = a.t = 2 * b.t; 0 <= --c;)
      a[c] = 0;
    for (c = 0; c < b.t - 1; ++c) {
      var d = b.am(c, b[c], a, 2 * c, 0, 1);
      (a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, d, b.t - c - 1)) >= b.DV && (a[c + b.t] -= b.DV, a[c + b.t + 1] = 1);
    }
    0 < a.t && (a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1));
    a.s = 0;
    a.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpDivRemTo = function (a, b, c) {
    var d = a.abs();
    if (!(0 >= d.t)) {
      var e = this.abs();
      if (e.t < d.t)
        null != b && b.fromInt(0), null != c && this.copyTo(c);
      else {
        null == c && (c = Sk.builtin.biginteger.nbi());
        var f = Sk.builtin.biginteger.nbi(), g = this.s;
        a = a.s;
        var h = this.DB - Sk.builtin.biginteger.nbits(d[d.t - 1]);
        0 < h ? (d.lShiftTo(h, f), e.lShiftTo(h, c)) : (d.copyTo(f), e.copyTo(c));
        d = f.t;
        e = f[d - 1];
        if (0 != e) {
          var k = e * (1 << this.F1) + (1 < d ? f[d - 2] >> this.F2 : 0), l = this.FV / k, k = (1 << this.F1) / k, m = 1 << this.F2, n = c.t, p = n - d, q = null == b ? Sk.builtin.biginteger.nbi() : b;
          f.dlShiftTo(p, q);
          0 <= c.compareTo(q) && (c[c.t++] = 1, c.subTo(q, c));
          Sk.builtin.biginteger.ONE.dlShiftTo(d, q);
          for (q.subTo(f, f); f.t < d;)
            f[f.t++] = 0;
          for (; 0 <= --p;) {
            var r = c[--n] == e ? this.DM : Math.floor(c[n] * l + (c[n - 1] + m) * k);
            if ((c[n] += f.am(0, r, c, p, 0, d)) < r)
              for (f.dlShiftTo(p, q), c.subTo(q, c); c[n] < --r;)
                c.subTo(q, c);
          }
          null != b && (c.drShiftTo(d, b), g != a && Sk.builtin.biginteger.ZERO.subTo(b, b));
          c.t = d;
          c.clamp();
          0 < h && c.rShiftTo(h, c);
          0 > g && Sk.builtin.biginteger.ZERO.subTo(c, c);
        }
      }
    }
  };
  Sk.builtin.biginteger.prototype.bnMod = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.abs().divRemTo(a, null, b);
    0 > this.s && 0 < b.compareTo(Sk.builtin.biginteger.ZERO) && a.subTo(b, b);
    return b;
  };
  Sk.builtin.biginteger.Classic = function (a) {
    this.m = a;
  };
  Sk.builtin.biginteger.prototype.cConvert = function (a) {
    return 0 > a.s || 0 <= a.compareTo(this.m) ? a.mod(this.m) : a;
  };
  Sk.builtin.biginteger.prototype.cRevert = function (a) {
    return a;
  };
  Sk.builtin.biginteger.prototype.cReduce = function (a) {
    a.divRemTo(this.m, null, a);
  };
  Sk.builtin.biginteger.prototype.cMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
    this.reduce(c);
  };
  Sk.builtin.biginteger.prototype.cSqrTo = function (a, b) {
    a.squareTo(b);
    this.reduce(b);
  };
  Sk.builtin.biginteger.Classic.prototype.convert = Sk.builtin.biginteger.prototype.cConvert;
  Sk.builtin.biginteger.Classic.prototype.revert = Sk.builtin.biginteger.prototype.cRevert;
  Sk.builtin.biginteger.Classic.prototype.reduce = Sk.builtin.biginteger.prototype.cReduce;
  Sk.builtin.biginteger.Classic.prototype.mulTo = Sk.builtin.biginteger.prototype.cMulTo;
  Sk.builtin.biginteger.Classic.prototype.sqrTo = Sk.builtin.biginteger.prototype.cSqrTo;
  Sk.builtin.biginteger.prototype.bnpInvDigit = function () {
    if (1 > this.t)
      return 0;
    var a = this[0];
    if (0 == (a & 1))
      return 0;
    var b = a & 3, b = b * (2 - (a & 15) * b) & 15, b = b * (2 - (a & 255) * b) & 255, b = b * (2 - ((a & 65535) * b & 65535)) & 65535, b = b * (2 - a * b % this.DV) % this.DV;
    return 0 < b ? this.DV - b : -b;
  };
  Sk.builtin.biginteger.Montgomery = function (a) {
    this.m = a;
    this.mp = a.invDigit();
    this.mpl = this.mp & 32767;
    this.mph = this.mp >> 15;
    this.um = (1 << a.DB - 15) - 1;
    this.mt2 = 2 * a.t;
  };
  Sk.builtin.biginteger.prototype.montConvert = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    a.abs().dlShiftTo(this.m.t, b);
    b.divRemTo(this.m, null, b);
    0 > a.s && 0 < b.compareTo(Sk.builtin.biginteger.ZERO) && this.m.subTo(b, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.montRevert = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    a.copyTo(b);
    this.reduce(b);
    return b;
  };
  Sk.builtin.biginteger.prototype.montReduce = function (a) {
    for (; a.t <= this.mt2;)
      a[a.t++] = 0;
    for (var b = 0; b < this.m.t; ++b) {
      var c = a[b] & 32767, d = c * this.mpl + ((c * this.mph + (a[b] >> 15) * this.mpl & this.um) << 15) & a.DM, c = b + this.m.t;
      for (a[c] += this.m.am(0, d, a, b, 0, this.m.t); a[c] >= a.DV;)
        a[c] -= a.DV, a[++c]++;
    }
    a.clamp();
    a.drShiftTo(this.m.t, a);
    0 <= a.compareTo(this.m) && a.subTo(this.m, a);
  };
  Sk.builtin.biginteger.prototype.montSqrTo = function (a, b) {
    a.squareTo(b);
    this.reduce(b);
  };
  Sk.builtin.biginteger.prototype.montMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
    this.reduce(c);
  };
  Sk.builtin.biginteger.Montgomery.prototype.convert = Sk.builtin.biginteger.prototype.montConvert;
  Sk.builtin.biginteger.Montgomery.prototype.revert = Sk.builtin.biginteger.prototype.montRevert;
  Sk.builtin.biginteger.Montgomery.prototype.reduce = Sk.builtin.biginteger.prototype.montReduce;
  Sk.builtin.biginteger.Montgomery.prototype.mulTo = Sk.builtin.biginteger.prototype.montMulTo;
  Sk.builtin.biginteger.Montgomery.prototype.sqrTo = Sk.builtin.biginteger.prototype.montSqrTo;
  Sk.builtin.biginteger.prototype.bnpIsEven = function () {
    return 0 == (0 < this.t ? this[0] & 1 : this.s);
  };
  Sk.builtin.biginteger.prototype.bnpExp = function (a, b) {
    if (4294967295 < a || 1 > a)
      return Sk.builtin.biginteger.ONE;
    var c = Sk.builtin.biginteger.nbi(), d = Sk.builtin.biginteger.nbi(), e = b.convert(this), f = Sk.builtin.biginteger.nbits(a) - 1;
    for (e.copyTo(c); 0 <= --f;)
      if (b.sqrTo(c, d), 0 < (a & 1 << f))
        b.mulTo(d, e, c);
      else
        var g = c, c = d, d = g;
    return b.revert(c);
  };
  Sk.builtin.biginteger.prototype.bnModPowInt = function (a, b) {
    var c;
    c = 256 > a || b.isEven() ? new Sk.builtin.biginteger.Classic(b) : new Sk.builtin.biginteger.Montgomery(b);
    return this.exp(a, c);
  };
  Sk.builtin.biginteger.prototype.copyTo = Sk.builtin.biginteger.prototype.bnpCopyTo;
  Sk.builtin.biginteger.prototype.fromInt = Sk.builtin.biginteger.prototype.bnpFromInt;
  Sk.builtin.biginteger.prototype.fromString = Sk.builtin.biginteger.prototype.bnpFromString;
  Sk.builtin.biginteger.prototype.clamp = Sk.builtin.biginteger.prototype.bnpClamp;
  Sk.builtin.biginteger.prototype.dlShiftTo = Sk.builtin.biginteger.prototype.bnpDLShiftTo;
  Sk.builtin.biginteger.prototype.drShiftTo = Sk.builtin.biginteger.prototype.bnpDRShiftTo;
  Sk.builtin.biginteger.prototype.lShiftTo = Sk.builtin.biginteger.prototype.bnpLShiftTo;
  Sk.builtin.biginteger.prototype.rShiftTo = Sk.builtin.biginteger.prototype.bnpRShiftTo;
  Sk.builtin.biginteger.prototype.subTo = Sk.builtin.biginteger.prototype.bnpSubTo;
  Sk.builtin.biginteger.prototype.multiplyTo = Sk.builtin.biginteger.prototype.bnpMultiplyTo;
  Sk.builtin.biginteger.prototype.squareTo = Sk.builtin.biginteger.prototype.bnpSquareTo;
  Sk.builtin.biginteger.prototype.divRemTo = Sk.builtin.biginteger.prototype.bnpDivRemTo;
  Sk.builtin.biginteger.prototype.invDigit = Sk.builtin.biginteger.prototype.bnpInvDigit;
  Sk.builtin.biginteger.prototype.isEven = Sk.builtin.biginteger.prototype.bnpIsEven;
  Sk.builtin.biginteger.prototype.exp = Sk.builtin.biginteger.prototype.bnpExp;
  Sk.builtin.biginteger.prototype.toString = Sk.builtin.biginteger.prototype.bnToString;
  Sk.builtin.biginteger.prototype.negate = Sk.builtin.biginteger.prototype.bnNegate;
  Sk.builtin.biginteger.prototype.abs = Sk.builtin.biginteger.prototype.bnAbs;
  Sk.builtin.biginteger.prototype.compareTo = Sk.builtin.biginteger.prototype.bnCompareTo;
  Sk.builtin.biginteger.prototype.bitLength = Sk.builtin.biginteger.prototype.bnBitLength;
  Sk.builtin.biginteger.prototype.mod = Sk.builtin.biginteger.prototype.bnMod;
  Sk.builtin.biginteger.prototype.modPowInt = Sk.builtin.biginteger.prototype.bnModPowInt;
  Sk.builtin.biginteger.ZERO = Sk.builtin.biginteger.nbv(0);
  Sk.builtin.biginteger.ONE = Sk.builtin.biginteger.nbv(1);
  Sk.builtin.biginteger.prototype.bnClone = function () {
    var a = Sk.builtin.biginteger.nbi();
    this.copyTo(a);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnIntValue = function () {
    if (0 > this.s) {
      if (1 == this.t)
        return this[0] - this.DV;
      if (0 == this.t)
        return -1;
    } else {
      if (1 == this.t)
        return this[0];
      if (0 == this.t)
        return 0;
    }
    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
  };
  Sk.builtin.biginteger.prototype.bnByteValue = function () {
    return 0 == this.t ? this.s : this[0] << 24 >> 24;
  };
  Sk.builtin.biginteger.prototype.bnShortValue = function () {
    return 0 == this.t ? this.s : this[0] << 16 >> 16;
  };
  Sk.builtin.biginteger.prototype.bnpChunkSize = function (a) {
    return Math.floor(Math.LN2 * this.DB / Math.log(a));
  };
  Sk.builtin.biginteger.prototype.bnSigNum = function () {
    return 0 > this.s ? -1 : 0 >= this.t || 1 == this.t && 0 >= this[0] ? 0 : 1;
  };
  Sk.builtin.biginteger.prototype.bnpToRadix = function (a) {
    null == a && (a = 10);
    if (0 == this.signum() || 2 > a || 36 < a)
      return '0';
    var b = this.chunkSize(a), b = Math.pow(a, b), c = Sk.builtin.biginteger.nbv(b), d = Sk.builtin.biginteger.nbi(), e = Sk.builtin.biginteger.nbi(), f = '';
    for (this.divRemTo(c, d, e); 0 < d.signum();)
      f = (b + e.intValue()).toString(a).substr(1) + f, d.divRemTo(c, d, e);
    return e.intValue().toString(a) + f;
  };
  Sk.builtin.biginteger.prototype.bnpFromRadix = function (a, b) {
    this.fromInt(0);
    null == b && (b = 10);
    for (var c = this.chunkSize(b), d = Math.pow(b, c), e = !1, f = 0, g = 0, h = 0; h < a.length; ++h) {
      var k = Sk.builtin.biginteger.intAt(a, h);
      if (0 > k) {
        if ('-' == a.charAt(h) && 0 == this.signum() && (e = !0), '.' == a.charAt(h))
          break;
      } else
        g = b * g + k, ++f >= c && (this.dMultiply(d), this.dAddOffset(g, 0), g = f = 0);
    }
    0 < f && (this.dMultiply(Math.pow(b, f)), this.dAddOffset(g, 0));
    e && Sk.builtin.biginteger.ZERO.subTo(this, this);
  };
  Sk.builtin.biginteger.prototype.bnpFromNumber = function (a, b, c) {
    if ('number' == typeof b)
      if (2 > a)
        this.fromInt(1);
      else
        for (this.fromNumber(a, c), this.testBit(a - 1) || this.bitwiseTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), Sk.builtin.biginteger.op_or, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(b);)
          this.dAddOffset(2, 0), this.bitLength() > a && this.subTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), this);
    this.fromString(a + '');
  };
  Sk.builtin.biginteger.prototype.bnToByteArray = function () {
    var a = this.t, b = [];
    b[0] = this.s;
    var c = this.DB - a * this.DB % 8, d, e = 0;
    if (0 < a--)
      for (c < this.DB && (d = this[a] >> c) != (this.s & this.DM) >> c && (b[e++] = d | this.s << this.DB - c); 0 <= a;)
        if (8 > c ? (d = (this[a] & (1 << c) - 1) << 8 - c, d |= this[--a] >> (c += this.DB - 8)) : (d = this[a] >> (c -= 8) & 255, 0 >= c && (c += this.DB, --a)), 0 != (d & 128) && (d |= -256), 0 == e && (this.s & 128) != (d & 128) && ++e, 0 < e || d != this.s)
          b[e++] = d;
    return b;
  };
  Sk.builtin.biginteger.prototype.bnEquals = function (a) {
    return 0 == this.compareTo(a);
  };
  Sk.builtin.biginteger.prototype.bnMin = function (a) {
    return 0 > this.compareTo(a) ? this : a;
  };
  Sk.builtin.biginteger.prototype.bnMax = function (a) {
    return 0 < this.compareTo(a) ? this : a;
  };
  Sk.builtin.biginteger.prototype.bnpBitwiseTo = function (a, b, c) {
    var d, e, f = Math.min(a.t, this.t);
    for (d = 0; d < f; ++d)
      c[d] = b(this[d], a[d]);
    if (a.t < this.t) {
      e = a.s & this.DM;
      for (d = f; d < this.t; ++d)
        c[d] = b(this[d], e);
      c.t = this.t;
    } else {
      e = this.s & this.DM;
      for (d = f; d < a.t; ++d)
        c[d] = b(e, a[d]);
      c.t = a.t;
    }
    c.s = b(this.s, a.s);
    c.clamp();
  };
  Sk.builtin.biginteger.op_and = function (a, b) {
    return a & b;
  };
  Sk.builtin.biginteger.prototype.bnAnd = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_and, b);
    return b;
  };
  Sk.builtin.biginteger.op_or = function (a, b) {
    return a | b;
  };
  Sk.builtin.biginteger.prototype.bnOr = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_or, b);
    return b;
  };
  Sk.builtin.biginteger.op_xor = function (a, b) {
    return a ^ b;
  };
  Sk.builtin.biginteger.prototype.bnXor = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_xor, b);
    return b;
  };
  Sk.builtin.biginteger.op_andnot = function (a, b) {
    return a & ~b;
  };
  Sk.builtin.biginteger.prototype.bnAndNot = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_andnot, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnNot = function () {
    for (var a = Sk.builtin.biginteger.nbi(), b = 0; b < this.t; ++b)
      a[b] = this.DM & ~this[b];
    a.t = this.t;
    a.s = ~this.s;
    return a;
  };
  Sk.builtin.biginteger.prototype.bnShiftLeft = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    0 > a ? this.rShiftTo(-a, b) : this.lShiftTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnShiftRight = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    0 > a ? this.lShiftTo(-a, b) : this.rShiftTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.lbit = function (a) {
    if (0 == a)
      return -1;
    var b = 0;
    0 == (a & 65535) && (a >>= 16, b += 16);
    0 == (a & 255) && (a >>= 8, b += 8);
    0 == (a & 15) && (a >>= 4, b += 4);
    0 == (a & 3) && (a >>= 2, b += 2);
    0 == (a & 1) && ++b;
    return b;
  };
  Sk.builtin.biginteger.prototype.bnGetLowestSetBit = function () {
    for (var a = 0; a < this.t; ++a)
      if (0 != this[a])
        return a * this.DB + Sk.builtin.biginteger.lbit(this[a]);
    return 0 > this.s ? this.t * this.DB : -1;
  };
  Sk.builtin.biginteger.cbit = function (a) {
    for (var b = 0; 0 != a;)
      a &= a - 1, ++b;
    return b;
  };
  Sk.builtin.biginteger.prototype.bnBitCount = function () {
    for (var a = 0, b = this.s & this.DM, c = 0; c < this.t; ++c)
      a += Sk.builtin.biginteger.cbit(this[c] ^ b);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnTestBit = function (a) {
    var b = Math.floor(a / this.DB);
    return b >= this.t ? 0 != this.s : 0 != (this[b] & 1 << a % this.DB);
  };
  Sk.builtin.biginteger.prototype.bnpChangeBit = function (a, b) {
    var c = Sk.builtin.biginteger.ONE.shiftLeft(a);
    this.bitwiseTo(c, b, c);
    return c;
  };
  Sk.builtin.biginteger.prototype.bnSetBit = function (a) {
    return this.changeBit(a, Sk.builtin.biginteger.op_or);
  };
  Sk.builtin.biginteger.prototype.bnClearBit = function (a) {
    return this.changeBit(a, Sk.builtin.biginteger.op_andnot);
  };
  Sk.builtin.biginteger.prototype.bnFlipBit = function (a) {
    return this.changeBit(a, Sk.builtin.biginteger.op_xor);
  };
  Sk.builtin.biginteger.prototype.bnpAddTo = function (a, b) {
    for (var c = 0, d = 0, e = Math.min(a.t, this.t); c < e;)
      d += this[c] + a[c], b[c++] = d & this.DM, d >>= this.DB;
    if (a.t < this.t) {
      for (d += a.s; c < this.t;)
        d += this[c], b[c++] = d & this.DM, d >>= this.DB;
      d += this.s;
    } else {
      for (d += this.s; c < a.t;)
        d += a[c], b[c++] = d & this.DM, d >>= this.DB;
      d += a.s;
    }
    b.s = 0 > d ? -1 : 0;
    0 < d ? b[c++] = d : -1 > d && (b[c++] = this.DV + d);
    b.t = c;
    b.clamp();
  };
  Sk.builtin.biginteger.prototype.bnAdd = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.addTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnSubtract = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.subTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnMultiply = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.multiplyTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnDivide = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.divRemTo(a, b, null);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnRemainder = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.divRemTo(a, null, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnDivideAndRemainder = function (a) {
    var b = Sk.builtin.biginteger.nbi(), c = Sk.builtin.biginteger.nbi();
    this.divRemTo(a, b, c);
    return [
      b,
      c
    ];
  };
  Sk.builtin.biginteger.prototype.bnpDMultiply = function (a) {
    this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpDAddOffset = function (a, b) {
    if (0 != a) {
      for (; this.t <= b;)
        this[this.t++] = 0;
      for (this[b] += a; this[b] >= this.DV;)
        this[b] -= this.DV, ++b >= this.t && (this[this.t++] = 0), ++this[b];
    }
  };
  Sk.builtin.biginteger.NullExp = function () {
  };
  Sk.builtin.biginteger.prototype.nNop = function (a) {
    return a;
  };
  Sk.builtin.biginteger.prototype.nMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
  };
  Sk.builtin.biginteger.prototype.nSqrTo = function (a, b) {
    a.squareTo(b);
  };
  Sk.builtin.biginteger.NullExp.prototype.convert = Sk.builtin.biginteger.prototype.nNop;
  Sk.builtin.biginteger.NullExp.prototype.revert = Sk.builtin.biginteger.prototype.nNop;
  Sk.builtin.biginteger.NullExp.prototype.mulTo = Sk.builtin.biginteger.prototype.nMulTo;
  Sk.builtin.biginteger.NullExp.prototype.sqrTo = Sk.builtin.biginteger.prototype.nSqrTo;
  Sk.builtin.biginteger.prototype.bnPow = function (a) {
    return this.exp(a, new Sk.builtin.biginteger.NullExp());
  };
  Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo = function (a, b, c) {
    var d = Math.min(this.t + a.t, b);
    c.s = 0;
    for (c.t = d; 0 < d;)
      c[--d] = 0;
    var e;
    for (e = c.t - this.t; d < e; ++d)
      c[d + this.t] = this.am(0, a[d], c, d, 0, this.t);
    for (e = Math.min(a.t, b); d < e; ++d)
      this.am(0, a[d], c, d, 0, b - d);
    c.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo = function (a, b, c) {
    --b;
    var d = c.t = this.t + a.t - b;
    for (c.s = 0; 0 <= --d;)
      c[d] = 0;
    for (d = Math.max(b - this.t, 0); d < a.t; ++d)
      c[this.t + d - b] = this.am(b - d, a[d], c, 0, 0, this.t + d - b);
    c.clamp();
    c.drShiftTo(1, c);
  };
  Sk.builtin.biginteger.Barrett = function (a) {
    this.r2 = Sk.builtin.biginteger.nbi();
    this.q3 = Sk.builtin.biginteger.nbi();
    Sk.builtin.biginteger.ONE.dlShiftTo(2 * a.t, this.r2);
    this.mu = this.r2.divide(a);
    this.m = a;
  };
  Sk.builtin.biginteger.prototype.barrettConvert = function (a) {
    if (0 > a.s || a.t > 2 * this.m.t)
      return a.mod(this.m);
    if (0 > a.compareTo(this.m))
      return a;
    var b = Sk.builtin.biginteger.nbi();
    a.copyTo(b);
    this.reduce(b);
    return b;
  };
  Sk.builtin.biginteger.prototype.barrettRevert = function (a) {
    return a;
  };
  Sk.builtin.biginteger.prototype.barrettReduce = function (a) {
    a.drShiftTo(this.m.t - 1, this.r2);
    a.t > this.m.t + 1 && (a.t = this.m.t + 1, a.clamp());
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    for (this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); 0 > a.compareTo(this.r2);)
      a.dAddOffset(1, this.m.t + 1);
    for (a.subTo(this.r2, a); 0 <= a.compareTo(this.m);)
      a.subTo(this.m, a);
  };
  Sk.builtin.biginteger.prototype.barrettSqrTo = function (a, b) {
    a.squareTo(b);
    this.reduce(b);
  };
  Sk.builtin.biginteger.prototype.barrettMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
    this.reduce(c);
  };
  Sk.builtin.biginteger.Barrett.prototype.convert = Sk.builtin.biginteger.prototype.barrettConvert;
  Sk.builtin.biginteger.Barrett.prototype.revert = Sk.builtin.biginteger.prototype.barrettRevert;
  Sk.builtin.biginteger.Barrett.prototype.reduce = Sk.builtin.biginteger.prototype.barrettReduce;
  Sk.builtin.biginteger.Barrett.prototype.mulTo = Sk.builtin.biginteger.prototype.barrettMulTo;
  Sk.builtin.biginteger.Barrett.prototype.sqrTo = Sk.builtin.biginteger.prototype.barrettSqrTo;
  Sk.builtin.biginteger.prototype.bnModPow = function (a, b) {
    var c = a.bitLength(), d, e = Sk.builtin.biginteger.nbv(1), f;
    if (0 >= c)
      return e;
    d = 18 > c ? 1 : 48 > c ? 3 : 144 > c ? 4 : 768 > c ? 5 : 6;
    f = 8 > c ? new Sk.builtin.biginteger.Classic(b) : b.isEven() ? new Sk.builtin.biginteger.Barrett(b) : new Sk.builtin.biginteger.Montgomery(b);
    var g = [], h = 3, k = d - 1, l = (1 << d) - 1;
    g[1] = f.convert(this);
    if (1 < d)
      for (c = Sk.builtin.biginteger.nbi(), f.sqrTo(g[1], c); h <= l;)
        g[h] = Sk.builtin.biginteger.nbi(), f.mulTo(c, g[h - 2], g[h]), h += 2;
    for (var m = a.t - 1, n, p = !0, q = Sk.builtin.biginteger.nbi(), c = Sk.builtin.biginteger.nbits(a[m]) - 1; 0 <= m;) {
      c >= k ? n = a[m] >> c - k & l : (n = (a[m] & (1 << c + 1) - 1) << k - c, 0 < m && (n |= a[m - 1] >> this.DB + c - k));
      for (h = d; 0 == (n & 1);)
        n >>= 1, --h;
      0 > (c -= h) && (c += this.DB, --m);
      if (p)
        g[n].copyTo(e), p = !1;
      else {
        for (; 1 < h;)
          f.sqrTo(e, q), f.sqrTo(q, e), h -= 2;
        0 < h ? f.sqrTo(e, q) : (h = e, e = q, q = h);
        f.mulTo(q, g[n], e);
      }
      for (; 0 <= m && 0 == (a[m] & 1 << c);)
        f.sqrTo(e, q), h = e, e = q, q = h, 0 > --c && (c = this.DB - 1, --m);
    }
    return f.revert(e);
  };
  Sk.builtin.biginteger.prototype.bnGCD = function (a) {
    var b = 0 > this.s ? this.negate() : this.clone();
    a = 0 > a.s ? a.negate() : a.clone();
    if (0 > b.compareTo(a)) {
      var c = b, b = a;
      a = c;
    }
    var c = b.getLowestSetBit(), d = a.getLowestSetBit();
    if (0 > d)
      return b;
    c < d && (d = c);
    0 < d && (b.rShiftTo(d, b), a.rShiftTo(d, a));
    for (; 0 < b.signum();)
      0 < (c = b.getLowestSetBit()) && b.rShiftTo(c, b), 0 < (c = a.getLowestSetBit()) && a.rShiftTo(c, a), 0 <= b.compareTo(a) ? (b.subTo(a, b), b.rShiftTo(1, b)) : (a.subTo(b, a), a.rShiftTo(1, a));
    0 < d && a.lShiftTo(d, a);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnpModInt = function (a) {
    if (0 >= a)
      return 0;
    var b = this.DV % a, c = 0 > this.s ? a - 1 : 0;
    if (0 < this.t)
      if (0 == b)
        c = this[0] % a;
      else
        for (var d = this.t - 1; 0 <= d; --d)
          c = (b * c + this[d]) % a;
    return c;
  };
  Sk.builtin.biginteger.prototype.bnModInverse = function (a) {
    var b = a.isEven();
    if (this.isEven() && b || 0 == a.signum())
      return Sk.builtin.biginteger.ZERO;
    for (var c = a.clone(), d = this.clone(), e = Sk.builtin.biginteger.nbv(1), f = Sk.builtin.biginteger.nbv(0), g = Sk.builtin.biginteger.nbv(0), h = Sk.builtin.biginteger.nbv(1); 0 != c.signum();) {
      for (; c.isEven();)
        c.rShiftTo(1, c), b ? (e.isEven() && f.isEven() || (e.addTo(this, e), f.subTo(a, f)), e.rShiftTo(1, e)) : f.isEven() || f.subTo(a, f), f.rShiftTo(1, f);
      for (; d.isEven();)
        d.rShiftTo(1, d), b ? (g.isEven() && h.isEven() || (g.addTo(this, g), h.subTo(a, h)), g.rShiftTo(1, g)) : h.isEven() || h.subTo(a, h), h.rShiftTo(1, h);
      0 <= c.compareTo(d) ? (c.subTo(d, c), b && e.subTo(g, e), f.subTo(h, f)) : (d.subTo(c, d), b && g.subTo(e, g), h.subTo(f, h));
    }
    if (0 != d.compareTo(Sk.builtin.biginteger.ONE))
      return Sk.builtin.biginteger.ZERO;
    if (0 <= h.compareTo(a))
      return h.subtract(a);
    if (0 > h.signum())
      h.addTo(a, h);
    else
      return h;
    return 0 > h.signum() ? h.add(a) : h;
  };
  Sk.builtin.biginteger.lowprimes = [
    2,
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53,
    59,
    61,
    67,
    71,
    73,
    79,
    83,
    89,
    97,
    101,
    103,
    107,
    109,
    113,
    127,
    131,
    137,
    139,
    149,
    151,
    157,
    163,
    167,
    173,
    179,
    181,
    191,
    193,
    197,
    199,
    211,
    223,
    227,
    229,
    233,
    239,
    241,
    251,
    257,
    263,
    269,
    271,
    277,
    281,
    283,
    293,
    307,
    311,
    313,
    317,
    331,
    337,
    347,
    349,
    353,
    359,
    367,
    373,
    379,
    383,
    389,
    397,
    401,
    409,
    419,
    421,
    431,
    433,
    439,
    443,
    449,
    457,
    461,
    463,
    467,
    479,
    487,
    491,
    499,
    503,
    509
  ];
  Sk.builtin.biginteger.lplim = 67108864 / Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1];
  Sk.builtin.biginteger.prototype.bnIsProbablePrime = function (a) {
    var b, c = this.abs();
    if (1 == c.t && c[0] <= Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1]) {
      for (b = 0; b < Sk.builtin.biginteger.lowprimes.length; ++b)
        if (c[0] == Sk.builtin.biginteger.lowprimes[b])
          return !0;
      return !1;
    }
    if (c.isEven())
      return !1;
    for (b = 1; b < Sk.builtin.biginteger.lowprimes.length;) {
      for (var d = Sk.builtin.biginteger.lowprimes[b], e = b + 1; e < Sk.builtin.biginteger.lowprimes.length && d < Sk.builtin.biginteger.lplim;)
        d *= Sk.builtin.biginteger.lowprimes[e++];
      for (d = c.modInt(d); b < e;)
        if (0 == d % Sk.builtin.biginteger.lowprimes[b++])
          return !1;
    }
    return c.millerRabin(a);
  };
  Sk.builtin.biginteger.prototype.bnpMillerRabin = function (a) {
    var b = this.subtract(Sk.builtin.biginteger.ONE), c = b.getLowestSetBit();
    if (0 >= c)
      return !1;
    var d = b.shiftRight(c);
    a = a + 1 >> 1;
    a > Sk.builtin.biginteger.lowprimes.length && (a = Sk.builtin.biginteger.lowprimes.length);
    for (var e = Sk.builtin.biginteger.nbi(), f = 0; f < a; ++f) {
      e.fromInt(Sk.builtin.biginteger.lowprimes[f]);
      var g = e.modPow(d, this);
      if (0 != g.compareTo(Sk.builtin.biginteger.ONE) && 0 != g.compareTo(b)) {
        for (var h = 1; h++ < c && 0 != g.compareTo(b);)
          if (g = g.modPowInt(2, this), 0 == g.compareTo(Sk.builtin.biginteger.ONE))
            return !1;
        if (0 != g.compareTo(b))
          return !1;
      }
    }
    return !0;
  };
  Sk.builtin.biginteger.prototype.isnegative = function () {
    return 0 > this.s;
  };
  Sk.builtin.biginteger.prototype.ispositive = function () {
    return 0 <= this.s;
  };
  Sk.builtin.biginteger.prototype.trueCompare = function (a) {
    return 0 <= this.s && 0 > a.s ? 1 : 0 > this.s && 0 <= a.s ? -1 : this.compare(a);
  };
  Sk.builtin.biginteger.prototype.chunkSize = Sk.builtin.biginteger.prototype.bnpChunkSize;
  Sk.builtin.biginteger.prototype.toRadix = Sk.builtin.biginteger.prototype.bnpToRadix;
  Sk.builtin.biginteger.prototype.fromRadix = Sk.builtin.biginteger.prototype.bnpFromRadix;
  Sk.builtin.biginteger.prototype.fromNumber = Sk.builtin.biginteger.prototype.bnpFromNumber;
  Sk.builtin.biginteger.prototype.bitwiseTo = Sk.builtin.biginteger.prototype.bnpBitwiseTo;
  Sk.builtin.biginteger.prototype.changeBit = Sk.builtin.biginteger.prototype.bnpChangeBit;
  Sk.builtin.biginteger.prototype.addTo = Sk.builtin.biginteger.prototype.bnpAddTo;
  Sk.builtin.biginteger.prototype.dMultiply = Sk.builtin.biginteger.prototype.bnpDMultiply;
  Sk.builtin.biginteger.prototype.dAddOffset = Sk.builtin.biginteger.prototype.bnpDAddOffset;
  Sk.builtin.biginteger.prototype.multiplyLowerTo = Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo;
  Sk.builtin.biginteger.prototype.multiplyUpperTo = Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo;
  Sk.builtin.biginteger.prototype.modInt = Sk.builtin.biginteger.prototype.bnpModInt;
  Sk.builtin.biginteger.prototype.millerRabin = Sk.builtin.biginteger.prototype.bnpMillerRabin;
  Sk.builtin.biginteger.prototype.clone = Sk.builtin.biginteger.prototype.bnClone;
  Sk.builtin.biginteger.prototype.intValue = Sk.builtin.biginteger.prototype.bnIntValue;
  Sk.builtin.biginteger.prototype.byteValue = Sk.builtin.biginteger.prototype.bnByteValue;
  Sk.builtin.biginteger.prototype.shortValue = Sk.builtin.biginteger.prototype.bnShortValue;
  Sk.builtin.biginteger.prototype.signum = Sk.builtin.biginteger.prototype.bnSigNum;
  Sk.builtin.biginteger.prototype.toByteArray = Sk.builtin.biginteger.prototype.bnToByteArray;
  Sk.builtin.biginteger.prototype.equals = Sk.builtin.biginteger.prototype.bnEquals;
  Sk.builtin.biginteger.prototype.compare = Sk.builtin.biginteger.prototype.compareTo;
  Sk.builtin.biginteger.prototype.min = Sk.builtin.biginteger.prototype.bnMin;
  Sk.builtin.biginteger.prototype.max = Sk.builtin.biginteger.prototype.bnMax;
  Sk.builtin.biginteger.prototype.and = Sk.builtin.biginteger.prototype.bnAnd;
  Sk.builtin.biginteger.prototype.or = Sk.builtin.biginteger.prototype.bnOr;
  Sk.builtin.biginteger.prototype.xor = Sk.builtin.biginteger.prototype.bnXor;
  Sk.builtin.biginteger.prototype.andNot = Sk.builtin.biginteger.prototype.bnAndNot;
  Sk.builtin.biginteger.prototype.not = Sk.builtin.biginteger.prototype.bnNot;
  Sk.builtin.biginteger.prototype.shiftLeft = Sk.builtin.biginteger.prototype.bnShiftLeft;
  Sk.builtin.biginteger.prototype.shiftRight = Sk.builtin.biginteger.prototype.bnShiftRight;
  Sk.builtin.biginteger.prototype.getLowestSetBit = Sk.builtin.biginteger.prototype.bnGetLowestSetBit;
  Sk.builtin.biginteger.prototype.bitCount = Sk.builtin.biginteger.prototype.bnBitCount;
  Sk.builtin.biginteger.prototype.testBit = Sk.builtin.biginteger.prototype.bnTestBit;
  Sk.builtin.biginteger.prototype.setBit = Sk.builtin.biginteger.prototype.bnSetBit;
  Sk.builtin.biginteger.prototype.clearBit = Sk.builtin.biginteger.prototype.bnClearBit;
  Sk.builtin.biginteger.prototype.flipBit = Sk.builtin.biginteger.prototype.bnFlipBit;
  Sk.builtin.biginteger.prototype.add = Sk.builtin.biginteger.prototype.bnAdd;
  Sk.builtin.biginteger.prototype.subtract = Sk.builtin.biginteger.prototype.bnSubtract;
  Sk.builtin.biginteger.prototype.multiply = Sk.builtin.biginteger.prototype.bnMultiply;
  Sk.builtin.biginteger.prototype.divide = Sk.builtin.biginteger.prototype.bnDivide;
  Sk.builtin.biginteger.prototype.remainder = Sk.builtin.biginteger.prototype.bnRemainder;
  Sk.builtin.biginteger.prototype.divideAndRemainder = Sk.builtin.biginteger.prototype.bnDivideAndRemainder;
  Sk.builtin.biginteger.prototype.modPow = Sk.builtin.biginteger.prototype.bnModPow;
  Sk.builtin.biginteger.prototype.modInverse = Sk.builtin.biginteger.prototype.bnModInverse;
  Sk.builtin.biginteger.prototype.pow = Sk.builtin.biginteger.prototype.bnPow;
  Sk.builtin.biginteger.prototype.gcd = Sk.builtin.biginteger.prototype.bnGCD;
  Sk.builtin.biginteger.prototype.isProbablePrime = Sk.builtin.biginteger.prototype.bnIsProbablePrime;
  Sk.builtin.nmber = function (a, b) {
    if (!(this instanceof Sk.builtin.nmber))
      return new Sk.builtin.nmber(a, b);
    a instanceof Sk.builtin.str && (a = a.v);
    if (a instanceof Sk.builtin.nmber)
      this.v = a.v, this.skType = a.skType;
    else if ('number' === typeof a)
      if (this.v = a, void 0 === b)
        this.skType = a > Sk.builtin.nmber.threshold$ || a < -Sk.builtin.nmber.threshold$ || 0 != a % 1 ? Sk.builtin.nmber.float$ : Sk.builtin.nmber.int$;
      else {
        if (this.skType = b, b === Sk.builtin.nmber.int$ && (a > Sk.builtin.nmber.threshold$ || a < -Sk.builtin.nmber.threshold$))
          return new Sk.builtin.lng(a);
      }
    else {
      if ('string' === typeof a) {
        var c = Sk.numberFromStr(a);
        void 0 !== b && (c.skType = b);
        return b === Sk.builtin.nmber.int$ && (c.v > Sk.builtin.nmber.threshold$ || c.v < -Sk.builtin.nmber.threshold$) ? new Sk.builtin.lng(a) : c;
      }
      if (a instanceof Sk.builtin.lng)
        return Sk.numberFromStr(a.str$(10, !0));
      if (a instanceof Sk.builtin.biginteger) {
        if (c = Sk.numberFromStr(a.toString()), void 0 !== b && (c.skType = b), b === Sk.builtin.nmber.int$ && (c.v > Sk.builtin.nmber.threshold$ || c.v < -Sk.builtin.nmber.threshold$))
          return new Sk.builtin.lng(a);
      } else
        this.v = 0, this.skType = void 0 === b ? Sk.builtin.nmber.int$ : b;
    }
    return this;
  };
  Sk.builtin.nmber.prototype.tp$index = function () {
    return this.v;
  };
  Sk.builtin.nmber.prototype.tp$hash = function () {
    return this.v;
  };
  Sk.builtin.nmber.prototype.tp$name = 'number';
  Sk.builtin.nmber.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('number', Sk.builtin.nmber);
  Sk.builtin.nmber.threshold$ = Math.pow(2, 53);
  Sk.builtin.nmber.float$ = 'float';
  Sk.builtin.nmber.int$ = 'int';
  Sk.builtin.nmber.fromInt$ = function (a) {
    return new Sk.builtin.nmber(a, void 0);
  };
  Sk.numberFromStr = function (a) {
    if ('inf' == a)
      return new Sk.builtin.nmber(Infinity, void 0);
    if ('-inf' == a)
      return new Sk.builtin.nmber(-Infinity, void 0);
    var b = new Sk.builtin.nmber(0, void 0);
    if (-1 !== a.indexOf('.') || -1 !== a.indexOf('e') || -1 !== a.indexOf('E'))
      return b.v = parseFloat(a), b.skType = Sk.builtin.nmber.float$, b;
    var c = a;
    '-' === a.charAt(0) && (c = a.substr(1));
    a = '0' !== c.charAt(0) || 'x' !== c.charAt(1) && 'X' !== c.charAt(1) ? '0' !== c.charAt(0) || 'b' !== c.charAt(1) && 'B' !== c.charAt(1) ? '0' === c.charAt(0) ? parseInt(a, 8) : parseInt(a, 10) : parseInt(a, 2) : parseInt(a, 16);
    b.v = a;
    b.skType = Sk.builtin.nmber.int$;
    return b;
  };
  goog.exportSymbol('Sk.numberFromStr', Sk.numberFromStr);
  Sk.builtin.nmber.prototype.clone = function () {
    return new Sk.builtin.nmber(this, void 0);
  };
  Sk.builtin.nmber.prototype.toFixed = function (a) {
    a = Sk.builtin.asnum$(a);
    return this.v.toFixed(a);
  };
  Sk.builtin.nmber.prototype.nb$add = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      b = new Sk.builtin.nmber(this.v + a.v, void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$add(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng)
      return b = this.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.v + parseFloat(a.str$(10, !0)), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$add(a);
  };
  Sk.builtin.nmber.prototype.nb$subtract = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      b = new Sk.builtin.nmber(this.v - a.v, void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$subtract(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng)
      return b = this.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.v - parseFloat(a.str$(10, !0)), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$subtract(a);
  };
  Sk.builtin.nmber.prototype.nb$multiply = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      b = new Sk.builtin.nmber(this.v * a.v, void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$multiply(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng)
      return b = this.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.v * parseFloat(a.str$(10, !0)), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$multiply(a);
  };
  Sk.builtin.nmber.prototype.nb$divide = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      if (0 == a.v)
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (Infinity === this.v)
        return Infinity === a.v || -Infinity === a.v ? new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$) : a.nb$isnegative() ? new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
      if (-Infinity === this.v)
        return Infinity === a.v || -Infinity === a.v ? new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$) : a.nb$isnegative() ? new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
      b = new Sk.builtin.nmber(this.v / a.v, void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$ || Sk.python3)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.v = Math.floor(b.v), b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$divide(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng) {
      if (0 == a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      return Infinity === this.v ? a.nb$isnegative() ? new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$) : -Infinity === this.v ? a.nb$isnegative() ? new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$) : b = this.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.v / parseFloat(a.str$(10, !0)), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$divide(a);
    }
  };
  Sk.builtin.nmber.prototype.nb$floor_divide = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (Infinity === this.v || -Infinity === this.v)
      return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
    if (a instanceof Sk.builtin.nmber) {
      if (0 == a.v)
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (Infinity === a.v)
        return this.nb$isnegative() ? new Sk.builtin.nmber(-1, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
      if (-Infinity === a.v)
        return this.nb$isnegative() || !this.nb$nonzero() ? new Sk.builtin.nmber(0, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(-1, Sk.builtin.nmber.float$);
      b = new Sk.builtin.nmber(Math.floor(this.v / a.v), void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.v = Math.floor(b.v), b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$floor_divide(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng) {
      if (0 == a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      this.skType === Sk.builtin.nmber.float$ ? (b = Math.floor(this.v / parseFloat(a.str$(10, !0))), b = new Sk.builtin.nmber(b, Sk.builtin.nmber.float$)) : b = new Sk.builtin.lng(this.v).nb$floor_divide(a);
      return b;
    }
  };
  Sk.builtin.nmber.prototype.nb$remainder = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      if (0 == a.v)
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (0 == this.v)
        return this.skType == Sk.builtin.nmber.float$ || a.skType == Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(0, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
      if (Infinity === a.v)
        return Infinity === this.v || -Infinity === this.v ? new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$) : this.nb$ispositive() ? new Sk.builtin.nmber(this.v, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
      b = this.v % a.v;
      0 > this.v ? 0 < a.v && 0 > b && (b += a.v) : 0 > a.v && 0 != b && (b += a.v);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b = new Sk.builtin.nmber(b, Sk.builtin.nmber.float$);
      else if (b = new Sk.builtin.nmber(b, Sk.builtin.nmber.int$), b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$remainder(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng) {
      if (0 == a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (0 == this.v)
        return this.skType === Sk.builtin.nmber.int$ ? new Sk.builtin.lng(0) : new Sk.builtin.nmber(0, this.skType);
      this.skType === Sk.builtin.nmber.float$ ? (a = parseFloat(a.str$(10, !0)), b = this.v % a, 0 > b ? 0 < a && 0 != b && (b += a) : 0 > a && 0 != b && (b += a), b = new Sk.builtin.nmber(b, Sk.builtin.nmber.float$)) : b = new Sk.builtin.lng(this.v).nb$remainder(a);
      return b;
    }
  };
  Sk.builtin.nmber.prototype.nb$power = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      if (0 > this.v && 0 != a.v % 1)
        throw new Sk.builtin.NegativePowerError('cannot raise a negative number to a fractional power');
      if (0 == this.v && 0 > a.v)
        throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
      b = new Sk.builtin.nmber(Math.pow(this.v, a.v), void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$ || 0 > a.v)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.v = Math.floor(b.v), b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$power(a.v);
      if (Infinity === Math.abs(b.v) && Infinity !== Math.abs(this.v) && Infinity !== Math.abs(a.v))
        throw new Sk.builtin.OverflowError('Numerical result out of range');
      return b;
    }
    if (a instanceof Sk.builtin.lng) {
      if (0 == this.v && 0 > a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
      return b = this.skType === Sk.builtin.nmber.float$ || a.nb$isnegative() ? new Sk.builtin.nmber(Math.pow(this.v, parseFloat(a.str$(10, !0))), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$power(a);
    }
  };
  Sk.builtin.nmber.prototype.nb$and = function (a) {
    a = Sk.builtin.asnum$(a);
    a &= this.v;
    void 0 !== a && 0 > a && (a += 4294967296);
    if (void 0 !== a)
      return new Sk.builtin.nmber(a, void 0);
  };
  Sk.builtin.nmber.prototype.nb$or = function (a) {
    a = Sk.builtin.asnum$(a);
    a |= this.v;
    void 0 !== a && 0 > a && (a += 4294967296);
    if (void 0 !== a)
      return new Sk.builtin.nmber(a, void 0);
  };
  Sk.builtin.nmber.prototype.nb$xor = function (a) {
    a = Sk.builtin.asnum$(a);
    a ^= this.v;
    void 0 !== a && 0 > a && (a += 4294967296);
    if (void 0 !== a)
      return new Sk.builtin.nmber(a, void 0);
  };
  Sk.builtin.nmber.prototype.nb$lshift = function (a) {
    var b;
    a = Sk.builtin.asnum$(a);
    if (void 0 !== a) {
      if (0 > a)
        throw new Sk.builtin.ValueError('negative shift count');
      b = this.v << a;
      if (b <= this.v)
        return Sk.builtin.lng.fromInt$(this.v).nb$lshift(a);
    }
    if (void 0 !== b)
      return new Sk.builtin.nmber(b, this.skType);
  };
  Sk.builtin.nmber.prototype.nb$rshift = function (a) {
    var b;
    a = Sk.builtin.asnum$(a);
    if (void 0 !== a) {
      if (0 > a)
        throw new Sk.builtin.ValueError('negative shift count');
      b = this.v >> a;
      0 < this.v && 0 > b && (b &= Math.pow(2, 32 - a) - 1);
    }
    if (void 0 !== b)
      return new Sk.builtin.nmber(b, this.skType);
  };
  Sk.builtin.nmber.prototype.nb$inplace_add = Sk.builtin.nmber.prototype.nb$add;
  Sk.builtin.nmber.prototype.nb$inplace_subtract = Sk.builtin.nmber.prototype.nb$subtract;
  Sk.builtin.nmber.prototype.nb$inplace_multiply = Sk.builtin.nmber.prototype.nb$multiply;
  Sk.builtin.nmber.prototype.nb$inplace_divide = Sk.builtin.nmber.prototype.nb$divide;
  Sk.builtin.nmber.prototype.nb$inplace_remainder = Sk.builtin.nmber.prototype.nb$remainder;
  Sk.builtin.nmber.prototype.nb$inplace_floor_divide = Sk.builtin.nmber.prototype.nb$floor_divide;
  Sk.builtin.nmber.prototype.nb$inplace_power = Sk.builtin.nmber.prototype.nb$power;
  Sk.builtin.nmber.prototype.nb$inplace_and = Sk.builtin.nmber.prototype.nb$and;
  Sk.builtin.nmber.prototype.nb$inplace_or = Sk.builtin.nmber.prototype.nb$or;
  Sk.builtin.nmber.prototype.nb$inplace_xor = Sk.builtin.nmber.prototype.nb$xor;
  Sk.builtin.nmber.prototype.nb$inplace_lshift = Sk.builtin.nmber.prototype.nb$lshift;
  Sk.builtin.nmber.prototype.nb$inplace_rshift = Sk.builtin.nmber.prototype.nb$rshift;
  Sk.builtin.nmber.prototype.nb$negative = function () {
    return new Sk.builtin.nmber(-this.v, void 0);
  };
  Sk.builtin.nmber.prototype.nb$positive = function () {
    return this.clone();
  };
  Sk.builtin.nmber.prototype.nb$nonzero = function () {
    return 0 !== this.v ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
  };
  Sk.builtin.nmber.prototype.nb$isnegative = function () {
    return 0 > this.v;
  };
  Sk.builtin.nmber.prototype.nb$ispositive = function () {
    return 0 <= this.v;
  };
  Sk.builtin.nmber.prototype.numberCompare = function (a) {
    a instanceof Sk.builtin.bool && (a = Sk.builtin.asnum$(a));
    a instanceof Sk.builtin.none && (a = 0);
    if ('number' === typeof a)
      return this.v - a;
    if (a instanceof Sk.builtin.nmber)
      return Infinity == this.v && Infinity == a.v || -Infinity == this.v && -Infinity == a.v ? 0 : this.v - a.v;
    if (a instanceof Sk.builtin.lng) {
      if (this.skType === Sk.builtin.nmber.int$ || 0 == this.v % 1)
        return new Sk.builtin.lng(this.v).longCompare(a);
      a = this.nb$subtract(a);
      if (a instanceof Sk.builtin.nmber)
        return a.v;
      if (a instanceof Sk.builtin.lng)
        return a.longCompare(Sk.builtin.biginteger.ZERO);
    }
  };
  Sk.builtin.nmber.prototype.__eq__ = function (a, b) {
    return 0 == a.numberCompare(b) && !(b instanceof Sk.builtin.none);
  };
  Sk.builtin.nmber.prototype.__ne__ = function (a, b) {
    return 0 != a.numberCompare(b) || b instanceof Sk.builtin.none;
  };
  Sk.builtin.nmber.prototype.__lt__ = function (a, b) {
    return 0 > a.numberCompare(b);
  };
  Sk.builtin.nmber.prototype.__le__ = function (a, b) {
    return 0 >= a.numberCompare(b);
  };
  Sk.builtin.nmber.prototype.__gt__ = function (a, b) {
    return 0 < a.numberCompare(b);
  };
  Sk.builtin.nmber.prototype.__ge__ = function (a, b) {
    return 0 <= a.numberCompare(b);
  };
  Sk.builtin.nmber.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.nmber.prototype.$r = function () {
    return new Sk.builtin.str(this.str$(10, !0));
  };
  Sk.builtin.nmber.prototype.tp$str = function () {
    return new Sk.builtin.str(this.str$(10, !0));
  };
  Sk.builtin.nmber.prototype.str$ = function (a, b) {
    if (isNaN(this.v))
      return 'nan';
    void 0 === b && (b = !0);
    if (Infinity == this.v)
      return 'inf';
    if (-Infinity == this.v && b)
      return '-inf';
    if (-Infinity == this.v && !b)
      return 'inf';
    var c = b ? this.v : Math.abs(this.v), d;
    if (void 0 === a || 10 === a)
      if (this.skType == Sk.builtin.nmber.float$) {
        d = c.toPrecision(12);
        var e = d.indexOf('.'), f = c.toString().slice(0, e), e = c.toString().slice(e);
        for (f.match(/^-?0$/) && e.slice(1).match(/^0{4,}/) && (d = 12 > d.length ? c.toExponential() : c.toExponential(11)); '0' == d.charAt(d.length - 1) && 0 > d.indexOf('e');)
          d = d.substring(0, d.length - 1);
        '.' == d.charAt(d.length - 1) && (d += '0');
        d = d.replace(/\.0+e/, 'e', 'i');
        d = d.replace(/(e[-+])([1-9])$/, '$10$2');
        d = d.replace(/0+(e.*)/, '$1');
      } else
        d = c.toString();
    else
      d = c.toString(a);
    if (this.skType !== Sk.builtin.nmber.float$)
      return d;
    0 > d.indexOf('.') && (0 > d.indexOf('E') && 0 > d.indexOf('e')) && (d += '.0');
    return d;
  };
  goog.exportSymbol('Sk.builtin.nmber', Sk.builtin.nmber);
  Sk.builtin.lng = function (a, b) {
    b = Sk.builtin.asnum$(b);
    if (!(this instanceof Sk.builtin.lng))
      return new Sk.builtin.lng(a, b);
    if (void 0 === a)
      this.biginteger = new Sk.builtin.biginteger(0);
    else if (a instanceof Sk.builtin.lng)
      this.biginteger = a.biginteger.clone();
    else if (a instanceof Sk.builtin.biginteger)
      this.biginteger = a;
    else {
      if (a instanceof String)
        return Sk.longFromStr(a, b);
      if (a instanceof Sk.builtin.str)
        return Sk.longFromStr(a.v, b);
      if (void 0 !== a && !Sk.builtin.checkString(a) && !Sk.builtin.checkNumber(a))
        if (!0 === a)
          a = 1;
        else if (!1 === a)
          a = 0;
        else
          throw new Sk.builtin.TypeError('long() argument must be a string or a number, not \'' + Sk.abstr.typeName(a) + '\'');
      a = Sk.builtin.asnum$nofloat(a);
      this.biginteger = new Sk.builtin.biginteger(a);
    }
    return this;
  };
  Sk.builtin.lng.prototype.tp$index = function () {
    return parseInt(this.str$(10, !0), 10);
  };
  Sk.builtin.lng.prototype.tp$hash = function () {
    return this.tp$index();
  };
  Sk.builtin.lng.prototype.tp$name = 'long';
  Sk.builtin.lng.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('long', Sk.builtin.lng);
  Sk.builtin.lng.threshold$ = Math.pow(2, 53);
  Sk.builtin.lng.MAX_INT$ = new Sk.builtin.lng(Sk.builtin.lng.threshold$);
  Sk.builtin.lng.MIN_INT$ = new Sk.builtin.lng(-Sk.builtin.lng.threshold$);
  Sk.builtin.lng.prototype.cantBeInt = function () {
    return 0 < this.longCompare(Sk.builtin.lng.MAX_INT$) || 0 > this.longCompare(Sk.builtin.lng.MIN_INT$);
  };
  Sk.builtin.lng.fromInt$ = function (a) {
    return new Sk.builtin.lng(a);
  };
  Sk.longFromStr = function (a, b) {
    var c = Sk.str2number(a, b, function (a, b) {
        return 10 == b ? new Sk.builtin.biginteger(a) : new Sk.builtin.biginteger(a, b);
      }, function (a) {
        return a.negate();
      }, 'long');
    return new Sk.builtin.lng(c);
  };
  goog.exportSymbol('Sk.longFromStr', Sk.longFromStr);
  Sk.builtin.lng.prototype.toInt$ = function () {
    return this.biginteger.intValue();
  };
  Sk.builtin.lng.prototype.clone = function () {
    return new Sk.builtin.lng(this);
  };
  Sk.builtin.lng.prototype.nb$add = function (a) {
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$add(a);
      a = new Sk.builtin.lng(a.v);
    }
    return a instanceof Sk.builtin.lng ? new Sk.builtin.lng(this.biginteger.add(a.biginteger)) : a instanceof Sk.builtin.biginteger ? new Sk.builtin.lng(this.biginteger.add(a)) : new Sk.builtin.lng(this.biginteger.add(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_add = Sk.builtin.lng.prototype.nb$add;
  Sk.builtin.lng.prototype.nb$subtract = function (a) {
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$subtract(a);
      a = new Sk.builtin.lng(a.v);
    }
    return a instanceof Sk.builtin.lng ? new Sk.builtin.lng(this.biginteger.subtract(a.biginteger)) : a instanceof Sk.builtin.biginteger ? new Sk.builtin.lng(this.biginteger.subtract(a)) : new Sk.builtin.lng(this.biginteger.subtract(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_subtract = Sk.builtin.lng.prototype.nb$subtract;
  Sk.builtin.lng.prototype.nb$multiply = function (a) {
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$multiply(a);
      a = new Sk.builtin.lng(a.v);
    }
    return a instanceof Sk.builtin.lng ? new Sk.builtin.lng(this.biginteger.multiply(a.biginteger)) : a instanceof Sk.builtin.biginteger ? new Sk.builtin.lng(this.biginteger.multiply(a)) : new Sk.builtin.lng(this.biginteger.multiply(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_multiply = Sk.builtin.lng.prototype.nb$multiply;
  Sk.builtin.lng.prototype.nb$divide = function (a) {
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$divide(a);
      a = new Sk.builtin.lng(a.v);
    }
    a instanceof Sk.builtin.lng || (a = new Sk.builtin.lng(a));
    var b = this.nb$isnegative(), c = a.nb$isnegative();
    if (b && !c || c && !b) {
      a = this.biginteger.divideAndRemainder(a.biginteger);
      if (0 == a[1].trueCompare(Sk.builtin.biginteger.ZERO))
        return new Sk.builtin.lng(a[0]);
      a = a[0].subtract(Sk.builtin.biginteger.ONE);
      return new Sk.builtin.lng(a);
    }
    return new Sk.builtin.lng(this.biginteger.divide(a.biginteger));
  };
  Sk.builtin.lng.prototype.nb$inplace_divide = Sk.builtin.lng.prototype.nb$divide;
  Sk.builtin.lng.prototype.nb$floor_divide = function (a) {
    return a instanceof Sk.builtin.nmber && a.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$floor_divide(a) : this.nb$divide(a);
  };
  Sk.builtin.lng.prototype.nb$inplace_floor_divide = Sk.builtin.lng.prototype.nb$floor_divide;
  Sk.builtin.lng.prototype.nb$remainder = function (a) {
    if (0 === this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO))
      return a instanceof Sk.builtin.nmber && a.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(0, Sk.builtin.nmber.float$) : new Sk.builtin.lng(0);
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$remainder(a);
      a = new Sk.builtin.lng(a.v);
    }
    a instanceof Sk.builtin.lng || (a = new Sk.builtin.lng(a));
    var b = new Sk.builtin.lng(this.biginteger.remainder(a.biginteger));
    this.nb$isnegative() ? a.nb$ispositive() && b.nb$nonzero() && (b = b.nb$add(a).nb$remainder(a)) : a.nb$isnegative() && b.nb$nonzero() && (b = b.nb$add(a));
    return b;
  };
  Sk.builtin.lng.prototype.nb$inplace_remainder = Sk.builtin.lng.prototype.nb$remainder;
  Sk.builtin.lng.prototype.nb$power = function (a, b) {
    if (void 0 !== b)
      return a = new Sk.builtin.biginteger(Sk.builtin.asnum$(a)), b = new Sk.builtin.biginteger(Sk.builtin.asnum$(b)), new Sk.builtin.lng(this.biginteger.modPowInt(a, b));
    if ('number' === typeof a) {
      if (0 > a) {
        var c = new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$);
        return c.nb$power(a);
      }
      return new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(a)));
    }
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$ || 0 > a.v)
        return c = new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$), c.nb$power(a);
      a = new Sk.builtin.lng(a.v);
    }
    return a instanceof Sk.builtin.lng ? a.nb$isnegative() ? (c = new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$), c.nb$power(a)) : new Sk.builtin.lng(this.biginteger.pow(a.biginteger)) : a instanceof Sk.builtin.biginteger ? a.isnegative() ? (c = new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$), c.nb$power(a)) : new Sk.builtin.lng(this.biginteger.pow(a)) : new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_power = Sk.builtin.lng.prototype.nb$power;
  Sk.builtin.lng.prototype.nb$lshift = function (a) {
    if (a instanceof Sk.builtin.lng) {
      if (0 > a.biginteger.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftLeft(a.biginteger));
    }
    if (a instanceof Sk.builtin.biginteger) {
      if (0 > a.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftLeft(a));
    }
    if (0 > a)
      throw new Sk.builtin.ValueError('negative shift count');
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.shiftLeft(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_lshift = Sk.builtin.lng.prototype.nb$lshift;
  Sk.builtin.lng.prototype.nb$rshift = function (a) {
    if (a instanceof Sk.builtin.lng) {
      if (0 > a.biginteger.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftRight(a.biginteger));
    }
    if (a instanceof Sk.builtin.biginteger) {
      if (0 > a.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftRight(a));
    }
    if (0 > a)
      throw new Sk.builtin.ValueError('negative shift count');
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.shiftRight(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_rshift = Sk.builtin.lng.prototype.nb$rshift;
  Sk.builtin.lng.prototype.nb$and = function (a) {
    if (a instanceof Sk.builtin.lng)
      return new Sk.builtin.lng(this.biginteger.and(a.biginteger));
    if (a instanceof Sk.builtin.biginteger)
      return new Sk.builtin.lng(this.biginteger.and(a));
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.and(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_and = Sk.builtin.lng.prototype.nb$and;
  Sk.builtin.lng.prototype.nb$or = function (a) {
    if (a instanceof Sk.builtin.lng)
      return new Sk.builtin.lng(this.biginteger.or(a.biginteger));
    if (a instanceof Sk.builtin.biginteger)
      return new Sk.builtin.lng(this.biginteger.or(a));
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.or(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_or = Sk.builtin.lng.prototype.nb$or;
  Sk.builtin.lng.prototype.nb$xor = function (a) {
    if (a instanceof Sk.builtin.lng)
      return new Sk.builtin.lng(this.biginteger.xor(a.biginteger));
    if (a instanceof Sk.builtin.biginteger)
      return new Sk.builtin.lng(this.biginteger.xor(a));
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.xor(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_xor = Sk.builtin.lng.prototype.nb$xor;
  Sk.builtin.lng.prototype.nb$negative = function () {
    return new Sk.builtin.lng(this.biginteger.negate());
  };
  Sk.builtin.lng.prototype.nb$positive = function () {
    return this.clone();
  };
  Sk.builtin.lng.prototype.nb$nonzero = function () {
    return 0 !== this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO);
  };
  Sk.builtin.lng.prototype.nb$isnegative = function () {
    return this.biginteger.isnegative();
  };
  Sk.builtin.lng.prototype.nb$ispositive = function () {
    return !this.biginteger.isnegative();
  };
  Sk.builtin.lng.prototype.longCompare = function (a) {
    'boolean' === typeof a && (a = a ? 1 : 0);
    'number' === typeof a && (a = new Sk.builtin.lng(a));
    return a instanceof Sk.builtin.nmber ? a.skType === Sk.builtin.nmber.int$ || 0 == a.v % 1 ? (a = new Sk.builtin.lng(a.v), this.longCompare(a)) : new Sk.builtin.nmber(this, Sk.builtin.nmber.float$).numberCompare(a) : a instanceof Sk.builtin.lng ? this.biginteger.subtract(a.biginteger) : a instanceof Sk.builtin.biginteger ? this.biginteger.subtract(a) : this.biginteger.subtract(new Sk.builtin.biginteger(a));
  };
  Sk.builtin.lng.prototype.__eq__ = function (a, b) {
    return 0 == a.longCompare(b) && !(b instanceof Sk.builtin.none);
  };
  Sk.builtin.lng.prototype.__ne__ = function (a, b) {
    return 0 != a.longCompare(b) || b instanceof Sk.builtin.none;
  };
  Sk.builtin.lng.prototype.__lt__ = function (a, b) {
    return 0 > a.longCompare(b);
  };
  Sk.builtin.lng.prototype.__le__ = function (a, b) {
    return 0 >= a.longCompare(b);
  };
  Sk.builtin.lng.prototype.__gt__ = function (a, b) {
    return 0 < a.longCompare(b);
  };
  Sk.builtin.lng.prototype.__ge__ = function (a, b) {
    return 0 <= a.longCompare(b);
  };
  Sk.builtin.lng.prototype.$r = function () {
    return new Sk.builtin.str(this.str$(10, !0) + 'L');
  };
  Sk.builtin.lng.prototype.tp$str = function () {
    return new Sk.builtin.str(this.str$(10, !0));
  };
  Sk.builtin.lng.prototype.str$ = function (a, b) {
    void 0 === b && (b = !0);
    var c = b ? this.biginteger : this.biginteger.abs();
    return void 0 === a || 10 === a ? c.toString() : c.toString(a);
  };
  Sk.str2number = function (a, b, c, d, e) {
    var f = a, g = !1;
    a = a.replace(/^\s+|\s+$/g, '');
    '-' == a.charAt(0) && (g = !0, a = a.substring(1));
    '+' == a.charAt(0) && (a = a.substring(1));
    void 0 === b && (b = 10);
    if ((2 > b || 36 < b) && 0 != b)
      throw new Sk.builtin.ValueError(e + '() base must be >= 2 and <= 36');
    if ('0x' == a.substring(0, 2).toLowerCase()) {
      if (16 != b && 0 != b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
      a = a.substring(2);
      b = 16;
    } else if ('0b' == a.substring(0, 2).toLowerCase()) {
      if (2 != b && 0 != b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
      a = a.substring(2);
      b = 2;
    } else if ('0o' == a.substring(0, 2).toLowerCase()) {
      if (8 != b && 0 != b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
      a = a.substring(2);
      b = 8;
    } else if ('0' == a.charAt(0)) {
      if ('0' == a)
        return 0;
      if (8 == b || 0 == b)
        b = 8;
    }
    0 == b && (b = 10);
    if (0 === a.length)
      throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
    var h, k, l;
    for (h = 0; h < a.length; h++)
      if (k = a.charCodeAt(h), l = b, 48 <= k && 57 >= k ? l = k - 48 : 65 <= k && 90 >= k ? l = k - 65 + 10 : 97 <= k && 122 >= k && (l = k - 97 + 10), l >= b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
    l = c(a, b);
    g && (l = d(l));
    return l;
  };
  Sk.builtin.int_ = function (a, b) {
    if (void 0 !== a && !Sk.builtin.checkString(a) && !Sk.builtin.checkNumber(a))
      if (a instanceof Sk.builtin.bool)
        a = Sk.builtin.asnum$(a);
      else
        throw new Sk.builtin.TypeError('int() argument must be a string or a number, not \'' + Sk.abstr.typeName(a) + '\'');
    if (a instanceof Sk.builtin.str) {
      b = Sk.builtin.asnum$(b);
      var c = Sk.str2number(a.v, b, parseInt, function (a) {
          return -a;
        }, 'int');
      return c > Sk.builtin.lng.threshold$ || c < -Sk.builtin.lng.threshold$ ? new Sk.builtin.lng(a, b) : new Sk.builtin.nmber(c, Sk.builtin.nmber.int$);
    }
    if (void 0 !== b)
      throw new Sk.builtin.TypeError('int() can\'t convert non-string with explicit base');
    if (a instanceof Sk.builtin.lng)
      return a.cantBeInt() ? new Sk.builtin.lng(a) : new Sk.builtin.nmber(a.toInt$(), Sk.builtin.nmber.int$);
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.nmber(a | 0, Sk.builtin.nmber.int$);
  };
  Sk.builtin.int_.prototype.tp$name = 'int';
  Sk.builtin.int_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('int', Sk.builtin.int_);
  Sk.builtin.float_ = function (a) {
    if (void 0 === a)
      return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
    if (a instanceof Sk.builtin.str) {
      if (a.v.match(/^-inf$/i))
        a = -Infinity;
      else if (a.v.match(/^[+]?inf$/i))
        a = Infinity;
      else if (a.v.match(/^[-+]?nan$/i))
        a = NaN;
      else {
        if (isNaN(a.v))
          throw new Sk.builtin.ValueError('float: Argument: ' + a.v + ' is not number');
        a = parseFloat(a.v);
      }
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    }
    if ('number' === typeof a || a instanceof Sk.builtin.nmber || a instanceof Sk.builtin.lng)
      return a = Sk.builtin.asnum$(a), new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    if (a instanceof Sk.builtin.bool)
      return a = Sk.builtin.asnum$(a), new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    throw new Sk.builtin.TypeError('float() argument must be a string or a number');
  };
  Sk.builtin.float_.prototype.tp$name = 'float';
  Sk.builtin.float_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('float', Sk.builtin.float_);
  Sk.builtin.slice = function (a, b, c) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    c = Sk.builtin.asnum$(c);
    if (!(this instanceof Sk.builtin.slice))
      return new Sk.builtin.slice(a, b, c);
    void 0 === b && void 0 === c && (b = a, a = null);
    a || (a = null);
    void 0 === b && (b = null);
    void 0 === c && (c = null);
    this.start = a;
    this.stop = b;
    this.step = c;
    if (null !== this.start && !Sk.builtin.checkInt(this.start) || null !== this.stop && !Sk.builtin.checkInt(this.stop) || null !== this.step && !Sk.builtin.checkInt(this.step))
      throw new Sk.builtin.TypeError('slice indices must be integers or None');
    return this;
  };
  Sk.builtin.slice.prototype.tp$str = function () {
    var a = Sk.builtin.repr(this.start).v, b = Sk.builtin.repr(this.stop).v, c = Sk.builtin.repr(this.step).v;
    return new Sk.builtin.str('slice(' + a + ', ' + b + ', ' + c + ')');
  };
  Sk.builtin.slice.prototype.indices = function (a) {
    a = Sk.builtin.asnum$(a);
    var b = this.start, c = this.stop, d = this.step;
    null === d && (d = 1);
    0 < d ? (null === b && (b = 0), null === c && (c = a), c > a && (c = a), 0 > b && (b = a + b, 0 > b && (b = 0)), 0 > c && (c = a + c)) : (null === b && (b = a - 1), b >= a && (b = a - 1), null === c ? c = -1 : 0 > c && (c = a + c, 0 > c && (c = -1)), 0 > b && (b = a + b));
    return [
      b,
      c,
      d
    ];
  };
  Sk.builtin.slice.prototype.sssiter$ = function (a, b) {
    var c = Sk.builtin.asnum$(a), d = this.indices('number' === typeof c ? c : a.v.length);
    if (0 < d[2]) {
      var e;
      for (e = d[0]; e < d[1] && !1 !== b(e, c); e += d[2]);
    } else
      for (e = d[0]; e > d[1] && !1 !== b(e, c); e += d[2]);
  };
  Sk.builtin.set = function (a) {
    if (!(this instanceof Sk.builtin.set))
      return new Sk.builtin.set(a);
    'undefined' === typeof a && (a = []);
    this.set_reset_();
    a = new Sk.builtin.list(a).tp$iter();
    for (var b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext())
      Sk.builtin.set.prototype.add.func_code(this, b);
    this.__class__ = Sk.builtin.set;
    this.v = this.v;
    return this;
  };
  Sk.builtin.set.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('set', Sk.builtin.set);
  Sk.builtin.set.prototype.set_iter_ = function () {
    return Sk.builtin.dict.prototype.keys.func_code(this.v).tp$iter();
  };
  Sk.builtin.set.prototype.set_reset_ = function () {
    this.v = new Sk.builtin.dict([]);
  };
  Sk.builtin.set.prototype.tp$name = 'set';
  Sk.builtin.set.prototype.$r = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      a.push(Sk.misceval.objectRepr(c).v);
    return new Sk.builtin.str('set([' + a.join(', ') + '])');
  };
  Sk.builtin.set.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.set.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
  Sk.builtin.set.prototype.tp$richcompare = function (a, b) {
    if (this === a && Sk.misceval.opAllowsEquality(b))
      return !0;
    if (!a.__class__ || a.__class__ != Sk.builtin.set)
      return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : !1;
    var c = this.sq$length(), d = a.sq$length();
    if (d !== c) {
      if ('Eq' === b)
        return !1;
      if ('NotEq' === b)
        return !0;
    }
    var e = !1, f = !1;
    switch (b) {
    case 'Lt':
    case 'LtE':
    case 'Eq':
    case 'NotEq':
      e = Sk.builtin.set.prototype.issubset.func_code(this, a);
      break;
    case 'Gt':
    case 'GtE':
      f = Sk.builtin.set.prototype.issuperset.func_code(this, a);
      break;
    default:
      goog.asserts.fail();
    }
    switch (b) {
    case 'Lt':
      return c < d && e;
    case 'LtE':
    case 'Eq':
      return e;
    case 'NotEq':
      return !e;
    case 'Gt':
      return c > d && f;
    case 'GtE':
      return f;
    }
  };
  Sk.builtin.set.prototype.tp$iter = Sk.builtin.set.prototype.set_iter_;
  Sk.builtin.set.prototype.sq$length = function () {
    return this.v.mp$length();
  };
  Sk.builtin.set.prototype.isdisjoint = new Sk.builtin.func(function (a, b) {
    for (var c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      if (Sk.abstr.sequenceContains(b, d))
        return Sk.builtin.bool.false$;
    return Sk.builtin.bool(!0);
  });
  Sk.builtin.set.prototype.issubset = new Sk.builtin.func(function (a, b) {
    var c = a.sq$length(), d = b.sq$length();
    if (c > d)
      return Sk.builtin.bool.false$;
    c = a.tp$iter();
    for (d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      if (!Sk.abstr.sequenceContains(b, d))
        return Sk.builtin.bool.false$;
    return Sk.builtin.bool.true$;
  });
  Sk.builtin.set.prototype.issuperset = new Sk.builtin.func(function (a, b) {
    return Sk.builtin.set.prototype.issubset.func_code(b, a);
  });
  Sk.builtin.set.prototype.union = new Sk.builtin.func(function (a) {
    for (var b = new Sk.builtin.set(a), c = 1; c < arguments.length; c++)
      Sk.builtin.set.prototype.update.func_code(b, arguments[c]);
    return b;
  });
  Sk.builtin.set.prototype.intersection = new Sk.builtin.func(function (a) {
    var b = Sk.builtin.set.prototype.copy.func_code(a);
    arguments[0] = b;
    Sk.builtin.set.prototype.intersection_update.func_code.apply(null, arguments);
    return b;
  });
  Sk.builtin.set.prototype.difference = new Sk.builtin.func(function (a, b) {
    var c = Sk.builtin.set.prototype.copy.func_code(a);
    arguments[0] = c;
    Sk.builtin.set.prototype.difference_update.func_code.apply(null, arguments);
    return c;
  });
  Sk.builtin.set.prototype.symmetric_difference = new Sk.builtin.func(function (a, b) {
    for (var c = Sk.builtin.set.prototype.union.func_code(a, b), d = c.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      Sk.abstr.sequenceContains(a, e) && Sk.abstr.sequenceContains(b, e) && Sk.builtin.set.prototype.discard.func_code(c, e);
    return c;
  });
  Sk.builtin.set.prototype.copy = new Sk.builtin.func(function (a) {
    return new Sk.builtin.set(a);
  });
  Sk.builtin.set.prototype.update = new Sk.builtin.func(function (a, b) {
    for (var c = b.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      Sk.builtin.set.prototype.add.func_code(a, d);
    return null;
  });
  Sk.builtin.set.prototype.intersection_update = new Sk.builtin.func(function (a) {
    for (var b = a.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      for (var d = 1; d < arguments.length; d++)
        if (!Sk.abstr.sequenceContains(arguments[d], c)) {
          Sk.builtin.set.prototype.discard.func_code(a, c);
          break;
        }
    return null;
  });
  Sk.builtin.set.prototype.difference_update = new Sk.builtin.func(function (a, b) {
    for (var c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      for (var e = 1; e < arguments.length; e++)
        if (Sk.abstr.sequenceContains(arguments[e], d)) {
          Sk.builtin.set.prototype.discard.func_code(a, d);
          break;
        }
    return null;
  });
  Sk.builtin.set.prototype.symmetric_difference_update = new Sk.builtin.func(function (a, b) {
    var c = Sk.builtin.set.prototype.symmetric_difference.func_code(a, b);
    a.set_reset_();
    Sk.builtin.set.prototype.update.func_code(a, c);
    return null;
  });
  Sk.builtin.set.prototype.add = new Sk.builtin.func(function (a, b) {
    a.v.mp$ass_subscript(b, !0);
    return null;
  });
  Sk.builtin.set.prototype.discard = new Sk.builtin.func(function (a, b) {
    if (void 0 !== a.v.mp$lookup(b)) {
      var c = Sk.builtin.hash, c = c(b);
      void 0 !== a.v[c] && (a.v.size -= 1, delete a.v[c]);
    }
    return null;
  });
  Sk.builtin.set.prototype.pop = new Sk.builtin.func(function (a) {
    if (0 === a.sq$length())
      throw new Sk.builtin.KeyError('pop from an empty set');
    var b = a.tp$iter().tp$iternext();
    Sk.builtin.set.prototype.discard.func_code(a, b);
    return b;
  });
  Sk.builtin.set.prototype.remove = new Sk.builtin.func(function (a, b) {
    a.v.mp$del_subscript(b);
    return null;
  });
  goog.exportSymbol('Sk.builtin.set', Sk.builtin.set);
  Sk.builtin.module = function () {
  };
  goog.exportSymbol('Sk.builtin.module', Sk.builtin.module);
  Sk.builtin.module.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('module', Sk.builtin.module);
  Sk.builtin.module.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.module.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
  Sk.builtin.generator = function (a, b, c, d, e) {
    if (a) {
      this.func_code = a;
      this.func_globals = b || null;
      this.gi$running = !1;
      this.gi$resumeat = 0;
      this.gi$sentvalue = void 0;
      this.gi$locals = {};
      if (0 < c.length)
        for (b = 0; b < a.co_varnames.length; ++b)
          this.gi$locals[a.co_varnames[b]] = c[b];
      if (void 0 !== e)
        for (var f in e)
          d[f] = e[f];
      this.func_closure = d;
      return this;
    }
  };
  goog.exportSymbol('Sk.builtin.generator', Sk.builtin.generator);
  Sk.builtin.generator.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.generator.prototype.tp$iter = function () {
    return this;
  };
  Sk.builtin.generator.prototype.tp$iternext = function (a) {
    this.gi$running = !0;
    void 0 === a && (a = null);
    this.gi$sentvalue = a;
    a = [this];
    this.func_closure && a.push(this.func_closure);
    a = this.func_code.apply(this.func_globals, a);
    this.gi$running = !1;
    goog.asserts.assert(void 0 !== a);
    if (null !== a)
      return this.gi$resumeat = a[0], a = a[1];
  };
  Sk.builtin.generator.prototype.next = new Sk.builtin.func(function (a) {
    return a.tp$iternext();
  });
  Sk.builtin.generator.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('generator', Sk.builtin.generator);
  Sk.builtin.generator.prototype.$r = function () {
    return new Sk.builtin.str('<generator object ' + this.func_code.co_name.v + '>');
  };
  Sk.builtin.generator.prototype.send = new Sk.builtin.func(function (a, b) {
    return a.tp$iternext(b);
  });
  Sk.builtin.makeGenerator = function (a, b) {
    var c = new Sk.builtin.generator(null, null, null);
    c.tp$iternext = a;
    for (var d in b)
      b.hasOwnProperty(d) && (c[d] = b[d]);
    return c;
  };
  goog.exportSymbol('Sk.builtin.makeGenerator', Sk.builtin.makeGenerator);
  Sk.builtin.file = function (a, b, c) {
    this.mode = b;
    this.name = a;
    this.closed = !1;
    if (Sk.inBrowser) {
      b = document.getElementById(a.v);
      if (null == b)
        throw new Sk.builtin.IOError('[Errno 2] No such file or directory: \'' + a.v + '\'');
      'textarea' == b.nodeName.toLowerCase() ? this.data$ = b.value : this.data$ = b.textContent;
    } else
      this.data$ = Sk.read(a.v);
    this.lineList = this.data$.split('\n');
    this.lineList = this.lineList.slice(0, -1);
    for (var d in this.lineList)
      this.lineList[d] += '\n';
    this.pos$ = this.currentLine = 0;
    this.__class__ = Sk.builtin.file;
    return this;
  };
  Sk.builtin.file.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('file', Sk.builtin.file);
  Sk.builtin.file.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.file.prototype.$r = function () {
    return new Sk.builtin.str('<' + (this.closed ? 'closed' : 'open') + 'file \'' + this.name + '\', mode \'' + this.mode + '\'>');
  };
  Sk.builtin.file.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        $lines: this.lineList,
        tp$iternext: function () {
          return a.$index >= a.$lines.length ? void 0 : new Sk.builtin.str(a.$lines[a.$index++]);
        }
      };
    return a;
  };
  Sk.builtin.file.prototype.close = new Sk.builtin.func(function (a) {
    a.closed = !0;
  });
  Sk.builtin.file.prototype.flush = new Sk.builtin.func(function (a) {
  });
  Sk.builtin.file.prototype.fileno = new Sk.builtin.func(function (a) {
    return 10;
  });
  Sk.builtin.file.prototype.isatty = new Sk.builtin.func(function (a) {
    return !1;
  });
  Sk.builtin.file.prototype.read = new Sk.builtin.func(function (a, b) {
    if (a.closed)
      throw new Sk.builtin.ValueError('I/O operation on closed file');
    var c = a.data$.length;
    void 0 === b && (b = c);
    var d = new Sk.builtin.str(a.data$.substr(a.pos$, b));
    a.pos$ += b;
    a.pos$ >= c && (a.pos$ = c);
    return d;
  });
  Sk.builtin.file.prototype.readline = new Sk.builtin.func(function (a, b) {
    var c = '';
    a.currentLine < a.lineList.length && (c = a.lineList[a.currentLine], a.currentLine++);
    return new Sk.builtin.str(c);
  });
  Sk.builtin.file.prototype.readlines = new Sk.builtin.func(function (a, b) {
    for (var c = [], d = a.currentLine; d < a.lineList.length; d++)
      c.push(new Sk.builtin.str(a.lineList[d]));
    return new Sk.builtin.list(c);
  });
  Sk.builtin.file.prototype.seek = new Sk.builtin.func(function (a, b, c) {
    void 0 === c && (c = 1);
    a.pos$ = 1 == c ? b : a.data$ + b;
  });
  Sk.builtin.file.prototype.tell = new Sk.builtin.func(function (a) {
    return a.pos$;
  });
  Sk.builtin.file.prototype.truncate = new Sk.builtin.func(function (a, b) {
    goog.asserts.fail();
  });
  Sk.builtin.file.prototype.write = new Sk.builtin.func(function (a, b) {
    goog.asserts.fail();
  });
  goog.exportSymbol('Sk.builtin.file', Sk.builtin.file);
  Sk.ffi = Sk.ffi || {};
  goog.exportSymbol('Sk.ffi.AssertionError', Sk.ffi.AssertionError);
  Sk.ffi.assertionError = function (a) {
    return new Sk.builtin.AssertionError(a);
  };
  goog.exportSymbol('Sk.ffi.assertionError', Sk.ffi.assertionError);
  goog.exportSymbol('Sk.ffi.AttributeError', Sk.ffi.AttributeError);
  Sk.ffi.attributeError = function (a) {
    return new Sk.builtin.AttributeError(a);
  };
  goog.exportSymbol('Sk.ffi.attributeError', Sk.ffi.attributeError);
  goog.exportSymbol('Sk.ffi.NotImplementedError', Sk.ffi.NotImplementedError);
  Sk.ffi.notImplementedError = function (a) {
    return new Sk.builtin.NotImplementedError(a);
  };
  goog.exportSymbol('Sk.ffi.notImplementedError', Sk.ffi.notImplementedError);
  goog.exportSymbol('Sk.ffi.TypeError', Sk.ffi.TypeError);
  Sk.ffi.typeError = function (a) {
    return new Sk.builtin.TypeError(a);
  };
  goog.exportSymbol('Sk.ffi.typeError', Sk.ffi.typeError);
  Sk.ffi.JsType = {
    UNDEFINED: 'undefined',
    OBJECT: 'object',
    STRING: 'string',
    NUMBER: 'number',
    BOOLEAN: 'boolean',
    FUNCTION: 'function'
  };
  Sk.ffi.bool = {
    True: Sk.builtin.bool.true$,
    False: Sk.builtin.bool.false$
  };
  goog.exportSymbol('Sk.ffi.bool', Sk.ffi.bool);
  Sk.ffi.none = { None: Sk.builtin.none.none$ };
  goog.exportSymbol('Sk.ffi.none', Sk.ffi.none);
  Sk.ffi.booleanToPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.ffi.JsType.BOOLEAN)
      return a ? Sk.ffi.bool.True : Sk.ffi.bool.False;
    if (c === Sk.ffi.JsType.OBJECT && null === a)
      return Sk.ffi.none.None;
    if (c === Sk.ffi.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.ffi.JsType.BOOLEAN)
        return Sk.ffi.booleanToPy(Boolean(b));
      if (c === Sk.ffi.JsType.UNDEFINED)
        return;
      if (c === Sk.ffi.JsType.OBJECT && null === b)
        return Sk.ffi.none.None;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.booleanToPy').mustHaveType([
        Sk.ffi.JsType.BOOLEAN,
        'null',
        Sk.ffi.JsType.UNDEFINED
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.booleanToPy').mustHaveType([
      Sk.ffi.JsType.BOOLEAN,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.booleanToPy', Sk.ffi.booleanToPy);
  Sk.ffi.numberToPy = function (a, b) {
    switch (b) {
    case Sk.ffi.PyType.FLOAT:
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    case Sk.ffi.PyType.INT:
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.int$);
    default:
      throw Sk.ffi.assertionError('ead77baa-30b2-470a-bb18-9db949965e45, kind => ' + b);
    }
  };
  goog.exportSymbol('Sk.ffi.numberToPy', Sk.ffi.numberToPy);
  Sk.ffi.numberToFloatPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.ffi.JsType.NUMBER)
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    if (c === Sk.ffi.JsType.OBJECT && null === a)
      return Sk.ffi.none.None;
    if (c === Sk.ffi.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.ffi.JsType.NUMBER)
        return Sk.ffi.numberToFloatPy(Number(b));
      if (c === Sk.ffi.JsType.UNDEFINED)
        return;
      if (c === Sk.ffi.JsType.OBJECT && null === b)
        return Sk.ffi.none.None;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.numberToFloatPy').mustHaveType([
        Sk.ffi.JsType.NUMBER,
        'null',
        Sk.ffi.JsType.UNDEFINED
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.numberToFloatPy').mustHaveType([
      Sk.ffi.JsType.NUMBER,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.numberToFloatPy', Sk.ffi.numberToFloatPy);
  Sk.ffi.numberToIntPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.ffi.JsType.NUMBER)
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.int$);
    if (c === Sk.ffi.JsType.OBJECT && null === a)
      return Sk.ffi.none.None;
    if (c === Sk.ffi.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.ffi.JsType.NUMBER)
        return Sk.ffi.numberToIntPy(Number(b));
      if (c === Sk.ffi.JsType.UNDEFINED)
        return;
      if (c === Sk.ffi.JsType.OBJECT && null === b)
        return Sk.ffi.none.None;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.numberToIntPy').mustHaveType([
        Sk.ffi.JsType.NUMBER,
        'null',
        Sk.ffi.JsType.UNDEFINED
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.numberToIntPy').mustHaveType([
      Sk.ffi.JsType.NUMBER,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.numberToIntPy', Sk.ffi.numberToIntPy);
  Sk.ffi.stringToPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.ffi.JsType.STRING)
      return 0 < a.length ? new Sk.builtin.str(a) : Sk.builtin.str.$emptystr;
    if (c === Sk.ffi.JsType.OBJECT && null === a)
      return Sk.ffi.none.None;
    if (c === Sk.ffi.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.ffi.JsType.STRING)
        return Sk.ffi.stringToPy(b.toString());
      if (c === Sk.ffi.JsType.UNDEFINED)
        return;
      if (c === Sk.ffi.JsType.OBJECT && null === b)
        return Sk.ffi.none.None;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.stringToPy').mustHaveType([
        Sk.ffi.JsType.STRING,
        Sk.ffi.JsType.UNDEFINED,
        'null'
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.stringToPy').mustHaveType([
      Sk.ffi.JsType.STRING,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.stringToPy', Sk.ffi.stringToPy);
  Sk.ffi.referenceToPy = function (a, b, c, d) {
    var e = typeof a;
    if (e === Sk.ffi.JsType.OBJECT || e === Sk.ffi.JsType.FUNCTION)
      if (typeof b === Sk.ffi.JsType.STRING)
        if (d)
          d.v = a, d.tp$name = b, d.custom = c;
        else
          return {
            v: a,
            tp$name: b,
            custom: c
          };
      else
        throw Sk.ffi.assertionError('9fad4b9e-4845-4a06-9bce-0aa7c68e1f03 [className is ' + b + ']');
    else
      throw Sk.ffi.assertionError('306f31df-f0a9-40a0-895b-d01308df8d6e typeof valueJs => ' + e);
  };
  goog.exportSymbol('Sk.ffi.referenceToPy', Sk.ffi.referenceToPy);
  Sk.ffi.functionPy = function (a) {
    return new Sk.builtin.func(a);
  };
  goog.exportSymbol('Sk.ffi.functionPy', Sk.ffi.functionPy);
  Sk.ffi.listPy = function (a) {
    return new Sk.builtin.list(a);
  };
  goog.exportSymbol('Sk.ffi.listPy', Sk.ffi.listPy);
  Sk.ffi.tuplePy = function (a) {
    return new Sk.builtin.tuple(a);
  };
  goog.exportSymbol('Sk.ffi.tuplePy', Sk.ffi.tuplePy);
  Sk.ffi.remapToPy = function (a, b, c) {
    var d = typeof a;
    if (d === Sk.ffi.JsType.OBJECT) {
      if ('[object Array]' === Object.prototype.toString.call(a)) {
        var e = [];
        for (b = 0; b < a.length; ++b)
          e.push(Sk.ffi.remapToPy(a[b]));
        return Sk.ffi.listPy(e);
      }
      if (typeof b === Sk.ffi.JsType.STRING)
        return Sk.ffi.referenceToPy(a, b.toString(), c);
      if (d === Sk.ffi.JsType.OBJECT && null === a)
        return Sk.ffi.none.None;
      b = [];
      for (e in a)
        b.push(Sk.ffi.remapToPy(e)), b.push(Sk.ffi.remapToPy(a[e]));
      return new Sk.builtin.dict(b);
    }
    if (d === Sk.ffi.JsType.STRING)
      return Sk.ffi.stringToPy(a);
    if (d === Sk.ffi.JsType.NUMBER)
      return Sk.ffi.numberToFloatPy(a);
    if (d === Sk.ffi.JsType.BOOLEAN)
      return Sk.ffi.booleanToPy(a);
    if (d === Sk.ffi.JsType.FUNCTION)
      return Sk.ffi.functionPy(a);
    if (d === Sk.ffi.JsType.UNDEFINED)
      return Sk.ffi.none.None;
    throw Sk.ffi.assertionError('d39f7c01-213e-4ded-9e5c-209a2dc94b4c, typeof valueJs => ' + d);
  };
  goog.exportSymbol('Sk.ffi.remapToPy', Sk.ffi.remapToPy);
  Sk.ffi.isBool = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.BOOL;
  };
  goog.exportSymbol('Sk.ffi.isBool', Sk.ffi.isBool);
  Sk.ffi.isInstance = function (a, b) {
    if (Sk.ffi.getType(a) === Sk.ffi.PyType.INSTANCE) {
      var c = typeof b;
      if (c === Sk.ffi.JsType.STRING)
        return Sk.ffi.typeName(a) === b;
      if (c === Sk.ffi.JsType.UNDEFINED)
        return !0;
      if ('[object Array]' === Object.prototype.toString.call(b)) {
        var d = Sk.ffi.typeName(a);
        return b.some(function (a) {
          return d === a;
        });
      }
      throw Sk.ffi.assertionError('caa41602-62da-4850-8f76-38d013f45a6c, typeof className => ' + c);
    }
    return !1;
  };
  goog.exportSymbol('Sk.ffi.isInstance', Sk.ffi.isInstance);
  Sk.ffi.isDefined = function (a) {
    return Sk.ffi.getType(a) !== Sk.ffi.PyType.UNDEFINED;
  };
  goog.exportSymbol('Sk.ffi.isDefined', Sk.ffi.isDefined);
  Sk.ffi.isDict = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.DICT;
  };
  goog.exportSymbol('Sk.ffi.isDict', Sk.ffi.isDict);
  Sk.ffi.isList = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.LIST;
  };
  goog.exportSymbol('Sk.ffi.isList', Sk.ffi.isList);
  Sk.ffi.isFloat = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.FLOAT;
  };
  goog.exportSymbol('Sk.ffi.isFloat', Sk.ffi.isFloat);
  Sk.ffi.isFunction = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.FUNCTION;
  };
  goog.exportSymbol('Sk.ffi.isFunction', Sk.ffi.isFunction);
  Sk.ffi.isFunctionRef = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.FUNREF;
  };
  goog.exportSymbol('Sk.ffi.isFunctionRef', Sk.ffi.isFunctionRef);
  Sk.ffi.isInt = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.INT;
  };
  goog.exportSymbol('Sk.ffi.isInt', Sk.ffi.isInt);
  Sk.ffi.isLong = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.LONG;
  };
  goog.exportSymbol('Sk.ffi.isLong', Sk.ffi.isLong);
  Sk.ffi.isNone = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.NONE;
  };
  goog.exportSymbol('Sk.ffi.isNone', Sk.ffi.isNone);
  Sk.ffi.isNum = function (a) {
    return Sk.builtin.checkNumber(a);
  };
  goog.exportSymbol('Sk.ffi.isNum', Sk.ffi.isNum);
  Sk.ffi.isStr = function (a) {
    return Sk.builtin.checkString(a);
  };
  goog.exportSymbol('Sk.ffi.isStr', Sk.ffi.isStr);
  Sk.ffi.isUndefined = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.UNDEFINED;
  };
  goog.exportSymbol('Sk.ffi.isUndefined', Sk.ffi.isUndefined);
  Sk.ffi.checkFunctionArgs = function (a, b, c, d, e, f) {
    b = b.length;
    var g = '';
    void 0 === d && (d = Infinity);
    e && (b -= 1);
    f && (b -= 1);
    if (b < c || b > d)
      throw g = (c === d ? a + '() takes exactly ' + c + ' arguments' : b < c ? a + '() takes at least ' + c + ' arguments' : a + '() takes at most ' + d + ' arguments') + (' (' + b + ' given)'), Sk.ffi.assertionError(g);
    return b;
  };
  goog.exportSymbol('Sk.ffi.checkFunctionArgs', Sk.ffi.checkFunctionArgs);
  Sk.ffi.checkMethodArgs = function (a, b, c, d, e, f) {
    return Sk.ffi.checkFunctionArgs(a, Array.prototype.slice.call(b, 1), c, d, e, f);
  };
  goog.exportSymbol('Sk.ffi.checkMethodArgs', Sk.ffi.checkMethodArgs);
  goog.exportSymbol('Sk.ffi.SimpleType', Sk.ffi.SimpleType);
  goog.exportSymbol('Sk.ffi.UnionType', Sk.ffi.UnionType);
  Sk.ffi.checkArgType = function (a, b, c, d) {
    if (!c)
      throw Sk.ffi.err.argument(a).mustHaveType(b);
  };
  goog.exportSymbol('Sk.ffi.checkArgType', Sk.ffi.checkArgType);
  Sk.ffi.checkLhsOperandType = function (a, b, c, d) {
    if (!c)
      throw Sk.ffi.err.operand('Left').toOperation(a).mustHaveType(b);
  };
  goog.exportSymbol('Sk.ffi.checkLhsOperandType', Sk.ffi.checkLhsOperandType);
  Sk.ffi.checkRhsOperandType = function (a, b, c, d) {
    if (!c)
      throw Sk.ffi.err.operand('Right').toOperation(a).mustHaveType(b);
  };
  goog.exportSymbol('Sk.ffi.checkRhsOperandType', Sk.ffi.checkRhsOperandType);
  Sk.ffi.PyType = {
    DICT: 1,
    LIST: 2,
    TUPLE: 3,
    BOOL: 4,
    FLOAT: 5,
    INT: 6,
    LONG: 7,
    STR: 8,
    NONE: 9,
    FUNCTION: 10,
    INSTANCE: 11,
    UNDEFINED: -1,
    FUNREF: -2
  };
  Sk.ffi.typeString = function (a, b) {
    function c(a) {
      return '<type \'' + a + '\'>';
    }
    function d(a) {
      switch (a) {
      case Sk.ffi.PyType.DICT:
        return c('dict');
      case Sk.ffi.PyType.LIST:
        return c('list');
      case Sk.ffi.PyType.TUPLE:
        return c('tuple');
      case Sk.ffi.PyType.BOOL:
        return c('bool');
      case Sk.ffi.PyType.FLOAT:
        return c('float');
      case Sk.ffi.PyType.LONG:
        return c('long');
      case Sk.ffi.PyType.INT:
        return c('int');
      case Sk.ffi.PyType.STR:
        return c('str');
      case Sk.ffi.PyType.NONE:
        return c('NoneType');
      case Sk.ffi.PyType.FUNCTION:
        return c('function');
      default:
        throw Sk.ffi.assertionError('fe2aed99-3b81-4a55-b3e8-61da7e734ac1, kind => ' + a);
      }
    }
    if (typeof a === Sk.ffi.JsType.STRING)
      return '<class \'' + String(a) + '\'>';
    if (typeof a === Sk.ffi.JsType.NUMBER)
      switch (a) {
      case Sk.ffi.PyType.DICT:
      case Sk.ffi.PyType.LIST:
      case Sk.ffi.PyType.TUPLE:
      case Sk.ffi.PyType.BOOL:
      case Sk.ffi.PyType.FLOAT:
      case Sk.ffi.PyType.LONG:
      case Sk.ffi.PyType.INT:
      case Sk.ffi.PyType.STR:
      case Sk.ffi.PyType.NONE:
      case Sk.ffi.PyType.FUNCTION:
        return d(a);
      case Sk.ffi.PyType.INSTANCE:
        return '<class \'' + String(b) + '\'>';
      default:
        throw Sk.ffi.assertionError('b15da19c-b080-4695-a157-cfcb740b265b, kind => ' + a);
      }
    else {
      if ('[object Array]' === Object.prototype.toString.call(a))
        return a.map(function (a) {
          return Sk.ffi.typeString(a);
        }).join(' or ');
      throw Sk.ffi.assertionError('c32e2f75-a391-49aa-b567-b376955b4b4c, typeof kind => ' + typeof a);
    }
  };
  goog.exportSymbol('Sk.ffi.typeString', Sk.ffi.typeString);
  Sk.ffi.getType = function (a) {
    if (typeof a === Sk.ffi.JsType.UNDEFINED)
      return Sk.ffi.PyType.UNDEFINED;
    if (a instanceof Sk.builtin.dict)
      return Sk.ffi.PyType.DICT;
    if (a instanceof Sk.builtin.list)
      return Sk.ffi.PyType.LIST;
    if (a instanceof Sk.builtin.tuple)
      return Sk.ffi.PyType.TUPLE;
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return Sk.ffi.PyType.FLOAT;
      if (a.skType === Sk.builtin.nmber.int$)
        return Sk.ffi.PyType.INT;
      throw Sk.ffi.assertionError('typeofPy(' + a + ') (Sk.builtin.nmber) skType=' + a.skType);
    }
    if (a instanceof Sk.builtin.lng)
      return Sk.ffi.PyType.LONG;
    if (a === Sk.builtin.bool.true$ || a === Sk.builtin.bool.false$)
      return Sk.ffi.PyType.BOOL;
    if (a === Sk.ffi.none.None)
      return Sk.ffi.PyType.NONE;
    var b = typeof a.v;
    if (b !== Sk.ffi.JsType.UNDEFINED) {
      if (b === Sk.ffi.JsType.STRING)
        return Sk.ffi.PyType.STR;
      if (b === Sk.ffi.JsType.OBJECT) {
        if (a.tp$name)
          return Sk.ffi.PyType.INSTANCE;
        throw Sk.ffi.assertionError('0a459acc-9540-466b-ba1a-333f8215b61e');
      }
      if (b === Sk.ffi.JsType.FUNCTION)
        return Sk.ffi.PyType.FUNREF;
      throw Sk.ffi.assertionError('bb971bb0-3751-49bb-ac24-8dab8a4bcd29 (x:\'' + b + '\')');
    }
    return Sk.ffi.PyType.FUNCTION;
  };
  goog.exportSymbol('Sk.ffi.getType', Sk.ffi.getType);
  Sk.ffi.typeName = function (a) {
    switch (Sk.ffi.getType(a)) {
    case Sk.ffi.PyType.INSTANCE:
    case Sk.ffi.PyType.BOOL:
    case Sk.ffi.PyType.FLOAT:
    case Sk.ffi.PyType.INT:
    case Sk.ffi.PyType.STR:
      return Sk.abstr.typeName(a);
    default:
      throw Sk.ffi.assertionError('0d35490f-ac78-45d7-ac5e-af6ef09278b1, Sk.ffi.getType(valuePy) => ' + Sk.ffi.getType(a));
    }
  };
  goog.exportSymbol('Sk.ffi.typeName', Sk.ffi.typeName);
  Sk.ffi.booleanToJs = function (a, b) {
    if (a === Sk.builtin.bool.true$)
      return !0;
    if (a === Sk.builtin.bool.false$)
      return !1;
    if (typeof b === Sk.ffi.JsType.STRING)
      throw Sk.ffi.typeError(String(b));
    throw Sk.ffi.err.attribute('value').mustHaveType(Sk.ffi.PyType.BOOL);
  };
  goog.exportSymbol('Sk.ffi.booleanToJs', Sk.ffi.booleanToJs);
  Sk.ffi.numberToJs = function (a, b) {
    if (a instanceof Sk.builtin.nmber)
      return Sk.builtin.asnum$(a);
    if (typeof b === Sk.ffi.JsType.STRING)
      throw Sk.ffi.typeError(String(b));
    throw Sk.ffi.err.attribute('value').mustHaveType([
      Sk.ffi.PyType.FLOAT,
      Sk.ffi.PyType.INT,
      Sk.ffi.PyType.LONG
    ]);
  };
  goog.exportSymbol('Sk.ffi.numberToJs', Sk.ffi.numberToJs);
  Sk.ffi.remapToJs = function (a, b) {
    Sk.ffi.checkFunctionArgs('Sk.ffi.remapToJs', arguments, 1, 2);
    switch (Sk.ffi.getType(a)) {
    case Sk.ffi.PyType.STR:
      return a.v;
    case Sk.ffi.PyType.DICT:
      for (var c = {}, d = a.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext()) {
        var f = a.mp$subscript(e);
        void 0 === f && (f = null);
        e = Sk.ffi.remapToJs(e);
        c[e] = Sk.ffi.remapToJs(f);
      }
      return c;
    case Sk.ffi.PyType.LIST:
      c = [];
      for (d = 0; d < a.v.length; ++d)
        c.push(Sk.ffi.remapToJs(a.v[d]));
      return c;
    case Sk.ffi.PyType.TUPLE:
      c = [];
      for (d = 0; d < a.v.length; ++d)
        c.push(Sk.ffi.remapToJs(a.v[d]));
      return c;
    case Sk.ffi.PyType.BOOL:
      if (a === Sk.builtin.bool.true$)
        return !0;
      if (a === Sk.builtin.bool.false$)
        return !1;
      throw Sk.ffi.assertionError('5fd1f529-f9b2-4d0c-9775-36e782973986');
    case Sk.ffi.PyType.FLOAT:
    case Sk.ffi.PyType.INT:
    case Sk.ffi.PyType.LONG:
      return Sk.builtin.asnum$(a);
    case Sk.ffi.PyType.INSTANCE:
      return a.v;
    case Sk.ffi.PyType.FUNREF:
      return a.v;
    case Sk.ffi.PyType.UNDEFINED:
      return b;
    case Sk.ffi.PyType.NONE:
      return null;
    case Sk.ffi.PyType.FUNCTION:
      return function () {
        var b = Array.prototype.slice.call(arguments, 0).map(function (a) {
            return Sk.ffi.remapToPy(a);
          });
        return Sk.ffi.remapToJs(Sk.misceval.apply(a, void 0, void 0, void 0, b));
      };
    default:
      throw Sk.ffi.assertionError('20be4da2-63e8-4fff-9359-7ab46eba4702 ' + Sk.ffi.getType(a));
    }
  };
  goog.exportSymbol('Sk.ffi.remapToJs', Sk.ffi.remapToJs);
  Sk.ffi.buildClass = function (a, b, c, d) {
    return Sk.misceval.buildClass(a, b, c, d);
  };
  goog.exportSymbol('Sk.ffi.buildClass', Sk.ffi.buildClass);
  Sk.ffi.callsim = function (a, b) {
    b = Array.prototype.slice.call(arguments, 1);
    return Sk.misceval.apply(a, void 0, void 0, void 0, b);
  };
  goog.exportSymbol('Sk.ffi.callsim', Sk.ffi.callsim);
  Sk.ffi.callableToPy = function (a, b, c) {
    return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, e) {
      e.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(null, b, null, a);
      });
      e.__call__ = Sk.ffi.functionPy(c);
      e.__str__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy(b);
      });
      e.__repr__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy(b);
      });
    }, b, []));
  };
  goog.exportSymbol('Sk.ffi.callableToPy', Sk.ffi.callableToPy);
  Sk.ffi.gattr = function (a, b) {
    return Sk.abstr.gattr(a, b);
  };
  goog.exportSymbol('Sk.ffi.gattr', Sk.ffi.gattr);
  Sk.ffi.indexError = function (a) {
    return new Sk.builtin.IndexError(a);
  };
  goog.exportSymbol('Sk.ffi.indexError', Sk.ffi.indexError);
  Sk.ffi.valueError = function (a) {
    return new Sk.builtin.ValueError(a);
  };
  goog.exportSymbol('Sk.ffi.valueError', Sk.ffi.valueError);
  Sk.ffi.err = {
    attribute: function (a) {
      return {
        isNotGetableOnType: function (b) {
          return Sk.ffi.attributeError(a + ' is not an attribute of ' + Sk.ffi.typeString(b));
        },
        isNotSetableOnType: function (b) {
          return Sk.ffi.attributeError(a + ' is not an attribute of ' + Sk.ffi.typeString(b));
        }
      };
    },
    argument: function (a) {
      return {
        inFunction: function (b) {
          return {
            mustHaveType: function (c) {
              return Sk.ffi.typeError('Expecting argument \'' + a + '\' in function \'' + b + '\' to have type ' + Sk.ffi.typeString(c) + '.');
            }
          };
        },
        mustHaveType: function (b) {
          return Sk.ffi.typeError(a + ' must be a ' + Sk.ffi.typeString(b));
        }
      };
    },
    operand: function (a) {
      return {
        toOperation: function (b) {
          return {
            mustHaveType: function (c) {
              return Sk.ffi.typeError('Expecting operand \'' + a + '\' to operation \'' + b + '\' to have type ' + Sk.ffi.typeString(c) + '.');
            }
          };
        }
      };
    }
  };
  goog.exportSymbol('Sk.ffi.err', Sk.ffi.err);
  Sk.ffi.callback = function (a) {
    return Sk.ffi.remapToJs(a);
  };
  goog.exportSymbol('Sk.ffi.callback', Sk.ffi.callback);
  Sk.ffi.stdwrap = function (a, b) {
    var c = new a();
    c.v = b;
    return c;
  };
  goog.exportSymbol('Sk.ffi.stdwrap', Sk.ffi.stdwrap);
  Sk.ffi.basicwrap = function (a) {
    return Sk.ffi.remapToPy(a);
  };
  goog.exportSymbol('Sk.ffi.basicwrap', Sk.ffi.basicwrap);
  Sk.ffi.unwrapo = function (a) {
    return Sk.ffi.remapToJs(a);
  };
  goog.exportSymbol('Sk.ffi.unwrapo', Sk.ffi.unwrapo);
  Sk.ffi.unwrapn = function (a) {
    return Sk.ffi.remapToJs(a);
  };
  goog.exportSymbol('Sk.ffi.unwrapn', Sk.ffi.unwrapn);
  Sk.ffh = Sk.ffh || {};
  var SPECIAL_METHOD_ADD = '__add__', SPECIAL_METHOD_CLIFFORD_CONJUGATE = '__cliffordConjugate__', SPECIAL_METHOD_DIV = '__div__', SPECIAL_METHOD_EQ = '__eq__', SPECIAL_METHOD_EXP = '__exp__', SPECIAL_METHOD_INVERT = '__invert__', SPECIAL_METHOD_LSHIFT = '__lshift__', SPECIAL_METHOD_MUL = '__mul__', SPECIAL_METHOD_NEG = '__neg__', SPECIAL_METHOD_NONZERO = '__nonzero__', SPECIAL_METHOD_POS = '__pos__', SPECIAL_METHOD_REPR = '__repr__', SPECIAL_METHOD_RSHIFT = '__rshift__', SPECIAL_METHOD_SQRT = '__sqrt__', SPECIAL_METHOD_STR = '__str__', SPECIAL_METHOD_SUB = '__sub__', SPECIAL_METHOD_XOR = '__xor__';
  Sk.ffh.unaryExec = function (a, b, c) {
    if (b[a])
      return Sk.ffi.callsim(b[a], b);
    if ('undefined' !== typeof c && b[c])
      return b[c].call(b);
    throw Sk.ffi.notImplementedError(a);
  };
  goog.exportSymbol('Sk.ffh.unaryExec', Sk.ffh.unaryExec);
  Sk.ffh.binaryExec = function (a, b, c, d) {
    if (b[a])
      return Sk.ffi.callsim(b[a], b, c);
    if ('undefined' !== typeof d && b[d])
      return b[d].call(b, c);
    throw Sk.ffi.notImplementedError(a);
  };
  goog.exportSymbol('Sk.ffh.binaryExec', Sk.ffh.binaryExec);
  Sk.ffh.add = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_ADD, a, b, 'nb$add');
  };
  goog.exportSymbol('Sk.ffh.add', Sk.ffh.add);
  Sk.ffh.subtract = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_SUB, a, b, 'nb$subtract');
  };
  goog.exportSymbol('Sk.ffh.subtract', Sk.ffh.subtract);
  Sk.ffh.multiply = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_MUL, a, b, 'nb$multiply');
  };
  goog.exportSymbol('Sk.ffh.multiply', Sk.ffh.multiply);
  Sk.ffh.divide = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_DIV, a, b, 'nb$divide');
  };
  goog.exportSymbol('Sk.ffh.divide', Sk.ffh.divide);
  Sk.ffh.xor = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_XOR, a, b, 'nb$xor');
  };
  goog.exportSymbol('Sk.ffh.xor', Sk.ffh.xor);
  Sk.ffh.lshift = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_LSHIFT, a, b, 'nb$lshift');
  };
  goog.exportSymbol('Sk.ffh.lshift', Sk.ffh.lshift);
  Sk.ffh.rshift = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_RSHIFT, a, b, 'nb$rshift');
  };
  goog.exportSymbol('Sk.ffh.rshift', Sk.ffh.rshift);
  Sk.ffh.equal = function (a, b) {
    if (a[SPECIAL_METHOD_EQ])
      return Sk.ffi.callsim(a[SPECIAL_METHOD_EQ], a, b);
    throw Sk.ffi.notImplementedError('equal(' + Sk.ffh.repr(a) + ', ' + Sk.ffh.repr(b) + ')');
  };
  goog.exportSymbol('Sk.ffh.equal', Sk.ffh.equal);
  Sk.ffh.cliffordConjugate = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_CLIFFORD_CONJUGATE, a, 'nb$cliffordConjugate');
  };
  goog.exportSymbol('Sk.ffh.cliffordConjugate', Sk.ffh.cliffordConjugate);
  Sk.ffh.exp = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_EXP, a, 'nb$exp');
  };
  goog.exportSymbol('Sk.ffh.exp', Sk.ffh.exp);
  Sk.ffh.positive = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_POS, a, 'nb$positive');
  };
  goog.exportSymbol('Sk.ffh.positive', Sk.ffh.positive);
  Sk.ffh.negative = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_NEG, a, 'nb$negative');
  };
  goog.exportSymbol('Sk.ffh.negative', Sk.ffh.negative);
  Sk.ffh.invert = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_INVERT, a, 'nb$invert');
  };
  goog.exportSymbol('Sk.ffh.invert', Sk.ffh.invert);
  Sk.ffh.nonzero = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_NONZERO, a, 'nb$nonzero');
  };
  goog.exportSymbol('Sk.ffh.nonzero', Sk.ffh.nonzero);
  Sk.ffh.sqrt = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_SQRT, a);
  };
  goog.exportSymbol('Sk.ffh.sqrt', Sk.ffh.sqrt);
  Sk.ffh.str = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_STR, a, 'tp$str');
  };
  goog.exportSymbol('Sk.ffh.str', Sk.ffh.str);
  Sk.ffh.repr = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_REPR, a, 'tp$str');
  };
  goog.exportSymbol('Sk.ffh.repr', Sk.ffh.repr);
  Sk.ffh.evaluate = function (a, b) {
    return Sk.ffi.isFloat(a) || Sk.ffi.isInt(a) || Sk.ffi.isLong(a) ? a : Sk.ffi.callsim(Sk.ffi.gattr(a, 'evaluate'), b);
  };
  goog.exportSymbol('Sk.ffh.evaluate', Sk.ffh.evaluate);
  Sk.builtin.enumerate = function (a, b) {
    if (!(this instanceof Sk.builtin.enumerate))
      return new Sk.builtin.enumerate(a, b);
    Sk.builtin.pyCheckArgs('enumerate', arguments, 1, 2);
    if (!Sk.builtin.checkIterable(a))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not iterable');
    if (void 0 !== b)
      if (Sk.misceval.isIndex(b))
        b = Sk.misceval.asIndex(b);
      else
        throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object cannot be interpreted as an index');
    else
      b = 0;
    var c = a.tp$iter();
    this.tp$iter = function () {
      return this;
    };
    this.$index = b;
    this.tp$iternext = function () {
      var a = c.tp$iternext();
      return void 0 === a ? void 0 : new Sk.builtin.tuple([
        this.$index++,
        a
      ]);
    };
    this.__class__ = Sk.builtin.enumerate;
    return this;
  };
  Sk.builtin.enumerate.prototype.tp$name = 'enumerate';
  Sk.builtin.enumerate.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('enumerate', Sk.builtin.enumerate);
  Sk.builtin.enumerate.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.enumerate.prototype.__iter__ = new Sk.builtin.func(function (a) {
    return a.tp$iter();
  });
  Sk.builtin.enumerate.prototype.next = new Sk.builtin.func(function (a) {
    return a.tp$iternext();
  });
  Sk.Tokenizer = function (a, b, c) {
    this.filename = a;
    this.callback = c;
    this.parenlev = this.lnum = 0;
    this.continued = !1;
    this.namechars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
    this.numchars = '0123456789';
    this.contstr = '';
    this.needcont = !1;
    this.contline = void 0;
    this.indents = [0];
    this.endprog = /.*/;
    this.strstart = [
      -1,
      -1
    ];
    this.interactive = b;
    this.doneFunc = function () {
      for (var a = 1; a < this.indents.length; ++a)
        if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
            this.lnum,
            0
          ], [
            this.lnum,
            0
          ], ''))
          return 'done';
      return this.callback(Sk.Tokenizer.Tokens.T_ENDMARKER, '', [
        this.lnum,
        0
      ], [
        this.lnum,
        0
      ], '') ? 'done' : 'failed';
    };
  };
  Sk.Tokenizer.Tokens = {
    T_ENDMARKER: 0,
    T_NAME: 1,
    T_NUMBER: 2,
    T_STRING: 3,
    T_NEWLINE: 4,
    T_INDENT: 5,
    T_DEDENT: 6,
    T_LPAR: 7,
    T_RPAR: 8,
    T_LSQB: 9,
    T_RSQB: 10,
    T_COLON: 11,
    T_COMMA: 12,
    T_SEMI: 13,
    T_PLUS: 14,
    T_MINUS: 15,
    T_STAR: 16,
    T_SLASH: 17,
    T_VBAR: 18,
    T_AMPER: 19,
    T_LESS: 20,
    T_GREATER: 21,
    T_EQUAL: 22,
    T_DOT: 23,
    T_PERCENT: 24,
    T_BACKQUOTE: 25,
    T_LBRACE: 26,
    T_RBRACE: 27,
    T_EQEQUAL: 28,
    T_NOTEQUAL: 29,
    T_LESSEQUAL: 30,
    T_GREATEREQUAL: 31,
    T_TILDE: 32,
    T_CIRCUMFLEX: 33,
    T_LEFTSHIFT: 34,
    T_RIGHTSHIFT: 35,
    T_DOUBLESTAR: 36,
    T_PLUSEQUAL: 37,
    T_MINEQUAL: 38,
    T_STAREQUAL: 39,
    T_SLASHEQUAL: 40,
    T_PERCENTEQUAL: 41,
    T_AMPEREQUAL: 42,
    T_VBAREQUAL: 43,
    T_CIRCUMFLEXEQUAL: 44,
    T_LEFTSHIFTEQUAL: 45,
    T_RIGHTSHIFTEQUAL: 46,
    T_DOUBLESTAREQUAL: 47,
    T_DOUBLESLASH: 48,
    T_DOUBLESLASHEQUAL: 49,
    T_AT: 50,
    T_OP: 51,
    T_COMMENT: 52,
    T_NL: 53,
    T_RARROW: 54,
    T_ERRORTOKEN: 55,
    T_N_TOKENS: 56,
    T_NT_OFFSET: 256
  };
  function group(a) {
    return '(' + Array.prototype.slice.call(arguments).join('|') + ')';
  }
  function any(a) {
    return group.apply(null, arguments) + '*';
  }
  function maybe(a) {
    return group.apply(null, arguments) + '?';
  }
  var Whitespace = '[ \\f\\t]*', Comment_ = '#[^\\r\\n]*', Ident = '[a-zA-Z_]\\w*', Binnumber = '0[bB][01]*', Hexnumber = '0[xX][\\da-fA-F]*[lL]?', Octnumber = '0[oO]?[0-7]*[lL]?', Decnumber = '[1-9]\\d*[lL]?', Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber), Exponent = '[eE][-+]?\\d+', Pointfloat = group('\\d+\\.\\d*', '\\.\\d+') + maybe(Exponent), Expfloat = '\\d+' + Exponent, Floatnumber = group(Pointfloat, Expfloat), Imagnumber = group('\\d+[jJ]', Floatnumber + '[jJ]'), Number_ = group(Imagnumber, Floatnumber, Intnumber), Single = '^[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'', Double_ = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"', Single3 = '[^\'\\\\]*(?:(?:\\\\.|\'(?!\'\'))[^\'\\\\]*)*\'\'\'', Double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""', Triple = group('[ubUB]?[rR]?\'\'\'', '[ubUB]?[rR]?"""'), String_ = group('[uU]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*\'', '[uU]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"'), Operator = group('\\*\\*=?', '>>=?', '<<=?', '<>', '!=', '//=?', '->', '[+\\-*/%&|^=<>]=?', '~'), Bracket = '[\\][(){}]', Special = group('\\r?\\n', '[:;.,`@]'), Funny = group(Operator, Bracket, Special), ContStr = group('[uUbB]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*' + group('\'', '\\\\\\r?\\n'), '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' + group('"', '\\\\\\r?\\n')), PseudoExtras = group('\\\\\\r?\\n', Comment_, Triple), PseudoToken = '^' + group(PseudoExtras, Number_, Funny, ContStr, Ident), pseudoprog, single3prog, double3prog, endprogs = {}, triple_quoted = {
      '\'\'\'': !0,
      '"""': !0,
      'r\'\'\'': !0,
      'r"""': !0,
      'R\'\'\'': !0,
      'R"""': !0,
      'u\'\'\'': !0,
      'u"""': !0,
      'U\'\'\'': !0,
      'U"""': !0,
      'b\'\'\'': !0,
      'b"""': !0,
      'B\'\'\'': !0,
      'B"""': !0,
      'ur\'\'\'': !0,
      'ur"""': !0,
      'Ur\'\'\'': !0,
      'Ur"""': !0,
      'uR\'\'\'': !0,
      'uR"""': !0,
      'UR\'\'\'': !0,
      'UR"""': !0,
      'br\'\'\'': !0,
      'br"""': !0,
      'Br\'\'\'': !0,
      'Br"""': !0,
      'bR\'\'\'': !0,
      'bR"""': !0,
      'BR\'\'\'': !0,
      'BR"""': !0
    }, single_quoted = {
      '\'': !0,
      '"': !0,
      'r\'': !0,
      'r"': !0,
      'R\'': !0,
      'R"': !0,
      'u\'': !0,
      'u"': !0,
      'U\'': !0,
      'U"': !0,
      'b\'': !0,
      'b"': !0,
      'B\'': !0,
      'B"': !0,
      'ur\'': !0,
      'ur"': !0,
      'Ur\'': !0,
      'Ur"': !0,
      'uR\'': !0,
      'uR"': !0,
      'UR\'': !0,
      'UR"': !0,
      'br\'': !0,
      'br"': !0,
      'Br\'': !0,
      'Br"': !0,
      'bR\'': !0,
      'bR"': !0,
      'BR\'': !0,
      'BR"': !0
    };
  (function () {
    for (var a in triple_quoted);
    for (a in single_quoted);
  }());
  var tabsize = 8;
  function contains(a, b) {
    for (var c = a.length; c--;)
      if (a[c] === b)
        return !0;
    return !1;
  }
  function rstrip(a, b) {
    for (var c = a.length; 0 < c && -1 !== b.indexOf(a.charAt(c - 1)); --c);
    return a.substring(0, c);
  }
  Sk.Tokenizer.prototype.generateTokens = function (a) {
    var b, c, d, e, f, g = RegExp(PseudoToken);
    c = RegExp(Single3, 'g');
    f = RegExp(Double3, 'g');
    var h = {
        '\'': RegExp(Single, 'g'),
        '"': RegExp(Double_, 'g'),
        '\'\'\'': c,
        '"""': f,
        'r\'\'\'': c,
        'r"""': f,
        'u\'\'\'': c,
        'u"""': f,
        'b\'\'\'': c,
        'b"""': f,
        'ur\'\'\'': c,
        'ur"""': f,
        'br\'\'\'': c,
        'br"""': f,
        'R\'\'\'': c,
        'R"""': f,
        'U\'\'\'': c,
        'U"""': f,
        'B\'\'\'': c,
        'B"""': f,
        'uR\'\'\'': c,
        'uR"""': f,
        'Ur\'\'\'': c,
        'Ur"""': f,
        'UR\'\'\'': c,
        'UR"""': f,
        'bR\'\'\'': c,
        'bR"""': f,
        'Br\'\'\'': c,
        'Br"""': f,
        'BR\'\'\'': c,
        'BR"""': f,
        r: null,
        R: null,
        u: null,
        U: null,
        b: null,
        B: null
      };
    a || (a = '');
    this.lnum += 1;
    c = 0;
    f = a.length;
    if (0 < this.contstr.length) {
      if (!a)
        throw new Sk.builtin.TokenError('EOF in multi-line string', this.filename, this.strstart[0], this.strstart[1], this.contline);
      this.endprog.lastIndex = 0;
      if (b = this.endprog.test(a)) {
        c = e = this.endprog.lastIndex;
        if (this.callback(Sk.Tokenizer.Tokens.T_STRING, this.contstr + a.substring(0, e), this.strstart, [
            this.lnum,
            e
          ], this.contline + a))
          return 'done';
        this.contstr = '';
        this.needcont = !1;
        this.contline = void 0;
      } else {
        if (this.needcont && '\\\n' !== a.substring(a.length - 2) && '\\\r\n' !== a.substring(a.length - 3)) {
          if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, this.contstr + a, this.strstart, [
              this.lnum,
              a.length
            ], this.contline))
            return 'done';
          this.contstr = '';
          this.contline = void 0;
        } else
          this.contstr += a, this.contline += a;
        return !1;
      }
    } else if (0 !== this.parenlev || this.continued) {
      if (!a)
        throw new Sk.builtin.TokenError('EOF in multi-line statement', this.filename, this.lnum, 0, a);
      this.continued = !1;
    } else {
      if (!a)
        return this.doneFunc();
      for (d = 0; c < f;) {
        if (' ' === a.charAt(c))
          d += 1;
        else if ('\t' === a.charAt(c))
          d = (d / tabsize + 1) * tabsize;
        else if ('\f' === a.charAt(c))
          d = 0;
        else
          break;
        c += 1;
      }
      if (c === f)
        return this.doneFunc();
      if (-1 !== '#\r\n'.indexOf(a.charAt(c))) {
        if ('#' === a.charAt(c))
          return g = rstrip(a.substring(c), '\r\n'), f = c + g.length, this.callback(Sk.Tokenizer.Tokens.T_COMMENT, g, [
            this.lnum,
            c
          ], [
            this.lnum,
            c + g.length
          ], a) || this.callback(Sk.Tokenizer.Tokens.T_NL, a.substring(f), [
            this.lnum,
            f
          ], [
            this.lnum,
            a.length
          ], a) ? 'done' : !1;
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, a.substring(c), [
            this.lnum,
            c
          ], [
            this.lnum,
            a.length
          ], a))
          return 'done';
        if (!this.interactive)
          return !1;
      }
      if (d > this.indents[this.indents.length - 1] && (this.indents.push(d), this.callback(Sk.Tokenizer.Tokens.T_INDENT, a.substring(0, c), [
          this.lnum,
          0
        ], [
          this.lnum,
          c
        ], a)))
        return 'done';
      for (; d < this.indents[this.indents.length - 1];) {
        if (!contains(this.indents, d))
          throw new Sk.builtin.IndentationError('unindent does not match any outer indentation level', this.filename, this.lnum, c, a);
        this.indents.splice(this.indents.length - 1, 1);
        if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
            this.lnum,
            c
          ], [
            this.lnum,
            c
          ], a))
          return 'done';
      }
    }
    for (; c < f;) {
      for (d = a.charAt(c); ' ' === d || '\f' === d || '\t' === d;)
        c += 1, d = a.charAt(c);
      g.lastIndex = 0;
      var k = g.exec(a.substring(c));
      if (k) {
        d = c;
        e = d + k[1].length;
        k = [
          this.lnum,
          d
        ];
        b = [
          this.lnum,
          e
        ];
        c = e;
        e = a.substring(d, e);
        var l = a.charAt(d);
        if (-1 !== this.numchars.indexOf(l) || '.' === l && '.' !== e) {
          if (this.callback(Sk.Tokenizer.Tokens.T_NUMBER, e, k, b, a))
            return 'done';
        } else if ('\r' === l || '\n' === l) {
          if (d = Sk.Tokenizer.Tokens.T_NEWLINE, 0 < this.parenlev && (d = Sk.Tokenizer.Tokens.T_NL), this.callback(d, e, k, b, a))
            return 'done';
        } else if ('#' === l) {
          if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, e, k, b, a))
            return 'done';
        } else if (triple_quoted.hasOwnProperty(e))
          if (this.endprog = h[e], this.endprog.lastIndex = 0, b = this.endprog.test(a.substring(c))) {
            if (c = this.endprog.lastIndex + c, e = a.substring(d, c), this.callback(Sk.Tokenizer.Tokens.T_STRING, e, k, [
                this.lnum,
                c
              ], a))
              return 'done';
          } else {
            this.strstart = [
              this.lnum,
              d
            ];
            this.contstr = a.substring(d);
            this.contline = a;
            break;
          }
        else if (single_quoted.hasOwnProperty(l) || single_quoted.hasOwnProperty(e.substring(0, 2)) || single_quoted.hasOwnProperty(e.substring(0, 3)))
          if ('\n' === e[e.length - 1]) {
            this.strstart = [
              this.lnum,
              d
            ];
            this.endprog = h[l] || h[e[1]] || h[e[2]];
            this.contstr = a.substring(d);
            this.needcont = !0;
            this.contline = a;
            break;
          } else {
            if (this.callback(Sk.Tokenizer.Tokens.T_STRING, e, k, b, a))
              return 'done';
          }
        else if (-1 !== this.namechars.indexOf(l)) {
          if (this.callback(Sk.Tokenizer.Tokens.T_NAME, e, k, b, a))
            return 'done';
        } else if ('\\' === l) {
          if (this.callback(Sk.Tokenizer.Tokens.T_NL, e, k, [
              this.lnum,
              c
            ], a))
            return 'done';
          this.continued = !0;
        } else if (-1 !== '([{'.indexOf(l) ? this.parenlev += 1 : -1 !== ')]}'.indexOf(l) && (this.parenlev -= 1), this.callback(Sk.Tokenizer.Tokens.T_OP, e, k, b, a))
          return 'done';
      } else {
        if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, a.charAt(c), [
            this.lnum,
            c
          ], [
            this.lnum,
            c + 1
          ], a))
          return 'done';
        c += 1;
      }
    }
    return !1;
  };
  Sk.Tokenizer.tokenNames = {
    0: 'T_ENDMARKER',
    1: 'T_NAME',
    2: 'T_NUMBER',
    3: 'T_STRING',
    4: 'T_NEWLINE',
    5: 'T_INDENT',
    6: 'T_DEDENT',
    7: 'T_LPAR',
    8: 'T_RPAR',
    9: 'T_LSQB',
    10: 'T_RSQB',
    11: 'T_COLON',
    12: 'T_COMMA',
    13: 'T_SEMI',
    14: 'T_PLUS',
    15: 'T_MINUS',
    16: 'T_STAR',
    17: 'T_SLASH',
    18: 'T_VBAR',
    19: 'T_AMPER',
    20: 'T_LESS',
    21: 'T_GREATER',
    22: 'T_EQUAL',
    23: 'T_DOT',
    24: 'T_PERCENT',
    25: 'T_BACKQUOTE',
    26: 'T_LBRACE',
    27: 'T_RBRACE',
    28: 'T_EQEQUAL',
    29: 'T_NOTEQUAL',
    30: 'T_LESSEQUAL',
    31: 'T_GREATEREQUAL',
    32: 'T_TILDE',
    33: 'T_CIRCUMFLEX',
    34: 'T_LEFTSHIFT',
    35: 'T_RIGHTSHIFT',
    36: 'T_DOUBLESTAR',
    37: 'T_PLUSEQUAL',
    38: 'T_MINEQUAL',
    39: 'T_STAREQUAL',
    40: 'T_SLASHEQUAL',
    41: 'T_PERCENTEQUAL',
    42: 'T_AMPEREQUAL',
    43: 'T_VBAREQUAL',
    44: 'T_CIRCUMFLEXEQUAL',
    45: 'T_LEFTSHIFTEQUAL',
    46: 'T_RIGHTSHIFTEQUAL',
    47: 'T_DOUBLESTAREQUAL',
    48: 'T_DOUBLESLASH',
    49: 'T_DOUBLESLASHEQUAL',
    50: 'T_AT',
    51: 'T_OP',
    52: 'T_COMMENT',
    53: 'T_NL',
    54: 'T_RARROW',
    55: 'T_ERRORTOKEN',
    56: 'T_N_TOKENS',
    256: 'T_NT_OFFSET'
  };
  goog.exportSymbol('Sk.Tokenizer', Sk.Tokenizer);
  goog.exportSymbol('Sk.Tokenizer.prototype.generateTokens', Sk.Tokenizer.prototype.generateTokens);
  goog.exportSymbol('Sk.Tokenizer.tokenNames', Sk.Tokenizer.tokenNames);
  Sk.OpMap = {
    '(': Sk.Tokenizer.Tokens.T_LPAR,
    ')': Sk.Tokenizer.Tokens.T_RPAR,
    '[': Sk.Tokenizer.Tokens.T_LSQB,
    ']': Sk.Tokenizer.Tokens.T_RSQB,
    ':': Sk.Tokenizer.Tokens.T_COLON,
    ',': Sk.Tokenizer.Tokens.T_COMMA,
    ';': Sk.Tokenizer.Tokens.T_SEMI,
    '+': Sk.Tokenizer.Tokens.T_PLUS,
    '-': Sk.Tokenizer.Tokens.T_MINUS,
    '*': Sk.Tokenizer.Tokens.T_STAR,
    '/': Sk.Tokenizer.Tokens.T_SLASH,
    '|': Sk.Tokenizer.Tokens.T_VBAR,
    '&': Sk.Tokenizer.Tokens.T_AMPER,
    '<': Sk.Tokenizer.Tokens.T_LESS,
    '>': Sk.Tokenizer.Tokens.T_GREATER,
    '=': Sk.Tokenizer.Tokens.T_EQUAL,
    '.': Sk.Tokenizer.Tokens.T_DOT,
    '%': Sk.Tokenizer.Tokens.T_PERCENT,
    '`': Sk.Tokenizer.Tokens.T_BACKQUOTE,
    '{': Sk.Tokenizer.Tokens.T_LBRACE,
    '}': Sk.Tokenizer.Tokens.T_RBRACE,
    '@': Sk.Tokenizer.Tokens.T_AT,
    '==': Sk.Tokenizer.Tokens.T_EQEQUAL,
    '!=': Sk.Tokenizer.Tokens.T_NOTEQUAL,
    '<>': Sk.Tokenizer.Tokens.T_NOTEQUAL,
    '<=': Sk.Tokenizer.Tokens.T_LESSEQUAL,
    '>=': Sk.Tokenizer.Tokens.T_GREATEREQUAL,
    '~': Sk.Tokenizer.Tokens.T_TILDE,
    '^': Sk.Tokenizer.Tokens.T_CIRCUMFLEX,
    '<<': Sk.Tokenizer.Tokens.T_LEFTSHIFT,
    '>>': Sk.Tokenizer.Tokens.T_RIGHTSHIFT,
    '**': Sk.Tokenizer.Tokens.T_DOUBLESTAR,
    '+=': Sk.Tokenizer.Tokens.T_PLUSEQUAL,
    '-=': Sk.Tokenizer.Tokens.T_MINEQUAL,
    '*=': Sk.Tokenizer.Tokens.T_STAREQUAL,
    '/=': Sk.Tokenizer.Tokens.T_SLASHEQUAL,
    '%=': Sk.Tokenizer.Tokens.T_PERCENTEQUAL,
    '&=': Sk.Tokenizer.Tokens.T_AMPEREQUAL,
    '|=': Sk.Tokenizer.Tokens.T_VBAREQUAL,
    '^=': Sk.Tokenizer.Tokens.T_CIRCUMFLEXEQUAL,
    '<<=': Sk.Tokenizer.Tokens.T_LEFTSHIFTEQUAL,
    '>>=': Sk.Tokenizer.Tokens.T_RIGHTSHIFTEQUAL,
    '**=': Sk.Tokenizer.Tokens.T_DOUBLESTAREQUAL,
    '//': Sk.Tokenizer.Tokens.T_DOUBLESLASH,
    '//=': Sk.Tokenizer.Tokens.T_DOUBLESLASHEQUAL,
    '->': Sk.Tokenizer.Tokens.T_RARROW
  };
  Sk.ParseTables = {
    sym: {
      and_expr: 257,
      and_test: 258,
      arglist: 259,
      argument: 260,
      arith_expr: 261,
      assert_stmt: 262,
      atom: 263,
      augassign: 264,
      break_stmt: 265,
      classdef: 266,
      comp_op: 267,
      comparison: 268,
      compound_stmt: 269,
      continue_stmt: 270,
      decorated: 271,
      decorator: 272,
      decorators: 273,
      del_stmt: 274,
      dictmaker: 275,
      dotted_as_name: 276,
      dotted_as_names: 277,
      dotted_name: 278,
      encoding_decl: 279,
      eval_input: 280,
      except_clause: 281,
      exec_stmt: 282,
      expr: 283,
      expr_stmt: 284,
      exprlist: 285,
      factor: 286,
      file_input: 287,
      flow_stmt: 288,
      for_stmt: 289,
      fpdef: 290,
      fplist: 291,
      funcdef: 292,
      gen_for: 293,
      gen_if: 294,
      gen_iter: 295,
      global_stmt: 296,
      if_stmt: 297,
      import_as_name: 298,
      import_as_names: 299,
      import_from: 300,
      import_name: 301,
      import_stmt: 302,
      lambdef: 303,
      list_for: 304,
      list_if: 305,
      list_iter: 306,
      listmaker: 307,
      not_test: 308,
      old_lambdef: 309,
      old_test: 310,
      or_test: 311,
      parameters: 312,
      pass_stmt: 313,
      power: 314,
      print_stmt: 315,
      raise_stmt: 316,
      return_stmt: 317,
      shift_expr: 318,
      simple_stmt: 319,
      single_input: 256,
      sliceop: 320,
      small_stmt: 321,
      stmt: 322,
      subscript: 323,
      subscriptlist: 324,
      suite: 325,
      term: 326,
      test: 327,
      testlist: 328,
      testlist1: 329,
      testlist_gexp: 330,
      testlist_safe: 331,
      trailer: 332,
      try_stmt: 333,
      varargslist: 334,
      while_stmt: 335,
      with_stmt: 336,
      with_var: 337,
      xor_expr: 338,
      yield_expr: 339,
      yield_stmt: 340
    },
    number2symbol: {
      256: 'single_input',
      257: 'and_expr',
      258: 'and_test',
      259: 'arglist',
      260: 'argument',
      261: 'arith_expr',
      262: 'assert_stmt',
      263: 'atom',
      264: 'augassign',
      265: 'break_stmt',
      266: 'classdef',
      267: 'comp_op',
      268: 'comparison',
      269: 'compound_stmt',
      270: 'continue_stmt',
      271: 'decorated',
      272: 'decorator',
      273: 'decorators',
      274: 'del_stmt',
      275: 'dictmaker',
      276: 'dotted_as_name',
      277: 'dotted_as_names',
      278: 'dotted_name',
      279: 'encoding_decl',
      280: 'eval_input',
      281: 'except_clause',
      282: 'exec_stmt',
      283: 'expr',
      284: 'expr_stmt',
      285: 'exprlist',
      286: 'factor',
      287: 'file_input',
      288: 'flow_stmt',
      289: 'for_stmt',
      290: 'fpdef',
      291: 'fplist',
      292: 'funcdef',
      293: 'gen_for',
      294: 'gen_if',
      295: 'gen_iter',
      296: 'global_stmt',
      297: 'if_stmt',
      298: 'import_as_name',
      299: 'import_as_names',
      300: 'import_from',
      301: 'import_name',
      302: 'import_stmt',
      303: 'lambdef',
      304: 'list_for',
      305: 'list_if',
      306: 'list_iter',
      307: 'listmaker',
      308: 'not_test',
      309: 'old_lambdef',
      310: 'old_test',
      311: 'or_test',
      312: 'parameters',
      313: 'pass_stmt',
      314: 'power',
      315: 'print_stmt',
      316: 'raise_stmt',
      317: 'return_stmt',
      318: 'shift_expr',
      319: 'simple_stmt',
      320: 'sliceop',
      321: 'small_stmt',
      322: 'stmt',
      323: 'subscript',
      324: 'subscriptlist',
      325: 'suite',
      326: 'term',
      327: 'test',
      328: 'testlist',
      329: 'testlist1',
      330: 'testlist_gexp',
      331: 'testlist_safe',
      332: 'trailer',
      333: 'try_stmt',
      334: 'varargslist',
      335: 'while_stmt',
      336: 'with_stmt',
      337: 'with_var',
      338: 'xor_expr',
      339: 'yield_expr',
      340: 'yield_stmt'
    },
    dfas: {
      256: [
        [
          [
            [
              1,
              1
            ],
            [
              2,
              1
            ],
            [
              3,
              2
            ]
          ],
          [[
              0,
              1
            ]],
          [[
              2,
              1
            ]]
        ],
        {
          2: 1,
          4: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          10: 1,
          11: 1,
          12: 1,
          13: 1,
          14: 1,
          15: 1,
          16: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          27: 1,
          28: 1,
          29: 1,
          30: 1,
          31: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1
        }
      ],
      257: [
        [
          [[
              37,
              1
            ]],
          [
            [
              38,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      258: [
        [
          [[
              39,
              1
            ]],
          [
            [
              40,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      259: [
        [
          [
            [
              41,
              1
            ],
            [
              42,
              2
            ],
            [
              43,
              3
            ]
          ],
          [[
              44,
              4
            ]],
          [
            [
              45,
              5
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              6
            ]],
          [
            [
              45,
              7
            ],
            [
              0,
              4
            ]
          ],
          [
            [
              41,
              1
            ],
            [
              42,
              2
            ],
            [
              43,
              3
            ],
            [
              0,
              5
            ]
          ],
          [[
              0,
              6
            ]],
          [
            [
              42,
              4
            ],
            [
              43,
              3
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1,
          41: 1,
          43: 1
        }
      ],
      260: [
        [
          [[
              44,
              1
            ]],
          [
            [
              46,
              2
            ],
            [
              47,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [[
              44,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      261: [
        [
          [[
              48,
              1
            ]],
          [
            [
              24,
              0
            ],
            [
              35,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      262: [
        [
          [[
              19,
              1
            ]],
          [[
              44,
              2
            ]],
          [
            [
              45,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [[
              0,
              4
            ]]
        ],
        { 19: 1 }
      ],
      263: [
        [
          [
            [
              17,
              1
            ],
            [
              8,
              2
            ],
            [
              9,
              5
            ],
            [
              28,
              4
            ],
            [
              11,
              3
            ],
            [
              13,
              6
            ],
            [
              20,
              2
            ]
          ],
          [
            [
              17,
              1
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              49,
              7
            ],
            [
              50,
              2
            ]
          ],
          [
            [
              51,
              2
            ],
            [
              52,
              8
            ],
            [
              53,
              8
            ]
          ],
          [
            [
              54,
              9
            ],
            [
              55,
              2
            ]
          ],
          [[
              56,
              10
            ]],
          [[
              50,
              2
            ]],
          [[
              51,
              2
            ]],
          [[
              55,
              2
            ]],
          [[
              13,
              2
            ]]
        ],
        {
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          28: 1
        }
      ],
      264: [
        [
          [
            [
              57,
              1
            ],
            [
              58,
              1
            ],
            [
              59,
              1
            ],
            [
              60,
              1
            ],
            [
              61,
              1
            ],
            [
              62,
              1
            ],
            [
              63,
              1
            ],
            [
              64,
              1
            ],
            [
              65,
              1
            ],
            [
              66,
              1
            ],
            [
              67,
              1
            ],
            [
              68,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          57: 1,
          58: 1,
          59: 1,
          60: 1,
          61: 1,
          62: 1,
          63: 1,
          64: 1,
          65: 1,
          66: 1,
          67: 1,
          68: 1
        }
      ],
      265: [
        [
          [[
              31,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 31: 1 }
      ],
      266: [
        [
          [[
              10,
              1
            ]],
          [[
              20,
              2
            ]],
          [
            [
              69,
              3
            ],
            [
              28,
              4
            ]
          ],
          [[
              70,
              5
            ]],
          [
            [
              51,
              6
            ],
            [
              71,
              7
            ]
          ],
          [[
              0,
              5
            ]],
          [[
              69,
              3
            ]],
          [[
              51,
              6
            ]]
        ],
        { 10: 1 }
      ],
      267: [
        [
          [
            [
              72,
              1
            ],
            [
              73,
              1
            ],
            [
              7,
              2
            ],
            [
              74,
              1
            ],
            [
              72,
              1
            ],
            [
              75,
              1
            ],
            [
              76,
              1
            ],
            [
              77,
              3
            ],
            [
              78,
              1
            ],
            [
              79,
              1
            ]
          ],
          [[
              0,
              1
            ]],
          [[
              75,
              1
            ]],
          [
            [
              7,
              1
            ],
            [
              0,
              3
            ]
          ]
        ],
        {
          7: 1,
          72: 1,
          73: 1,
          74: 1,
          75: 1,
          76: 1,
          77: 1,
          78: 1,
          79: 1
        }
      ],
      268: [
        [
          [[
              80,
              1
            ]],
          [
            [
              81,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      269: [
        [
          [
            [
              82,
              1
            ],
            [
              83,
              1
            ],
            [
              84,
              1
            ],
            [
              85,
              1
            ],
            [
              86,
              1
            ],
            [
              87,
              1
            ],
            [
              88,
              1
            ],
            [
              89,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          4: 1,
          10: 1,
          14: 1,
          16: 1,
          27: 1,
          30: 1,
          33: 1,
          34: 1
        }
      ],
      270: [
        [
          [[
              32,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 32: 1 }
      ],
      271: [
        [
          [[
              90,
              1
            ]],
          [
            [
              88,
              2
            ],
            [
              85,
              2
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 33: 1 }
      ],
      272: [
        [
          [[
              33,
              1
            ]],
          [[
              91,
              2
            ]],
          [
            [
              28,
              4
            ],
            [
              2,
              3
            ]
          ],
          [[
              0,
              3
            ]],
          [
            [
              51,
              5
            ],
            [
              92,
              6
            ]
          ],
          [[
              2,
              3
            ]],
          [[
              51,
              5
            ]]
        ],
        { 33: 1 }
      ],
      273: [
        [
          [[
              93,
              1
            ]],
          [
            [
              93,
              1
            ],
            [
              0,
              1
            ]
          ]
        ],
        { 33: 1 }
      ],
      274: [
        [
          [[
              21,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        { 21: 1 }
      ],
      275: [
        [
          [[
              44,
              1
            ]],
          [[
              69,
              2
            ]],
          [[
              44,
              3
            ]],
          [
            [
              45,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              44,
              1
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      276: [
        [
          [[
              91,
              1
            ]],
          [
            [
              95,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              20,
              3
            ]],
          [[
              0,
              3
            ]]
        ],
        { 20: 1 }
      ],
      277: [
        [
          [[
              96,
              1
            ]],
          [
            [
              45,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        { 20: 1 }
      ],
      278: [
        [
          [[
              20,
              1
            ]],
          [
            [
              97,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        { 20: 1 }
      ],
      279: [
        [
          [[
              20,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 20: 1 }
      ],
      280: [
        [
          [[
              71,
              1
            ]],
          [
            [
              2,
              1
            ],
            [
              98,
              2
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      281: [
        [
          [[
              99,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              95,
              3
            ],
            [
              45,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [[
              0,
              4
            ]]
        ],
        { 99: 1 }
      ],
      282: [
        [
          [[
              15,
              1
            ]],
          [[
              80,
              2
            ]],
          [
            [
              75,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [
            [
              45,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              44,
              6
            ]],
          [[
              0,
              6
            ]]
        ],
        { 15: 1 }
      ],
      283: [
        [
          [[
              100,
              1
            ]],
          [
            [
              101,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      284: [
        [
          [[
              71,
              1
            ]],
          [
            [
              102,
              2
            ],
            [
              47,
              3
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              71,
              4
            ],
            [
              53,
              4
            ]
          ],
          [
            [
              71,
              5
            ],
            [
              53,
              5
            ]
          ],
          [[
              0,
              4
            ]],
          [
            [
              47,
              3
            ],
            [
              0,
              5
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      285: [
        [
          [[
              80,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              80,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      286: [
        [
          [
            [
              103,
              2
            ],
            [
              24,
              1
            ],
            [
              6,
              1
            ],
            [
              35,
              1
            ]
          ],
          [[
              104,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      287: [
        [
          [
            [
              2,
              0
            ],
            [
              98,
              1
            ],
            [
              105,
              0
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          2: 1,
          4: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          10: 1,
          11: 1,
          12: 1,
          13: 1,
          14: 1,
          15: 1,
          16: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          27: 1,
          28: 1,
          29: 1,
          30: 1,
          31: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1,
          98: 1
        }
      ],
      288: [
        [
          [
            [
              106,
              1
            ],
            [
              107,
              1
            ],
            [
              108,
              1
            ],
            [
              109,
              1
            ],
            [
              110,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          5: 1,
          18: 1,
          25: 1,
          31: 1,
          32: 1
        }
      ],
      289: [
        [
          [[
              27,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              75,
              3
            ]],
          [[
              71,
              4
            ]],
          [[
              69,
              5
            ]],
          [[
              70,
              6
            ]],
          [
            [
              111,
              7
            ],
            [
              0,
              6
            ]
          ],
          [[
              69,
              8
            ]],
          [[
              70,
              9
            ]],
          [[
              0,
              9
            ]]
        ],
        { 27: 1 }
      ],
      290: [
        [
          [
            [
              28,
              1
            ],
            [
              20,
              2
            ]
          ],
          [[
              112,
              3
            ]],
          [[
              0,
              2
            ]],
          [[
              51,
              2
            ]]
        ],
        {
          20: 1,
          28: 1
        }
      ],
      291: [
        [
          [[
              113,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              113,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          20: 1,
          28: 1
        }
      ],
      292: [
        [
          [[
              4,
              1
            ]],
          [[
              20,
              2
            ]],
          [[
              114,
              3
            ]],
          [[
              69,
              4
            ]],
          [[
              70,
              5
            ]],
          [[
              0,
              5
            ]]
        ],
        { 4: 1 }
      ],
      293: [
        [
          [[
              27,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              75,
              3
            ]],
          [[
              115,
              4
            ]],
          [
            [
              116,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              0,
              5
            ]]
        ],
        { 27: 1 }
      ],
      294: [
        [
          [[
              30,
              1
            ]],
          [[
              117,
              2
            ]],
          [
            [
              116,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              0,
              3
            ]]
        ],
        { 30: 1 }
      ],
      295: [
        [
          [
            [
              46,
              1
            ],
            [
              118,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          27: 1,
          30: 1
        }
      ],
      296: [
        [
          [[
              26,
              1
            ]],
          [[
              20,
              2
            ]],
          [
            [
              45,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        { 26: 1 }
      ],
      297: [
        [
          [[
              30,
              1
            ]],
          [[
              44,
              2
            ]],
          [[
              69,
              3
            ]],
          [[
              70,
              4
            ]],
          [
            [
              111,
              5
            ],
            [
              119,
              1
            ],
            [
              0,
              4
            ]
          ],
          [[
              69,
              6
            ]],
          [[
              70,
              7
            ]],
          [[
              0,
              7
            ]]
        ],
        { 30: 1 }
      ],
      298: [
        [
          [[
              20,
              1
            ]],
          [
            [
              95,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              20,
              3
            ]],
          [[
              0,
              3
            ]]
        ],
        { 20: 1 }
      ],
      299: [
        [
          [[
              120,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              120,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        { 20: 1 }
      ],
      300: [
        [
          [[
              29,
              1
            ]],
          [
            [
              91,
              2
            ],
            [
              97,
              3
            ]
          ],
          [[
              23,
              4
            ]],
          [
            [
              91,
              2
            ],
            [
              23,
              4
            ],
            [
              97,
              3
            ]
          ],
          [
            [
              121,
              5
            ],
            [
              41,
              5
            ],
            [
              28,
              6
            ]
          ],
          [[
              0,
              5
            ]],
          [[
              121,
              7
            ]],
          [[
              51,
              5
            ]]
        ],
        { 29: 1 }
      ],
      301: [
        [
          [[
              23,
              1
            ]],
          [[
              122,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        { 23: 1 }
      ],
      302: [
        [
          [
            [
              123,
              1
            ],
            [
              124,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          23: 1,
          29: 1
        }
      ],
      303: [
        [
          [[
              36,
              1
            ]],
          [
            [
              69,
              2
            ],
            [
              125,
              3
            ]
          ],
          [[
              44,
              4
            ]],
          [[
              69,
              2
            ]],
          [[
              0,
              4
            ]]
        ],
        { 36: 1 }
      ],
      304: [
        [
          [[
              27,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              75,
              3
            ]],
          [[
              126,
              4
            ]],
          [
            [
              127,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              0,
              5
            ]]
        ],
        { 27: 1 }
      ],
      305: [
        [
          [[
              30,
              1
            ]],
          [[
              117,
              2
            ]],
          [
            [
              127,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              0,
              3
            ]]
        ],
        { 30: 1 }
      ],
      306: [
        [
          [
            [
              128,
              1
            ],
            [
              129,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          27: 1,
          30: 1
        }
      ],
      307: [
        [
          [[
              44,
              1
            ]],
          [
            [
              128,
              2
            ],
            [
              45,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              44,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              45,
              3
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      308: [
        [
          [
            [
              7,
              1
            ],
            [
              130,
              2
            ]
          ],
          [[
              39,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      309: [
        [
          [[
              36,
              1
            ]],
          [
            [
              69,
              2
            ],
            [
              125,
              3
            ]
          ],
          [[
              117,
              4
            ]],
          [[
              69,
              2
            ]],
          [[
              0,
              4
            ]]
        ],
        { 36: 1 }
      ],
      310: [
        [
          [
            [
              131,
              1
            ],
            [
              115,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      311: [
        [
          [[
              132,
              1
            ]],
          [
            [
              133,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      312: [
        [
          [[
              28,
              1
            ]],
          [
            [
              51,
              2
            ],
            [
              125,
              3
            ]
          ],
          [[
              0,
              2
            ]],
          [[
              51,
              2
            ]]
        ],
        { 28: 1 }
      ],
      313: [
        [
          [[
              22,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 22: 1 }
      ],
      314: [
        [
          [[
              134,
              1
            ]],
          [
            [
              135,
              1
            ],
            [
              43,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              104,
              3
            ]],
          [[
              0,
              3
            ]]
        ],
        {
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          28: 1
        }
      ],
      315: [
        [
          [[
              12,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              136,
              3
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              45,
              4
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              5
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              4
            ]
          ],
          [
            [
              45,
              6
            ],
            [
              0,
              5
            ]
          ],
          [[
              44,
              7
            ]],
          [
            [
              45,
              8
            ],
            [
              0,
              7
            ]
          ],
          [
            [
              44,
              7
            ],
            [
              0,
              8
            ]
          ]
        ],
        { 12: 1 }
      ],
      316: [
        [
          [[
              5,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              45,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [
            [
              45,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              44,
              6
            ]],
          [[
              0,
              6
            ]]
        ],
        { 5: 1 }
      ],
      317: [
        [
          [[
              18,
              1
            ]],
          [
            [
              71,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 18: 1 }
      ],
      318: [
        [
          [[
              137,
              1
            ]],
          [
            [
              136,
              0
            ],
            [
              138,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      319: [
        [
          [[
              139,
              1
            ]],
          [
            [
              2,
              2
            ],
            [
              140,
              3
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              139,
              1
            ],
            [
              2,
              2
            ]
          ]
        ],
        {
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          12: 1,
          13: 1,
          15: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          28: 1,
          29: 1,
          31: 1,
          32: 1,
          35: 1,
          36: 1
        }
      ],
      320: [
        [
          [[
              69,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 69: 1 }
      ],
      321: [
        [
          [
            [
              141,
              1
            ],
            [
              142,
              1
            ],
            [
              143,
              1
            ],
            [
              144,
              1
            ],
            [
              145,
              1
            ],
            [
              146,
              1
            ],
            [
              147,
              1
            ],
            [
              148,
              1
            ],
            [
              149,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          12: 1,
          13: 1,
          15: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          28: 1,
          29: 1,
          31: 1,
          32: 1,
          35: 1,
          36: 1
        }
      ],
      322: [
        [
          [
            [
              1,
              1
            ],
            [
              3,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          4: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          10: 1,
          11: 1,
          12: 1,
          13: 1,
          14: 1,
          15: 1,
          16: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          27: 1,
          28: 1,
          29: 1,
          30: 1,
          31: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1
        }
      ],
      323: [
        [
          [
            [
              44,
              1
            ],
            [
              69,
              2
            ],
            [
              97,
              3
            ]
          ],
          [
            [
              69,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              44,
              4
            ],
            [
              150,
              5
            ],
            [
              0,
              2
            ]
          ],
          [[
              97,
              6
            ]],
          [
            [
              150,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              0,
              5
            ]],
          [[
              97,
              5
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1,
          69: 1,
          97: 1
        }
      ],
      324: [
        [
          [[
              151,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              151,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1,
          69: 1,
          97: 1
        }
      ],
      325: [
        [
          [
            [
              1,
              1
            ],
            [
              2,
              2
            ]
          ],
          [[
              0,
              1
            ]],
          [[
              152,
              3
            ]],
          [[
              105,
              4
            ]],
          [
            [
              153,
              1
            ],
            [
              105,
              4
            ]
          ]
        ],
        {
          2: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          12: 1,
          13: 1,
          15: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          28: 1,
          29: 1,
          31: 1,
          32: 1,
          35: 1,
          36: 1
        }
      ],
      326: [
        [
          [[
              104,
              1
            ]],
          [
            [
              154,
              0
            ],
            [
              41,
              0
            ],
            [
              155,
              0
            ],
            [
              156,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      327: [
        [
          [
            [
              115,
              1
            ],
            [
              157,
              2
            ]
          ],
          [
            [
              30,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [[
              115,
              4
            ]],
          [[
              111,
              5
            ]],
          [[
              44,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      328: [
        [
          [[
              44,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              44,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      329: [
        [
          [[
              44,
              1
            ]],
          [
            [
              45,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      330: [
        [
          [[
              44,
              1
            ]],
          [
            [
              46,
              2
            ],
            [
              45,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              44,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              45,
              3
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      331: [
        [
          [[
              117,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              117,
              3
            ]],
          [
            [
              45,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              117,
              3
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      332: [
        [
          [
            [
              28,
              1
            ],
            [
              97,
              2
            ],
            [
              11,
              3
            ]
          ],
          [
            [
              51,
              4
            ],
            [
              92,
              5
            ]
          ],
          [[
              20,
              4
            ]],
          [[
              158,
              6
            ]],
          [[
              0,
              4
            ]],
          [[
              51,
              4
            ]],
          [[
              50,
              4
            ]]
        ],
        {
          11: 1,
          28: 1,
          97: 1
        }
      ],
      333: [
        [
          [[
              14,
              1
            ]],
          [[
              69,
              2
            ]],
          [[
              70,
              3
            ]],
          [
            [
              159,
              4
            ],
            [
              160,
              5
            ]
          ],
          [[
              69,
              6
            ]],
          [[
              69,
              7
            ]],
          [[
              70,
              8
            ]],
          [[
              70,
              9
            ]],
          [
            [
              159,
              4
            ],
            [
              111,
              10
            ],
            [
              160,
              5
            ],
            [
              0,
              8
            ]
          ],
          [[
              0,
              9
            ]],
          [[
              69,
              11
            ]],
          [[
              70,
              12
            ]],
          [
            [
              160,
              5
            ],
            [
              0,
              12
            ]
          ]
        ],
        { 14: 1 }
      ],
      334: [
        [
          [
            [
              41,
              1
            ],
            [
              113,
              2
            ],
            [
              43,
              3
            ]
          ],
          [[
              20,
              4
            ]],
          [
            [
              47,
              5
            ],
            [
              45,
              6
            ],
            [
              0,
              2
            ]
          ],
          [[
              20,
              7
            ]],
          [
            [
              45,
              8
            ],
            [
              0,
              4
            ]
          ],
          [[
              44,
              9
            ]],
          [
            [
              41,
              1
            ],
            [
              113,
              2
            ],
            [
              43,
              3
            ],
            [
              0,
              6
            ]
          ],
          [[
              0,
              7
            ]],
          [[
              43,
              3
            ]],
          [
            [
              45,
              6
            ],
            [
              0,
              9
            ]
          ]
        ],
        {
          20: 1,
          28: 1,
          41: 1,
          43: 1
        }
      ],
      335: [
        [
          [[
              16,
              1
            ]],
          [[
              44,
              2
            ]],
          [[
              69,
              3
            ]],
          [[
              70,
              4
            ]],
          [
            [
              111,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              69,
              6
            ]],
          [[
              70,
              7
            ]],
          [[
              0,
              7
            ]]
        ],
        { 16: 1 }
      ],
      336: [
        [
          [[
              34,
              1
            ]],
          [[
              44,
              2
            ]],
          [
            [
              69,
              3
            ],
            [
              161,
              4
            ]
          ],
          [[
              70,
              5
            ]],
          [[
              69,
              3
            ]],
          [[
              0,
              5
            ]]
        ],
        { 34: 1 }
      ],
      337: [
        [
          [[
              95,
              1
            ]],
          [[
              80,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        { 95: 1 }
      ],
      338: [
        [
          [[
              162,
              1
            ]],
          [
            [
              163,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      339: [
        [
          [[
              25,
              1
            ]],
          [
            [
              71,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 25: 1 }
      ],
      340: [
        [
          [[
              53,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 25: 1 }
      ]
    },
    states: [
      [
        [
          [
            1,
            1
          ],
          [
            2,
            1
          ],
          [
            3,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            2,
            1
          ]]
      ],
      [
        [[
            37,
            1
          ]],
        [
          [
            38,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            39,
            1
          ]],
        [
          [
            40,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            6
          ]],
        [
          [
            45,
            7
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            5
          ]
        ],
        [[
            0,
            6
          ]],
        [
          [
            42,
            4
          ],
          [
            43,
            3
          ]
        ]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            44,
            2
          ]]
      ],
      [
        [[
            48,
            1
          ]],
        [
          [
            24,
            0
          ],
          [
            35,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            19,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [
          [
            17,
            1
          ],
          [
            8,
            2
          ],
          [
            9,
            5
          ],
          [
            28,
            4
          ],
          [
            11,
            3
          ],
          [
            13,
            6
          ],
          [
            20,
            2
          ]
        ],
        [
          [
            17,
            1
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            49,
            7
          ],
          [
            50,
            2
          ]
        ],
        [
          [
            51,
            2
          ],
          [
            52,
            8
          ],
          [
            53,
            8
          ]
        ],
        [
          [
            54,
            9
          ],
          [
            55,
            2
          ]
        ],
        [[
            56,
            10
          ]],
        [[
            50,
            2
          ]],
        [[
            51,
            2
          ]],
        [[
            55,
            2
          ]],
        [[
            13,
            2
          ]]
      ],
      [
        [
          [
            57,
            1
          ],
          [
            58,
            1
          ],
          [
            59,
            1
          ],
          [
            60,
            1
          ],
          [
            61,
            1
          ],
          [
            62,
            1
          ],
          [
            63,
            1
          ],
          [
            64,
            1
          ],
          [
            65,
            1
          ],
          [
            66,
            1
          ],
          [
            67,
            1
          ],
          [
            68,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            31,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            10,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            28,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [
          [
            51,
            6
          ],
          [
            71,
            7
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            51,
            6
          ]]
      ],
      [
        [
          [
            72,
            1
          ],
          [
            73,
            1
          ],
          [
            7,
            2
          ],
          [
            74,
            1
          ],
          [
            72,
            1
          ],
          [
            75,
            1
          ],
          [
            76,
            1
          ],
          [
            77,
            3
          ],
          [
            78,
            1
          ],
          [
            79,
            1
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            75,
            1
          ]],
        [
          [
            7,
            1
          ],
          [
            0,
            3
          ]
        ]
      ],
      [
        [[
            80,
            1
          ]],
        [
          [
            81,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [
          [
            82,
            1
          ],
          [
            83,
            1
          ],
          [
            84,
            1
          ],
          [
            85,
            1
          ],
          [
            86,
            1
          ],
          [
            87,
            1
          ],
          [
            88,
            1
          ],
          [
            89,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            32,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            90,
            1
          ]],
        [
          [
            88,
            2
          ],
          [
            85,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            33,
            1
          ]],
        [[
            91,
            2
          ]],
        [
          [
            28,
            4
          ],
          [
            2,
            3
          ]
        ],
        [[
            0,
            3
          ]],
        [
          [
            51,
            5
          ],
          [
            92,
            6
          ]
        ],
        [[
            2,
            3
          ]],
        [[
            51,
            5
          ]]
      ],
      [
        [[
            93,
            1
          ]],
        [
          [
            93,
            1
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            21,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            44,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            44,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [[
            91,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      [
        [[
            96,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            20,
            1
          ]],
        [
          [
            97,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            20,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            71,
            1
          ]],
        [
          [
            2,
            1
          ],
          [
            98,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            99,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            95,
            3
          ],
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [[
            15,
            1
          ]],
        [[
            80,
            2
          ]],
        [
          [
            75,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      [
        [[
            100,
            1
          ]],
        [
          [
            101,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            71,
            1
          ]],
        [
          [
            102,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            71,
            4
          ],
          [
            53,
            4
          ]
        ],
        [
          [
            71,
            5
          ],
          [
            53,
            5
          ]
        ],
        [[
            0,
            4
          ]],
        [
          [
            47,
            3
          ],
          [
            0,
            5
          ]
        ]
      ],
      [
        [[
            80,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            80,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [
          [
            103,
            2
          ],
          [
            24,
            1
          ],
          [
            6,
            1
          ],
          [
            35,
            1
          ]
        ],
        [[
            104,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [
          [
            2,
            0
          ],
          [
            98,
            1
          ],
          [
            105,
            0
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [
          [
            106,
            1
          ],
          [
            107,
            1
          ],
          [
            108,
            1
          ],
          [
            109,
            1
          ],
          [
            110,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            71,
            4
          ]],
        [[
            69,
            5
          ]],
        [[
            70,
            6
          ]],
        [
          [
            111,
            7
          ],
          [
            0,
            6
          ]
        ],
        [[
            69,
            8
          ]],
        [[
            70,
            9
          ]],
        [[
            0,
            9
          ]]
      ],
      [
        [
          [
            28,
            1
          ],
          [
            20,
            2
          ]
        ],
        [[
            112,
            3
          ]],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      [
        [[
            113,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            113,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            4,
            1
          ]],
        [[
            20,
            2
          ]],
        [[
            114,
            3
          ]],
        [[
            69,
            4
          ]],
        [[
            70,
            5
          ]],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            115,
            4
          ]],
        [
          [
            116,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            116,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      [
        [
          [
            46,
            1
          ],
          [
            118,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            26,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            45,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            30,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            119,
            1
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      [
        [[
            20,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      [
        [[
            120,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            120,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            29,
            1
          ]],
        [
          [
            91,
            2
          ],
          [
            97,
            3
          ]
        ],
        [[
            23,
            4
          ]],
        [
          [
            91,
            2
          ],
          [
            23,
            4
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            121,
            5
          ],
          [
            41,
            5
          ],
          [
            28,
            6
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            121,
            7
          ]],
        [[
            51,
            5
          ]]
      ],
      [
        [[
            23,
            1
          ]],
        [[
            122,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [
          [
            123,
            1
          ],
          [
            124,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            126,
            4
          ]],
        [
          [
            127,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            127,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      [
        [
          [
            128,
            1
          ],
          [
            129,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            128,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [
          [
            7,
            1
          ],
          [
            130,
            2
          ]
        ],
        [[
            39,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            117,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [
          [
            131,
            1
          ],
          [
            115,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            132,
            1
          ]],
        [
          [
            133,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            28,
            1
          ]],
        [
          [
            51,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      [
        [[
            22,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            134,
            1
          ]],
        [
          [
            135,
            1
          ],
          [
            43,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            104,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      [
        [[
            12,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            136,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            4
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            5
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            45,
            6
          ],
          [
            0,
            5
          ]
        ],
        [[
            44,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            7
          ]
        ],
        [
          [
            44,
            7
          ],
          [
            0,
            8
          ]
        ]
      ],
      [
        [[
            5,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      [
        [[
            18,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            137,
            1
          ]],
        [
          [
            136,
            0
          ],
          [
            138,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            139,
            1
          ]],
        [
          [
            2,
            2
          ],
          [
            140,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            139,
            1
          ],
          [
            2,
            2
          ]
        ]
      ],
      [
        [[
            69,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [
          [
            141,
            1
          ],
          [
            142,
            1
          ],
          [
            143,
            1
          ],
          [
            144,
            1
          ],
          [
            145,
            1
          ],
          [
            146,
            1
          ],
          [
            147,
            1
          ],
          [
            148,
            1
          ],
          [
            149,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [
          [
            1,
            1
          ],
          [
            3,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [
          [
            44,
            1
          ],
          [
            69,
            2
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            69,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            4
          ],
          [
            150,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            97,
            6
          ]],
        [
          [
            150,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            97,
            5
          ]]
      ],
      [
        [[
            151,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            151,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [
          [
            1,
            1
          ],
          [
            2,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            152,
            3
          ]],
        [[
            105,
            4
          ]],
        [
          [
            153,
            1
          ],
          [
            105,
            4
          ]
        ]
      ],
      [
        [[
            104,
            1
          ]],
        [
          [
            154,
            0
          ],
          [
            41,
            0
          ],
          [
            155,
            0
          ],
          [
            156,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [
          [
            115,
            1
          ],
          [
            157,
            2
          ]
        ],
        [
          [
            30,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            115,
            4
          ]],
        [[
            111,
            5
          ]],
        [[
            44,
            2
          ]]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [[
            117,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            117,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            117,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [
          [
            28,
            1
          ],
          [
            97,
            2
          ],
          [
            11,
            3
          ]
        ],
        [
          [
            51,
            4
          ],
          [
            92,
            5
          ]
        ],
        [[
            20,
            4
          ]],
        [[
            158,
            6
          ]],
        [[
            0,
            4
          ]],
        [[
            51,
            4
          ]],
        [[
            50,
            4
          ]]
      ],
      [
        [[
            14,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            70,
            3
          ]],
        [
          [
            159,
            4
          ],
          [
            160,
            5
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            69,
            7
          ]],
        [[
            70,
            8
          ]],
        [[
            70,
            9
          ]],
        [
          [
            159,
            4
          ],
          [
            111,
            10
          ],
          [
            160,
            5
          ],
          [
            0,
            8
          ]
        ],
        [[
            0,
            9
          ]],
        [[
            69,
            11
          ]],
        [[
            70,
            12
          ]],
        [
          [
            160,
            5
          ],
          [
            0,
            12
          ]
        ]
      ],
      [
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            20,
            4
          ]],
        [
          [
            47,
            5
          ],
          [
            45,
            6
          ],
          [
            0,
            2
          ]
        ],
        [[
            20,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            9
          ]],
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            6
          ]
        ],
        [[
            0,
            7
          ]],
        [[
            43,
            3
          ]],
        [
          [
            45,
            6
          ],
          [
            0,
            9
          ]
        ]
      ],
      [
        [[
            16,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      [
        [[
            34,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            161,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            95,
            1
          ]],
        [[
            80,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            162,
            1
          ]],
        [
          [
            163,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            25,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            53,
            1
          ]],
        [[
            0,
            1
          ]]
      ]
    ],
    labels: [
      [
        0,
        'EMPTY'
      ],
      [
        319,
        null
      ],
      [
        4,
        null
      ],
      [
        269,
        null
      ],
      [
        1,
        'def'
      ],
      [
        1,
        'raise'
      ],
      [
        32,
        null
      ],
      [
        1,
        'not'
      ],
      [
        2,
        null
      ],
      [
        26,
        null
      ],
      [
        1,
        'class'
      ],
      [
        9,
        null
      ],
      [
        1,
        'print'
      ],
      [
        25,
        null
      ],
      [
        1,
        'try'
      ],
      [
        1,
        'exec'
      ],
      [
        1,
        'while'
      ],
      [
        3,
        null
      ],
      [
        1,
        'return'
      ],
      [
        1,
        'assert'
      ],
      [
        1,
        null
      ],
      [
        1,
        'del'
      ],
      [
        1,
        'pass'
      ],
      [
        1,
        'import'
      ],
      [
        15,
        null
      ],
      [
        1,
        'yield'
      ],
      [
        1,
        'global'
      ],
      [
        1,
        'for'
      ],
      [
        7,
        null
      ],
      [
        1,
        'from'
      ],
      [
        1,
        'if'
      ],
      [
        1,
        'break'
      ],
      [
        1,
        'continue'
      ],
      [
        50,
        null
      ],
      [
        1,
        'with'
      ],
      [
        14,
        null
      ],
      [
        1,
        'lambda'
      ],
      [
        318,
        null
      ],
      [
        19,
        null
      ],
      [
        308,
        null
      ],
      [
        1,
        'and'
      ],
      [
        16,
        null
      ],
      [
        260,
        null
      ],
      [
        36,
        null
      ],
      [
        327,
        null
      ],
      [
        12,
        null
      ],
      [
        293,
        null
      ],
      [
        22,
        null
      ],
      [
        326,
        null
      ],
      [
        307,
        null
      ],
      [
        10,
        null
      ],
      [
        8,
        null
      ],
      [
        330,
        null
      ],
      [
        339,
        null
      ],
      [
        275,
        null
      ],
      [
        27,
        null
      ],
      [
        329,
        null
      ],
      [
        46,
        null
      ],
      [
        39,
        null
      ],
      [
        41,
        null
      ],
      [
        47,
        null
      ],
      [
        42,
        null
      ],
      [
        43,
        null
      ],
      [
        37,
        null
      ],
      [
        44,
        null
      ],
      [
        49,
        null
      ],
      [
        40,
        null
      ],
      [
        38,
        null
      ],
      [
        45,
        null
      ],
      [
        11,
        null
      ],
      [
        325,
        null
      ],
      [
        328,
        null
      ],
      [
        29,
        null
      ],
      [
        21,
        null
      ],
      [
        28,
        null
      ],
      [
        1,
        'in'
      ],
      [
        30,
        null
      ],
      [
        1,
        'is'
      ],
      [
        31,
        null
      ],
      [
        20,
        null
      ],
      [
        283,
        null
      ],
      [
        267,
        null
      ],
      [
        333,
        null
      ],
      [
        297,
        null
      ],
      [
        289,
        null
      ],
      [
        266,
        null
      ],
      [
        336,
        null
      ],
      [
        335,
        null
      ],
      [
        292,
        null
      ],
      [
        271,
        null
      ],
      [
        273,
        null
      ],
      [
        278,
        null
      ],
      [
        259,
        null
      ],
      [
        272,
        null
      ],
      [
        285,
        null
      ],
      [
        1,
        'as'
      ],
      [
        276,
        null
      ],
      [
        23,
        null
      ],
      [
        0,
        null
      ],
      [
        1,
        'except'
      ],
      [
        338,
        null
      ],
      [
        18,
        null
      ],
      [
        264,
        null
      ],
      [
        314,
        null
      ],
      [
        286,
        null
      ],
      [
        322,
        null
      ],
      [
        265,
        null
      ],
      [
        270,
        null
      ],
      [
        316,
        null
      ],
      [
        317,
        null
      ],
      [
        340,
        null
      ],
      [
        1,
        'else'
      ],
      [
        291,
        null
      ],
      [
        290,
        null
      ],
      [
        312,
        null
      ],
      [
        311,
        null
      ],
      [
        295,
        null
      ],
      [
        310,
        null
      ],
      [
        294,
        null
      ],
      [
        1,
        'elif'
      ],
      [
        298,
        null
      ],
      [
        299,
        null
      ],
      [
        277,
        null
      ],
      [
        301,
        null
      ],
      [
        300,
        null
      ],
      [
        334,
        null
      ],
      [
        331,
        null
      ],
      [
        306,
        null
      ],
      [
        304,
        null
      ],
      [
        305,
        null
      ],
      [
        268,
        null
      ],
      [
        309,
        null
      ],
      [
        258,
        null
      ],
      [
        1,
        'or'
      ],
      [
        263,
        null
      ],
      [
        332,
        null
      ],
      [
        35,
        null
      ],
      [
        261,
        null
      ],
      [
        34,
        null
      ],
      [
        321,
        null
      ],
      [
        13,
        null
      ],
      [
        288,
        null
      ],
      [
        262,
        null
      ],
      [
        284,
        null
      ],
      [
        313,
        null
      ],
      [
        315,
        null
      ],
      [
        274,
        null
      ],
      [
        282,
        null
      ],
      [
        296,
        null
      ],
      [
        302,
        null
      ],
      [
        320,
        null
      ],
      [
        323,
        null
      ],
      [
        5,
        null
      ],
      [
        6,
        null
      ],
      [
        48,
        null
      ],
      [
        17,
        null
      ],
      [
        24,
        null
      ],
      [
        303,
        null
      ],
      [
        324,
        null
      ],
      [
        281,
        null
      ],
      [
        1,
        'finally'
      ],
      [
        337,
        null
      ],
      [
        257,
        null
      ],
      [
        33,
        null
      ]
    ],
    keywords: {
      and: 40,
      as: 95,
      assert: 19,
      'break': 31,
      'class': 10,
      'continue': 32,
      def: 4,
      del: 21,
      elif: 119,
      'else': 111,
      except: 99,
      exec: 15,
      'finally': 160,
      'for': 27,
      from: 29,
      global: 26,
      'if': 30,
      'import': 23,
      'in': 75,
      is: 77,
      lambda: 36,
      not: 7,
      or: 133,
      pass: 22,
      print: 12,
      raise: 5,
      'return': 18,
      'try': 14,
      'while': 16,
      'with': 34,
      yield: 25
    },
    tokens: {
      0: 98,
      1: 20,
      2: 8,
      3: 17,
      4: 2,
      5: 152,
      6: 153,
      7: 28,
      8: 51,
      9: 11,
      10: 50,
      11: 69,
      12: 45,
      13: 140,
      14: 35,
      15: 24,
      16: 41,
      17: 155,
      18: 101,
      19: 38,
      20: 79,
      21: 73,
      22: 47,
      23: 97,
      24: 156,
      25: 13,
      26: 9,
      27: 55,
      28: 74,
      29: 72,
      30: 76,
      31: 78,
      32: 6,
      33: 163,
      34: 138,
      35: 136,
      36: 43,
      37: 63,
      38: 67,
      39: 58,
      40: 66,
      41: 59,
      42: 61,
      43: 62,
      44: 64,
      45: 68,
      46: 57,
      47: 60,
      48: 154,
      49: 65,
      50: 33
    },
    start: 256
  };
  function Parser(a, b) {
    this.filename = a;
    this.grammar = b;
    return this;
  }
  Parser.prototype.setup = function (a) {
    a = a || this.grammar.start;
    this.stack = [{
        dfa: this.grammar.dfas[a],
        state: 0,
        node: {
          type: a,
          value: null,
          context: null,
          children: []
        }
      }];
    this.used_names = {};
  };
  function findInDfa(a, b) {
    for (var c = a.length; c--;)
      if (a[c][0] === b[0] && a[c][1] === b[1])
        return !0;
    return !1;
  }
  Parser.prototype.addtoken = function (a, b, c) {
    var d = this.classify(a, b, c);
    a:
      for (;;) {
        for (var e = this.stack[this.stack.length - 1], f = e.dfa[0], g = f[e.state], h = 0; h < g.length; ++h) {
          var k = g[h][0], l = g[h][1], m = this.grammar.labels[k][0];
          if (d === k) {
            goog.asserts.assert(256 > m);
            this.shift(a, b, l, c);
            for (a = l; 1 === f[a].length && 0 === f[a][0][0] && f[a][0][1] === a;) {
              this.pop();
              if (0 === this.stack.length)
                return !0;
              e = this.stack[this.stack.length - 1];
              a = e.state;
              f = e.dfa[0];
            }
            return !1;
          }
          if (256 <= m && this.grammar.dfas[m][1].hasOwnProperty(d)) {
            this.push(m, this.grammar.dfas[m], l, c);
            continue a;
          }
        }
        if (findInDfa(g, [
            0,
            e.state
          ])) {
          if (this.pop(), 0 === this.stack.length)
            throw new Sk.builtin.ParseError('too much input', this.filename);
        } else
          throw new Sk.builtin.ParseError('bad input', this.filename, c[0][0], c);
      }
  };
  Parser.prototype.classify = function (a, b, c) {
    if (a === Sk.Tokenizer.Tokens.T_NAME && (this.used_names[b] = !0, b = this.grammar.keywords.hasOwnProperty(b) && this.grammar.keywords[b]))
      return b;
    b = this.grammar.tokens.hasOwnProperty(a) && this.grammar.tokens[a];
    if (!b)
      throw new Sk.builtin.ParseError('bad token', this.filename, c[0][0], c);
    return b;
  };
  Parser.prototype.shift = function (a, b, c, d) {
    var e = this.stack[this.stack.length - 1].dfa, f = this.stack[this.stack.length - 1].node;
    f.children.push({
      type: a,
      value: b,
      lineno: d[0][0],
      col_offset: d[0][1],
      children: null
    });
    this.stack[this.stack.length - 1] = {
      dfa: e,
      state: c,
      node: f
    };
  };
  Parser.prototype.push = function (a, b, c, d) {
    a = {
      type: a,
      value: null,
      lineno: d[0][0],
      col_offset: d[0][1],
      children: []
    };
    this.stack[this.stack.length - 1] = {
      dfa: this.stack[this.stack.length - 1].dfa,
      state: c,
      node: this.stack[this.stack.length - 1].node
    };
    this.stack.push({
      dfa: b,
      state: 0,
      node: a
    });
  };
  Parser.prototype.pop = function () {
    var a = this.stack.pop().node;
    a && (0 !== this.stack.length ? this.stack[this.stack.length - 1].node.children.push(a) : (this.rootnode = a, this.rootnode.used_names = this.used_names));
  };
  function makeParser(a, b) {
    void 0 === b && (b = 'file_input');
    var c = new Parser(a, Sk.ParseTables);
    'file_input' === b ? c.setup(Sk.ParseTables.sym.file_input) : goog.asserts.fail('todo;');
    var d = Sk.Tokenizer.Tokens.T_COMMENT, e = Sk.Tokenizer.Tokens.T_NL, f = Sk.Tokenizer.Tokens.T_OP, g = new Sk.Tokenizer(a, 'single_input' === b, function (a, b, g, m, n) {
        if (a !== d && a !== e && (a === f && (a = Sk.OpMap[b]), c.addtoken(a, b, [
            g,
            m,
            n
          ])))
          return !0;
      });
    return function (a) {
      if (a = g.generateTokens(a)) {
        if ('done' !== a)
          throw new Sk.builtin.ParseError('incomplete input', this.filename);
        return c.rootnode;
      }
      return !1;
    };
  }
  Sk.parse = function (a, b) {
    var c = makeParser(a);
    '\n' !== b.substr(b.length - 1, 1) && (b += '\n');
    for (var d = b.split('\n'), e, f = 0; f < d.length; ++f)
      e = c(d[f] + (f === d.length - 1 ? '' : '\n'));
    return e;
  };
  Sk.parseTreeDump = function (a, b) {
    b = b || '';
    var c;
    c = '' + b;
    if (256 <= a.type) {
      c += Sk.ParseTables.number2symbol[a.type] + '\n';
      for (var d = 0; d < a.children.length; ++d)
        c += Sk.parseTreeDump(a.children[d], b + '  ');
    } else
      c += Sk.Tokenizer.tokenNames[a.type] + ': ' + new Sk.builtin.str(a.value).$r().v + '\n';
    return c;
  };
  goog.exportSymbol('Sk.parse', Sk.parse);
  goog.exportSymbol('Sk.parseTreeDump', Sk.parseTreeDump);
  function Load() {
  }
  function Store() {
  }
  function Del() {
  }
  function AugLoad() {
  }
  function AugStore() {
  }
  function Param() {
  }
  function And() {
  }
  function Or() {
  }
  function Add() {
  }
  function Sub() {
  }
  function Mult() {
  }
  function Div() {
  }
  function Mod() {
  }
  function Pow() {
  }
  function LShift() {
  }
  function RShift() {
  }
  function BitOr() {
  }
  function BitXor() {
  }
  function BitAnd() {
  }
  function FloorDiv() {
  }
  function Invert() {
  }
  function Not() {
  }
  function UAdd() {
  }
  function USub() {
  }
  function Eq() {
  }
  function NotEq() {
  }
  function Lt() {
  }
  function LtE() {
  }
  function Gt() {
  }
  function GtE() {
  }
  function Is() {
  }
  function IsNot() {
  }
  function In_() {
  }
  function NotIn() {
  }
  function Module(a) {
    this.body = a;
    return this;
  }
  function Interactive(a) {
    this.body = a;
    return this;
  }
  function Expression(a) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.body = a;
    return this;
  }
  function Suite(a) {
    this.body = a;
    return this;
  }
  function FunctionDef(a, b, c, d, e, f) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.name = a;
    this.args = b;
    this.body = c;
    this.decorator_list = d;
    this.lineno = e;
    this.col_offset = f;
    return this;
  }
  function ClassDef(a, b, c, d, e, f) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.name = a;
    this.bases = b;
    this.body = c;
    this.decorator_list = d;
    this.lineno = e;
    this.col_offset = f;
    return this;
  }
  function Return_(a, b, c) {
    this.value = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Delete_(a, b, c) {
    this.targets = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Assign(a, b, c, d) {
    goog.asserts.assert(null !== b && void 0 !== b);
    this.targets = a;
    this.value = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function AugAssign(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.target = a;
    this.op = b;
    this.value = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Print(a, b, c, d, e) {
    this.dest = a;
    this.values = b;
    this.nl = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function For_(a, b, c, d, e, f) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.target = a;
    this.iter = b;
    this.body = c;
    this.orelse = d;
    this.lineno = e;
    this.col_offset = f;
    return this;
  }
  function While_(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.test = a;
    this.body = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function If_(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.test = a;
    this.body = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function With_(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.context_expr = a;
    this.optional_vars = b;
    this.body = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Raise(a, b, c, d, e) {
    this.type = a;
    this.inst = b;
    this.tback = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function TryExcept(a, b, c, d, e) {
    this.body = a;
    this.handlers = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function TryFinally(a, b, c, d) {
    this.body = a;
    this.finalbody = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Assert(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.test = a;
    this.msg = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Import_(a, b, c) {
    this.names = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function ImportFrom(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.module = a;
    this.names = b;
    this.level = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Exec(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.body = a;
    this.globals = b;
    this.locals = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Global(a, b, c) {
    this.names = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Expr(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.value = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Pass(a, b) {
    this.lineno = a;
    this.col_offset = b;
    return this;
  }
  function Break_(a, b) {
    this.lineno = a;
    this.col_offset = b;
    return this;
  }
  function Continue_(a, b) {
    this.lineno = a;
    this.col_offset = b;
    return this;
  }
  function BoolOp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.op = a;
    this.values = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function BinOp(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.left = a;
    this.op = b;
    this.right = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function UnaryOp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.op = a;
    this.operand = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Lambda(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.args = a;
    this.body = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function IfExp(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.test = a;
    this.body = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Dict(a, b, c, d) {
    this.keys = a;
    this.values = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function ListComp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.elt = a;
    this.generators = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function GeneratorExp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.elt = a;
    this.generators = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Yield(a, b, c) {
    this.value = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Compare(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.left = a;
    this.ops = b;
    this.comparators = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Call(a, b, c, d, e, f, g) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.func = a;
    this.args = b;
    this.keywords = c;
    this.starargs = d;
    this.kwargs = e;
    this.lineno = f;
    this.col_offset = g;
    return this;
  }
  function Num(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.n = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Str(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.s = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Attribute(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.value = a;
    this.attr = b;
    this.ctx = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Subscript(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.value = a;
    this.slice = b;
    this.ctx = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Name(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.id = a;
    this.ctx = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function List(a, b, c, d) {
    goog.asserts.assert(null !== b && void 0 !== b);
    this.elts = a;
    this.ctx = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Tuple(a, b, c, d) {
    goog.asserts.assert(null !== b && void 0 !== b);
    this.elts = a;
    this.ctx = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Ellipsis() {
    return this;
  }
  function Slice(a, b, c) {
    this.lower = a;
    this.upper = b;
    this.step = c;
    return this;
  }
  function ExtSlice(a) {
    this.dims = a;
    return this;
  }
  function Index(a) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.value = a;
    return this;
  }
  function comprehension(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.target = a;
    this.iter = b;
    this.ifs = c;
    return this;
  }
  function ExceptHandler(a, b, c, d, e) {
    this.type = a;
    this.name = b;
    this.body = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function arguments_(a, b, c, d) {
    this.args = a;
    this.vararg = b;
    this.kwarg = c;
    this.defaults = d;
    return this;
  }
  function keyword(a, b) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.arg = a;
    this.value = b;
    return this;
  }
  function alias(a, b) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.name = a;
    this.asname = b;
    return this;
  }
  Module.prototype._astname = 'Module';
  Module.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  Interactive.prototype._astname = 'Interactive';
  Interactive.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  Expression.prototype._astname = 'Expression';
  Expression.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  Suite.prototype._astname = 'Suite';
  Suite.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  FunctionDef.prototype._astname = 'FunctionDef';
  FunctionDef.prototype._fields = [
    'name',
    function (a) {
      return a.name;
    },
    'args',
    function (a) {
      return a.args;
    },
    'body',
    function (a) {
      return a.body;
    },
    'decorator_list',
    function (a) {
      return a.decorator_list;
    }
  ];
  ClassDef.prototype._astname = 'ClassDef';
  ClassDef.prototype._fields = [
    'name',
    function (a) {
      return a.name;
    },
    'bases',
    function (a) {
      return a.bases;
    },
    'body',
    function (a) {
      return a.body;
    },
    'decorator_list',
    function (a) {
      return a.decorator_list;
    }
  ];
  Return_.prototype._astname = 'Return';
  Return_.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  Delete_.prototype._astname = 'Delete';
  Delete_.prototype._fields = [
    'targets',
    function (a) {
      return a.targets;
    }
  ];
  Assign.prototype._astname = 'Assign';
  Assign.prototype._fields = [
    'targets',
    function (a) {
      return a.targets;
    },
    'value',
    function (a) {
      return a.value;
    }
  ];
  AugAssign.prototype._astname = 'AugAssign';
  AugAssign.prototype._fields = [
    'target',
    function (a) {
      return a.target;
    },
    'op',
    function (a) {
      return a.op;
    },
    'value',
    function (a) {
      return a.value;
    }
  ];
  Print.prototype._astname = 'Print';
  Print.prototype._fields = [
    'dest',
    function (a) {
      return a.dest;
    },
    'values',
    function (a) {
      return a.values;
    },
    'nl',
    function (a) {
      return a.nl;
    }
  ];
  For_.prototype._astname = 'For';
  For_.prototype._fields = [
    'target',
    function (a) {
      return a.target;
    },
    'iter',
    function (a) {
      return a.iter;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  While_.prototype._astname = 'While';
  While_.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  If_.prototype._astname = 'If';
  If_.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  With_.prototype._astname = 'With';
  With_.prototype._fields = [
    'context_expr',
    function (a) {
      return a.context_expr;
    },
    'optional_vars',
    function (a) {
      return a.optional_vars;
    },
    'body',
    function (a) {
      return a.body;
    }
  ];
  Raise.prototype._astname = 'Raise';
  Raise.prototype._fields = [
    'type',
    function (a) {
      return a.type;
    },
    'inst',
    function (a) {
      return a.inst;
    },
    'tback',
    function (a) {
      return a.tback;
    }
  ];
  TryExcept.prototype._astname = 'TryExcept';
  TryExcept.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    },
    'handlers',
    function (a) {
      return a.handlers;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  TryFinally.prototype._astname = 'TryFinally';
  TryFinally.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    },
    'finalbody',
    function (a) {
      return a.finalbody;
    }
  ];
  Assert.prototype._astname = 'Assert';
  Assert.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'msg',
    function (a) {
      return a.msg;
    }
  ];
  Import_.prototype._astname = 'Import';
  Import_.prototype._fields = [
    'names',
    function (a) {
      return a.names;
    }
  ];
  ImportFrom.prototype._astname = 'ImportFrom';
  ImportFrom.prototype._fields = [
    'module',
    function (a) {
      return a.module;
    },
    'names',
    function (a) {
      return a.names;
    },
    'level',
    function (a) {
      return a.level;
    }
  ];
  Exec.prototype._astname = 'Exec';
  Exec.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    },
    'globals',
    function (a) {
      return a.globals;
    },
    'locals',
    function (a) {
      return a.locals;
    }
  ];
  Global.prototype._astname = 'Global';
  Global.prototype._fields = [
    'names',
    function (a) {
      return a.names;
    }
  ];
  Expr.prototype._astname = 'Expr';
  Expr.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  Pass.prototype._astname = 'Pass';
  Pass.prototype._fields = [];
  Break_.prototype._astname = 'Break';
  Break_.prototype._fields = [];
  Continue_.prototype._astname = 'Continue';
  Continue_.prototype._fields = [];
  BoolOp.prototype._astname = 'BoolOp';
  BoolOp.prototype._fields = [
    'op',
    function (a) {
      return a.op;
    },
    'values',
    function (a) {
      return a.values;
    }
  ];
  BinOp.prototype._astname = 'BinOp';
  BinOp.prototype._fields = [
    'left',
    function (a) {
      return a.left;
    },
    'op',
    function (a) {
      return a.op;
    },
    'right',
    function (a) {
      return a.right;
    }
  ];
  UnaryOp.prototype._astname = 'UnaryOp';
  UnaryOp.prototype._fields = [
    'op',
    function (a) {
      return a.op;
    },
    'operand',
    function (a) {
      return a.operand;
    }
  ];
  Lambda.prototype._astname = 'Lambda';
  Lambda.prototype._fields = [
    'args',
    function (a) {
      return a.args;
    },
    'body',
    function (a) {
      return a.body;
    }
  ];
  IfExp.prototype._astname = 'IfExp';
  IfExp.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  Dict.prototype._astname = 'Dict';
  Dict.prototype._fields = [
    'keys',
    function (a) {
      return a.keys;
    },
    'values',
    function (a) {
      return a.values;
    }
  ];
  ListComp.prototype._astname = 'ListComp';
  ListComp.prototype._fields = [
    'elt',
    function (a) {
      return a.elt;
    },
    'generators',
    function (a) {
      return a.generators;
    }
  ];
  GeneratorExp.prototype._astname = 'GeneratorExp';
  GeneratorExp.prototype._fields = [
    'elt',
    function (a) {
      return a.elt;
    },
    'generators',
    function (a) {
      return a.generators;
    }
  ];
  Yield.prototype._astname = 'Yield';
  Yield.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  Compare.prototype._astname = 'Compare';
  Compare.prototype._fields = [
    'left',
    function (a) {
      return a.left;
    },
    'ops',
    function (a) {
      return a.ops;
    },
    'comparators',
    function (a) {
      return a.comparators;
    }
  ];
  Call.prototype._astname = 'Call';
  Call.prototype._fields = [
    'func',
    function (a) {
      return a.func;
    },
    'args',
    function (a) {
      return a.args;
    },
    'keywords',
    function (a) {
      return a.keywords;
    },
    'starargs',
    function (a) {
      return a.starargs;
    },
    'kwargs',
    function (a) {
      return a.kwargs;
    }
  ];
  Num.prototype._astname = 'Num';
  Num.prototype._fields = [
    'n',
    function (a) {
      return a.n;
    }
  ];
  Str.prototype._astname = 'Str';
  Str.prototype._fields = [
    's',
    function (a) {
      return a.s;
    }
  ];
  Attribute.prototype._astname = 'Attribute';
  Attribute.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    },
    'attr',
    function (a) {
      return a.attr;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Subscript.prototype._astname = 'Subscript';
  Subscript.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    },
    'slice',
    function (a) {
      return a.slice;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Name.prototype._astname = 'Name';
  Name.prototype._fields = [
    'id',
    function (a) {
      return a.id;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  List.prototype._astname = 'List';
  List.prototype._fields = [
    'elts',
    function (a) {
      return a.elts;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Tuple.prototype._astname = 'Tuple';
  Tuple.prototype._fields = [
    'elts',
    function (a) {
      return a.elts;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Load.prototype._astname = 'Load';
  Load.prototype._isenum = !0;
  Store.prototype._astname = 'Store';
  Store.prototype._isenum = !0;
  Del.prototype._astname = 'Del';
  Del.prototype._isenum = !0;
  AugLoad.prototype._astname = 'AugLoad';
  AugLoad.prototype._isenum = !0;
  AugStore.prototype._astname = 'AugStore';
  AugStore.prototype._isenum = !0;
  Param.prototype._astname = 'Param';
  Param.prototype._isenum = !0;
  Ellipsis.prototype._astname = 'Ellipsis';
  Ellipsis.prototype._fields = [];
  Slice.prototype._astname = 'Slice';
  Slice.prototype._fields = [
    'lower',
    function (a) {
      return a.lower;
    },
    'upper',
    function (a) {
      return a.upper;
    },
    'step',
    function (a) {
      return a.step;
    }
  ];
  ExtSlice.prototype._astname = 'ExtSlice';
  ExtSlice.prototype._fields = [
    'dims',
    function (a) {
      return a.dims;
    }
  ];
  Index.prototype._astname = 'Index';
  Index.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  And.prototype._astname = 'And';
  And.prototype._isenum = !0;
  Or.prototype._astname = 'Or';
  Or.prototype._isenum = !0;
  Add.prototype._astname = 'Add';
  Add.prototype._isenum = !0;
  Sub.prototype._astname = 'Sub';
  Sub.prototype._isenum = !0;
  Mult.prototype._astname = 'Mult';
  Mult.prototype._isenum = !0;
  Div.prototype._astname = 'Div';
  Div.prototype._isenum = !0;
  Mod.prototype._astname = 'Mod';
  Mod.prototype._isenum = !0;
  Pow.prototype._astname = 'Pow';
  Pow.prototype._isenum = !0;
  LShift.prototype._astname = 'LShift';
  LShift.prototype._isenum = !0;
  RShift.prototype._astname = 'RShift';
  RShift.prototype._isenum = !0;
  BitOr.prototype._astname = 'BitOr';
  BitOr.prototype._isenum = !0;
  BitXor.prototype._astname = 'BitXor';
  BitXor.prototype._isenum = !0;
  BitAnd.prototype._astname = 'BitAnd';
  BitAnd.prototype._isenum = !0;
  FloorDiv.prototype._astname = 'FloorDiv';
  FloorDiv.prototype._isenum = !0;
  Invert.prototype._astname = 'Invert';
  Invert.prototype._isenum = !0;
  Not.prototype._astname = 'Not';
  Not.prototype._isenum = !0;
  UAdd.prototype._astname = 'UAdd';
  UAdd.prototype._isenum = !0;
  USub.prototype._astname = 'USub';
  USub.prototype._isenum = !0;
  Eq.prototype._astname = 'Eq';
  Eq.prototype._isenum = !0;
  NotEq.prototype._astname = 'NotEq';
  NotEq.prototype._isenum = !0;
  Lt.prototype._astname = 'Lt';
  Lt.prototype._isenum = !0;
  LtE.prototype._astname = 'LtE';
  LtE.prototype._isenum = !0;
  Gt.prototype._astname = 'Gt';
  Gt.prototype._isenum = !0;
  GtE.prototype._astname = 'GtE';
  GtE.prototype._isenum = !0;
  Is.prototype._astname = 'Is';
  Is.prototype._isenum = !0;
  IsNot.prototype._astname = 'IsNot';
  IsNot.prototype._isenum = !0;
  In_.prototype._astname = 'In';
  In_.prototype._isenum = !0;
  NotIn.prototype._astname = 'NotIn';
  NotIn.prototype._isenum = !0;
  comprehension.prototype._astname = 'comprehension';
  comprehension.prototype._fields = [
    'target',
    function (a) {
      return a.target;
    },
    'iter',
    function (a) {
      return a.iter;
    },
    'ifs',
    function (a) {
      return a.ifs;
    }
  ];
  ExceptHandler.prototype._astname = 'ExceptHandler';
  ExceptHandler.prototype._fields = [
    'type',
    function (a) {
      return a.type;
    },
    'name',
    function (a) {
      return a.name;
    },
    'body',
    function (a) {
      return a.body;
    }
  ];
  arguments_.prototype._astname = 'arguments';
  arguments_.prototype._fields = [
    'args',
    function (a) {
      return a.args;
    },
    'vararg',
    function (a) {
      return a.vararg;
    },
    'kwarg',
    function (a) {
      return a.kwarg;
    },
    'defaults',
    function (a) {
      return a.defaults;
    }
  ];
  keyword.prototype._astname = 'keyword';
  keyword.prototype._fields = [
    'arg',
    function (a) {
      return a.arg;
    },
    'value',
    function (a) {
      return a.value;
    }
  ];
  alias.prototype._astname = 'alias';
  alias.prototype._fields = [
    'name',
    function (a) {
      return a.name;
    },
    'asname',
    function (a) {
      return a.asname;
    }
  ];
  var SYM = Sk.ParseTables.sym, TOK = Sk.Tokenizer.Tokens;
  function Compiling(a, b) {
    this.c_encoding = a;
    this.c_filename = b;
  }
  function NCH(a) {
    goog.asserts.assert(void 0 !== a);
    return null === a.children ? 0 : a.children.length;
  }
  function CHILD(a, b) {
    goog.asserts.assert(void 0 !== a);
    goog.asserts.assert(void 0 !== b);
    return a.children[b];
  }
  function REQ(a, b) {
    goog.asserts.assert(a.type === b, 'node wasn\'t expected type');
  }
  function strobj(a) {
    goog.asserts.assert('string' === typeof a, 'expecting string, got ' + typeof a);
    return new Sk.builtin.str(a);
  }
  function numStmts(a) {
    switch (a.type) {
    case SYM.single_input:
      if (CHILD(a, 0).type === TOK.T_NEWLINE)
        break;
      else
        return numStmts(CHILD(a, 0));
    case SYM.file_input:
      for (var b = 0, c = 0; c < NCH(a); ++c) {
        var d = CHILD(a, c);
        d.type === SYM.stmt && (b += numStmts(d));
      }
      return b;
    case SYM.stmt:
      return numStmts(CHILD(a, 0));
    case SYM.compound_stmt:
      return 1;
    case SYM.simple_stmt:
      return Math.floor(NCH(a) / 2);
    case SYM.suite:
      if (1 === NCH(a))
        return numStmts(CHILD(a, 0));
      b = 0;
      for (c = 2; c < NCH(a) - 1; ++c)
        b += numStmts(CHILD(a, c));
      return b;
    default:
      goog.asserts.fail('Non-statement found');
    }
    return 0;
  }
  function forbiddenCheck(a, b, c, d) {
    if ('None' === c)
      throw new Sk.builtin.SyntaxError('assignment to None', a.c_filename, d);
    if ('True' === c || 'False' === c)
      throw new Sk.builtin.SyntaxError('assignment to True or False is forbidden', a.c_filename, d);
  }
  function setContext(a, b, c, d) {
    goog.asserts.assert(c !== AugStore && c !== AugLoad);
    var e = null, f = null;
    switch (b.constructor) {
    case Attribute:
    case Name:
      c === Store && forbiddenCheck(a, d, b.attr, d.lineno);
      b.ctx = c;
      break;
    case Subscript:
      b.ctx = c;
      break;
    case List:
      b.ctx = c;
      e = b.elts;
      break;
    case Tuple:
      if (0 === b.elts.length)
        throw new Sk.builtin.SyntaxError('can\'t assign to ()', a.c_filename, d.lineno);
      b.ctx = c;
      e = b.elts;
      break;
    case Lambda:
      f = 'lambda';
      break;
    case Call:
      f = 'function call';
      break;
    case BoolOp:
    case BinOp:
    case UnaryOp:
      f = 'operator';
      break;
    case GeneratorExp:
      f = 'generator expression';
      break;
    case Yield:
      f = 'yield expression';
      break;
    case ListComp:
      f = 'list comprehension';
      break;
    case Dict:
    case Num:
    case Str:
      f = 'literal';
      break;
    case Compare:
      f = 'comparison';
      break;
    case IfExp:
      f = 'conditional expression';
      break;
    default:
      goog.asserts.fail('unhandled expression in assignment');
    }
    if (f)
      throw new Sk.builtin.SyntaxError('can\'t ' + (c === Store ? 'assign to' : 'delete') + ' ' + f, a.c_filename, d.lineno);
    if (e)
      for (b = 0; b < e.length; ++b)
        setContext(a, e[b], c, d);
  }
  var operatorMap = {};
  (function () {
    operatorMap[TOK.T_VBAR] = BitOr;
    operatorMap[TOK.T_VBAR] = BitOr;
    operatorMap[TOK.T_CIRCUMFLEX] = BitXor;
    operatorMap[TOK.T_AMPER] = BitAnd;
    operatorMap[TOK.T_LEFTSHIFT] = LShift;
    operatorMap[TOK.T_RIGHTSHIFT] = RShift;
    operatorMap[TOK.T_PLUS] = Add;
    operatorMap[TOK.T_MINUS] = Sub;
    operatorMap[TOK.T_STAR] = Mult;
    operatorMap[TOK.T_SLASH] = Div;
    operatorMap[TOK.T_DOUBLESLASH] = FloorDiv;
    operatorMap[TOK.T_PERCENT] = Mod;
  }());
  function getOperator(a) {
    goog.asserts.assert(void 0 !== operatorMap[a.type]);
    return operatorMap[a.type];
  }
  function astForCompOp(a, b) {
    REQ(b, SYM.comp_op);
    if (1 === NCH(b))
      switch (b = CHILD(b, 0), b.type) {
      case TOK.T_LESS:
        return Lt;
      case TOK.T_GREATER:
        return Gt;
      case TOK.T_EQEQUAL:
        return Eq;
      case TOK.T_LESSEQUAL:
        return LtE;
      case TOK.T_GREATEREQUAL:
        return GtE;
      case TOK.T_NOTEQUAL:
        return NotEq;
      case TOK.T_NAME:
        if ('in' === b.value)
          return In_;
        if ('is' === b.value)
          return Is;
      }
    else if (2 === NCH(b) && CHILD(b, 0).type === TOK.T_NAME) {
      if ('in' === CHILD(b, 1).value)
        return NotIn;
      if ('is' === CHILD(b, 0).value)
        return IsNot;
    }
    goog.asserts.fail('invalid comp_op');
  }
  function seqForTestlist(a, b) {
    goog.asserts.assert(b.type === SYM.testlist || b.type === SYM.listmaker || b.type === SYM.testlist_gexp || b.type === SYM.testlist_safe || b.type === SYM.testlist1);
    for (var c = [], d = 0; d < NCH(b); d += 2)
      goog.asserts.assert(CHILD(b, d).type === SYM.test || CHILD(b, d).type === SYM.old_test), c[d / 2] = astForExpr(a, CHILD(b, d));
    return c;
  }
  function astForSuite(a, b) {
    REQ(b, SYM.suite);
    var c = [], d = 0, e;
    if (CHILD(b, 0).type === SYM.simple_stmt) {
      b = CHILD(b, 0);
      e = NCH(b) - 1;
      CHILD(b, e - 1).type === TOK.T_SEMI && (e -= 1);
      for (var f = 0; f < e; f += 2)
        c[d++] = astForStmt(a, CHILD(b, f));
    } else
      for (f = 2; f < NCH(b) - 1; ++f)
        if (e = CHILD(b, f), REQ(e, SYM.stmt), 1 === numStmts(e))
          c[d++] = astForStmt(a, e);
        else {
          e = CHILD(e, 0);
          REQ(e, SYM.simple_stmt);
          for (var g = 0; g < NCH(e); g += 2) {
            if (0 === NCH(CHILD(e, g))) {
              goog.asserts.assert(g + 1 === NCH(e));
              break;
            }
            c[d++] = astForStmt(a, CHILD(e, g));
          }
        }
    goog.asserts.assert(d === numStmts(b));
    return c;
  }
  function astForExceptClause(a, b, c) {
    REQ(b, SYM.except_clause);
    REQ(c, SYM.suite);
    if (1 === NCH(b))
      return new ExceptHandler(null, null, astForSuite(a, c), b.lineno, b.col_offset);
    if (2 === NCH(b))
      return new ExceptHandler(astForExpr(a, CHILD(b, 1)), null, astForSuite(a, c), b.lineno, b.col_offset);
    if (4 === NCH(b)) {
      var d = astForExpr(a, CHILD(b, 3));
      setContext(a, d, Store, CHILD(b, 3));
      return new ExceptHandler(astForExpr(a, CHILD(b, 1)), d, astForSuite(a, c), b.lineno, b.col_offset);
    }
    goog.asserts.fail('wrong number of children for except clause');
  }
  function astForTryStmt(a, b) {
    var c = NCH(b), d = (c - 3) / 3, e, f = [], g = null;
    REQ(b, SYM.try_stmt);
    e = astForSuite(a, CHILD(b, 2));
    if (CHILD(b, c - 3).type === TOK.T_NAME)
      'finally' === CHILD(b, c - 3).value ? (9 <= c && CHILD(b, c - 6).type === TOK.T_NAME && (f = astForSuite(a, CHILD(b, c - 4)), d--), g = astForSuite(a, CHILD(b, c - 1))) : f = astForSuite(a, CHILD(b, c - 1)), d--;
    else if (CHILD(b, c - 3).type !== SYM.except_clause)
      throw new Sk.builtin.SyntaxError('malformed \'try\' statement', a.c_filename, b.lineno);
    if (0 < d) {
      for (var c = [], h = 0; h < d; ++h)
        c[h] = astForExceptClause(a, CHILD(b, 3 + 3 * h), CHILD(b, 5 + 3 * h));
      d = new TryExcept(e, c, f, b.lineno, b.col_offset);
      if (!g)
        return d;
      e = [d];
    }
    goog.asserts.assert(null !== g);
    return new TryFinally(e, g, b.lineno, b.col_offset);
  }
  function astForDottedName(a, b) {
    REQ(b, SYM.dotted_name);
    for (var c = b.lineno, d = b.col_offset, e = strobj(CHILD(b, 0).value), f = new Name(e, Load, c, d), g = 2; g < NCH(b); g += 2)
      e = strobj(CHILD(b, g).value), f = new Attribute(f, e, Load, c, d);
    return f;
  }
  function astForDecorator(a, b) {
    REQ(b, SYM.decorator);
    REQ(CHILD(b, 0), TOK.T_AT);
    REQ(CHILD(b, NCH(b) - 1), TOK.T_NEWLINE);
    var c = astForDottedName(a, CHILD(b, 1));
    return 3 === NCH(b) ? c : 5 === NCH(b) ? new Call(c, [], [], null, null, b.lineno, b.col_offset) : astForCall(a, CHILD(b, 3), c);
  }
  function astForDecorators(a, b) {
    REQ(b, SYM.decorators);
    for (var c = [], d = 0; d < NCH(b); ++d)
      c[d] = astForDecorator(a, CHILD(b, d));
    return c;
  }
  function astForDecorated(a, b) {
    REQ(b, SYM.decorated);
    var c = astForDecorators(a, CHILD(b, 0));
    goog.asserts.assert(CHILD(b, 1).type === SYM.funcdef || CHILD(b, 1).type === SYM.classdef);
    var d = null;
    CHILD(b, 1).type === SYM.funcdef ? d = astForFuncdef(a, CHILD(b, 1), c) : CHILD(b, 1) === SYM.classdef && (d = astForClassdef(a, CHILD(b, 1), c));
    d && (d.lineno = b.lineno, d.col_offset = b.col_offset);
    return d;
  }
  function astForWithVar(a, b) {
    REQ(b, SYM.with_var);
    return astForExpr(a, CHILD(b, 1));
  }
  function astForWithStmt(a, b) {
    var c = 3;
    goog.asserts.assert(b.type === SYM.with_stmt);
    var d = astForExpr(a, CHILD(b, 1));
    if (CHILD(b, 2).type === SYM.with_var) {
      var e = astForWithVar(a, CHILD(b, 2));
      setContext(a, e, Store, b);
      c = 4;
    }
    return new With_(d, e, astForSuite(a, CHILD(b, c)), b.lineno, b.col_offset);
  }
  function astForExecStmt(a, b) {
    var c, d = null, e = null, f = NCH(b);
    goog.asserts.assert(2 === f || 4 === f || 6 === f);
    REQ(b, SYM.exec_stmt);
    c = astForExpr(a, CHILD(b, 1));
    4 <= f && (d = astForExpr(a, CHILD(b, 3)));
    6 === f && (e = astForExpr(a, CHILD(b, 5)));
    return new Exec(c, d, e, b.lineno, b.col_offset);
  }
  function astForIfStmt(a, b) {
    REQ(b, SYM.if_stmt);
    if (4 === NCH(b))
      return new If_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), [], b.lineno, b.col_offset);
    var c = CHILD(b, 4).value.charAt(2);
    if ('s' === c)
      return new If_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), astForSuite(a, CHILD(b, 6)), b.lineno, b.col_offset);
    if ('i' === c) {
      var c = NCH(b) - 4, d = !1, e = [];
      CHILD(b, c + 1).type === TOK.T_NAME && 's' === CHILD(b, c + 1).value.charAt(2) && (d = !0, c -= 3);
      c /= 4;
      d && (e = [new If_(astForExpr(a, CHILD(b, NCH(b) - 6)), astForSuite(a, CHILD(b, NCH(b) - 4)), astForSuite(a, CHILD(b, NCH(b) - 1)), CHILD(b, NCH(b) - 6).lineno, CHILD(b, NCH(b) - 6).col_offset)], c--);
      for (d = 0; d < c; ++d)
        var f = 5 + 4 * (c - d - 1), e = [new If_(astForExpr(a, CHILD(b, f)), astForSuite(a, CHILD(b, f + 2)), e, CHILD(b, f).lineno, CHILD(b, f).col_offset)];
      return new If_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), e, b.lineno, b.col_offset);
    }
    goog.asserts.fail('unexpected token in \'if\' statement');
  }
  function astForExprlist(a, b, c) {
    REQ(b, SYM.exprlist);
    for (var d = [], e = 0; e < NCH(b); e += 2) {
      var f = astForExpr(a, CHILD(b, e));
      d[e / 2] = f;
      c && setContext(a, f, c, CHILD(b, e));
    }
    return d;
  }
  function astForDelStmt(a, b) {
    REQ(b, SYM.del_stmt);
    return new Delete_(astForExprlist(a, CHILD(b, 1), Del), b.lineno, b.col_offset);
  }
  function astForGlobalStmt(a, b) {
    REQ(b, SYM.global_stmt);
    for (var c = [], d = 1; d < NCH(b); d += 2)
      c[(d - 1) / 2] = strobj(CHILD(b, d).value);
    return new Global(c, b.lineno, b.col_offset);
  }
  function astForAssertStmt(a, b) {
    REQ(b, SYM.assert_stmt);
    if (2 === NCH(b))
      return new Assert(astForExpr(a, CHILD(b, 1)), null, b.lineno, b.col_offset);
    if (4 === NCH(b))
      return new Assert(astForExpr(a, CHILD(b, 1)), astForExpr(a, CHILD(b, 3)), b.lineno, b.col_offset);
    goog.asserts.fail('improper number of parts to assert stmt');
  }
  function aliasForImportName(a, b) {
    a:
      for (;;)
        switch (b.type) {
        case SYM.import_as_name:
          var c = null, d = strobj(CHILD(b, 0).value);
          3 === NCH(b) && (c = CHILD(b, 2).value);
          return new alias(d, null == c ? null : strobj(c));
        case SYM.dotted_as_name:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          } else
            return c = aliasForImportName(a, CHILD(b, 0)), goog.asserts.assert(!c.asname), c.asname = strobj(CHILD(b, 2).value), c;
        case SYM.dotted_name:
          if (1 === NCH(b))
            return new alias(strobj(CHILD(b, 0).value), null);
          c = '';
          for (d = 0; d < NCH(b); d += 2)
            c += CHILD(b, d).value + '.';
          return new alias(strobj(c.substr(0, c.length - 1)), null);
        case TOK.T_STAR:
          return new alias(strobj('*'), null);
        default:
          throw new Sk.builtin.SyntaxError('unexpected import name', a.c_filename, b.lineno);
        }
  }
  function astForImportStmt(a, b) {
    REQ(b, SYM.import_stmt);
    var c = b.lineno, d = b.col_offset;
    b = CHILD(b, 0);
    if (b.type === SYM.import_name) {
      b = CHILD(b, 1);
      REQ(b, SYM.dotted_as_names);
      for (var e = [], f = 0; f < NCH(b); f += 2)
        e[f / 2] = aliasForImportName(a, CHILD(b, f));
      return new Import_(e, c, d);
    }
    if (b.type === SYM.import_from) {
      for (var g = null, h = 0, e = 1; e < NCH(b); ++e) {
        if (CHILD(b, e).type === SYM.dotted_name) {
          g = aliasForImportName(a, CHILD(b, e));
          e++;
          break;
        } else if (CHILD(b, e).type !== TOK.T_DOT)
          break;
        h++;
      }
      ++e;
      switch (CHILD(b, e).type) {
      case TOK.T_STAR:
        b = CHILD(b, e);
        break;
      case TOK.T_LPAR:
        b = CHILD(b, e + 1);
        NCH(b);
        break;
      case SYM.import_as_names:
        b = CHILD(b, e);
        e = NCH(b);
        if (0 === e % 2)
          throw new Sk.builtin.SyntaxError('trailing comma not allowed without surrounding parentheses', a.c_filename, b.lineno);
        break;
      default:
        throw new Sk.builtin.SyntaxError('Unexpected node-type in from-import', a.c_filename, b.lineno);
      }
      e = [];
      if (b.type === TOK.T_STAR)
        e[0] = aliasForImportName(a, b);
      else
        for (f = 0; f < NCH(b); f += 2)
          e[f / 2] = aliasForImportName(a, CHILD(b, f));
      return new ImportFrom(strobj(g ? g.name.v : ''), e, h, c, d);
    }
    throw new Sk.builtin.SyntaxError('unknown import statement', a.c_filename, b.lineno);
  }
  function astForTestlistGexp(a, b) {
    goog.asserts.assert(b.type === SYM.testlist_gexp || b.type === SYM.argument);
    return 1 < NCH(b) && CHILD(b, 1).type === SYM.gen_for ? astForGenexp(a, b) : astForTestlist(a, b);
  }
  function astForListcomp(a, b) {
    function c(a, b) {
      for (var c = 0;;) {
        REQ(b, SYM.list_iter);
        if (CHILD(b, 0).type === SYM.list_for)
          return c;
        b = CHILD(b, 0);
        REQ(b, SYM.list_if);
        c++;
        if (2 == NCH(b))
          return c;
        b = CHILD(b, 2);
      }
    }
    REQ(b, SYM.listmaker);
    goog.asserts.assert(1 < NCH(b));
    for (var d = astForExpr(a, CHILD(b, 0)), e = function (a, b) {
          var c = 0, d = CHILD(b, 1);
          a:
            for (;;) {
              c++;
              REQ(d, SYM.list_for);
              if (5 === NCH(d))
                d = CHILD(d, 4);
              else
                return c;
              b:
                for (;;) {
                  REQ(d, SYM.list_iter);
                  d = CHILD(d, 0);
                  if (d.type === SYM.list_for)
                    continue a;
                  else if (d.type === SYM.list_if)
                    if (3 === NCH(d)) {
                      d = CHILD(d, 2);
                      continue b;
                    } else
                      return c;
                  break;
                }
              break;
            }
        }(a, b), f = [], g = CHILD(b, 1), h = 0; h < e; ++h) {
      REQ(g, SYM.list_for);
      var k = CHILD(g, 1), l = astForExprlist(a, k, Store), m = astForTestlist(a, CHILD(g, 3)), k = 1 === NCH(k) ? new comprehension(l[0], m, []) : new comprehension(new Tuple(l, Store, g.lineno, g.col_offset), m, []);
      if (5 === NCH(g)) {
        for (var g = CHILD(g, 4), l = c(a, g), m = [], n = 0; n < l; ++n)
          REQ(g, SYM.list_iter), g = CHILD(g, 0), REQ(g, SYM.list_if), m[n] = astForExpr(a, CHILD(g, 1)), 3 === NCH(g) && (g = CHILD(g, 2));
        g.type === SYM.list_iter && (g = CHILD(g, 0));
        k.ifs = m;
      }
      f[h] = k;
    }
    return new ListComp(d, f, b.lineno, b.col_offset);
  }
  function astForFactor(a, b) {
    if (CHILD(b, 0).type === TOK.T_MINUS && 2 === NCH(b)) {
      var c = CHILD(b, 1);
      if (c.type === SYM.factor && 1 === NCH(c) && (c = CHILD(c, 0), c.type === SYM.power && 1 === NCH(c) && (c = CHILD(c, 0), c.type === SYM.atom))) {
        var d = CHILD(c, 0);
        if (d.type === TOK.T_NUMBER)
          return d.value = '-' + d.value, astForAtom(a, c);
      }
    }
    c = astForExpr(a, CHILD(b, 1));
    switch (CHILD(b, 0).type) {
    case TOK.T_PLUS:
      return new UnaryOp(UAdd, c, b.lineno, b.col_offset);
    case TOK.T_MINUS:
      return new UnaryOp(USub, c, b.lineno, b.col_offset);
    case TOK.T_TILDE:
      return new UnaryOp(Invert, c, b.lineno, b.col_offset);
    }
    goog.asserts.fail('unhandled factor');
  }
  function astForForStmt(a, b) {
    var c = [];
    REQ(b, SYM.for_stmt);
    9 === NCH(b) && (c = astForSuite(a, CHILD(b, 8)));
    var d = CHILD(b, 1), e = astForExprlist(a, d, Store), d = 1 === NCH(d) ? e[0] : new Tuple(e, Store, b.lineno, b.col_offset);
    return new For_(d, astForTestlist(a, CHILD(b, 3)), astForSuite(a, CHILD(b, 5)), c, b.lineno, b.col_offset);
  }
  function astForCall(a, b, c) {
    REQ(b, SYM.arglist);
    for (var d = 0, e = 0, f = 0, g = 0; g < NCH(b); ++g) {
      var h = CHILD(b, g);
      h.type === SYM.argument && (1 === NCH(h) ? d++ : CHILD(h, 1).type === SYM.gen_for ? f++ : e++);
    }
    if (1 < f || f && (d || e))
      throw new Sk.builtin.SyntaxError('Generator expression must be parenthesized if not sole argument', a.c_filename, b.lineno);
    if (255 < d + e + f)
      throw new Sk.builtin.SyntaxError('more than 255 arguments', a.c_filename, b.lineno);
    for (var f = [], k = [], e = d = 0, l = null, m = null, g = 0; g < NCH(b); ++g)
      if (h = CHILD(b, g), h.type === SYM.argument)
        if (1 === NCH(h)) {
          if (e)
            throw new Sk.builtin.SyntaxError('non-keyword arg after keyword arg', a.c_filename, b.lineno);
          if (l)
            throw new Sk.builtin.SyntaxError('only named arguments may follow *expression', a.c_filename, b.lineno);
          f[d++] = astForExpr(a, CHILD(h, 0));
        } else if (CHILD(h, 1).type === SYM.gen_for)
          f[d++] = astForGenexp(a, h);
        else {
          var n = astForExpr(a, CHILD(h, 0));
          if (n.constructor === Lambda)
            throw new Sk.builtin.SyntaxError('lambda cannot contain assignment', a.c_filename, b.lineno);
          if (n.constructor !== Name)
            throw new Sk.builtin.SyntaxError('keyword can\'t be an expression', a.c_filename, b.lineno);
          n = n.id;
          forbiddenCheck(a, CHILD(h, 0), n, b.lineno);
          for (var p = 0; p < e; ++p)
            if (k[p].arg === n)
              throw new Sk.builtin.SyntaxError('keyword argument repeated', a.c_filename, b.lineno);
          k[e++] = new keyword(n, astForExpr(a, CHILD(h, 2)));
        }
      else
        h.type === TOK.T_STAR ? l = astForExpr(a, CHILD(b, ++g)) : h.type === TOK.T_DOUBLESTAR && (m = astForExpr(a, CHILD(b, ++g)));
    return new Call(c, f, k, l, m, c.lineno, c.col_offset);
  }
  function astForTrailer(a, b, c) {
    REQ(b, SYM.trailer);
    if (CHILD(b, 0).type === TOK.T_LPAR)
      return 2 === NCH(b) ? new Call(c, [], [], null, null, b.lineno, b.col_offset) : astForCall(a, CHILD(b, 1), c);
    if (CHILD(b, 0).type === TOK.T_DOT)
      return new Attribute(c, strobj(CHILD(b, 1).value), Load, b.lineno, b.col_offset);
    REQ(CHILD(b, 0), TOK.T_LSQB);
    REQ(CHILD(b, 2), TOK.T_RSQB);
    b = CHILD(b, 1);
    if (1 === NCH(b))
      return new Subscript(c, astForSlice(a, CHILD(b, 0)), Load, b.lineno, b.col_offset);
    for (var d = !0, e = [], f = 0; f < NCH(b); f += 2) {
      var g = astForSlice(a, CHILD(b, f));
      g.constructor !== Index && (d = !1);
      e[f / 2] = g;
    }
    if (!d)
      return new Subscript(c, new ExtSlice(e), Load, b.lineno, b.col_offset);
    a = [];
    for (f = 0; f < e.length; ++f)
      g = e[f], goog.asserts.assert(g.constructor === Index && null !== g.value && void 0 !== g.value), a[f] = g.value;
    e = new Tuple(a, Load, b.lineno, b.col_offset);
    return new Subscript(c, new Index(e), Load, b.lineno, b.col_offset);
  }
  function astForFlowStmt(a, b) {
    var c;
    REQ(b, SYM.flow_stmt);
    c = CHILD(b, 0);
    switch (c.type) {
    case SYM.break_stmt:
      return new Break_(b.lineno, b.col_offset);
    case SYM.continue_stmt:
      return new Continue_(b.lineno, b.col_offset);
    case SYM.yield_stmt:
      return new Expr(astForExpr(a, CHILD(c, 0)), b.lineno, b.col_offset);
    case SYM.return_stmt:
      return 1 === NCH(c) ? new Return_(null, b.lineno, b.col_offset) : new Return_(astForTestlist(a, CHILD(c, 1)), b.lineno, b.col_offset);
    case SYM.raise_stmt:
      if (1 === NCH(c))
        return new Raise(null, null, null, b.lineno, b.col_offset);
      if (2 === NCH(c))
        return new Raise(astForExpr(a, CHILD(c, 1)), null, null, b.lineno, b.col_offset);
      if (4 === NCH(c))
        return new Raise(astForExpr(a, CHILD(c, 1)), astForExpr(a, CHILD(c, 3)), null, b.lineno, b.col_offset);
      if (6 === NCH(c))
        return new Raise(astForExpr(a, CHILD(c, 1)), astForExpr(a, CHILD(c, 3)), astForExpr(a, CHILD(c, 5)), b.lineno, b.col_offset);
    default:
      goog.asserts.fail('unexpected flow_stmt');
    }
    goog.asserts.fail('unhandled flow statement');
  }
  function astForArguments(a, b) {
    var c, d = null, e = null;
    if (b.type === SYM.parameters) {
      if (2 === NCH(b))
        return new arguments_([], null, null, []);
      b = CHILD(b, 1);
    }
    REQ(b, SYM.varargslist);
    for (var f = [], g = [], h = !1, k = 0, l = 0, m = 0; k < NCH(b);)
      switch (c = CHILD(b, k), c.type) {
      case SYM.fpdef:
        var n = 0;
        a:
          for (;;) {
            if (k + 1 < NCH(b) && CHILD(b, k + 1).type === TOK.T_EQUAL)
              g[l++] = astForExpr(a, CHILD(b, k + 2)), k += 2, h = !0;
            else if (h) {
              if (n)
                throw new Sk.builtin.SyntaxError('parenthesized arg with default', a.c_filename, b.lineno);
              throw new Sk.builtin.SyntaxError('non-default argument follows default argument', a.c_filename, b.lineno);
            }
            if (3 === NCH(c)) {
              c = CHILD(c, 1);
              if (1 !== NCH(c))
                throw new Sk.builtin.SyntaxError('tuple parameter unpacking has been removed', a.c_filename, b.lineno);
              n = !0;
              c = CHILD(c, 0);
              goog.asserts.assert(c.type === SYM.fpdef);
              continue a;
            }
            if (CHILD(c, 0).type === TOK.T_NAME) {
              forbiddenCheck(a, b, CHILD(c, 0).value, b.lineno);
              var p = strobj(CHILD(c, 0).value);
              f[m++] = new Name(p, Param, c.lineno, c.col_offset);
            }
            k += 2;
            if (n)
              throw new Sk.builtin.SyntaxError('parenthesized argument names are invalid', a.c_filename, b.lineno);
            break;
          }
        break;
      case TOK.T_STAR:
        forbiddenCheck(a, CHILD(b, k + 1), CHILD(b, k + 1).value, b.lineno);
        d = strobj(CHILD(b, k + 1).value);
        k += 3;
        break;
      case TOK.T_DOUBLESTAR:
        forbiddenCheck(a, CHILD(b, k + 1), CHILD(b, k + 1).value, b.lineno);
        e = strobj(CHILD(b, k + 1).value);
        k += 3;
        break;
      default:
        goog.asserts.fail('unexpected node in varargslist');
      }
    return new arguments_(f, d, e, g);
  }
  function astForFuncdef(a, b, c) {
    REQ(b, SYM.funcdef);
    var d = strobj(CHILD(b, 1).value);
    forbiddenCheck(a, CHILD(b, 1), CHILD(b, 1).value, b.lineno);
    var e = astForArguments(a, CHILD(b, 2));
    a = astForSuite(a, CHILD(b, 4));
    return new FunctionDef(d, e, a, c, b.lineno, b.col_offset);
  }
  function astForClassBases(a, b) {
    goog.asserts.assert(0 < NCH(b));
    REQ(b, SYM.testlist);
    return 1 === NCH(b) ? [astForExpr(a, CHILD(b, 0))] : seqForTestlist(a, b);
  }
  function astForClassdef(a, b, c) {
    REQ(b, SYM.classdef);
    forbiddenCheck(a, b, CHILD(b, 1).value, b.lineno);
    var d = strobj(CHILD(b, 1).value);
    if (4 === NCH(b))
      return new ClassDef(d, [], astForSuite(a, CHILD(b, 3)), c, b.lineno, b.col_offset);
    if (CHILD(b, 3).type === TOK.T_RPAR)
      return new ClassDef(d, [], astForSuite(a, CHILD(b, 5)), c, b.lineno, b.col_offset);
    var e = astForClassBases(a, CHILD(b, 3));
    a = astForSuite(a, CHILD(b, 6));
    return new ClassDef(d, e, a, c, b.lineno, b.col_offset);
  }
  function astForLambdef(a, b) {
    var c, d;
    3 === NCH(b) ? (c = new arguments_([], null, null, []), d = astForExpr(a, CHILD(b, 2))) : (c = astForArguments(a, CHILD(b, 1)), d = astForExpr(a, CHILD(b, 3)));
    return new Lambda(c, d, b.lineno, b.col_offset);
  }
  function astForGenexp(a, b) {
    function c(a, b) {
      for (var c = 0;;) {
        REQ(b, SYM.gen_iter);
        if (CHILD(b, 0).type === SYM.gen_for)
          return c;
        b = CHILD(b, 0);
        REQ(b, SYM.gen_if);
        c++;
        if (2 == NCH(b))
          return c;
        b = CHILD(b, 2);
      }
    }
    goog.asserts.assert(b.type === SYM.testlist_gexp || b.type === SYM.argument);
    goog.asserts.assert(1 < NCH(b));
    for (var d = astForExpr(a, CHILD(b, 0)), e = function (a, b) {
          var c = 0, d = CHILD(b, 1);
          a:
            for (;;) {
              c++;
              REQ(d, SYM.gen_for);
              if (5 === NCH(d))
                d = CHILD(d, 4);
              else
                return c;
              b:
                for (;;) {
                  REQ(d, SYM.gen_iter);
                  d = CHILD(d, 0);
                  if (d.type === SYM.gen_for)
                    continue a;
                  else if (d.type === SYM.gen_if)
                    if (3 === NCH(d)) {
                      d = CHILD(d, 2);
                      continue b;
                    } else
                      return c;
                  break;
                }
              break;
            }
          goog.asserts.fail('logic error in countGenFors');
        }(a, b), f = [], g = CHILD(b, 1), h = 0; h < e; ++h) {
      REQ(g, SYM.gen_for);
      var k = CHILD(g, 1), l = astForExprlist(a, k, Store), m = astForExpr(a, CHILD(g, 3)), k = 1 === NCH(k) ? new comprehension(l[0], m, []) : new comprehension(new Tuple(l, Store, g.lineno, g.col_offset), m, []);
      if (5 === NCH(g)) {
        for (var g = CHILD(g, 4), l = c(a, g), n = [], p = 0; p < l; ++p)
          REQ(g, SYM.gen_iter), g = CHILD(g, 0), REQ(g, SYM.gen_if), m = astForExpr(a, CHILD(g, 1)), n[p] = m, 3 === NCH(g) && (g = CHILD(g, 2));
        g.type === SYM.gen_iter && (g = CHILD(g, 0));
        k.ifs = n;
      }
      f[h] = k;
    }
    return new GeneratorExp(d, f, b.lineno, b.col_offset);
  }
  function astForWhileStmt(a, b) {
    REQ(b, SYM.while_stmt);
    if (4 === NCH(b))
      return new While_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), [], b.lineno, b.col_offset);
    if (7 === NCH(b))
      return new While_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), astForSuite(a, CHILD(b, 6)), b.lineno, b.col_offset);
    goog.asserts.fail('wrong number of tokens for \'while\' stmt');
  }
  function astForAugassign(a, b) {
    REQ(b, SYM.augassign);
    b = CHILD(b, 0);
    switch (b.value.charAt(0)) {
    case '+':
      return Add;
    case '-':
      return Sub;
    case '/':
      return '/' === b.value.charAt(1) ? FloorDiv : Div;
    case '%':
      return Mod;
    case '<':
      return LShift;
    case '>':
      return RShift;
    case '&':
      return BitAnd;
    case '^':
      return BitXor;
    case '|':
      return BitOr;
    case '*':
      return '*' === b.value.charAt(1) ? Pow : Mult;
    default:
      goog.asserts.fail('invalid augassign');
    }
  }
  function astForBinop(a, b) {
    for (var c = new BinOp(astForExpr(a, CHILD(b, 0)), getOperator(CHILD(b, 1)), astForExpr(a, CHILD(b, 2)), b.lineno, b.col_offset), d = (NCH(b) - 1) / 2, e = 1; e < d; ++e)
      var f = CHILD(b, 2 * e + 1), g = getOperator(f), h = astForExpr(a, CHILD(b, 2 * e + 2)), c = new BinOp(c, g, h, f.lineno, f.col_offset);
    return c;
  }
  function astForTestlist(a, b) {
    goog.asserts.assert(0 < NCH(b));
    b.type === SYM.testlist_gexp ? 1 < NCH(b) && goog.asserts.assert(CHILD(b, 1).type !== SYM.gen_for) : goog.asserts.assert(b.type === SYM.testlist || b.type === SYM.testlist_safe || b.type === SYM.testlist1);
    return 1 === NCH(b) ? astForExpr(a, CHILD(b, 0)) : new Tuple(seqForTestlist(a, b), Load, b.lineno, b.col_offset);
  }
  function astForExprStmt(a, b) {
    REQ(b, SYM.expr_stmt);
    if (1 === NCH(b))
      return new Expr(astForTestlist(a, CHILD(b, 0)), b.lineno, b.col_offset);
    if (CHILD(b, 1).type === SYM.augassign) {
      var c = CHILD(b, 0), d = astForTestlist(a, c);
      switch (d.constructor) {
      case GeneratorExp:
        throw new Sk.builtin.SyntaxError('augmented assignment to generator expression not possible', a.c_filename, b.lineno);
      case Yield:
        throw new Sk.builtin.SyntaxError('augmented assignment to yield expression not possible', a.c_filename, b.lineno);
      case Name:
        forbiddenCheck(a, c, d.id, b.lineno);
        break;
      case Attribute:
      case Subscript:
        break;
      default:
        throw new Sk.builtin.SyntaxError('illegal expression for augmented assignment', a.c_filename, b.lineno);
      }
      setContext(a, d, Store, c);
      c = CHILD(b, 2);
      c = c.type === SYM.testlist ? astForTestlist(a, c) : astForExpr(a, c);
      return new AugAssign(d, astForAugassign(a, CHILD(b, 1)), c, b.lineno, b.col_offset);
    }
    REQ(CHILD(b, 1), TOK.T_EQUAL);
    for (var d = [], e = 0; e < NCH(b) - 2; e += 2) {
      c = CHILD(b, e);
      if (c.type === SYM.yield_expr)
        throw new Sk.builtin.SyntaxError('assignment to yield expression not possible', a.c_filename, b.lineno);
      c = astForTestlist(a, c);
      setContext(a, c, Store, CHILD(b, e));
      d[e / 2] = c;
    }
    c = CHILD(b, NCH(b) - 1);
    c = c.type === SYM.testlist ? astForTestlist(a, c) : astForExpr(a, c);
    return new Assign(d, c, b.lineno, b.col_offset);
  }
  function astForIfexpr(a, b) {
    goog.asserts.assert(5 === NCH(b));
    return new IfExp(astForExpr(a, CHILD(b, 2)), astForExpr(a, CHILD(b, 0)), astForExpr(a, CHILD(b, 4)), b.lineno, b.col_offset);
  }
  function parsestr(a, b) {
    var c = b.charAt(0), d = !1;
    if ('u' === c || 'U' === c)
      b = b.substr(1), c = b.charAt(0);
    else if ('r' === c || 'R' === c)
      b = b.substr(1), c = b.charAt(0), d = !0;
    goog.asserts.assert('b' !== c && 'B' !== c, 'todo; haven\'t done b\'\' strings yet');
    goog.asserts.assert('\'' === c || '"' === c && b.charAt(b.length - 1) === c);
    b = b.substr(1, b.length - 2);
    4 <= b.length && (b.charAt(0) === c && b.charAt(1) === c) && (goog.asserts.assert(b.charAt(b.length - 1) === c && b.charAt(b.length - 2) === c), b = b.substr(2, b.length - 4));
    if (d || -1 === b.indexOf('\\'))
      c = strobj(decodeURIComponent(escape(b)));
    else {
      for (var c = strobj, d = b, e = d.length, f = '', g = 0; g < e; ++g) {
        var h = d.charAt(g);
        if ('\\' === h)
          if (++g, h = d.charAt(g), 'n' === h)
            f += '\n';
          else if ('\\' === h)
            f += '\\';
          else if ('t' === h)
            f += '\t';
          else if ('r' === h)
            f += '\r';
          else if ('b' === h)
            f += '\b';
          else if ('f' === h)
            f += '\f';
          else if ('v' === h)
            f += '\x0B';
          else if ('0' === h)
            f += '\0';
          else if ('"' === h)
            f += '"';
          else if ('\'' === h)
            f += '\'';
          else {
            if ('\n' !== h)
              if ('x' === h)
                var h = d.charAt(++g), k = d.charAt(++g), f = f + String.fromCharCode(parseInt(h + k, 16));
              else if ('u' === h || 'U' === h)
                var h = d.charAt(++g), k = d.charAt(++g), l = d.charAt(++g), m = d.charAt(++g), f = f + String.fromCharCode(parseInt(h + k, 16), parseInt(l + m, 16));
              else
                f += '\\' + h;
          }
        else
          f += h;
      }
      c = c(f);
    }
    return c;
  }
  function parsestrplus(a, b) {
    REQ(CHILD(b, 0), TOK.T_STRING);
    for (var c = new Sk.builtin.str(''), d = 0; d < NCH(b); ++d)
      try {
        c = c.sq$concat(parsestr(a, CHILD(b, d).value));
      } catch (e) {
        throw new Sk.builtin.SyntaxError('invalid string (possibly contains a unicode character)', a.c_filename, CHILD(b, d).lineno);
      }
    return c;
  }
  function parsenumber(a, b, c) {
    var d = b.charAt(b.length - 1);
    if ('j' === d || 'J' === d)
      throw new Sk.builtin.SyntaxError('complex numbers are currently unsupported', a.c_filename, c);
    if ('l' === d || 'L' === d)
      return Sk.longFromStr(b.substr(0, b.length - 1), 0);
    if (-1 !== b.indexOf('.'))
      return new Sk.builtin.nmber(parseFloat(b), Sk.builtin.nmber.float$);
    c = b;
    a = !1;
    '-' === b.charAt(0) && (c = b.substr(1), a = !0);
    if ('0' !== c.charAt(0) || 'x' !== c.charAt(1) && 'X' !== c.charAt(1)) {
      if (-1 !== b.indexOf('e') || -1 !== b.indexOf('E'))
        return new Sk.builtin.nmber(parseFloat(b), Sk.builtin.nmber.float$);
      if ('0' !== c.charAt(0) || 'b' !== c.charAt(1) && 'B' !== c.charAt(1))
        if ('0' === c.charAt(0))
          if ('0' === c)
            c = 0;
          else {
            c = c.substring(1);
            if ('o' === c.charAt(0) || 'O' === c.charAt(0))
              c = c.substring(1);
            c = parseInt(c, 8);
          }
        else
          c = parseInt(c, 10);
      else
        c = c.substring(2), c = parseInt(c, 2);
    } else
      c = c.substring(2), c = parseInt(c, 16);
    return c > Sk.builtin.lng.threshold$ && Math.floor(c) === c && -1 === b.indexOf('e') && -1 === b.indexOf('E') ? Sk.longFromStr(b, 0) : a ? new Sk.builtin.nmber(-c, Sk.builtin.int$) : new Sk.builtin.nmber(c, Sk.builtin.int$);
  }
  function astForSlice(a, b) {
    REQ(b, SYM.subscript);
    var c = CHILD(b, 0), d = null, e = null, f = null;
    if (c.type === TOK.T_DOT)
      return new Ellipsis();
    if (1 === NCH(b) && c.type === SYM.test)
      return new Index(astForExpr(a, c));
    c.type === SYM.test && (d = astForExpr(a, c));
    c.type === TOK.T_COLON ? 1 < NCH(b) && (c = CHILD(b, 1), c.type === SYM.test && (e = astForExpr(a, c))) : 2 < NCH(b) && (c = CHILD(b, 2), c.type === SYM.test && (e = astForExpr(a, c)));
    c = CHILD(b, NCH(b) - 1);
    c.type === SYM.sliceop && (1 === NCH(c) ? (c = CHILD(c, 0), f = new Name(strobj('None'), Load, c.lineno, c.col_offset)) : (c = CHILD(c, 1), c.type === SYM.test && (f = astForExpr(a, c))));
    return new Slice(d, e, f);
  }
  function astForAtom(a, b) {
    var c = CHILD(b, 0);
    switch (c.type) {
    case TOK.T_NAME:
      return new Name(strobj(c.value), Load, b.lineno, b.col_offset);
    case TOK.T_STRING:
      return new Str(parsestrplus(a, b), b.lineno, b.col_offset);
    case TOK.T_NUMBER:
      return new Num(parsenumber(a, c.value, b.lineno), b.lineno, b.col_offset);
    case TOK.T_LPAR:
      return c = CHILD(b, 1), c.type === TOK.T_RPAR ? new Tuple([], Load, b.lineno, b.col_offset) : c.type === SYM.yield_expr ? astForExpr(a, c) : 1 < NCH(c) && CHILD(c, 1).type === SYM.gen_for ? astForGenexp(a, c) : astForTestlistGexp(a, c);
    case TOK.T_LSQB:
      c = CHILD(b, 1);
      if (c.type === TOK.T_RSQB)
        return new List([], Load, b.lineno, b.col_offset);
      REQ(c, SYM.listmaker);
      return 1 === NCH(c) || CHILD(c, 1).type === TOK.T_COMMA ? new List(seqForTestlist(a, c), Load, b.lineno, b.col_offset) : astForListcomp(a, c);
    case TOK.T_LBRACE:
      c = CHILD(b, 1);
      NCH(c);
      for (var d = [], e = [], f = 0; f < NCH(c); f += 4)
        d[f / 4] = astForExpr(a, CHILD(c, f)), e[f / 4] = astForExpr(a, CHILD(c, f + 2));
      return new Dict(d, e, b.lineno, b.col_offset);
    case TOK.T_BACKQUOTE:
      throw new Sk.builtin.SyntaxError('backquote not supported, use repr()', a.c_filename, b.lineno);
    default:
      goog.asserts.fail('unhandled atom', c.type);
    }
  }
  function astForPower(a, b) {
    REQ(b, SYM.power);
    var c = astForAtom(a, CHILD(b, 0));
    if (1 === NCH(b))
      return c;
    for (var d = 1; d < NCH(b); ++d) {
      var e = CHILD(b, d);
      if (e.type !== SYM.trailer)
        break;
      e = astForTrailer(a, e, c);
      e.lineno = c.lineno;
      e.col_offset = c.col_offset;
      c = e;
    }
    CHILD(b, NCH(b) - 1).type === SYM.factor && (d = astForExpr(a, CHILD(b, NCH(b) - 1)), c = new BinOp(c, Pow, d, b.lineno, b.col_offset));
    return c;
  }
  function astForExpr(a, b) {
    a:
      for (;;) {
        switch (b.type) {
        case SYM.test:
        case SYM.old_test:
          if (CHILD(b, 0).type === SYM.lambdef || CHILD(b, 0).type === SYM.old_lambdef)
            return astForLambdef(a, CHILD(b, 0));
          if (1 < NCH(b))
            return astForIfexpr(a, b);
        case SYM.or_test:
        case SYM.and_test:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          }
          for (var c = [], d = 0; d < NCH(b); d += 2)
            c[d / 2] = astForExpr(a, CHILD(b, d));
          if ('and' === CHILD(b, 1).value)
            return new BoolOp(And, c, b.lineno, b.col_offset);
          goog.asserts.assert('or' === CHILD(b, 1).value);
          return new BoolOp(Or, c, b.lineno, b.col_offset);
        case SYM.not_test:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          } else
            return new UnaryOp(Not, astForExpr(a, CHILD(b, 1)), b.lineno, b.col_offset);
        case SYM.comparison:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          } else {
            for (var c = [], e = [], d = 1; d < NCH(b); d += 2)
              c[(d - 1) / 2] = astForCompOp(a, CHILD(b, d)), e[(d - 1) / 2] = astForExpr(a, CHILD(b, d + 1));
            return new Compare(astForExpr(a, CHILD(b, 0)), c, e, b.lineno, b.col_offset);
          }
        case SYM.expr:
        case SYM.xor_expr:
        case SYM.and_expr:
        case SYM.shift_expr:
        case SYM.arith_expr:
        case SYM.term:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          }
          return astForBinop(a, b);
        case SYM.yield_expr:
          return d = null, 2 === NCH(b) && (d = astForTestlist(a, CHILD(b, 1))), new Yield(d, b.lineno, b.col_offset);
        case SYM.factor:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          }
          return astForFactor(a, b);
        case SYM.power:
          return astForPower(a, b);
        default:
          goog.asserts.fail('unhandled expr', 'n.type: %d', b.type);
        }
        break;
      }
  }
  function astForPrintStmt(a, b) {
    var c = 1, d = null;
    REQ(b, SYM.print_stmt);
    2 <= NCH(b) && CHILD(b, 1).type === TOK.T_RIGHTSHIFT && (d = astForExpr(a, CHILD(b, 2)), c = 4);
    for (var e = [], f = 0; c < NCH(b); c += 2, ++f)
      e[f] = astForExpr(a, CHILD(b, c));
    c = CHILD(b, NCH(b) - 1).type === TOK.T_COMMA ? !1 : !0;
    return new Print(d, e, c, b.lineno, b.col_offset);
  }
  function astForStmt(a, b) {
    b.type === SYM.stmt && (goog.asserts.assert(1 === NCH(b)), b = CHILD(b, 0));
    b.type === SYM.simple_stmt && (goog.asserts.assert(1 === numStmts(b)), b = CHILD(b, 0));
    if (b.type === SYM.small_stmt)
      switch (REQ(b, SYM.small_stmt), b = CHILD(b, 0), b.type) {
      case SYM.expr_stmt:
        return astForExprStmt(a, b);
      case SYM.print_stmt:
        return astForPrintStmt(a, b);
      case SYM.del_stmt:
        return astForDelStmt(a, b);
      case SYM.pass_stmt:
        return new Pass(b.lineno, b.col_offset);
      case SYM.flow_stmt:
        return astForFlowStmt(a, b);
      case SYM.import_stmt:
        return astForImportStmt(a, b);
      case SYM.global_stmt:
        return astForGlobalStmt(a, b);
      case SYM.exec_stmt:
        return astForExecStmt(a, b);
      case SYM.assert_stmt:
        return astForAssertStmt(a, b);
      default:
        goog.asserts.fail('unhandled small_stmt');
      }
    else {
      var c = CHILD(b, 0);
      REQ(b, SYM.compound_stmt);
      switch (c.type) {
      case SYM.if_stmt:
        return astForIfStmt(a, c);
      case SYM.while_stmt:
        return astForWhileStmt(a, c);
      case SYM.for_stmt:
        return astForForStmt(a, c);
      case SYM.try_stmt:
        return astForTryStmt(a, c);
      case SYM.with_stmt:
        return astForWithStmt(a, c);
      case SYM.funcdef:
        return astForFuncdef(a, c, []);
      case SYM.classdef:
        return astForClassdef(a, c, []);
      case SYM.decorated:
        return astForDecorated(a, c);
      default:
        goog.asserts.assert('unhandled compound_stmt');
      }
    }
  }
  Sk.astFromParse = function (a, b) {
    var c = new Compiling('utf-8', b), d = [], e, f = 0;
    switch (a.type) {
    case SYM.file_input:
      for (var g = 0; g < NCH(a) - 1; ++g)
        if (e = CHILD(a, g), a.type !== TOK.T_NEWLINE) {
          REQ(e, SYM.stmt);
          var h = numStmts(e);
          if (1 === h)
            d[f++] = astForStmt(c, e);
          else {
            e = CHILD(e, 0);
            REQ(e, SYM.simple_stmt);
            for (var k = 0; k < h; ++k)
              d[f++] = astForStmt(c, CHILD(e, 2 * k));
          }
        }
      return new Module(d);
    case SYM.eval_input:
      goog.asserts.fail('todo;');
    case SYM.single_input:
      goog.asserts.fail('todo;');
    default:
      goog.asserts.fail('todo;');
    }
  };
  Sk.astDump = function (a) {
    var b = function (a) {
        for (var b = '', c = 0; c < a; ++c)
          b += ' ';
        return b;
      }, c = function (a, e) {
        if (null === a)
          return e + 'None';
        if (a.prototype && void 0 !== a.prototype._astname && a.prototype._isenum)
          return e + a.prototype._astname + '()';
        if (void 0 !== a._astname) {
          for (var f = b(a._astname.length + 1), g = [], h = 0; h < a._fields.length; h += 2) {
            var k = a._fields[h], l = a._fields[h + 1](a), m = b(k.length + 1);
            g.push([
              k,
              c(l, e + f + m)
            ]);
          }
          k = [];
          for (h = 0; h < g.length; ++h)
            l = g[h], k.push(l[0] + '=' + l[1].replace(/^\s+/, ''));
          h = k.join(',\n' + e + f);
          return e + a._astname + '(' + h + ')';
        }
        if (goog.isArrayLike(a)) {
          f = [];
          for (h = 0; h < a.length; ++h)
            f.push(c(a[h], e + ' '));
          h = f.join(',\n');
          return e + '[' + h.replace(/^\s+/, '') + ']';
        }
        h = !0 === a ? 'True' : !1 === a ? 'False' : a instanceof Sk.builtin.lng ? a.tp$str().v : a instanceof Sk.builtin.str ? a.$r().v : '' + a;
        return e + h;
      };
    return c(a, '');
  };
  goog.exportSymbol('Sk.astFromParse', Sk.astFromParse);
  goog.exportSymbol('Sk.astDump', Sk.astDump);
  var DEF_GLOBAL = 1, DEF_LOCAL = 2, DEF_PARAM = 4, USE = 8, DEF_STAR = 16, DEF_DOUBLESTAR = 32, DEF_INTUPLE = 64, DEF_FREE = 128, DEF_FREE_GLOBAL = 256, DEF_FREE_CLASS = 512, DEF_IMPORT = 1024, DEF_BOUND = DEF_LOCAL | DEF_PARAM | DEF_IMPORT, SCOPE_OFF = 11, SCOPE_MASK = 7, LOCAL = 1, GLOBAL_EXPLICIT = 2, GLOBAL_IMPLICIT = 3, FREE = 4, CELL = 5, OPT_IMPORT_STAR = 1, OPT_EXEC = 2, OPT_BARE_EXEC = 4, OPT_TOPLEVEL = 8, GENERATOR = 2, GENERATOR_EXPRESSION = 2, ModuleBlock = 'module', FunctionBlock = 'function', ClassBlock = 'class';
  function Symbol(a, b, c) {
    this.__name = a;
    this.__flags = b;
    this.__scope = b >> SCOPE_OFF & SCOPE_MASK;
    this.__namespaces = c || [];
  }
  Symbol.prototype.get_name = function () {
    return this.__name;
  };
  Symbol.prototype.is_referenced = function () {
    return !!(this.__flags & USE);
  };
  Symbol.prototype.is_parameter = function () {
    return !!(this.__flags & DEF_PARAM);
  };
  Symbol.prototype.is_global = function () {
    return this.__scope === GLOBAL_IMPLICIT || this.__scope == GLOBAL_EXPLICIT;
  };
  Symbol.prototype.is_declared_global = function () {
    return this.__scope == GLOBAL_EXPLICIT;
  };
  Symbol.prototype.is_local = function () {
    return !!(this.__flags & DEF_BOUND);
  };
  Symbol.prototype.is_free = function () {
    return this.__scope == FREE;
  };
  Symbol.prototype.is_imported = function () {
    return !!(this.__flags & DEF_IMPORT);
  };
  Symbol.prototype.is_assigned = function () {
    return !!(this.__flags & DEF_LOCAL);
  };
  Symbol.prototype.is_namespace = function () {
    return this.__namespaces && 0 < this.__namespaces.length;
  };
  Symbol.prototype.get_namespaces = function () {
    return this.__namespaces;
  };
  var astScopeCounter = 0;
  function SymbolTableScope(a, b, c, d, e) {
    this.symFlags = {};
    this.name = b;
    this.varnames = [];
    this.children = [];
    this.blockType = c;
    this.returnsValue = this.varkeywords = this.varargs = this.generator = this.childHasFree = this.hasFree = this.isNested = !1;
    this.lineno = e;
    this.table = a;
    a.cur && (a.cur.nested || a.cur.blockType === FunctionBlock) && (this.isNested = !0);
    d.scopeId = astScopeCounter++;
    a.stss[d.scopeId] = this;
    this.symbols = {};
  }
  SymbolTableScope.prototype.get_type = function () {
    return this.blockType;
  };
  SymbolTableScope.prototype.get_name = function () {
    return this.name;
  };
  SymbolTableScope.prototype.get_lineno = function () {
    return this.lineno;
  };
  SymbolTableScope.prototype.is_nested = function () {
    return this.isNested;
  };
  SymbolTableScope.prototype.has_children = function () {
    return 0 < this.children.length;
  };
  SymbolTableScope.prototype.get_identifiers = function () {
    return this._identsMatching(function (a) {
      return !0;
    });
  };
  SymbolTableScope.prototype.lookup = function (a) {
    if (this.symbols.hasOwnProperty(a))
      a = this.symbols[a];
    else {
      var b = this.symFlags[a], c = this.__check_children(a);
      a = this.symbols[a] = new Symbol(a, b, c);
    }
    return a;
  };
  SymbolTableScope.prototype.__check_children = function (a) {
    for (var b = [], c = 0; c < this.children.length; ++c) {
      var d = this.children[c];
      d.name === a && b.push(d);
    }
    return b;
  };
  SymbolTableScope.prototype._identsMatching = function (a) {
    var b = [], c;
    for (c in this.symFlags)
      this.symFlags.hasOwnProperty(c) && a(this.symFlags[c]) && b.push(c);
    b.sort();
    return b;
  };
  SymbolTableScope.prototype.get_parameters = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_parameters only valid for function scopes');
    this._funcParams || (this._funcParams = this._identsMatching(function (a) {
      return a & DEF_PARAM;
    }));
    return this._funcParams;
  };
  SymbolTableScope.prototype.get_locals = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_locals only valid for function scopes');
    this._funcLocals || (this._funcLocals = this._identsMatching(function (a) {
      return a & DEF_BOUND;
    }));
    return this._funcLocals;
  };
  SymbolTableScope.prototype.get_globals = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_globals only valid for function scopes');
    this._funcGlobals || (this._funcGlobals = this._identsMatching(function (a) {
      a = a >> SCOPE_OFF & SCOPE_MASK;
      return a == GLOBAL_IMPLICIT || a == GLOBAL_EXPLICIT;
    }));
    return this._funcGlobals;
  };
  SymbolTableScope.prototype.get_frees = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_frees only valid for function scopes');
    this._funcFrees || (this._funcFrees = this._identsMatching(function (a) {
      return (a >> SCOPE_OFF & SCOPE_MASK) == FREE;
    }));
    return this._funcFrees;
  };
  SymbolTableScope.prototype.get_methods = function () {
    goog.asserts.assert('class' == this.get_type(), 'get_methods only valid for class scopes');
    if (!this._classMethods) {
      for (var a = [], b = 0; b < this.children.length; ++b)
        a.push(this.children[b].name);
      a.sort();
      this._classMethods = a;
    }
    return this._classMethods;
  };
  SymbolTableScope.prototype.getScope = function (a) {
    a = this.symFlags[a];
    return void 0 === a ? 0 : a >> SCOPE_OFF & SCOPE_MASK;
  };
  function SymbolTable(a) {
    this.filename = a;
    this.top = this.cur = null;
    this.stack = [];
    this.curClass = this.global = null;
    this.tmpname = 0;
    this.stss = {};
  }
  SymbolTable.prototype.getStsForAst = function (a) {
    goog.asserts.assert(void 0 !== a.scopeId, 'ast wasn\'t added to st?');
    a = this.stss[a.scopeId];
    goog.asserts.assert(void 0 !== a, 'unknown sym tab entry');
    return a;
  };
  SymbolTable.prototype.SEQStmt = function (a) {
    goog.asserts.assert(goog.isArrayLike(a), 'SEQ: nodes isn\'t array? got %s', a);
    for (var b = a.length, c = 0; c < b; ++c) {
      var d = a[c];
      d && this.visitStmt(d);
    }
  };
  SymbolTable.prototype.SEQExpr = function (a) {
    goog.asserts.assert(goog.isArrayLike(a), 'SEQ: nodes isn\'t array? got %s', a);
    for (var b = a.length, c = 0; c < b; ++c) {
      var d = a[c];
      d && this.visitExpr(d);
    }
  };
  SymbolTable.prototype.enterBlock = function (a, b, c, d) {
    a = fixReservedNames(a);
    var e = null;
    this.cur && (e = this.cur, this.stack.push(this.cur));
    this.cur = new SymbolTableScope(this, a, b, c, d);
    'top' === a && (this.global = this.cur.symFlags);
    e && e.children.push(this.cur);
  };
  SymbolTable.prototype.exitBlock = function () {
    this.cur = null;
    0 < this.stack.length && (this.cur = this.stack.pop());
  };
  SymbolTable.prototype.visitParams = function (a, b) {
    for (var c = 0; c < a.length; ++c) {
      var d = a[c];
      if (d.constructor === Name)
        goog.asserts.assert(d.ctx === Param || d.ctx === Store && !b), this.addDef(d.id, DEF_PARAM, d.lineno);
      else
        throw new Sk.builtin.SyntaxError('invalid expression in parameter list', this.filename);
    }
  };
  SymbolTable.prototype.visitArguments = function (a, b) {
    a.args && this.visitParams(a.args, !0);
    a.vararg && (this.addDef(a.vararg, DEF_PARAM, b), this.cur.varargs = !0);
    a.kwarg && (this.addDef(a.kwarg, DEF_PARAM, b), this.cur.varkeywords = !0);
  };
  SymbolTable.prototype.newTmpname = function (a) {
    this.addDef(new Sk.builtin.str('_[' + ++this.tmpname + ']'), DEF_LOCAL, a);
  };
  SymbolTable.prototype.addDef = function (a, b, c) {
    var d = mangleName(this.curClass, new Sk.builtin.str(a)).v, d = fixReservedNames(d), e = this.cur.symFlags[d];
    if (void 0 !== e) {
      if (b & DEF_PARAM && e & DEF_PARAM)
        throw new Sk.builtin.SyntaxError('duplicate argument \'' + a.v + '\' in function definition', this.filename, c);
      e |= b;
    } else
      e = b;
    this.cur.symFlags[d] = e;
    b & DEF_PARAM ? this.cur.varnames.push(d) : b & DEF_GLOBAL && (e = b, a = this.global[d], void 0 !== a && (e |= a), this.global[d] = e);
  };
  SymbolTable.prototype.visitSlice = function (a) {
    switch (a.constructor) {
    case Slice:
      a.lower && this.visitExpr(a.lower);
      a.upper && this.visitExpr(a.upper);
      a.step && this.visitExpr(a.step);
      break;
    case ExtSlice:
      for (var b = 0; b < a.dims.length; ++b)
        this.visitSlice(a.dims[b]);
      break;
    case Index:
      this.visitExpr(a.value);
    }
  };
  SymbolTable.prototype.visitStmt = function (a) {
    goog.asserts.assert(void 0 !== a, 'visitStmt called with undefined');
    switch (a.constructor) {
    case FunctionDef:
      this.addDef(a.name, DEF_LOCAL, a.lineno);
      a.args.defaults && this.SEQExpr(a.args.defaults);
      a.decorator_list && this.SEQExpr(a.decorator_list);
      this.enterBlock(a.name.v, FunctionBlock, a, a.lineno);
      this.visitArguments(a.args, a.lineno);
      this.SEQStmt(a.body);
      this.exitBlock();
      break;
    case ClassDef:
      this.addDef(a.name, DEF_LOCAL, a.lineno);
      this.SEQExpr(a.bases);
      a.decorator_list && this.SEQExpr(a.decorator_list);
      this.enterBlock(a.name.v, ClassBlock, a, a.lineno);
      var b = this.curClass;
      this.curClass = a.name;
      this.SEQStmt(a.body);
      this.curCalss = b;
      this.exitBlock();
      break;
    case Return_:
      if (a.value && (this.visitExpr(a.value), this.cur.returnsValue = !0, this.cur.generator))
        throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
      break;
    case Delete_:
      this.SEQExpr(a.targets);
      break;
    case Assign:
      this.SEQExpr(a.targets);
      this.visitExpr(a.value);
      break;
    case AugAssign:
      this.visitExpr(a.target);
      this.visitExpr(a.value);
      break;
    case Print:
      a.dest && this.visitExpr(a.dest);
      this.SEQExpr(a.values);
      break;
    case For_:
      this.visitExpr(a.target);
      this.visitExpr(a.iter);
      this.SEQStmt(a.body);
      a.orelse && this.SEQStmt(a.orelse);
      break;
    case While_:
      this.visitExpr(a.test);
      this.SEQStmt(a.body);
      a.orelse && this.SEQStmt(a.orelse);
      break;
    case If_:
      this.visitExpr(a.test);
      this.SEQStmt(a.body);
      a.orelse && this.SEQStmt(a.orelse);
      break;
    case Raise:
      a.type && (this.visitExpr(a.type), a.inst && (this.visitExpr(a.inst), a.tback && this.visitExpr(a.tback)));
      break;
    case TryExcept:
      this.SEQStmt(a.body);
      this.SEQStmt(a.orelse);
      this.visitExcepthandlers(a.handlers);
      break;
    case TryFinally:
      this.SEQStmt(a.body);
      this.SEQStmt(a.finalbody);
      break;
    case Assert:
      this.visitExpr(a.test);
      a.msg && this.visitExpr(a.msg);
      break;
    case Import_:
    case ImportFrom:
      this.visitAlias(a.names, a.lineno);
      break;
    case Exec:
      this.visitExpr(a.body);
      a.globals && (this.visitExpr(a.globals), a.locals && this.visitExpr(a.locals));
      break;
    case Global:
      for (var b = a.names.length, c = 0; c < b; ++c) {
        var d = mangleName(this.curClass, a.names[c]).v, d = fixReservedNames(d), e = this.cur.symFlags[d];
        if (e & (DEF_LOCAL | USE)) {
          if (e & DEF_LOCAL)
            throw new Sk.builtin.SyntaxError('name \'' + d + '\' is assigned to before global declaration', this.filename, a.lineno);
          throw new Sk.builtin.SyntaxError('name \'' + d + '\' is used prior to global declaration', this.filename, a.lineno);
        }
        this.addDef(new Sk.builtin.str(d), DEF_GLOBAL, a.lineno);
      }
      break;
    case Expr:
      this.visitExpr(a.value);
      break;
    case Pass:
    case Break_:
    case Continue_:
      break;
    case With_:
      this.newTmpname(a.lineno);
      this.visitExpr(a.context_expr);
      a.optional_vars && (this.newTmpname(a.lineno), this.visitExpr(a.optional_vars));
      this.SEQStmt(a.body);
      break;
    default:
      goog.asserts.fail('Unhandled type ' + a.constructor.name + ' in visitStmt');
    }
  };
  SymbolTable.prototype.visitExpr = function (a) {
    goog.asserts.assert(void 0 !== a, 'visitExpr called with undefined');
    switch (a.constructor) {
    case BoolOp:
      this.SEQExpr(a.values);
      break;
    case BinOp:
      this.visitExpr(a.left);
      this.visitExpr(a.right);
      break;
    case UnaryOp:
      this.visitExpr(a.operand);
      break;
    case Lambda:
      this.addDef(new Sk.builtin.str('lambda'), DEF_LOCAL, a.lineno);
      a.args.defaults && this.SEQExpr(a.args.defaults);
      this.enterBlock('lambda', FunctionBlock, a, a.lineno);
      this.visitArguments(a.args, a.lineno);
      this.visitExpr(a.body);
      this.exitBlock();
      break;
    case IfExp:
      this.visitExpr(a.test);
      this.visitExpr(a.body);
      this.visitExpr(a.orelse);
      break;
    case Dict:
      this.SEQExpr(a.keys);
      this.SEQExpr(a.values);
      break;
    case ListComp:
      this.newTmpname(a.lineno);
      this.visitExpr(a.elt);
      this.visitComprehension(a.generators, 0);
      break;
    case GeneratorExp:
      this.visitGenexp(a);
      break;
    case Yield:
      a.value && this.visitExpr(a.value);
      this.cur.generator = !0;
      if (this.cur.returnsValue)
        throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
      break;
    case Compare:
      this.visitExpr(a.left);
      this.SEQExpr(a.comparators);
      break;
    case Call:
      this.visitExpr(a.func);
      this.SEQExpr(a.args);
      for (var b = 0; b < a.keywords.length; ++b)
        this.visitExpr(a.keywords[b].value);
      a.starargs && this.visitExpr(a.starargs);
      a.kwargs && this.visitExpr(a.kwargs);
      break;
    case Num:
    case Str:
      break;
    case Attribute:
      this.visitExpr(a.value);
      break;
    case Subscript:
      this.visitExpr(a.value);
      this.visitSlice(a.slice);
      break;
    case Name:
      this.addDef(a.id, a.ctx === Load ? USE : DEF_LOCAL, a.lineno);
      break;
    case List:
    case Tuple:
      this.SEQExpr(a.elts);
      break;
    default:
      goog.asserts.fail('Unhandled type ' + a.constructor.name + ' in visitExpr');
    }
  };
  SymbolTable.prototype.visitComprehension = function (a, b) {
    for (var c = a.length, d = b; d < c; ++d) {
      var e = a[d];
      this.visitExpr(e.target);
      this.visitExpr(e.iter);
      this.SEQExpr(e.ifs);
    }
  };
  SymbolTable.prototype.visitAlias = function (a, b) {
    for (var c = 0; c < a.length; ++c) {
      var d = a[c], e = d = null === d.asname ? d.name.v : d.asname.v, f = d.indexOf('.');
      -1 !== f && (e = d.substr(0, f));
      if ('*' !== d)
        this.addDef(new Sk.builtin.str(e), DEF_IMPORT, b);
      else if (this.cur.blockType !== ModuleBlock)
        throw new Sk.builtin.SyntaxError('import * only allowed at module level', this.filename);
    }
  };
  SymbolTable.prototype.visitGenexp = function (a) {
    var b = a.generators[0];
    this.visitExpr(b.iter);
    this.enterBlock('genexpr', FunctionBlock, a, a.lineno);
    this.cur.generator = !0;
    this.addDef(new Sk.builtin.str('.0'), DEF_PARAM, a.lineno);
    this.visitExpr(b.target);
    this.SEQExpr(b.ifs);
    this.visitComprehension(a.generators, 1);
    this.visitExpr(a.elt);
    this.exitBlock();
  };
  SymbolTable.prototype.visitExcepthandlers = function (a) {
    for (var b = 0, c; c = a[b]; ++b)
      c.type && this.visitExpr(c.type), c.name && this.visitExpr(c.name), this.SEQStmt(c.body);
  };
  function _dictUpdate(a, b) {
    for (var c in b)
      a[c] = b[c];
  }
  SymbolTable.prototype.analyzeBlock = function (a, b, c, d) {
    var e = {}, f = {}, g = {}, h = {}, k = {};
    a.blockType == ClassBlock && (_dictUpdate(g, d), b && _dictUpdate(h, b));
    for (var l in a.symFlags)
      this.analyzeName(a, f, l, a.symFlags[l], b, e, c, d);
    a.blockType !== ClassBlock && (a.blockType === FunctionBlock && _dictUpdate(h, e), b && _dictUpdate(h, b), _dictUpdate(g, d));
    d = {};
    e = a.children.length;
    for (l = 0; l < e; ++l) {
      var m = a.children[l];
      this.analyzeChildBlock(m, h, k, g, d);
      if (m.hasFree || m.childHasFree)
        a.childHasFree = !0;
    }
    _dictUpdate(k, d);
    a.blockType === FunctionBlock && this.analyzeCells(f, k);
    this.updateSymbols(a.symFlags, f, b, k, a.blockType === ClassBlock);
    _dictUpdate(c, k);
  };
  SymbolTable.prototype.analyzeChildBlock = function (a, b, c, d, e) {
    var f = {};
    _dictUpdate(f, b);
    b = {};
    _dictUpdate(b, c);
    c = {};
    _dictUpdate(c, d);
    this.analyzeBlock(a, f, b, c);
    _dictUpdate(e, b);
  };
  SymbolTable.prototype.analyzeCells = function (a, b) {
    for (var c in a)
      a[c] === LOCAL && void 0 !== b[c] && (a[c] = CELL, delete b[c]);
  };
  SymbolTable.prototype.updateSymbols = function (a, b, c, d, e) {
    for (var f in a) {
      var g = a[f], g = g | b[f] << SCOPE_OFF;
      a[f] = g;
    }
    b = FREE << SCOPE_OFF;
    for (f in d)
      d = a[f], void 0 !== d ? e && d & (DEF_BOUND | DEF_GLOBAL) && (a[f] = d | DEF_FREE_CLASS) : void 0 !== c[f] && (a[f] = b);
  };
  SymbolTable.prototype.analyzeName = function (a, b, c, d, e, f, g, h) {
    if (d & DEF_GLOBAL) {
      if (d & DEF_PARAM)
        throw new Sk.builtin.SyntaxError('name \'' + c + '\' is local and global', this.filename, a.lineno);
      b[c] = GLOBAL_EXPLICIT;
      h[c] = null;
      e && void 0 !== e[c] && delete e[c];
    } else
      d & DEF_BOUND ? (b[c] = LOCAL, f[c] = null, delete h[c]) : e && void 0 !== e[c] ? (b[c] = FREE, a.hasFree = !0, g[c] = null) : (h && void 0 !== h[c] || !a.isNested || (a.hasFree = !0), b[c] = GLOBAL_IMPLICIT);
  };
  SymbolTable.prototype.analyze = function () {
    this.analyzeBlock(this.top, null, {}, {});
  };
  Sk.symboltable = function (a, b) {
    var c = new SymbolTable(b);
    c.enterBlock('top', ModuleBlock, a, 0);
    c.top = c.cur;
    for (var d = 0; d < a.body.length; ++d)
      c.visitStmt(a.body[d]);
    c.exitBlock();
    c.analyze();
    return c;
  };
  Sk.dumpSymtab = function (a) {
    var b = function (a) {
        return a ? 'True' : 'False';
      }, c = function (a) {
        for (var b = [], c = 0; c < a.length; ++c)
          b.push(new Sk.builtin.str(a[c]).$r().v);
        return '[' + b.join(', ') + ']';
      }, d = function (a, f) {
        void 0 === f && (f = '');
        var g;
        g = '' + (f + 'Sym_type: ' + a.get_type() + '\n');
        g += f + 'Sym_name: ' + a.get_name() + '\n';
        g += f + 'Sym_lineno: ' + a.get_lineno() + '\n';
        g += f + 'Sym_nested: ' + b(a.is_nested()) + '\n';
        g += f + 'Sym_haschildren: ' + b(a.has_children()) + '\n';
        'class' === a.get_type() ? g += f + 'Class_methods: ' + c(a.get_methods()) + '\n' : 'function' === a.get_type() && (g += f + 'Func_params: ' + c(a.get_parameters()) + '\n', g += f + 'Func_locals: ' + c(a.get_locals()) + '\n', g += f + 'Func_globals: ' + c(a.get_globals()) + '\n', g += f + 'Func_frees: ' + c(a.get_frees()) + '\n');
        g += f + '-- Identifiers --\n';
        for (var h = a.get_identifiers(), k = h.length, l = 0; l < k; ++l) {
          var m = a.lookup(h[l]);
          g += f + 'name: ' + m.get_name() + '\n';
          g += f + '  is_referenced: ' + b(m.is_referenced()) + '\n';
          g += f + '  is_imported: ' + b(m.is_imported()) + '\n';
          g += f + '  is_parameter: ' + b(m.is_parameter()) + '\n';
          g += f + '  is_global: ' + b(m.is_global()) + '\n';
          g += f + '  is_declared_global: ' + b(m.is_declared_global()) + '\n';
          g += f + '  is_local: ' + b(m.is_local()) + '\n';
          g += f + '  is_free: ' + b(m.is_free()) + '\n';
          g += f + '  is_assigned: ' + b(m.is_assigned()) + '\n';
          g += f + '  is_namespace: ' + b(m.is_namespace()) + '\n';
          var m = m.get_namespaces(), n = m.length;
          g += f + '  namespaces: [\n';
          for (var p = [], q = 0; q < n; ++q)
            p.push(d(m[q], f + '    '));
          g += p.join('\n');
          g += f + '  ]\n';
        }
        return g;
      };
    return d(a.top, '');
  };
  goog.exportSymbol('Sk.symboltable', Sk.symboltable);
  goog.exportSymbol('Sk.dumpSymtab', Sk.dumpSymtab);
  var out;
  Sk.gensymcount = 0;
  function Compiler(a, b, c, d) {
    this.filename = a;
    this.st = b;
    this.flags = c;
    this.interactive = !1;
    this.nestlevel = 0;
    this.u = null;
    this.stack = [];
    this.result = [];
    this.allUnits = [];
    this.source = d ? d.split('\n') : !1;
  }
  function CompilerUnit() {
    this.private_ = this.name = this.ste = null;
    this.lineno = this.firstlineno = 0;
    this.linenoSet = !1;
    this.localnames = [];
    this.blocknum = 0;
    this.blocks = [];
    this.curblock = 0;
    this.scopename = null;
    this.suffixCode = this.switchCode = this.varDeclsCode = this.prefixCode = '';
    this.breakBlocks = [];
    this.continueBlocks = [];
    this.exceptBlocks = [];
    this.finallyBlocks = [];
  }
  CompilerUnit.prototype.activateScope = function () {
    var a = this;
    out = function () {
      for (var b = a.blocks[a.curblock], c = 0; c < arguments.length; ++c)
        b.push(arguments[c]);
    };
  };
  Compiler.prototype.getSourceLine = function (a) {
    goog.asserts.assert(this.source);
    return this.source[a - 1];
  };
  Compiler.prototype.annotateSource = function (a) {
    if (this.source) {
      var b = a.lineno;
      a = a.col_offset;
      out('\n//\n// line ', b, ':\n// ', this.getSourceLine(b), '\n// ');
      for (var c = 0; c < a; ++c)
        out(' ');
      out('^\n//\n');
      out('\nSk.currLineNo = ', b, ';\nSk.currColNo = ', a, '\n\n');
      out('\nSk.currFilename = \'', this.filename, '\';\n\n');
    }
  };
  Compiler.prototype.gensym = function (a) {
    a = '$' + (a || '');
    return a += Sk.gensymcount++;
  };
  Compiler.prototype.niceName = function (a) {
    return this.gensym(a.replace('<', '').replace('>', '').replace(' ', '_'));
  };
  var reservedWords_ = {
      'abstract': !0,
      as: !0,
      'boolean': !0,
      'break': !0,
      'byte': !0,
      'case': !0,
      'catch': !0,
      'char': !0,
      'class': !0,
      'continue': !0,
      'const': !0,
      'debugger': !0,
      'default': !0,
      'delete': !0,
      'do': !0,
      'double': !0,
      'else': !0,
      'enum': !0,
      'export': !0,
      'extends': !0,
      'false': !0,
      'final': !0,
      'finally': !0,
      'float': !0,
      'for': !0,
      'function': !0,
      'goto': !0,
      'if': !0,
      'implements': !0,
      'import': !0,
      'in': !0,
      'instanceof': !0,
      'int': !0,
      'interface': !0,
      is: !0,
      'long': !0,
      namespace: !0,
      'native': !0,
      'new': !0,
      'null': !0,
      'package': !0,
      'private': !0,
      'protected': !0,
      'public': !0,
      'return': !0,
      'short': !0,
      'static': !0,
      'super': !1,
      'switch': !0,
      'synchronized': !0,
      'this': !0,
      'throw': !0,
      'throws': !0,
      'transient': !0,
      'true': !0,
      'try': !0,
      'typeof': !0,
      use: !0,
      'var': !0,
      'void': !0,
      'volatile': !0,
      'while': !0,
      'with': !0
    };
  function fixReservedWords(a) {
    return !0 !== reservedWords_[a] ? a : a + '_$rw$';
  }
  var reservedNames_ = {
      __defineGetter__: !0,
      __defineSetter__: !0,
      apply: !0,
      call: !0,
      eval: !0,
      hasOwnProperty: !0,
      isPrototypeOf: !0,
      __lookupGetter__: !0,
      __lookupSetter__: !0,
      __noSuchMethod__: !0,
      propertyIsEnumerable: !0,
      toSource: !0,
      toLocaleString: !0,
      toString: !0,
      unwatch: !0,
      valueOf: !0,
      watch: !0,
      length: !0
    };
  function fixReservedNames(a) {
    return reservedNames_[a] ? a + '_$rn$' : a;
  }
  Sk.mangleName = function (a) {
    return fixReservedNames(a);
  };
  goog.exportSymbol('Sk.mangleName', Sk.mangleName);
  function mangleName(a, b) {
    var c = b.v, d = null;
    if (null === a || (null === c || '_' !== c.charAt(0) || '_' !== c.charAt(1)) || '_' === c.charAt(c.length - 1) && '_' === c.charAt(c.length - 2))
      return b;
    d = a.v;
    d.replace(/_/g, '');
    if ('' === d)
      return b;
    d = a.v;
    d.replace(/^_*/, '');
    return d = new Sk.builtin.str('_' + d + c);
  }
  Compiler.prototype._gr = function (a, b) {
    var c = this.gensym(a);
    out('var ', c, '=');
    for (var d = 1; d < arguments.length; ++d)
      out(arguments[d]);
    out(';');
    return c;
  };
  Compiler.prototype._interruptTest = function () {
    out('if (Sk.execStart === undefined) {Sk.execStart=new Date()}');
    out('if (Sk.execLimit != null && new Date() - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeLimitError(Sk.timeoutMsg())}');
  };
  Compiler.prototype._jumpfalse = function (a, b) {
    var c = this._gr('jfalse', '(', a, '===false||!Sk.misceval.isTrue(', a, '))');
    this._interruptTest();
    out('if(', c, '){/*test failed */$blk=', b, ';continue;}');
  };
  Compiler.prototype._jumpundef = function (a, b) {
    this._interruptTest();
    out('if(', a, '===undefined){$blk=', b, ';continue;}');
  };
  Compiler.prototype._jumptrue = function (a, b) {
    var c = this._gr('jtrue', '(', a, '===true||Sk.misceval.isTrue(', a, '))');
    this._interruptTest();
    out('if(', c, '){/*test passed */$blk=', b, ';continue;}');
  };
  Compiler.prototype._jump = function (a) {
    this._interruptTest();
    out('$blk=', a, ';/* jump */continue;');
  };
  Compiler.prototype.ctupleorlist = function (a, b, c) {
    goog.asserts.assert('tuple' === c || 'list' === c);
    if (a.ctx === Store)
      for (var d = 0; d < a.elts.length; ++d)
        this.vexpr(a.elts[d], 'Sk.abstr.objectGetItem(' + b + ',' + d + ')');
    else if (a.ctx === Load) {
      b = [];
      for (d = 0; d < a.elts.length; ++d)
        b.push(this._gr('elem', this.vexpr(a.elts[d])));
      return this._gr('load' + c, 'new Sk.builtins[\'', c, '\']([', b, '])');
    }
  };
  Compiler.prototype.cdict = function (a) {
    goog.asserts.assert(a.values.length === a.keys.length);
    for (var b = [], c = 0; c < a.values.length; ++c) {
      var d = this.vexpr(a.values[c]);
      b.push(this.vexpr(a.keys[c]));
      b.push(d);
    }
    return this._gr('loaddict', 'new Sk.builtins[\'dict\']([', b, '])');
  };
  Compiler.prototype.clistcompgen = function (a, b, c, d) {
    var e = this.newBlock('list gen start'), f = this.newBlock('list gen skip'), g = this.newBlock('list gen anchor'), h = b[c], k = this.vexpr(h.iter), k = this._gr('iter', 'Sk.abstr.iter(', k, ')');
    this._jump(e);
    this.setBlock(e);
    k = this._gr('next', 'Sk.abstr.iternext(', k, ')');
    this._jumpundef(k, g);
    this.vexpr(h.target, k);
    for (var k = h.ifs.length, l = 0; l < k; ++l) {
      var m = this.vexpr(h.ifs[l]);
      this._jumpfalse(m, e);
    }
    ++c < b.length && this.clistcompgen(a, b, c, d);
    c >= b.length && (b = this.vexpr(d), out(a, '.v.push(', b, ');'), this._jump(f), this.setBlock(f));
    this._jump(e);
    this.setBlock(g);
    return a;
  };
  Compiler.prototype.clistcomp = function (a) {
    goog.asserts.assert(a instanceof ListComp);
    var b = this._gr('_compr', 'new Sk.builtins[\'list\']([])');
    return this.clistcompgen(b, a.generators, 0, a.elt);
  };
  Compiler.prototype.cyield = function (a) {
    if (this.u.ste.blockType !== FunctionBlock)
      throw new SyntaxError('\'yield\' outside function');
    var b = 'null';
    a.value && (b = this.vexpr(a.value));
    a = this.newBlock('after yield');
    out('return [/*resume*/', a, ',/*ret*/', b, '];');
    this.setBlock(a);
    return '$gen.gi$sentvalue';
  };
  Compiler.prototype.ccompare = function (a) {
    goog.asserts.assert(a.ops.length === a.comparators.length);
    for (var b = this.vexpr(a.left), c = a.ops.length, d = this.newBlock('done'), e = this._gr('compareres', 'null'), f = 0; f < c; ++f) {
      var g = this.vexpr(a.comparators[f]), b = this._gr('compare', 'Sk.builtin.bool(Sk.misceval.richCompareBool(', b, ',', g, ',\'', a.ops[f].prototype._astname, '\'))');
      out(e, '=', b, ';');
      this._jumpfalse(b, d);
      b = g;
    }
    this._jump(d);
    this.setBlock(d);
    return e;
  };
  Compiler.prototype.ccall = function (a) {
    var b = this.vexpr(a.func), c = this.vseqexpr(a.args);
    if (0 < a.keywords.length || a.starargs || a.kwargs) {
      for (var d = [], e = 0; e < a.keywords.length; ++e)
        d.push('\'' + a.keywords[e].arg.v + '\''), d.push(this.vexpr(a.keywords[e].value));
      var d = '[' + d.join(',') + ']', f = e = 'undefined';
      a.starargs && (e = this.vexpr(a.starargs));
      a.kwargs && (f = this.vexpr(a.kwargs));
      return this._gr('call', 'Sk.misceval.call(', b, ',', f, ',', e, ',', d, 0 < c.length ? ',' : '', c, ')');
    }
    return this._gr('call', 'Sk.misceval.callsim(', b, 0 < c.length ? ',' : '', c, ')');
  };
  Compiler.prototype.cslice = function (a) {
    goog.asserts.assert(a instanceof Slice);
    var b = a.lower ? this.vexpr(a.lower) : 'null', c = a.upper ? this.vexpr(a.upper) : 'null';
    a = a.step ? this.vexpr(a.step) : 'null';
    return this._gr('slice', 'new Sk.builtins[\'slice\'](', b, ',', c, ',', a, ')');
  };
  Compiler.prototype.vslicesub = function (a) {
    var b;
    switch (a.constructor) {
    case Number:
    case String:
      b = a;
      break;
    case Index:
      b = this.vexpr(a.value);
      break;
    case Slice:
      b = this.cslice(a);
      break;
    case Ellipsis:
    case ExtSlice:
      goog.asserts.fail('todo;');
      break;
    default:
      goog.asserts.fail('invalid subscript kind');
    }
    return b;
  };
  Compiler.prototype.vslice = function (a, b, c, d) {
    a = this.vslicesub(a);
    return this.chandlesubscr(b, c, a, d);
  };
  Compiler.prototype.chandlesubscr = function (a, b, c, d) {
    if (a === Load || a === AugLoad)
      return this._gr('lsubscr', 'Sk.abstr.objectGetItem(', b, ',', c, ')');
    a === Store || a === AugStore ? out('Sk.abstr.objectSetItem(', b, ',', c, ',', d, ');') : a === Del ? out('Sk.abstr.objectDelItem(', b, ',', c, ');') : goog.asserts.fail('handlesubscr fail');
  };
  Compiler.prototype.cboolop = function (a) {
    goog.asserts.assert(a instanceof BoolOp);
    var b;
    b = a.op === And ? this._jumpfalse : this._jumptrue;
    var c = this.newBlock('end of boolop');
    a = a.values;
    for (var d = a.length, e, f = 0; f < d; ++f) {
      var g = this.vexpr(a[f]);
      0 === f && (e = this._gr('boolopsucc', g));
      out(e, '=', g, ';');
      b.call(this, g, c);
    }
    this._jump(c);
    this.setBlock(c);
    return e;
  };
  Compiler.prototype.vexpr = function (a, b, c) {
    a.lineno > this.u.lineno && (this.u.lineno = a.lineno, this.u.linenoSet = !1);
    switch (a.constructor) {
    case BoolOp:
      return this.cboolop(a);
    case BinOp:
      return this._gr('binop', 'Sk.abstr.numberBinOp(', this.vexpr(a.left), ',', this.vexpr(a.right), ',\'', a.op.prototype._astname, '\')');
    case UnaryOp:
      return this._gr('unaryop', 'Sk.abstr.numberUnaryOp(', this.vexpr(a.operand), ',\'', a.op.prototype._astname, '\')');
    case Lambda:
      return this.clambda(a);
    case IfExp:
      return this.cifexp(a);
    case Dict:
      return this.cdict(a);
    case ListComp:
      return this.clistcomp(a);
    case GeneratorExp:
      return this.cgenexp(a);
    case Yield:
      return this.cyield(a);
    case Compare:
      return this.ccompare(a);
    case Call:
      return b = this.ccall(a), this.annotateSource(a), b;
    case Num:
      if ('number' === typeof a.n)
        return a.n;
      if (a.n instanceof Sk.builtin.nmber)
        return 'new Sk.builtin.nmber(' + a.n.v + ',\'' + a.n.skType + '\')';
      if (a.n instanceof Sk.builtin.lng)
        return 'Sk.longFromStr(\'' + a.n.tp$str().v + '\')';
      goog.asserts.fail('unhandled Num type');
    case Str:
      return this._gr('str', 'new Sk.builtins[\'str\'](', a.s.$r().v, ')');
    case Attribute:
      var d;
      a.ctx !== AugStore && (d = this.vexpr(a.value));
      var e = a.attr.$r().v, e = e.substring(1, e.length - 1), e = mangleName(this.u.private_, new Sk.builtin.str(e)).v, e = fixReservedWords(e), e = fixReservedNames(e);
      switch (a.ctx) {
      case AugLoad:
      case Load:
        return this._gr('lattr', 'Sk.abstr.gattr(', d, ',\'', e, '\')');
      case AugStore:
        out('if(', b, '!==undefined){');
        d = this.vexpr(c || null);
        out('Sk.abstr.sattr(', d, ',\'', e, '\',', b, ');');
        out('}');
        break;
      case Store:
        out('Sk.abstr.sattr(', d, ',\'', e, '\',', b, ');');
        break;
      case Del:
        goog.asserts.fail('todo;');
        break;
      default:
        goog.asserts.fail('invalid attribute expression');
      }
      break;
    case Subscript:
      switch (a.ctx) {
      case AugLoad:
      case Load:
      case Store:
      case Del:
        return this.vslice(a.slice, a.ctx, this.vexpr(a.value), b);
      case AugStore:
        out('if(', b, '!==undefined){');
        d = this.vexpr(c || null);
        this.vslice(a.slice, a.ctx, d, b);
        out('}');
        break;
      default:
        goog.asserts.fail('invalid subscript expression');
      }
      break;
    case Name:
      return this.nameop(a.id, a.ctx, b);
    case List:
      return this.ctupleorlist(a, b, 'list');
    case Tuple:
      return this.ctupleorlist(a, b, 'tuple');
    default:
      goog.asserts.fail('unhandled case in vexpr');
    }
  };
  Compiler.prototype.vseqexpr = function (a, b) {
    goog.asserts.assert(void 0 === b || a.length === b.length);
    for (var c = [], d = 0; d < a.length; ++d)
      c.push(this.vexpr(a[d], void 0 === b ? void 0 : b[d]));
    return c;
  };
  Compiler.prototype.caugassign = function (a) {
    goog.asserts.assert(a instanceof AugAssign);
    var b = a.target;
    switch (b.constructor) {
    case Attribute:
      var c = new Attribute(b.value, b.attr, AugLoad, b.lineno, b.col_offset), d = this.vexpr(c), e = this.vexpr(a.value);
      a = this._gr('inplbinopattr', 'Sk.abstr.numberInplaceBinOp(', d, ',', e, ',\'', a.op.prototype._astname, '\')');
      c.ctx = AugStore;
      return this.vexpr(c, a, b.value);
    case Subscript:
      return c = this.vslicesub(b.slice), c = new Subscript(b.value, c, AugLoad, b.lineno, b.col_offset), d = this.vexpr(c), e = this.vexpr(a.value), a = this._gr('inplbinopsubscr', 'Sk.abstr.numberInplaceBinOp(', d, ',', e, ',\'', a.op.prototype._astname, '\')'), c.ctx = AugStore, this.vexpr(c, a, b.value);
    case Name:
      return c = this.nameop(b.id, Load), e = this.vexpr(a.value), a = this._gr('inplbinop', 'Sk.abstr.numberInplaceBinOp(', c, ',', e, ',\'', a.op.prototype._astname, '\')'), this.nameop(b.id, Store, a);
    default:
      goog.asserts.fail('unhandled case in augassign');
    }
  };
  Compiler.prototype.exprConstant = function (a) {
    switch (a.constructor) {
    case Num:
      return Sk.misceval.isTrue(a.n);
    case Str:
      return Sk.misceval.isTrue(a.s);
    default:
      return -1;
    }
  };
  Compiler.prototype.newBlock = function (a) {
    var b = this.u.blocknum++;
    this.u.blocks[b] = [];
    this.u.blocks[b]._name = a || '<unnamed>';
    return b;
  };
  Compiler.prototype.setBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.curblock = a;
  };
  Compiler.prototype.pushBreakBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.breakBlocks.push(a);
  };
  Compiler.prototype.popBreakBlock = function () {
    this.u.breakBlocks.pop();
  };
  Compiler.prototype.pushContinueBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.continueBlocks.push(a);
  };
  Compiler.prototype.popContinueBlock = function () {
    this.u.continueBlocks.pop();
  };
  Compiler.prototype.pushExceptBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.exceptBlocks.push(a);
  };
  Compiler.prototype.popExceptBlock = function () {
    this.u.exceptBlocks.pop();
  };
  Compiler.prototype.pushFinallyBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.finallyBlocks.push(a);
  };
  Compiler.prototype.popFinallyBlock = function () {
    this.u.finallyBlocks.pop();
  };
  Compiler.prototype.setupExcept = function (a) {
    out('$exc.push(', a, ');');
  };
  Compiler.prototype.endExcept = function () {
    out('$exc.pop();');
  };
  Compiler.prototype.outputLocals = function (a) {
    for (var b = {}, c = 0; a.argnames && c < a.argnames.length; ++c)
      b[a.argnames[c]] = !0;
    a.localnames.sort();
    for (var d = [], c = 0; c < a.localnames.length; ++c) {
      var e = a.localnames[c];
      void 0 === b[e] && (d.push(e), b[e] = !0);
    }
    return 0 < d.length ? 'var ' + d.join(',') + '; /* locals */' : '';
  };
  Compiler.prototype.outputAllUnits = function () {
    for (var a = '', b = 0; b < this.allUnits.length; ++b) {
      for (var c = this.allUnits[b], a = a + c.prefixCode, a = a + this.outputLocals(c), a = a + c.varDeclsCode, a = a + c.switchCode, d = c.blocks, e = 0; e < d.length; ++e)
        a += 'case ' + e + ': /* --- ' + d[e]._name + ' --- */', a += d[e].join(''), a += 'throw new Sk.builtin.SystemError(\'internal error: unterminated block\');';
      a += c.suffixCode;
    }
    return a;
  };
  Compiler.prototype.cif = function (a) {
    goog.asserts.assert(a instanceof If_);
    var b = this.exprConstant(a.test);
    if (0 === b)
      a.orelse && this.vseqstmt(a.orelse);
    else if (1 === b)
      this.vseqstmt(a.body);
    else {
      var c = this.newBlock('end of if'), b = this.newBlock('next branch of if'), d = this.vexpr(a.test);
      this._jumpfalse(d, b);
      this.vseqstmt(a.body);
      this._jump(c);
      this.setBlock(b);
      a.orelse && this.vseqstmt(a.orelse);
      this._jump(c);
    }
    this.setBlock(c);
  };
  Compiler.prototype.cwhile = function (a) {
    if (0 === this.exprConstant(a.test))
      a.orelse && this.vseqstmt(a.orelse);
    else {
      var b = this.newBlock('while test');
      this._jump(b);
      this.setBlock(b);
      var c = this.newBlock('after while'), d = 0 < a.orelse.length ? this.newBlock('while orelse') : null, e = this.newBlock('while body');
      this._jumpfalse(this.vexpr(a.test), d ? d : c);
      this._jump(e);
      this.pushBreakBlock(c);
      this.pushContinueBlock(b);
      this.setBlock(e);
      this.vseqstmt(a.body);
      this._jump(b);
      this.popContinueBlock();
      this.popBreakBlock();
      0 < a.orelse.length && (this.setBlock(d), this.vseqstmt(a.orelse), this._jump(c));
      this.setBlock(c);
    }
  };
  Compiler.prototype.cfor = function (a) {
    var b = this.newBlock('for start'), c = this.newBlock('for cleanup'), d = this.newBlock('for end');
    this.pushBreakBlock(d);
    this.pushContinueBlock(b);
    var e = this.vexpr(a.iter), f;
    this.u.ste.generator ? (f = '$loc.' + this.gensym('iter'), out(f, '=Sk.abstr.iter(', e, ');')) : f = this._gr('iter', 'Sk.abstr.iter(', e, ')');
    this._jump(b);
    this.setBlock(b);
    e = this._gr('next', 'Sk.abstr.iternext(', f, ')');
    this._jumpundef(e, c);
    this.vexpr(a.target, e);
    this.vseqstmt(a.body);
    this._jump(b);
    this.setBlock(c);
    this.popContinueBlock();
    this.popBreakBlock();
    this.vseqstmt(a.orelse);
    this._jump(d);
    this.setBlock(d);
  };
  Compiler.prototype.craise = function (a) {
    if (a && a.type && a.type.id && 'StopIteration' === a.type.id.v)
      out('return undefined;');
    else {
      var b = '';
      a.inst ? (b = this.vexpr(a.inst), out('throw ', this.vexpr(a.type), '(', b, ');')) : a.type ? a.type.func ? out('throw ', this.vexpr(a.type), ';') : out('throw ', this.vexpr(a.type), '(\'\');') : out('throw $err;');
    }
  };
  Compiler.prototype.ctryexcept = function (a) {
    for (var b = a.handlers.length, c = [], d = 0; d < b; ++d)
      c.push(this.newBlock('except_' + d + '_'));
    var e = this.newBlock('unhandled'), f = this.newBlock('orelse'), g = this.newBlock('end');
    this.setupExcept(c[0]);
    this.vseqstmt(a.body);
    this.endExcept();
    this._jump(f);
    for (d = 0; d < b; ++d) {
      this.setBlock(c[d]);
      var h = a.handlers[d];
      if (!h.type && d < b - 1)
        throw new SyntaxError('default \'except:\' must be last');
      if (h.type) {
        var k = this.vexpr(h.type), l = d == b - 1 ? e : c[d + 1], k = this._gr('instance', '$err instanceof ', k);
        this._jumpfalse(k, l);
      }
      h.name && this.vexpr(h.name, '$err');
      this.vseqstmt(h.body);
      this._jump(g);
    }
    this.setBlock(e);
    out('throw $err;');
    this.setBlock(f);
    this.vseqstmt(a.orelse);
    this._jump(g);
    this.setBlock(g);
  };
  Compiler.prototype.ctryfinally = function (a) {
    out('/*todo; tryfinally*/');
    this.ctryexcept(a.body[0]);
  };
  Compiler.prototype.cassert = function (a) {
    var b = this.vexpr(a.test), c = this.newBlock('end');
    this._jumptrue(b, c);
    out('throw new Sk.builtin.AssertionError(', a.msg ? this.vexpr(a.msg) : '', ');');
    this.setBlock(c);
  };
  Compiler.prototype.cimportas = function (a, b, c) {
    a = a.v;
    var d = a.indexOf('.');
    if (-1 !== d)
      for (a = a.substr(d + 1); -1 !== d;) {
        var d = a.indexOf('.'), e = -1 !== d ? a.substr(0, d) : a;
        c = this._gr('lattr', 'Sk.abstr.gattr(', c, ',\'', e, '\')');
        a = a.substr(d + 1);
      }
    return this.nameop(b, Store, c);
  };
  Compiler.prototype.cimport = function (a) {
    for (var b = a.names.length, c = 0; c < b; ++c) {
      var d = a.names[c], e = this._gr('module', 'Sk.builtin.__import__(', d.name.$r().v, ',$gbl,$loc,[])');
      if (d.asname)
        this.cimportas(d.name, d.asname, e);
      else {
        var d = d.name, f = d.v.indexOf('.');
        -1 !== f && (d = new Sk.builtin.str(d.v.substr(0, f)));
        this.nameop(d, Store, e);
      }
    }
  };
  Compiler.prototype.cfromimport = function (a) {
    for (var b = a.names.length, c = [], d = 0; d < b; ++d)
      c[d] = a.names[d].name.$r().v;
    c = this._gr('module', 'Sk.builtin.__import__(', a.module.$r().v, ',$gbl,$loc,[', c, '])');
    for (d = 0; d < b; ++d) {
      var e = a.names[d];
      if (0 === d && '*' === e.name.v) {
        goog.asserts.assert(1 === b);
        out('Sk.importStar(', c, ',$loc, $gbl);');
        break;
      }
      var f = this._gr('item', 'Sk.abstr.gattr(', c, ',', e.name.$r().v, ')'), g = e.name;
      e.asname && (g = e.asname);
      this.nameop(g, Store, f);
    }
  };
  Compiler.prototype.buildcodeobj = function (a, b, c, d, e) {
    var f = [], g = null, h = null;
    c && this.vseqexpr(c);
    d && d.defaults && (f = this.vseqexpr(d.defaults));
    d && d.vararg && (g = d.vararg);
    d && d.kwarg && (h = d.kwarg);
    a = this.enterScope(b, a, a.lineno);
    c = this.u.ste.generator;
    var k = this.u.ste.hasFree, l = this.u.ste.childHasFree, m = this.newBlock('codeobj entry');
    this.u.prefixCode = 'var ' + a + '=(function ' + this.niceName(b.v) + '$(';
    var n = [];
    if (c) {
      if (h)
        throw new SyntaxError(b.v + '(): keyword arguments in generators not supported');
      if (g)
        throw new SyntaxError(b.v + '(): variable number of arguments in generators not supported');
      n.push('$gen');
    } else {
      h && n.push('$kwa');
      for (var p = 0; d && p < d.args.length; ++p)
        n.push(this.nameop(d.args[p].id, Param));
    }
    k && n.push('$free');
    this.u.prefixCode += n.join(',');
    this.u.prefixCode += '){';
    c && (this.u.prefixCode += '\n// generator\n');
    k && (this.u.prefixCode += '\n// has free\n');
    l && (this.u.prefixCode += '\n// has cell\n');
    p = '{}';
    c && (m = '$gen.gi$resumeat', p = '$gen.gi$locals');
    var q = '';
    l && (q = ',$cell={}');
    this.u.varDeclsCode += 'var $blk=' + m + ',$exc=[],$loc=' + p + q + ',$gbl=this,$err=undefined;';
    for (p = 0; d && p < d.args.length; ++p)
      l = d.args[p].id, this.isCell(l) && (this.u.varDeclsCode += '$cell.' + l.v + '=' + l.v + ';');
    c || (this.u.varDeclsCode += 'Sk.builtin.pyCheckArgs("' + b.v + '", arguments, ' + (d ? d.args.length - f.length : 0) + ', ' + (g ? Infinity : d ? d.args.length : 0) + ', ' + (h ? !0 : !1) + ', ' + k + ');');
    if (0 < f.length)
      for (l = d.args.length - f.length, p = 0; p < f.length; ++p)
        m = this.nameop(d.args[p + l].id, Param), this.u.varDeclsCode += 'if(' + m + '===undefined)' + m + '=' + a + '.$defaults[' + p + '];';
    g && (this.u.varDeclsCode += g.v + '=new Sk.builtins[\'tuple\'](Array.prototype.slice.call(arguments,' + n.length + ')); /*vararg*/');
    h && (this.u.varDeclsCode += h.v + '=new Sk.builtins[\'dict\']($kwa);');
    this.u.switchCode = 'while(true){try{ switch($blk){';
    this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});';
    e.call(this, a);
    var r;
    if (d && 0 < d.args.length) {
      e = [];
      for (p = 0; p < d.args.length; ++p)
        e.push(d.args[p].id.v);
      r = e.join('\', \'');
      this.u.argnames = e;
    }
    this.exitScope();
    0 < f.length && out(a, '.$defaults=[', f.join(','), '];');
    r && out(a, '.co_varnames=[\'', r, '\'];');
    h && out(a, '.co_kwargs=1;');
    h = '';
    k && (h = ',$cell', this.u.ste.hasFree && (h += ',$free'));
    return c ? d && 0 < d.args.length ? this._gr('gener', '(function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgs("', b.v, '",arguments,', d.args.length - f.length, ',', d.args.length, ');return new Sk.builtins[\'generator\'](', a, ',$gbl,$origargs', h, ');})') : this._gr('gener', '(function(){Sk.builtin.pyCheckArgs("', b.v, '",arguments,0,0);return new Sk.builtins[\'generator\'](', a, ',$gbl,[]', h, ');})') : this._gr('funcobj', 'new Sk.builtins[\'function\'](', a, ',$gbl', h, ')');
  };
  Compiler.prototype.cfunction = function (a) {
    goog.asserts.assert(a instanceof FunctionDef);
    var b = this.buildcodeobj(a, a.name, a.decorator_list, a.args, function (b) {
        this.vseqstmt(a.body);
        out('return Sk.builtin.none.none$;');
      });
    this.nameop(a.name, Store, b);
  };
  Compiler.prototype.clambda = function (a) {
    goog.asserts.assert(a instanceof Lambda);
    return this.buildcodeobj(a, new Sk.builtin.str('<lambda>'), null, a.args, function (b) {
      b = this.vexpr(a.body);
      out('return ', b, ';');
    });
  };
  Compiler.prototype.cifexp = function (a) {
    var b = this.newBlock('next of ifexp'), c = this.newBlock('end of ifexp'), d = this._gr('res', 'null'), e = this.vexpr(a.test);
    this._jumpfalse(e, b);
    out(d, '=', this.vexpr(a.body), ';');
    this._jump(c);
    this.setBlock(b);
    out(d, '=', this.vexpr(a.orelse), ';');
    this._jump(c);
    this.setBlock(c);
    return d;
  };
  Compiler.prototype.cgenexpgen = function (a, b, c) {
    var d = this.newBlock('start for ' + b), e = this.newBlock('skip for ' + b);
    this.newBlock('if cleanup for ' + b);
    var f = this.newBlock('end for ' + b), g = a[b], h;
    if (0 === b)
      h = '$loc.$iter0';
    else {
      var k = this.vexpr(g.iter);
      h = '$loc.' + this.gensym('iter');
      out(h, '=', 'Sk.abstr.iter(', k, ');');
    }
    this._jump(d);
    this.setBlock(d);
    h = this._gr('next', 'Sk.abstr.iternext(', h, ')');
    this._jumpundef(h, f);
    this.vexpr(g.target, h);
    h = g.ifs.length;
    for (k = 0; k < h; ++k) {
      var l = this.vexpr(g.ifs[k]);
      this._jumpfalse(l, d);
    }
    ++b < a.length && this.cgenexpgen(a, b, c);
    b >= a.length && (a = this.vexpr(c), out('return [', e, '/*resume*/,', a, '/*ret*/];'), this.setBlock(e));
    this._jump(d);
    this.setBlock(f);
    1 === b && out('return null;');
  };
  Compiler.prototype.cgenexp = function (a) {
    var b = this.buildcodeobj(a, new Sk.builtin.str('<genexpr>'), null, null, function (b) {
        this.cgenexpgen(a.generators, 0, a.elt);
      }), b = this._gr('gener', b, '()');
    out(b, '.gi$locals.$iter0=Sk.abstr.iter(', this.vexpr(a.generators[0].iter), ');');
    return b;
  };
  Compiler.prototype.cclass = function (a) {
    goog.asserts.assert(a instanceof ClassDef);
    var b = this.vseqexpr(a.bases), c = this.enterScope(a.name, a, a.lineno), d = this.newBlock('class entry');
    this.u.prefixCode = 'var ' + c + '=(function $' + a.name.v + '$class_outer($globals,$locals,$rest){var $gbl=$globals,$loc=$locals;';
    this.u.switchCode += 'return(function ' + a.name.v + '(){';
    this.u.switchCode += 'var $blk=' + d + ',$exc=[];while(true){switch($blk){';
    this.u.suffixCode = '}break;}}).apply(null,$rest);});';
    this.u.private_ = a.name;
    this.cbody(a.body);
    out('break;');
    this.exitScope();
    b = this._gr('built', 'Sk.misceval.buildClass($gbl,', c, ',', a.name.$r().v, ',[', b, '])');
    this.nameop(a.name, Store, b);
  };
  Compiler.prototype.ccontinue = function (a) {
    if (0 === this.u.continueBlocks.length)
      throw new SyntaxError('\'continue\' outside loop');
    this._jump(this.u.continueBlocks[this.u.continueBlocks.length - 1]);
  };
  Compiler.prototype.vstmt = function (a) {
    this.u.lineno = a.lineno;
    this.u.linenoSet = !1;
    this.annotateSource(a);
    switch (a.constructor) {
    case FunctionDef:
      this.cfunction(a);
      break;
    case ClassDef:
      this.cclass(a);
      break;
    case Return_:
      if (this.u.ste.blockType !== FunctionBlock)
        throw new SyntaxError('\'return\' outside function');
      a.value ? out('return ', this.vexpr(a.value), ';') : out('return null;');
      break;
    case Delete_:
      this.vseqexpr(a.targets);
      break;
    case Assign:
      for (var b = a.targets.length, c = this.vexpr(a.value), d = 0; d < b; ++d)
        this.vexpr(a.targets[d], c);
      break;
    case AugAssign:
      return this.caugassign(a);
    case Print:
      this.cprint(a);
      break;
    case For_:
      return this.cfor(a);
    case While_:
      return this.cwhile(a);
    case If_:
      return this.cif(a);
    case Raise:
      return this.craise(a);
    case TryExcept:
      return this.ctryexcept(a);
    case TryFinally:
      return this.ctryfinally(a);
    case Assert:
      return this.cassert(a);
    case Import_:
      return this.cimport(a);
    case ImportFrom:
      return this.cfromimport(a);
    case Global:
      break;
    case Expr:
      this.vexpr(a.value);
      break;
    case Pass:
      break;
    case Break_:
      if (0 === this.u.breakBlocks.length)
        throw new SyntaxError('\'break\' outside loop');
      this._jump(this.u.breakBlocks[this.u.breakBlocks.length - 1]);
      break;
    case Continue_:
      this.ccontinue(a);
      break;
    default:
      goog.asserts.fail('unhandled case in vstmt');
    }
  };
  Compiler.prototype.vseqstmt = function (a) {
    for (var b = 0; b < a.length; ++b)
      this.vstmt(a[b]);
  };
  var OP_FAST = 0, OP_GLOBAL = 1, OP_DEREF = 2, OP_NAME = 3, D_NAMES = 0, D_FREEVARS = 1, D_CELLVARS = 2;
  Compiler.prototype.isCell = function (a) {
    a = mangleName(this.u.private_, a).v;
    return this.u.ste.getScope(a) === CELL ? !0 : !1;
  };
  Compiler.prototype.nameop = function (a, b, c) {
    if ((b === Store || b === AugStore || b === Del) && '__debug__' === a.v)
      throw new Sk.builtin.SyntaxError('can not assign to __debug__');
    if ((b === Store || b === AugStore || b === Del) && 'None' === a.v)
      throw new Sk.builtin.SyntaxError('can not assign to None');
    if ('None' === a.v)
      return 'Sk.builtin.none.none$';
    if ('True' === a.v)
      return 'Sk.builtin.bool.true$';
    if ('False' === a.v)
      return 'Sk.builtin.bool.false$';
    var d = mangleName(this.u.private_, a).v, d = fixReservedNames(d), e = OP_NAME, f = this.u.ste.getScope(d), g = null;
    switch (f) {
    case FREE:
      g = '$free';
      e = OP_DEREF;
      break;
    case CELL:
      g = '$cell';
      e = OP_DEREF;
      break;
    case LOCAL:
      this.u.ste.blockType !== FunctionBlock || this.u.ste.generator || (e = OP_FAST);
      break;
    case GLOBAL_IMPLICIT:
      this.u.ste.blockType === FunctionBlock && (e = OP_GLOBAL);
      break;
    case GLOBAL_EXPLICIT:
      e = OP_GLOBAL;
    }
    d = fixReservedWords(d);
    goog.asserts.assert(f || '_' === a.v.charAt(1));
    a = d;
    this.u.ste.generator || this.u.ste.blockType !== FunctionBlock ? d = '$loc.' + d : e !== OP_FAST && e !== OP_NAME || this.u.localnames.push(d);
    switch (e) {
    case OP_FAST:
      switch (b) {
      case Load:
      case Param:
        return out('if (', d, ' === undefined) { throw new Error(\'local variable \\\'', d, '\\\' referenced before assignment\'); }\n'), d;
      case Store:
        out(d, '=', c, ';');
        break;
      case Del:
        out('delete ', d, ';');
        break;
      default:
        goog.asserts.fail('unhandled');
      }
      break;
    case OP_NAME:
      switch (b) {
      case Load:
        return b = this.gensym('loadname'), out('var ', b, '=', d, '!==undefined?', d, ':Sk.misceval.loadname(\'', a, '\',$gbl);'), b;
      case Store:
        out(d, '=', c, ';');
        break;
      case Del:
        out('delete ', d, ';');
        break;
      case Param:
        return d;
      default:
        goog.asserts.fail('unhandled');
      }
      break;
    case OP_GLOBAL:
      switch (b) {
      case Load:
        return this._gr('loadgbl', 'Sk.misceval.loadname(\'', a, '\',$gbl)');
      case Store:
        out('$gbl.', a, '=', c, ';');
        break;
      case Del:
        out('delete $gbl.', a);
        break;
      default:
        goog.asserts.fail('unhandled case in name op_global');
      }
      break;
    case OP_DEREF:
      switch (b) {
      case Load:
        return g + '.' + a;
      case Store:
        out(g, '.', a, '=', c, ';');
        break;
      case Param:
        return a;
      default:
        goog.asserts.fail('unhandled case in name op_deref');
      }
      break;
    default:
      goog.asserts.fail('unhandled case');
    }
  };
  Compiler.prototype.enterScope = function (a, b, c) {
    var d = new CompilerUnit();
    d.ste = this.st.getStsForAst(b);
    d.name = a;
    d.firstlineno = c;
    this.u && this.u.private_ && (d.private_ = this.u.private_);
    this.stack.push(this.u);
    this.allUnits.push(d);
    a = this.gensym('scope');
    d.scopename = a;
    this.u = d;
    this.u.activateScope();
    this.nestlevel++;
    return a;
  };
  Compiler.prototype.exitScope = function () {
    var a = this.u;
    this.nestlevel--;
    (this.u = 0 <= this.stack.length - 1 ? this.stack.pop() : null) && this.u.activateScope();
    if ('<module>' !== a.name.v) {
      var b = a.name.$r().v, b = b.substring(1, b.length - 1), b = fixReservedWords(b), b = fixReservedNames(b);
      out(a.scopename, '.co_name=new Sk.builtins[\'str\'](\'', b, '\');');
    }
  };
  Compiler.prototype.cbody = function (a) {
    for (var b = 0; b < a.length; ++b)
      this.vstmt(a[b]);
  };
  Compiler.prototype.cprint = function (a) {
    goog.asserts.assert(a instanceof Print);
    a.dest && this.vexpr(a.dest);
    for (var b = a.values.length, c = 0; c < b; ++c)
      out('Sk.misceval.print_(', 'new Sk.builtins[\'str\'](', this.vexpr(a.values[c]), ').v);');
    a.nl && out('Sk.misceval.print_(', '"\\n");');
  };
  Compiler.prototype.cmod = function (a) {
    var b = this.enterScope(new Sk.builtin.str('<module>'), a, 0), c = this.newBlock('module entry');
    this.u.prefixCode = 'var ' + b + '=(function($modname){';
    this.u.varDeclsCode = 'var $blk=' + c + ',$exc=[],$gbl={},$loc=$gbl,$err=undefined;$gbl.__name__=$modname;Sk.globals=$gbl;';
    this.u.switchCode = 'try { while(true){try{ switch($blk){';
    this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } }catch(err){ if (err instanceof Sk.builtin.SystemExit && !Sk.throwSystemExit) { Sk.misceval.print_(err.toString() + \'\\n\'); return $loc; } else { throw err; } } });';
    switch (a.constructor) {
    case Module:
      this.cbody(a.body);
      out('return $loc;');
      break;
    default:
      goog.asserts.fail('todo; unhandled case in compilerMod');
    }
    this.exitScope();
    this.result.push(this.outputAllUnits());
    return b;
  };
  Sk.compile = function (a, b, c) {
    c = Sk.parse(b, a);
    c = Sk.astFromParse(c, b);
    var d = Sk.symboltable(c, b);
    a = new Compiler(b, d, 0, a);
    b = a.cmod(c);
    a = a.result.join('');
    return {
      funcname: b,
      code: a
    };
  };
  goog.exportSymbol('Sk.compile', Sk.compile);
  Sk.resetCompiler = function () {
    Sk.gensymcount = 0;
  };
  goog.exportSymbol('Sk.resetCompiler', Sk.resetCompiler);
  Sk.sysmodules = new Sk.builtin.dict([]);
  Sk.realsyspath = void 0;
  Sk.importSearchPathForName = function (a, b, c) {
    for (var d = Sk.realsyspath.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      for (var f = a.replace(/\./g, '/'), e = [
            e.v + '/' + f + b,
            e.v + '/' + f + '/__init__' + b
          ], f = 0; f < e.length; ++f) {
        var g = e[f];
        try {
          return Sk.read(g), g;
        } catch (h) {
        }
      }
    if (!c)
      throw new Sk.builtin.ImportError('No module named ' + a);
  };
  Sk.doOneTimeInitialization = function () {
    Sk.builtin.type.basesStr_ = new Sk.builtin.str('__bases__');
    Sk.builtin.type.mroStr_ = new Sk.builtin.str('__mro__');
    Sk.builtin.object.$d = new Sk.builtin.dict([]);
    Sk.builtin.object.$d.mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple([]));
    Sk.builtin.object.$d.mp$ass_subscript(Sk.builtin.type.mroStr_, new Sk.builtin.tuple([Sk.builtin.object]));
  };
  Sk.importSetUpPath = function () {
    if (!Sk.realsyspath) {
      for (var a = [
            new Sk.builtin.str('src/builtin'),
            new Sk.builtin.str('src/lib'),
            new Sk.builtin.str('.')
          ], b = 0; b < Sk.syspath.length; ++b)
        a.push(new Sk.builtin.str(Sk.syspath[b]));
      Sk.realsyspath = new Sk.builtin.list(a);
      Sk.doOneTimeInitialization();
    }
  };
  if (COMPILED)
    var js_beautify = function (a) {
      return a;
    };
  Sk.importModuleInternal_ = function (a, b, c, d) {
    Sk.importSetUpPath();
    void 0 === c && (c = a);
    var e = null, f = c.split('.'), g;
    try {
      var h = Sk.sysmodules.mp$subscript(c);
      return 1 < f.length ? Sk.sysmodules.mp$subscript(f[0]) : h;
    } catch (k) {
    }
    1 < f.length && (g = f.slice(0, f.length - 1).join('.'), e = Sk.importModuleInternal_(g, b));
    h = new Sk.builtin.module();
    Sk.sysmodules.mp$ass_subscript(a, h);
    d ? a = Sk.compile(d, a + '.py', 'exec') : (d = Sk.importSearchPathForName(a, '.js', !0)) ? a = {
      funcname: '$builtinmodule',
      code: Sk.read(d)
    } : (a = Sk.importSearchPathForName(a, '.py'), a = Sk.compile(Sk.read(a), a, 'exec'));
    d = h.$js = a.code;
    null != Sk.dateSet && Sk.dateSet || (d = 'Sk.execStart = new Date();\n' + a.code, Sk.dateSet = !0);
    if (b) {
      b = js_beautify(a.code).split('\n');
      for (d = 1; d <= b.length; ++d) {
        for (var l = '', m = ('' + d).length; 5 > m; ++m)
          l += ' ';
        b[d - 1] = '/* ' + l + d + ' */ ' + b[d - 1];
      }
      d = b.join('\n');
      Sk.debugout(d);
    }
    d += '\n' + a.funcname + '(' + ('new Sk.builtin.str(\'' + c + '\')') + ');';
    b = goog.global.eval(d);
    b.__name__ || (b.__name__ = new Sk.builtin.str(c));
    h.$d = b;
    return e ? (Sk.sysmodules.mp$subscript(g).tp$setattr(f[f.length - 1], h), e) : h;
  };
  Sk.importModule = function (a, b) {
    return Sk.importModuleInternal_(a, b);
  };
  Sk.importMain = function (a, b) {
    Sk.dateSet = !1;
    Sk.filesLoaded = !1;
    Sk.sysmodules = new Sk.builtin.dict([]);
    Sk.realsyspath = void 0;
    Sk.resetCompiler();
    return Sk.importModuleInternal_(a, b, '__main__');
  };
  Sk.importMainWithBody = function (a, b, c) {
    Sk.dateSet = !1;
    Sk.filesLoaded = !1;
    Sk.sysmodules = new Sk.builtin.dict([]);
    Sk.realsyspath = void 0;
    Sk.resetCompiler();
    return Sk.importModuleInternal_(a, b, '__main__', c);
  };
  Sk.builtin.__import__ = function (a, b, c, d) {
    b = Sk.importModuleInternal_(a);
    if (!d || 0 === d.length)
      return b;
    b = Sk.sysmodules.mp$subscript(a);
    goog.asserts.assert(b);
    return b;
  };
  Sk.importStar = function (a, b) {
    var c = Object.getOwnPropertyNames(a.$d), d;
    for (d in c)
      b[c[d]] = a.$d[c[d]];
  };
  goog.exportSymbol('Sk.importMain', Sk.importMain);
  goog.exportSymbol('Sk.importMainWithBody', Sk.importMainWithBody);
  goog.exportSymbol('Sk.builtin.__import__', Sk.builtin.__import__);
  goog.exportSymbol('Sk.importStar', Sk.importStar);
  Sk.builtin.timSort = function (a, b) {
    this.list = new Sk.builtin.list(a.v);
    this.MIN_GALLOP = 7;
    this.listlength = b ? b : a.sq$length();
  };
  Sk.builtin.timSort.prototype.lt = function (a, b) {
    return Sk.misceval.richCompareBool(a, b, 'Lt');
  };
  Sk.builtin.timSort.prototype.le = function (a, b) {
    return !this.lt(b, a);
  };
  Sk.builtin.timSort.prototype.setitem = function (a, b) {
    this.list.v[a] = b;
  };
  Sk.builtin.timSort.prototype.binary_sort = function (a, b) {
    for (var c = a.base + b; c < a.base + a.len; c++) {
      for (var d = a.base, e = c, f = a.getitem(e); d < e;) {
        var g = d + (e - d >> 1);
        this.lt(f, a.getitem(g)) ? e = g : d = g + 1;
      }
      goog.asserts.assert(d === e);
      for (g = c; g > d; g--)
        a.setitem(g, a.getitem(g - 1));
      a.setitem(d, f);
    }
  };
  Sk.builtin.timSort.prototype.count_run = function (a) {
    var b;
    if (1 >= a.len) {
      var c = a.len;
      b = !1;
    } else if (c = 2, this.lt(a.getitem(a.base + 1), a.getitem(a.base))) {
      b = !0;
      for (var d = a.base + 2; d < a.base + a.len; d++)
        if (this.lt(a.getitem(d), a.getitem(d - 1)))
          c++;
        else
          break;
    } else
      for (b = !1, d = a.base + 2; d < a.base + a.len && !this.lt(a.getitem(d), a.getitem(d - 1)); d++)
        c++;
    return {
      run: new Sk.builtin.listSlice(a.list, a.base, c),
      descending: b
    };
  };
  Sk.builtin.timSort.prototype.sort = function () {
    var a = new Sk.builtin.listSlice(this.list, 0, this.listlength);
    if (!(2 > a.len)) {
      this.merge_init();
      for (var b = this.merge_compute_minrun(a.len); 0 < a.len;) {
        var c = this.count_run(a);
        c.descending && c.run.reverse();
        if (c.run.len < b) {
          var d = c.run.len;
          c.run.len = b < a.len ? b : a.len;
          this.binary_sort(c.run, d);
        }
        a.advance(c.run.len);
        this.pending.push(c.run);
        this.merge_collapse();
      }
      goog.asserts.assert(a.base == this.listlength);
      this.merge_force_collapse();
      goog.asserts.assert(1 == this.pending.length);
      goog.asserts.assert(0 == this.pending[0].base);
      goog.asserts.assert(this.pending[0].len == this.listlength);
    }
  };
  Sk.builtin.timSort.prototype.gallop = function (a, b, c, d) {
    goog.asserts.assert(0 <= c && c < b.len);
    var e = this;
    d = d ? function (a, b) {
      return e.le(a, b);
    } : function (a, b) {
      return e.lt(a, b);
    };
    var f = b.base + c, g = 0, h = 1, k;
    if (d(b.getitem(f), a)) {
      for (k = b.len - c; h < k;)
        if (d(b.getitem(f + h), a)) {
          g = h;
          try {
            h = (h << 1) + 1;
          } catch (l) {
            h = k;
          }
        } else
          break;
      h > k && (h = k);
      g += c;
      h += c;
    } else {
      for (k = c + 1; h < k && !d(b.getitem(f - h), a);) {
        g = h;
        try {
          h = (h << 1) + 1;
        } catch (m) {
          h = k;
        }
      }
      h > k && (h = k);
      f = c - g;
      g = c - h;
      h = f;
    }
    goog.asserts.assert(-1 <= g < h <= b.len);
    for (g += 1; g < h;)
      c = g + (h - g >> 1), d(b.getitem(b.base + c), a) ? g = c + 1 : h = c;
    goog.asserts.assert(g == h);
    return h;
  };
  Sk.builtin.timSort.prototype.merge_init = function () {
    this.min_gallop = this.MIN_GALLOP;
    this.pending = [];
  };
  Sk.builtin.timSort.prototype.merge_lo = function (a, b) {
    goog.asserts.assert(0 < a.len && 0 < b.len && a.base + a.len == b.base);
    var c = this.min_gallop, d = a.base;
    a = a.copyitems();
    try {
      if (this.setitem(d, b.popleft()), d++, 1 != a.len && 0 != b.len)
        for (var e, f;;) {
          for (f = e = 0;;)
            if (this.lt(b.getitem(b.base), a.getitem(a.base))) {
              this.setitem(d, b.popleft());
              d++;
              if (0 == b.len)
                return;
              f++;
              e = 0;
              if (f >= c)
                break;
            } else {
              this.setitem(d, a.popleft());
              d++;
              if (1 == a.len)
                return;
              e++;
              f = 0;
              if (e >= c)
                break;
            }
          for (c += 1;;) {
            this.min_gallop = c -= 1 < c;
            e = this.gallop(b.getitem(b.base), a, 0, !0);
            for (var g = a.base; g < a.base + e; g++)
              this.setitem(d, a.getitem(g)), d++;
            a.advance(e);
            if (1 >= a.len)
              return;
            this.setitem(d, b.popleft());
            d++;
            if (0 == b.len)
              return;
            f = this.gallop(a.getitem(a.base), b, 0, !1);
            for (g = b.base; g < b.base + f; g++)
              this.setitem(d, b.getitem(g)), d++;
            b.advance(f);
            if (0 == b.len)
              return;
            this.setitem(d, a.popleft());
            d++;
            if (1 == a.len)
              return;
            if (e < this.MIN_GALLOP && f < this.MIN_GALLOP)
              break;
            c++;
            this.min_gallop = c;
          }
        }
    } finally {
      goog.asserts.assert(0 <= a.len && 0 <= b.len);
      for (g = b.base; g < b.base + b.len; g++)
        this.setitem(d, b.getitem(g)), d++;
      for (g = a.base; g < a.base + a.len; g++)
        this.setitem(d, a.getitem(g)), d++;
    }
  };
  Sk.builtin.timSort.prototype.merge_hi = function (a, b) {
    goog.asserts.assert(0 < a.len && 0 < b.len && a.base + a.len == b.base);
    var c = this.min_gallop, d = b.base + b.len;
    b = b.copyitems();
    try {
      if (d--, this.setitem(d, a.popright()), 0 != a.len && 1 != b.len)
        for (var e, f, g, h;;) {
          for (f = e = 0;;)
            if (g = a.getitem(a.base + a.len - 1), h = b.getitem(b.base + b.len - 1), this.lt(h, g)) {
              d--;
              this.setitem(d, g);
              a.len--;
              if (0 == a.len)
                return;
              e++;
              f = 0;
              if (e >= c)
                break;
            } else {
              d--;
              this.setitem(d, h);
              b.len--;
              if (1 == b.len)
                return;
              f++;
              e = 0;
              if (f >= c)
                break;
            }
          for (c += 1;;) {
            this.min_gallop = c -= 1 < c;
            h = b.getitem(b.base + b.len - 1);
            var k = this.gallop(h, a, a.len - 1, !0);
            e = a.len - k;
            for (var l = a.base + a.len - 1; l > a.base + k - 1; l--)
              d--, this.setitem(d, a.getitem(l));
            a.len -= e;
            if (0 == a.len)
              return;
            d--;
            this.setitem(d, b.popright());
            if (1 == b.len)
              return;
            g = a.getitem(a.base + a.len - 1);
            k = this.gallop(g, b, b.len - 1, !1);
            f = b.len - k;
            for (l = b.base + b.len - 1; l > b.base + k - 1; l--)
              d--, this.setitem(d, b.getitem(l));
            b.len -= f;
            if (1 >= b.len)
              return;
            d--;
            this.setitem(d, a.popright());
            if (0 == a.len)
              return;
            if (e < this.MIN_GALLOP && f < this.MIN_GALLOP)
              break;
            c++;
            this.min_gallop = c;
          }
        }
    } finally {
      goog.asserts.assert(0 <= a.len && 0 <= b.len);
      for (l = a.base + a.len - 1; l > a.base - 1; l--)
        d--, this.setitem(d, a.getitem(l));
      for (l = b.base + b.len - 1; l > b.base - 1; l--)
        d--, this.setitem(d, b.getitem(l));
    }
  };
  Sk.builtin.timSort.prototype.merge_at = function (a) {
    0 > a && (a = this.pending.length + a);
    var b = this.pending[a], c = this.pending[a + 1];
    goog.asserts.assert(0 < b.len && 0 < c.len);
    goog.asserts.assert(b.base + b.len == c.base);
    this.pending[a] = new Sk.builtin.listSlice(this.list, b.base, b.len + c.len);
    this.pending.splice(a + 1, 1);
    a = this.gallop(c.getitem(c.base), b, 0, !0);
    b.advance(a);
    0 != b.len && (c.len = this.gallop(b.getitem(b.base + b.len - 1), c, c.len - 1, !1), 0 != c.len && (b.len <= c.len ? this.merge_lo(b, c) : this.merge_hi(b, c)));
  };
  Sk.builtin.timSort.prototype.merge_collapse = function () {
    for (var a = this.pending; 1 < a.length;)
      if (3 <= a.length && a[a.length - 3].len <= a[a.length - 2].len + a[a.length - 1].len)
        a[a.length - 3].len < a[a.length - 1].len ? this.merge_at(-3) : this.merge_at(-2);
      else if (a[a.length - 2].len <= a[a.length - 1].len)
        this.merge_at(-2);
      else
        break;
  };
  Sk.builtin.timSort.prototype.merge_force_collapse = function () {
    for (var a = this.pending; 1 < a.length;)
      3 <= a.length && a[a.length - 3].len < a[a.length - 1].len ? this.merge_at(-3) : this.merge_at(-2);
  };
  Sk.builtin.timSort.prototype.merge_compute_minrun = function (a) {
    for (var b = 0; 64 <= a;)
      b |= a & 1, a >>= 1;
    return a + b;
  };
  Sk.builtin.listSlice = function (a, b, c) {
    this.list = a;
    this.base = b;
    this.len = c;
  };
  Sk.builtin.listSlice.prototype.copyitems = function () {
    var a = this.base, b = this.base + this.len;
    goog.asserts.assert(0 <= a <= b);
    return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(a, b)), 0, this.len);
  };
  Sk.builtin.listSlice.prototype.advance = function (a) {
    this.base += a;
    this.len -= a;
    goog.asserts.assert(this.base <= this.list.sq$length());
  };
  Sk.builtin.listSlice.prototype.getitem = function (a) {
    return this.list.v[a];
  };
  Sk.builtin.listSlice.prototype.setitem = function (a, b) {
    this.list.v[a] = b;
  };
  Sk.builtin.listSlice.prototype.popleft = function () {
    var a = this.list.v[this.base];
    this.base++;
    this.len--;
    return a;
  };
  Sk.builtin.listSlice.prototype.popright = function () {
    this.len--;
    return this.list.v[this.base + this.len];
  };
  Sk.builtin.listSlice.prototype.reverse = function () {
    for (var a = this.list, b = this.base, c = b + this.len - 1; b < c;) {
      var d = a.v[b];
      a.v[b] = a.v[c];
      a.v[c] = d;
      b++;
      c--;
    }
  };
  goog.exportSymbol('Sk.builtin.listSlice', Sk.builtin.listSlice);
  goog.exportSymbol('Sk.builtin.timSort', Sk.builtin.timSort);
  Sk.builtins = {
    range: Sk.builtin.range,
    round: Sk.builtin.round,
    len: Sk.builtin.len,
    min: Sk.builtin.min,
    max: Sk.builtin.max,
    sum: Sk.builtin.sum,
    zip: Sk.builtin.zip,
    abs: Sk.builtin.abs,
    fabs: Sk.builtin.abs,
    ord: Sk.builtin.ord,
    chr: Sk.builtin.chr,
    hex: Sk.builtin.hex,
    oct: Sk.builtin.oct,
    bin: Sk.builtin.bin,
    dir: Sk.builtin.dir,
    repr: Sk.builtin.repr,
    open: Sk.builtin.open,
    isinstance: Sk.builtin.isinstance,
    hash: Sk.builtin.hash,
    getattr: Sk.builtin.getattr,
    float_$rw$: Sk.builtin.float_,
    int_$rw$: Sk.builtin.int_,
    hasattr: Sk.builtin.hasattr,
    map: Sk.builtin.map,
    filter: Sk.builtin.filter,
    reduce: Sk.builtin.reduce,
    sorted: Sk.builtin.sorted,
    bool: Sk.builtin.bool,
    any: Sk.builtin.any,
    all: Sk.builtin.all,
    enumerate: Sk.builtin.enumerate,
    AttributeError: Sk.builtin.AttributeError,
    ValueError: Sk.builtin.ValueError,
    Exception: Sk.builtin.Exception,
    ZeroDivisionError: Sk.builtin.ZeroDivisionError,
    AssertionError: Sk.builtin.AssertionError,
    ImportError: Sk.builtin.ImportError,
    IndentationError: Sk.builtin.IndentationError,
    IndexError: Sk.builtin.IndexError,
    KeyError: Sk.builtin.KeyError,
    TypeError: Sk.builtin.TypeError,
    NameError: Sk.builtin.NameError,
    IOError: Sk.builtin.IOError,
    NotImplementedError: Sk.builtin.NotImplementedError,
    SystemExit: Sk.builtin.SystemExit,
    OverflowError: Sk.builtin.OverflowError,
    OperationError: Sk.builtin.OperationError,
    dict: Sk.builtin.dict,
    file: Sk.builtin.file,
    'function': Sk.builtin.func,
    generator: Sk.builtin.generator,
    list: Sk.builtin.list,
    long_$rw$: Sk.builtin.lng,
    method: Sk.builtin.method,
    object: Sk.builtin.object,
    slice: Sk.builtin.slice,
    str: Sk.builtin.str,
    set: Sk.builtin.set,
    tuple: Sk.builtin.tuple,
    type: Sk.builtin.type,
    input: Sk.builtin.input,
    raw_input: Sk.builtin.raw_input,
    jseval: Sk.builtin.jseval,
    jsmillis: Sk.builtin.jsmillis,
    quit: Sk.builtin.quit,
    exit: Sk.builtin.quit,
    bytearray: Sk.builtin.bytearray,
    callable: Sk.builtin.callable,
    complex: Sk.builtin.complex,
    delattr: Sk.builtin.delattr,
    divmod: Sk.builtin.divmod,
    eval_$rn$: Sk.builtin.eval_,
    execfile: Sk.builtin.execfile,
    format: Sk.builtin.format,
    frozenset: Sk.builtin.frozenset,
    globals: Sk.builtin.globals,
    help: Sk.builtin.help,
    issubclass: Sk.builtin.issubclass,
    iter: Sk.builtin.iter,
    locals: Sk.builtin.locals,
    memoryview: Sk.builtin.memoryview,
    next: Sk.builtin.next_,
    pow: Sk.builtin.pow,
    property: Sk.builtin.property,
    reload: Sk.builtin.reload,
    reversed: Sk.builtin.reversed,
    'super': Sk.builtin.superbi,
    unichr: Sk.builtin.unichr,
    vars: Sk.builtin.vars,
    xrange: Sk.builtin.xrange,
    apply_$rn$: Sk.builtin.apply_,
    buffer: Sk.builtin.buffer,
    coerce: Sk.builtin.coerce,
    intern: Sk.builtin.intern
  };
  goog.exportSymbol('Sk.builtins', Sk.builtins);
  Sk.stdlib = {};
  (function () {
    Sk.builtin.defineMath = function (a) {
      Sk.ffi.checkFunctionArgs('defineMath', arguments, 1, 1);
      a.pi = Sk.builtin.assk$(Math.PI, Sk.builtin.nmber.float$);
      a.e = Sk.builtin.assk$(Math.E, Sk.builtin.nmber.float$);
      a.cliffordConjugate = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('cliffordConjugate', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? a : Sk.ffh.cliffordConjugate(a);
      });
      a.fabs = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('fabs', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.abs(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.asin = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('asin', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.asin(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.acos = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('acos', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.acos(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.atan = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('atan', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.atan(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.atan2 = Sk.ffi.functionPy(function (a, c) {
        Sk.ffi.checkFunctionArgs('atan2', arguments, 2, 2);
        Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(a));
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(c));
        return new Sk.builtin.nmber(Math.atan2(Sk.builtin.asnum$(a), Sk.builtin.asnum$(c)), Sk.builtin.nmber.float$);
      });
      a.sin = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('sin', arguments, 1, 1);
        if (Sk.ffi.isNum(a))
          return Sk.ffi.numberToFloatPy(Math.sin(Sk.ffi.remapToJs(a)));
        try {
          var c = Sk.ffi.gattr(a, 'sin');
          return Sk.ffi.callsim(c);
        } catch (d) {
          Sk.builtin.pyCheckType('rad', 'number', !1);
        }
      });
      a.cos = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('cos', arguments, 1, 1);
        if (Sk.ffi.isNum(a))
          return Sk.ffi.numberToFloatPy(Math.cos(Sk.ffi.remapToJs(a)));
        try {
          var c = Sk.ffi.gattr(a, 'cos');
          return Sk.ffi.callsim(c);
        } catch (d) {
          throw Sk.ffi.err.argument('angle').inFunction('cos').mustHaveType('dimensionless number');
        }
      });
      a.tan = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('tan', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.tan(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.asinh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('asinh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = a + Math.sqrt(a * a + 1);
        return new Sk.builtin.nmber(Math.log(c), Sk.builtin.nmber.float$);
      });
      a.acosh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('acosh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = a + Math.sqrt(a * a - 1);
        return new Sk.builtin.nmber(Math.log(c), Sk.builtin.nmber.float$);
      });
      a.atanh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('atanh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        return new Sk.builtin.nmber(Math.log((1 + a) / (1 - a)) / 2, Sk.builtin.nmber.float$);
      });
      a.sinh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('sinh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = Math.pow(Math.E, a);
        return new Sk.builtin.nmber((c - 1 / c) / 2, Sk.builtin.nmber.float$);
      });
      a.cosh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('cosh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = Math.pow(Math.E, a);
        return new Sk.builtin.nmber((c + 1 / c) / 2, Sk.builtin.nmber.float$);
      });
      a.tanh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('tanh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = Math.pow(Math.E, a), d = 1 / c;
        return new Sk.builtin.nmber((c - d) / 2 / ((c + d) / 2), Sk.builtin.nmber.float$);
      });
      a.ceil = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('ceil', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.ceil(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.floor = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('floor', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.floor(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.sqrt = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('sqrt', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? Sk.ffi.numberToFloatPy(Math.sqrt(Sk.ffi.remapToJs(a))) : Sk.ffh.sqrt(a);
      });
      a.trunc = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('trunc', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Sk.builtin.asnum$(a) | 0, Sk.builtin.nmber.float$);
      });
      a.log = Sk.ffi.functionPy(function (a, c) {
        Sk.ffi.checkFunctionArgs('log', arguments, 1, 2);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        if (void 0 === c)
          return new Sk.builtin.nmber(Math.log(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
        Sk.builtin.pyCheckType('base', 'number', Sk.builtin.checkNumber(c));
        var d = Math.log(Sk.builtin.asnum$(a)) / Math.log(Sk.builtin.asnum$(c));
        return new Sk.builtin.nmber(d, Sk.builtin.nmber.float$);
      });
      a.log10 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('log10', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        var c = Math.log(Sk.builtin.asnum$(a)) / Math.log(10);
        return new Sk.builtin.nmber(c, Sk.builtin.nmber.float$);
      });
      a.exp = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('exp', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? Sk.ffi.numberToFloatPy(Math.exp(Sk.ffi.remapToJs(a))) : Sk.ffh.exp(a);
      });
      a.pow = Sk.ffi.functionPy(function (a, c) {
        Sk.ffi.checkFunctionArgs('pow', arguments, 2, 2);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(c));
        return new Sk.builtin.nmber(Math.pow(Sk.builtin.asnum$(a), Sk.builtin.asnum$(c)), Sk.builtin.nmber.float$);
      });
      a.radians = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('radians', arguments, 1, 1);
        Sk.builtin.pyCheckType('deg', 'number', Sk.builtin.checkNumber(a));
        var c = Math.PI / 180 * Sk.builtin.asnum$(a);
        return new Sk.builtin.nmber(c, Sk.builtin.nmber.float$);
      });
      a.degrees = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('degrees', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        var c = 180 / Math.PI * Sk.builtin.asnum$(a);
        return new Sk.builtin.nmber(c, Sk.builtin.nmber.float$);
      });
      a.hypot = Sk.ffi.functionPy(function (a, c) {
        Sk.ffi.checkFunctionArgs('hypot', arguments, 2, 2);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(c));
        a = Sk.builtin.asnum$(a);
        c = Sk.builtin.asnum$(c);
        return new Sk.builtin.nmber(Math.sqrt(a * a + c * c), Sk.builtin.nmber.float$);
      });
      a.factorial = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('factorial', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Math.floor(Sk.builtin.asnum$(a));
        for (var c = 1, d = 2; d <= a; d++)
          c *= d;
        return new Sk.builtin.nmber(c, Sk.builtin.nmber.int$);
      });
    };
  }.call(this));
  (function () {
    Sk.builtin.defineComplex = function (a, b) {
      function c(a) {
        return Sk.ffi.isInstance(a, b);
      }
      function d(a, b) {
        return Math.sqrt(a * a + b * b);
      }
      function e(a, b, c) {
        var d, e, f, g, r;
        f = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < f.length && f.push('+') : f.push('-');
            d = Math.abs(a);
            if (1 === d)
              return f.push(b);
            f.push(d.toString());
            if ('1' !== b)
              return f.push(c), f.push(b);
          }
        };
        e = g = 0;
        for (r = a.length - 1; 0 <= r ? g <= r : g >= r; e = 0 <= r ? ++g : --g)
          d(a[e], b[e]);
        return 0 < f.length ? f.join('') : '0';
      }
      function f(c, d) {
        return Sk.ffi.callsim(a[b], Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d));
      }
      Sk.ffi.checkFunctionArgs('defineComplex', arguments, 2, 2);
      var g = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      a[b] = Sk.ffi.buildClass(a, function (d, k) {
        k.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.ffi.checkMethodArgs(b, arguments, 2, 2);
          Sk.ffi.checkArgType('real', g, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('imag', g, Sk.ffi.isNum(d), d);
          Sk.ffi.referenceToPy({
            x: Sk.ffi.remapToJs(c),
            y: Sk.ffi.remapToJs(d)
          }, b, void 0, a);
        });
        k.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          b = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'real':
            return Sk.ffi.numberToFloatPy(b.x);
          case 'imag':
            return Sk.ffi.numberToFloatPy(b.y);
          case 'abs':
            return Sk.ffi.callableToPy(a, 'abs', function (a) {
              return Sk.ffi.numberToFloatPy(Math.sqrt(b.x * b.x + b.y * b.y));
            });
          case 'exp':
            return Sk.ffi.callableToPy(a, 'exp', function (a) {
              a = Math.exp(b.x);
              var c = Math.cos(b.y), d = Math.sin(b.y);
              return f(a * c, a * d);
            });
          }
        });
        k.__add__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), g = Sk.ffi.remapToJs(d);
          if (c(d))
            return f(e.x + g.x, e.y + g.y);
          if (Sk.ffi.isNum(d))
            return f(e.x + g, e.y);
          throw Sk.ffi.err.argument('other').mustHaveType(b);
        });
        k.__radd__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkArgType('other', g, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a);
          return f(c + d.x, d.y);
        });
        k.__iadd__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(d);
          if (Sk.ffi.isNum(d))
            e.x += f;
          else if (c(d))
            e.x += f.x, e.y += f.y;
          else
            throw Sk.ffi.err.argument('other').mustHaveType([
              b,
              g
            ]);
          return a;
        });
        k.__sub__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), k = Sk.ffi.remapToJs(d);
          if (c(d))
            return f(e.x - k.x, e.y - k.y);
          if (Sk.ffi.isNum(d))
            return f(e.x - k, e.y);
          throw Sk.ffi.err.argument('other').mustHaveType([
            b,
            g
          ]);
        });
        k.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          var c, d;
          c = Sk.ffi.remapToJs(b);
          d = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return c -= d.x, d = -d.y, f(c, d);
          throw Sk.ffi.err.argument('other').mustHaveType(g);
        });
        k.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? c.x -= d : (c.x -= d.x, c.y -= d.y);
          return a;
        });
        k.__mul__ = Sk.ffi.functionPy(function (a, b) {
          var c, d;
          d = Sk.ffi.remapToJs(a);
          var e = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? (c = d.x * e, d = d.y * e) : (c = d.x * e.x - d.y * e.y, d = d.y * e.x + d.x * e.y);
          return f(c, d);
        });
        k.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          var c, d;
          d = Sk.ffi.remapToJs(b);
          var e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return c = d * e.x, d *= e.y, f(c, d);
          throw Sk.ffi.err.argument('a').mustHaveType(g);
        });
        k.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.x, e = c.y, f = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? (c.x *= f, c.y *= f) : (c.x = d * f.x - e * f.y, c.y = e * f.x + d * f.y);
          return a;
        });
        k.__div__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), k = Sk.ffi.remapToJs(d);
          if (c(d)) {
            var h = k.x * k.x + k.y * k.y;
            return f((e.x * k.x + e.y * k.y) / h, (e.y * k.x - e.x * k.y) / h);
          }
          if (Sk.ffi.isNum(d))
            return f(e.x / k, e.y / k);
          Sk.ffi.checkArgType('other', [
            b,
            g
          ], !1, d);
        });
        k.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkArgType('other', g, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b)) {
            var e = d.x * d.x + d.y * d.y;
            return f(c * d.x / e, -c * d.y / e);
          }
          throw Sk.ffi.err.argument('other').mustHaveType(g);
        });
        k.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.x, e = c.y, f = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            c.x /= f, c.y /= f;
          else {
            var g = f.x * f.x + f.y * f.y;
            c.x = (d * f.x + e * f.y) / g;
            c.y = (e * f.x - d * f.y) / g;
          }
          return a;
        });
        k.__abs__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.sqrt(a.x * a.x + a.y * a.y));
        });
        k.__exp__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Math.exp(b.x);
          var c = Math.cos(b.y), b = Math.sin(b.y);
          return f(a * c, a * b);
        });
        k.__pos__ = Sk.ffi.functionPy(function (a) {
          return a;
        });
        k.__neg__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return f(-a.x, -a.y);
        });
        k.__invert__ = Sk.ffi.functionPy(function (a) {
          var b = f(1, 0);
          return Sk.ffi.callsim(a.__div__, b, a);
        });
        k.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('(' + e([
            a.x,
            a.y
          ], [
            '1',
            'j'
          ], '') + ')');
        });
        k.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy(b + '(' + a.x + ', ' + a.y + ')');
        });
        k.__eq__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.x === b.x && a.y === b.y;
        });
        k.__ne__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.x !== b.x || a.y !== b.y;
        });
      }, b, []);
      a.phase = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('phase', arguments, 1, 1);
        if (c(a)) {
          var d = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.atan2(d.y, d.x));
        }
        if (Sk.ffi.isNum(a))
          return Sk.ffi.numberToFloatPy(Math.atan2(0, Sk.ffi.remapToJs(a)));
        Sk.ffi.checkArgType('x', b, !1, a);
      });
      a.polar = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('polar', arguments, 1, 1);
        if (c(a)) {
          var e = Sk.ffi.remapToJs(a);
          return Sk.ffi.tuplePy([
            Sk.ffi.remapToPy(d(e.x, e.y)),
            Sk.ffi.remapToPy(Math.atan2(e.y, e.x))
          ]);
        }
        if (Sk.ffi.isNum(a))
          return Sk.ffi.tuplePy([
            Sk.ffi.remapToPy(d(Sk.ffi.remapToJs(a), 0)),
            Sk.ffi.remapToPy(0)
          ]);
        Sk.ffi.checkArgType('x', b, !1, a);
      });
      a.pi = Sk.ffi.numberToFloatPy(Math.PI);
      a.e = Sk.ffi.numberToFloatPy(Math.E);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineQuaternion = function (a, b) {
      function c(a, b, c) {
        var d, k, l, m, n;
        l = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < l.length && l.push('+') : l.push('-');
            d = Math.abs(a);
            if (1 === d)
              return l.push(b);
            l.push(d.toString());
            if ('1' !== b)
              return l.push(c), l.push(b);
          }
        };
        k = m = 0;
        for (n = a.length - 1; 0 <= n ? m <= n : m >= n; k = 0 <= n ? ++m : --m)
          d(a[k], b[k]);
        return 0 < l.length ? l.join('') : '0';
      }
      function d(b, c, d, h) {
        return Sk.ffi.callsim(a.Quaternion, Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d), Sk.ffi.numberToFloatPy(h), Sk.ffi.numberToFloatPy(b));
      }
      Sk.ffi.checkFunctionArgs('defineQuaternion', arguments, 2, 2);
      a.Quaternion = Sk.ffi.buildClass(a, function (e, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.isInstance(c, 'Quaternion') ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Quaternion', void 0, a) : (c = Sk.ffi.remapToJs(c), d = Sk.ffi.remapToJs(d), e = Sk.ffi.remapToJs(e), f = Sk.ffi.remapToJs(f), Sk.ffi.referenceToPy(new b.Quaternion(c, d, e, f), 'Quaternion', void 0, a));
        });
        f.__add__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          return Sk.ffi.isNum(b) ? d(c.w + e, c.x, c.y, c.z) : d(c.w + e.w, c.x + e.x, c.y + e.y, c.z + e.z);
        });
        f.__radd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return d(c + e.w, e.x, e.y, e.z);
          throw Sk.ffi.err.operand('other').toOperation('+').mustHaveType('Quaternion');
        });
        f.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? c.w += d : (c.w += d.w, c.x += d.x, c.y += d.y, c.z += d.z);
          return a;
        });
        f.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          return Sk.ffi.isNum(b) ? d(c.w - e, c.x, c.y, c.z) : d(c.w - e.w, c.x - e.x, c.y - e.y, c.z - e.z);
        });
        f.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return d(c - e.w, -e.x, -e.y, -e.z);
          throw Sk.ffi.err.operand('other').toOperation('-').mustHaveType('Quaternion');
        });
        f.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? c.w -= d : (c.w -= d.w, c.x -= d.x, c.y -= d.y, c.z -= d.z);
          return a;
        });
        f.__mul__ = Sk.ffi.functionPy(function (c, e) {
          var f = Sk.ffi.remapToJs(c), l = Sk.ffi.remapToJs(e);
          if (Sk.ffi.isNum(e))
            return d(f.w * l, f.x * l, f.y * l, f.z * l);
          f = new b.Quaternion(0, 0, 0, 1).multiplyQuaternions(f, l);
          return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(f, 'Quaternion'));
        });
        f.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return d(c * e.w, c * e.x, c * e.y, c * e.z);
          throw Sk.ffi.err.operand('other').toOperation('*').mustHaveType('Quaternion');
        });
        f.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? (c.w *= d, c.x *= d, c.y *= d, c.z *= d) : c.multiply(d);
          return a;
        });
        f.nb$positive = function () {
          return this;
        };
        f.nb$negative = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(-a.w, -a.x, -a.y, -a.z);
        };
        f.__eq__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, 'Quaternion')) {
            var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
            return Sk.ffi.booleanToPy(c.w === d.w && c.x === d.x && c.y === d.y && c.z === d.z);
          }
          return Sk.ffi.bool.False;
        });
        f.__ne__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, 'Quaternion')) {
            var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
            return Sk.ffi.booleanToPy(c.w !== d.w || c.x !== d.x || c.y !== d.y || c.z !== d.z);
          }
          return Sk.ffi.bool.True;
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'x':
            return Sk.ffi.numberToFloatPy(e.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(e.y);
          case 'z':
            return Sk.ffi.numberToFloatPy(e.z);
          case 'w':
            return Sk.ffi.numberToFloatPy(e.w);
          case 'copy':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'copy', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                Sk.ffi.checkMethodArgs('copy', arguments, 1, 1);
                Sk.ffi.checkArgType('q', 'Quaternion', Sk.ffi.isInstance(c, 'Quaternion'), c);
                var d = Sk.ffi.remapToJs(c);
                e.copy(d);
                return b;
              });
            }, 'copy', []));
          case 'setFromAxisAngle':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'setFromAxisAngle', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d) {
                a = Sk.ffi.remapToJs(c);
                d = Sk.ffi.remapToJs(d);
                e.setFromAxisAngle(a, d);
                return b;
              });
            }, 'setFromAxisAngle', []));
          case 'setFromEuler':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'setFromEuler', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d) {
                a = Sk.ffi.remapToJs(c);
                d = Sk.ffi.remapToJs(d);
                e.setFromEuler(a, d);
                return b;
              });
            }, 'setFromEuler', []));
          case 'set':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'set', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d, f, h) {
                e.x = Sk.ffi.remapToJs(c);
                e.y = Sk.ffi.remapToJs(d);
                e.z = Sk.ffi.remapToJs(f);
                e.w = Sk.ffi.remapToJs(h);
                return b;
              });
            }, 'set', []));
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'clone', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return d(e.w, e.x, e.y, e.z);
              });
            }, 'clone', []));
          case 'conjugate':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'conjugate', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                e.conjugate();
                return b;
              });
            }, 'conjugate', []));
          case 'inverse':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'inverse', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                a = 1 / e.lengthSq();
                e.conjugate();
                e.w *= a;
                e.x *= a;
                e.y *= a;
                e.z *= a;
                return b;
              });
            }, 'inverse', []));
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'magnitude', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(e.length());
              });
            }, 'magnitude', []));
          case 'quadrance':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'quadrance', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(e.lengthSq());
              });
            }, 'quadrance', []));
          case 'normalize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'normalize', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                e.normalize();
                return b;
              });
            }, 'normalize', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Quaternion');
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'x':
            a.x = c;
            break;
          case 'y':
            a.y = c;
            break;
          case 'z':
            a.z = c;
            break;
          case 'w':
            a.w = c;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Quaternion');
          }
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Quaternion(' + [
            a.x,
            a.y,
            a.z,
            a.w
          ].join(', ') + ')');
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy(c([
            a.w,
            a.x,
            a.y,
            a.z
          ], [
            '1',
            'i',
            'j',
            'k'
          ]));
        });
      }, 'Quaternion', []);
    };
  }.call(this));
  Sk.builtin.buildDocumentClass = function (a) {
    var b = function (b) {
        return b ? Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(b, 'Node')) : Sk.ffi.remapToPy(null);
      }, c = {};
    return Sk.misceval.buildClass(a, function (d, e) {
      e.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkMethodArgs('Node', arguments, 0, 0);
        Sk.ffi.referenceToPy(document, 'Document', void 0, a);
      });
      e.__getattr__ = Sk.ffi.functionPy(function (d, e) {
        switch (e) {
        case 'body':
          return b(document.body);
        case 'webkitHidden':
          return Sk.ffi.booleanToPy(document.webkitHidden);
        case 'addEventListener':
          return Sk.ffi.callsim(Sk.misceval.buildClass(a, function (b, d) {
            d.__init__ = Sk.ffi.functionPy(function (a) {
            });
            d.__call__ = Sk.ffi.functionPy(function (b, d, e, f) {
              b = Sk.ffi.remapToJs(d);
              d = function (b) {
                b = Sk.ffi.callsim(a.Event, Sk.ffi.remapToPy(b, 'Event'));
                Sk.ffi.callsim(e, b);
              };
              c[b] = d;
              document.addEventListener(b, d, f);
            });
          }, 'addEventListener', []));
        case 'removeEventListener':
          return Sk.ffi.callsim(Sk.misceval.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b, d, e) {
              a = Sk.ffi.remapToJs(b);
              d = c[a];
              delete c[a];
              document.removeEventListener(a, d, e);
            });
          }, 'removeEventListener', []));
        case 'createElement':
          return Sk.ffi.callableToPy(a, 'createElement', function (a, c, d) {
            Sk.ffi.checkMethodArgs('createElement', arguments, 1, 2);
            Sk.ffi.checkArgType('tagName', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            var e = document.createElement(Sk.ffi.remapToJs(c));
            if (d instanceof Sk.builtin.dict)
              for (var f = d.tp$iter(), g = f.tp$iternext(); void 0 !== g; g = f.tp$iternext()) {
                var q = d.mp$subscript(g);
                void 0 === q && (q = null);
                g = Sk.ffi.remapToJs(g);
                q = Sk.ffi.remapToJs(q);
                e.setAttribute(g, q);
              }
            return b(e);
          });
        case 'getElementById':
          return Sk.ffi.callableToPy(a, 'getElementById', function (a, c) {
            Sk.ffi.checkMethodArgs('getElementById', arguments, 1, 1);
            Sk.ffi.checkArgType('id', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            return b(document.getElementById(Sk.ffi.remapToJs(c)));
          });
        case 'getElementsByTagName':
          return Sk.ffi.callableToPy(a, 'getElementsByTagName', function (a, c) {
            Sk.ffi.checkMethodArgs('getElementsByTagName', arguments, 1, 1);
            Sk.ffi.checkArgType('tagName', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            for (var d = document.getElementsByTagName(Sk.ffi.remapToJs(c)), e = [], f = d.length - 1; 0 <= f; f--)
              e.push(b(d[f]));
            return Sk.ffi.listPy(e);
          });
        case 'removeElementsByTagName':
          return Sk.ffi.callableToPy(a, 'removeElementsByTagName', function (a, c) {
            Sk.ffi.checkMethodArgs('removeElementsByTagName', arguments, 1, 1);
            Sk.ffi.checkArgType('tagName', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            for (var d = document.getElementsByTagName(Sk.ffi.remapToJs(c)), e = [], f = d.length - 1; 0 <= f; f--) {
              var g = d[f];
              g.parentNode.removeChild(g);
              e.push(b(g));
            }
            return Sk.ffi.listPy(e);
          });
        default:
          throw Sk.ffi.err.attribute(e).isNotGetableOnType('Document');
        }
      });
      e.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
        switch (b) {
        default:
          throw Sk.ffi.err.attribute(b).isNotSetableOnType('Document');
        }
      });
      e.__str__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy('Document');
      });
      e.__repr__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy('Document');
      });
    }, 'Document', []);
  };
  (function () {
    Sk.builtin.defineEasel = function (a, b, c) {
      function d(b, c, d) {
        var e = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'alpha':
          return Sk.ffi.numberToFloatPy(e.alpha);
        case 'graphics':
          return Sk.ffi.callsim(a.Graphics, Sk.ffi.referenceToPy(e.graphics, 'Graphics'));
        case 'name':
          return Sk.ffi.stringToPy(e.name);
        case 'x':
          return Sk.ffi.numberToFloatPy(e.x);
        case 'y':
          return Sk.ffi.numberToFloatPy(e.y);
        case 'rotation':
          return Sk.ffi.numberToFloatPy(e.rotation);
        case 'addEventListener':
          return Sk.builtin.addEventListener(a, e);
        case 'removeEventListener':
          return Sk.builtin.removeEventListener(a, e);
        case 'globalToLocal':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
            c.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'globalToLocal';
              a.v = e.globalToLocal;
            });
            c.__call__ = Sk.ffi.functionPy(function (b, c, d) {
              b = e.globalToLocal(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d));
              return Sk.ffi.callsim(a.Point, Sk.ffi.referenceToPy(b, 'Point'));
            });
          }, 'globalToLocal', []));
        case 'hitTest':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'hitTest';
              a.v = e.hitTest;
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
              return Sk.ffi.remapToPy(e.hitTest(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c)));
            });
          }, 'hitTest', []));
        case 'localToLocal':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
            c.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'localToLocal';
              a.v = e.localToLocal;
            });
            c.__call__ = Sk.ffi.functionPy(function (b, c, d, f) {
              b = e.localToLocal(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(f));
              return Sk.ffi.callsim(a.Point, Sk.ffi.referenceToPy(b, 'Point'));
            });
          }, 'localToLocal', []));
        default:
          throw Sk.ffi.err.attribute(c).isNotGetableOnType(d);
        }
      }
      function e(a, b, c, d) {
        a = Sk.ffi.remapToJs(a);
        var e = Sk.ffi.remapToJs(c);
        switch (b) {
        case 'alpha':
          Sk.ffi.checkArgType('alpha', f, Sk.ffi.isNum(c), c);
          a.alpha = e;
          break;
        case 'name':
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
          a.name = e;
          break;
        case 'x':
        case 'y':
          Sk.ffi.checkArgType(b, f, Sk.ffi.isNum(c), c);
          a[b] = e;
          break;
        case 'rotation':
          Sk.ffi.checkArgType('rotation', f, Sk.ffi.isNum(c), c);
          a.rotation = e;
          break;
        default:
          throw Sk.ffi.err.attribute(b).isNotSetableOnType(d);
        }
      }
      Sk.ffi.checkFunctionArgs('defineEasel', arguments, 3, 3);
      Sk.builtin.defineEuclidean2(a, c);
      Sk.builtin.defineEvent(a);
      var f = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      a.Graphics = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('Graphics', arguments, 0, 1);
          Sk.ffi.isDefined(c) ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Graphics', void 0, a) : Sk.ffi.referenceToPy(new b.Graphics(), 'Graphics', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'beginFill':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(d.beginFill, 'beginFill', void 0, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                c = Sk.ffi.remapToJs(c);
                d.beginFill(c);
                return b;
              });
            }, 'beginFill', []));
          case 'beginStroke':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(d.beginStroke, 'beginStroke', void 0, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                c = Sk.ffi.remapToJs(c);
                d.beginStroke(c);
                return b;
              });
            }, 'beginStroke', []));
          case 'drawCircle':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'drawCircle';
                a.v = d.drawCircle;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                d.drawCircle(c, e, f);
                return b;
              });
            }, 'drawCircle', []));
          case 'drawRect':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'drawRect';
                a.v = d.drawRect;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f, g) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                g = Sk.ffi.remapToJs(g);
                d.drawRect(c, e, f, g);
                return b;
              });
            }, 'drawRect', []));
          case 'drawRoundRect':
            return Sk.ffi.callableToPy(a, c, function (a, c, e, g, h, l) {
              Sk.ffi.checkMethodArgs('drawRoundRect', arguments, 5, 5);
              Sk.ffi.checkArgType('x', f, Sk.ffi.isNum(c), c);
              Sk.ffi.checkArgType('y', f, Sk.ffi.isNum(e), e);
              Sk.ffi.checkArgType('width', f, Sk.ffi.isNum(g), g);
              Sk.ffi.checkArgType('height', f, Sk.ffi.isNum(h), h);
              Sk.ffi.checkArgType('radius', f, Sk.ffi.isNum(l), l);
              var z = Sk.ffi.remapToJs(c), y = Sk.ffi.remapToJs(e), C = Sk.ffi.remapToJs(g), t = Sk.ffi.remapToJs(h), B = Sk.ffi.remapToJs(l);
              d.drawRoundRect(z, y, C, t, B);
              return b;
            });
          case 'endFill':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'endFill';
                a.v = d.endFill;
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                d.endFill();
                return b;
              });
            }, 'endFill', []));
          case 'endStroke':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'endStroke';
                a.v = d.endStroke;
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                d.endStroke();
                return b;
              });
            }, 'endStroke', []));
          case 'lineTo':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'lineTo';
                a.v = d.lineTo;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.lineTo(c, e);
                return b;
              });
            }, 'lineTo', []));
          case 'moveTo':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'moveTo';
                a.v = d.moveTo;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.moveTo(c, e);
                return b;
              });
            }, 'moveTo', []));
          case 'setStrokeStyle':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setStrokeStyle';
                a.v = d.setStrokeStyle;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f, g, h) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                g = Sk.ffi.remapToJs(g);
                h = Sk.ffi.remapToJs(h);
                d.setStrokeStyle(c, e, f, g, h);
                return b;
              });
            }, 'setStrokeStyle', []));
          }
        });
      }, 'Graphics', []);
      a.MovieClip = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          c = null !== c ? Sk.ffi.remapToJs(c) : null;
          d = Sk.ffi.remapToJs(d);
          e = Sk.ffi.remapToJs(e);
          f = Sk.ffi.remapToJs(f);
          Sk.ffi.referenceToPy(new b.MovieClip(c, d, e, f), 'MovieClip', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'timeline':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'timeline';
                a.v = d.timeline;
              });
              c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                var d = Sk.ffi.remapToJs(b);
                switch (c) {
                case 'addTween':
                  return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                    b.__init__ = Sk.ffi.functionPy(function (a) {
                      a.tp$name = 'addTween';
                      a.v = d.addTween;
                    });
                    b.__call__ = Sk.ffi.functionPy(function (a, b) {
                      var c = Sk.ffi.remapToJs(b);
                      d.addTween(c);
                    });
                  }, 'addTween', []));
                }
              });
            }, 'timeline', []));
          case 'gotoAndPlay':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'gotoAndPlay';
                a.v = d.gotoAndPlay;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                var c = Sk.ffi.remapToJs(b);
                d.gotoAndPlay(c);
              });
            }, 'gotoAndPlay', []));
          }
        });
      }, 'MovieClip', []);
      a.Shape = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('Shape', arguments, 0, 1);
          if (Sk.ffi.isUndefined(c))
            Sk.ffi.referenceToPy(new b.Shape(), 'Shape', void 0, a);
          else
            switch (Sk.ffi.checkArgType('graphics', 'Graphics', Sk.ffi.isInstance(c), c), Sk.ffi.typeName(c)) {
            case 'Shape':
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Shape', void 0, a);
              break;
            case 'Graphics':
              Sk.ffi.referenceToPy(new b.Shape(Sk.ffi.remapToJs(c)), 'Shape', void 0, a);
              break;
            default:
              Sk.ffi.checkArgType('graphics', 'Graphics', !1, c);
            }
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return d(a, b, 'Shape');
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return e(a, b, c, 'Shape');
        });
      }, 'Shape', []);
      a.Stage = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('Stage', arguments, 1, 1);
          Sk.ffi.checkArgType('canvas', 'Node', Sk.ffi.isInstance(c, 'Node'), c);
          var d = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new b.Stage(d), 'Stage', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'mouseInBounds':
            return Sk.ffi.remapToPy(d.mouseInBounds);
          case 'mouseMoveOutside':
            return Sk.ffi.remapToPy(d.mouseMoveOutside);
          case 'mouseX':
            return Sk.ffi.numberToIntPy(d.mouseX);
          case 'mouseY':
            return Sk.ffi.numberToIntPy(d.mouseY);
          case 'addChild':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'addChild';
                a.v = d.addChild;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                d.addChild(Sk.ffi.remapToJs(b));
                return b;
              });
            }, 'addChild', []));
          case 'enableMouseOver':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'enableMouseOver';
                a.v = d.enableMouseOver;
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                d.enableMouseOver();
              });
            }, 'enableMouseOver', []));
          case 'render':
          case 'update':
            return Sk.ffi.callableToPy(a, c, function (a) {
              d.update();
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Stage');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'autoClear':
            a.autoClear = c;
            break;
          case 'mouseMoveOutside':
            a.mouseMoveOutside = c;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Stage');
          }
        });
      }, 'Stage', []);
      a.Text = Sk.ffi.buildClass(a, function (c, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, c, d, e) {
          Sk.ffi.checkArgType('text', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
          Sk.ffi.checkArgType('font', Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
          c = Sk.ffi.remapToJs(c);
          d = Sk.ffi.remapToJs(d);
          e = Sk.ffi.remapToJs(e);
          Sk.ffi.referenceToPy(new b.Text(c, d, e), 'Text', void 0, a);
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'text':
            return Sk.ffi.stringToPy(e.text);
          case 'textAlign':
            return Sk.ffi.stringToPy(e.textAlign);
          case 'getMeasuredWidth':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getMeasuredWidth';
                a.v = e.getMeasuredWidth;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                return Sk.builtin.assk$(e.getMeasuredWidth(), Sk.builtin.nmber.float$);
              });
            }, 'getMeasuredWidth', []));
          case 'getMeasuredHeight':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getMeasuredHeight';
                a.v = e.getMeasuredHeight;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                return Sk.builtin.assk$(e.getMeasuredHeight(), Sk.builtin.nmber.float$);
              });
            }, 'getMeasuredHeight', []));
          default:
            return d(b, c, 'Text');
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'hitArea':
            d.hitArea = f;
            break;
          case 'text':
            d.text = f;
            break;
          case 'textAlign':
            d.textAlign = f;
            break;
          default:
            return e(a, b, c, 'Text');
          }
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Text(' + a.x + ', ' + a.y + ')');
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('[' + a.x + ', ' + a.y + ']');
        });
      }, 'Text', []);
      a.Ticker = Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          a.tp$name = 'Ticker';
          a.v = b.Ticker;
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'addEventListener':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'addEventListener';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, e) {
                a = Sk.ffi.remapToJs(b);
                b = Sk.ffi.remapToJs(c);
                'object' !== typeof b && (b = function (a) {
                  Sk.ffi.callsim(c);
                });
                d.addEventListener(a, b, e);
              });
            }, 'addEventListener', []));
          }
        });
      }, 'Ticker', []));
      a.Tween = Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          a.tp$name = 'Tween';
          a.v = b.Tween;
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'get':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'get';
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c, e, f, g) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                g = Sk.ffi.remapToJs(g);
                var h = d.get(c, e, f, g);
                return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                  c.__init__ = Sk.ffi.functionPy(function (a) {
                    a.tp$name = 'Tween';
                    a.v = h;
                  });
                  c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                    var d = Sk.ffi.remapToJs(b);
                    switch (c) {
                    case 'to':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'to';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (a, c, e, f) {
                          c = Sk.ffi.remapToJs(c);
                          e = Sk.ffi.remapToJs(e);
                          f = Sk.ffi.remapToJs(f);
                          d.to(c, e, f);
                          return b;
                        });
                      }, 'to', []));
                    case 'onComplete':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'onComplete';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (a, c, e) {
                          a = Sk.ffi.remapToJs(e);
                          d.call(function (a) {
                            Sk.ffi.callsim(c, Sk.ffi.remapToPy(a));
                          }, a);
                          return b;
                        });
                      }, 'onComplete', []));
                    case 'wait':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'wait';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (a, c) {
                          c = Sk.ffi.remapToJs(c);
                          d.wait(c);
                          return b;
                        });
                      }, 'wait', []));
                    }
                  });
                }, 'Tween', []));
              });
            }, 'get', []));
          }
        });
      }, 'Tween', []));
      a.Container = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.isUndefined(c) ? Sk.ffi.referenceToPy(new b.Container(), 'Container', void 0, a) : Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Container', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'name':
            return Sk.ffi.stringToPy(d.name);
          case 'x':
            return Sk.builtin.assk$(d.x, Sk.builtin.nmber.float$);
          case 'y':
            return Sk.builtin.assk$(d.y, Sk.builtin.nmber.float$);
          case 'rotation':
            return Sk.builtin.assk$(d.rotation, Sk.builtin.nmber.float$);
          case 'addChild':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'addChild';
                a.v = d.addChild;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                d.addChild(Sk.ffi.remapToJs(b));
                return b;
              });
            }, 'addChild', []));
          case 'addEventListener':
            return Sk.builtin.addEventListener(a, d);
          case 'getChildAt':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getChildAt';
                a.v = d.getChildAt;
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c) {
                var e = d.getChildAt(Sk.ffi.remapToJs(c));
                return Sk.ffi.callsim(a.Shape, Sk.ffi.referenceToPy(e, 'Shape'));
              });
            }, 'getChildAt', []));
          case 'getNumChildren':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getNumChildren';
                a.v = d.getNumChildren;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                return Sk.builtin.assk$(d.getNumChildren(), Sk.builtin.nmber.int$);
              });
            }, 'getNumChildren', []));
          case 'removeEventListener':
            return Sk.builtin.removeEventListener(a, d);
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'name':
            a.name = c;
            break;
          case 'x':
            a.x = c;
            break;
          case 'y':
            a.y = c;
            break;
          case 'rotation':
            a.rotation = c;
            break;
          default:
            throw new Sk.builtin.AttributeError(b + ' is not a writeable attribute of Container');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Container(' + a.x + ', ' + a.y + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('[' + a.x + ', ' + a.y + ']');
        });
      }, 'Container', []);
      a.Ease = Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          a.tp$name = 'Ease';
          a.v = b.Ease;
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, c) {
          switch (c) {
          case 'bounceOut':
            return { v: b.Ease.bounceOut };
          }
        });
      }, 'Ease', []));
      a.Point = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.builtin.pyCheckArgs('Point', arguments, 1, 3);
          a.tp$name = 'Point';
          switch (arguments.length) {
          case 1:
            a.v = new b.Point();
            break;
          case 2:
            c = Sk.ffi.remapToJs(c);
            a.tp$name = 'Point';
            a.v = c;
            break;
          case 3:
            Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(c)), Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(d)), c = Sk.ffi.remapToJs(c), d = Sk.ffi.remapToJs(d), a.tp$name = 'Point', a.v = new b.Point(c, d);
          }
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'x':
            return Sk.builtin.assk$(d.x, Sk.builtin.nmber.float$);
          case 'y':
            return Sk.builtin.assk$(d.y, Sk.builtin.nmber.float$);
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'clone';
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                return Sk.ffi.callsim(a.Point, Sk.ffi.remapToPy(d.x), Sk.ffi.remapToPy(d.y));
              });
            }, 'clone', []));
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'x':
            a.x = c;
            break;
          case 'y':
            a.y = c;
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Point(' + a.x + ', ' + a.y + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('[' + a.x + ', ' + a.y + ']');
        });
      }, 'Point', []);
      a.getHSL = Sk.ffi.functionPy(function (a, c, d, e) {
        a = Sk.ffi.remapToJs(a);
        c = Sk.ffi.remapToJs(c);
        d = Sk.ffi.remapToJs(d);
        e = Sk.ffi.remapToJs(e);
        return Sk.ffi.stringToPy(b.Graphics.getHSL(a, c, d, e));
      });
    };
  }.call(this));
  Sk.builtin.defineEvent = function (a) {
    a.Event = Sk.ffi.buildClass(a, function (b, c) {
      c.__init__ = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Event', void 0, a);
      });
      c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
        var f = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'altKey':
          return Sk.ffi.booleanToPy(f.altKey);
        case 'bubbles':
          return Sk.ffi.booleanToPy(f.bubbles);
        case 'button':
          return Sk.ffi.numberToIntPy(f.button);
        case 'cancelable':
          return Sk.ffi.booleanToPy(f.cancelable);
        case 'clientX':
          return Sk.ffi.numberToIntPy(f.clientX);
        case 'clientY':
          return Sk.ffi.numberToIntPy(f.clientY);
        case 'ctrlKey':
          return Sk.ffi.booleanToPy(f.ctrlKey);
        case 'defaultPrevented':
          return Sk.ffi.booleanToPy(f.defaultPrevented);
        case 'keyCode':
          return Sk.ffi.numberToIntPy(f.keyCode);
        case 'screenX':
          return Sk.ffi.numberToIntPy(f.screenX);
        case 'screenY':
          return Sk.ffi.numberToIntPy(f.screenY);
        case 'shiftKey':
          return Sk.ffi.booleanToPy(f.shiftKey);
        case 'target':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              Sk.ffi.referenceToPy(f.target, 'target', void 0, a);
            });
            b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
              return Sk.ffi.remapToPy(f.target[b], '');
            });
            b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
              f.target[b] = Sk.ffi.remapToJs(c);
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              a = Sk.ffi.remapToJs(a);
              return Sk.ffi.stringToPy('' + a);
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              a = Sk.ffi.remapToJs(a);
              return Sk.ffi.stringToPy('' + a);
            });
          }, 'target', []));
        case 'type':
          return Sk.ffi.stringToPy(f.type);
        case 'addEventListener':
          return Sk.builtin.addEventListener(a, f);
        case 'preventDefault':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'preventDefault';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              f.preventDefault();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('preventDefault');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('preventDefault');
            });
          }, 'preventDefault', []));
        case 'stopImmediatePropagation':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'stopImmediatePropagation';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              f.stopImmediatePropagation();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('stopImmediatePropagation');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('stopImmediatePropagation');
            });
          }, 'stopImmediatePropagation', []));
        case 'stopPropagation':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'stopPropagation';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              f.stopPropagation();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('stopPropagation');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('stopPropagation');
            });
          }, 'stopPropagation', []));
        default:
          return Sk.ffi.remapToPy(f[c], '');
        }
      });
      c.__str__ = Sk.ffi.functionPy(function (a) {
        a = Sk.ffi.remapToJs(a);
        return Sk.ffi.stringToPy('' + a);
      });
      c.__repr__ = Sk.ffi.functionPy(function (a) {
        a = Sk.ffi.remapToJs(a);
        return Sk.ffi.stringToPy('' + a);
      });
    }, 'Event', []);
  };
  Sk.builtin.addEventListener = function (a, b) {
    return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
      d.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(b.addEventListener, 'addEventListener', void 0, a);
      });
      d.__call__ = Sk.ffi.functionPy(function (c, d, g, h) {
        c = Sk.ffi.remapToJs(d);
        h = Sk.ffi.remapToJs(h);
        b.addEventListener(c, function (b) {
          b = Sk.ffi.callsim(a.Event, Sk.ffi.referenceToPy(b, 'Event'));
          Sk.ffi.callsim(g, b);
        }, h);
      });
    }, 'addEventListener', []));
  };
  Sk.builtin.removeEventListener = function (a, b) {
    return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
      d.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(b.removeEventListener, 'removeEventListener', void 0, a);
      });
      d.__call__ = Sk.ffi.functionPy(function (c, d, g, h) {
        c = Sk.ffi.remapToJs(d);
        h = Sk.ffi.remapToJs(h);
        b.removeEventListener(c, function (b) {
          b = Sk.ffi.callsim(a.Event, Sk.ffi.referenceToPy(b, 'Event'));
          Sk.ffi.callsim(g, b);
        }, h);
      });
    }, 'removeEventListener', []));
  };
  (function () {
    Sk.builtin.defineGeometry = function (a, b, c) {
      function d(b) {
        var c = Sk.ffi.remapToJs(b);
        return Sk.ffi.callableToPy(a, 'name', function (a, d) {
          Sk.ffi.checkMethodArgs('name', arguments, 1, 1);
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
          c.name = Sk.ffi.remapToJs(d);
          return b;
        });
      }
      function e(b, c) {
        function d(a) {
          var b = Sk.ffi.remapToJs(a);
          c.name && (b.name = c.name);
          return a;
        }
        if (c.material)
          return d(Sk.ffi.callsim(a.Mesh, b, c.material));
        var e = {};
        e.color = 'undefined' !== typeof c.color ? c.color : 16777215;
        'undefined' !== typeof c.wireframeLinewidth && (e.wireframeLinewidth = c.wireframeLinewidth);
        'undefined' !== typeof c.wireframe ? e = (e.wireframe = c.wireframe) ? Sk.ffi.callsim(a.MeshBasicMaterial, Sk.ffi.remapToPy(e)) : Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(e)) : (e.wireframe = !1, e = Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(e)));
        return d(Sk.ffi.callsim(a.Mesh, b, e));
      }
      function f(a) {
        a = [
          [
            +a,
            0,
            0
          ],
          [
            0,
            +a,
            0
          ],
          [
            0,
            0,
            +a
          ],
          [
            -a,
            0,
            0
          ],
          [
            0,
            -a,
            0
          ],
          [
            0,
            0,
            -a
          ]
        ].map(function (a) {
          var c = new b.Geometry();
          c.vertices.push(new b.Vector3(0, 0, 0));
          c.vertices.push(new b.Vector3(a[0], a[1], a[2]));
          return c;
        });
        var c = new b.Object3D();
        c.add(new b.Line(a[0], new b.LineBasicMaterial({
          color: 16711680,
          opacity: 0.5,
          transparent: !0
        })));
        c.add(new b.Line(a[1], new b.LineBasicMaterial({
          color: 65280,
          opacity: 0.5,
          transparent: !0
        })));
        c.add(new b.Line(a[2], new b.LineBasicMaterial({
          color: 255,
          opacity: 0.5,
          transparent: !0
        })));
        c.add(new b.Line(a[3], new b.LineBasicMaterial({
          color: 16711680,
          opacity: 0.2,
          transparent: !0
        })));
        c.add(new b.Line(a[4], new b.LineBasicMaterial({
          color: 65280,
          opacity: 0.2,
          transparent: !0
        })));
        c.add(new b.Line(a[5], new b.LineBasicMaterial({
          color: 255,
          opacity: 0.2,
          transparent: !0
        })));
        return c;
      }
      function g(a, c, d, e, f) {
        var g = new b.Object3D(), h = a * c, n = d / c, k = a * d;
        a = f.x * k;
        d = f.y * k;
        f = f.z * k;
        for (k = -h; k <= h; k += 1)
          if (0 != k) {
            var p = k * n, q = new b.Geometry();
            q.vertices.push(new b.Vector3(e.x * p - a, e.y * p - d, e.z * p - f));
            q.vertices.push(new b.Vector3(e.x * p + a, e.y * p + d, e.z * p + f));
            p = new b.Line(q, 0 === k % c ? l : m);
            g.add(p);
          }
        return g;
      }
      function h(b, c, e) {
        var f = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'attitude':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        case 'color':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, k, Sk.ffi.isNum(d) || Sk.ffi.isStr(d) || Sk.ffi.isInstance(d, 'Color'), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        case 'material':
          return Sk.ffi.callableToPy(a, 'material', function (a, c) {
            Sk.ffi.checkMethodArgs('material', arguments, 1, 1);
            Sk.ffi.checkArgType('material', 'Material', Sk.ffi.isInstance(c), c);
            f.material = c;
            return b;
          });
        case 'name':
          return d(b);
        case 'scale':
          return Sk.ffi.callableToPy(a, 'scale', function (a, c) {
            Sk.ffi.checkMethodArgs('scale', arguments, 1, 1);
            Sk.ffi.checkArgType('scale', [
              k,
              Sk.ffi.PyType.NONE
            ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
            f.scale = Sk.ffi.remapToJs(c);
            return b;
          });
        case 'volume':
          return Sk.ffi.callableToPy(a, 'volume', function (a, c) {
            Sk.ffi.checkMethodArgs('volume', arguments, 1, 1);
            Sk.ffi.checkArgType('volume', k, Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
            f.volume = Sk.ffi.remapToJs(c);
            return b;
          });
        case 'wireframe':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        case 'wireframeLinewidth':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, Sk.ffi.PyType.INT, Sk.ffi.isInt(d), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        default:
          throw Sk.ffi.err.attribute(c).isNotGetableOnType(e);
        }
      }
      Sk.ffi.checkFunctionArgs('defineGeometry', arguments, 3, 3);
      var k = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], l = new b.LineBasicMaterial({
          color: 6726098,
          opacity: 0.2,
          transparent: !0
        }), m = new b.LineBasicMaterial({
          color: 6726098,
          opacity: 0.02,
          transparent: !0
        }), n = new b.Vector3(1, 0, 0), p = new b.Vector3(0, 1, 0);
      new b.Vector3(0, 0, 1);
      var q = new b.Euclidean3(new b.Vector3(0, 0, 0), new b.Quaternion(0, 0, 0, 1), 0, !1);
      a.world = Sk.ffi.functionPy(function () {
        Sk.ffi.checkFunctionArgs('world', arguments, 0, 0);
        var c = Sk.ffi.callsim(a.Scene), d = Sk.ffi.remapToJs(c), e = new b.PointLight(16777215);
        e.position.set(5, 5, 5);
        d.add(e);
        d.add(new b.AmbientLight(2236962));
        return c;
      });
      a.CartesianSpace = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (b, c, d) {
          var e, h;
          Sk.ffi.checkMethodArgs('CartesianSpace', arguments, 0, 2);
          Sk.ffi.isDefined(c) ? Sk.ffi.checkArgType('scene', 'Scene', Sk.ffi.isInstance(c, 'Scene'), c) : c = Sk.ffi.callsim(a.world);
          e = Sk.ffi.remapToJs(c);
          Sk.ffi.isDefined(d) ? Sk.ffi.checkArgType('renderer', [
            'CanvasRenderer',
            'WebGLRenderer'
          ], Sk.ffi.isInstance(d, 'WebGLRenderer') || Sk.ffi.isInstance(d, 'CanvasRenderer'), d) : d = Sk.ffi.callsim(a.WebGLRenderer, Sk.ffi.remapToPy({ antialias: !0 }));
          h = Sk.ffi.remapToJs(d);
          var k = Sk.ffi.callsim(a.PerspectiveCamera, Sk.ffi.numberToFloatPy(45), Sk.ffi.numberToFloatPy(1), Sk.ffi.numberToFloatPy(0.1), Sk.ffi.numberToFloatPy(10000)), l = Sk.ffi.remapToJs(k);
          l.up.set(0, 0, 1);
          l.position.set(8, 4, 5);
          l.lookAt(e.position);
          h.setClearColor(526344, 1);
          e.add(f(1000));
          e.add(g(5, 10, 1, n, p));
          e.add(g(5, 10, 1, p, n));
          Sk.ffi.referenceToPy({
            scenePy: c,
            cameraPy: k,
            rendererPy: d
          }, 'CartesianSpace', void 0, b);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'camera':
            return d.cameraPy;
          case 'origin':
            return Sk.ffi.gattr(d.scenePy, 'position');
          case 'renderer':
            return d.rendererPy;
          case 'scene':
            return d.scenePy;
          case 'add':
            return Sk.ffi.gattr(d.scenePy, 'add');
          case 'render':
            return Sk.ffi.callableToPy(a, 'render', function (a) {
              a = Sk.ffi.gattr(d.rendererPy, 'render');
              return Sk.ffi.callsim(a, d.scenePy, d.cameraPy);
            });
          case 'viewSize':
            return Sk.ffi.callableToPy(a, 'render', function (a, b, c) {
              Sk.ffi.checkMethodArgs('viewSize', arguments, 2, 2);
              Sk.ffi.checkArgType('width', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
              Sk.ffi.checkArgType('height', Sk.ffi.PyType.INT, Sk.ffi.isInt(c), c);
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              Sk.ffi.remapToJs(d.rendererPy).setSize(e, f);
              var g = Sk.ffi.remapToJs(d.cameraPy);
              g.aspect = e / f;
              g.updateProjectionMatrix();
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('CartesianSpace');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CartesianSpace');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CartesianSpace');
        });
      }, 'CartesianSpace', []);
      a.ArrowBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('ArrowBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'ArrowBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'magnitude':
            return Sk.ffi.callableToPy(a, 'magnitude', function (a, c) {
              Sk.ffi.checkMethodArgs('magnitude', arguments, 1, 1);
              Sk.ffi.checkArgType('magnitude', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.magnitude = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, f = {};
              f.attitude = d.attitude ? d.attitude : q;
              if (d.volume) {
                var g = (d.radius ? d.radius : 0.5) / (d.length ? d.length : 1);
                f.radius = Math.pow(3 * g * d.volume / Math.PI, 1 / 3);
                f.length = f.radius / g;
              } else
                f.scale = d.scale ? d.scale : 1, f.radius = d.radius ? d.radius : 0.5, f.length = d.length ? d.length : 1;
              c = f;
              var f = Sk.ffi.numberToFloatPy(c.scale), g = Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(c.attitude, 'Euclidean3')), h = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32);
              c = Sk.ffi.numberToFloatPy(c.magnitude);
              f = Sk.ffi.callsim(a.ArrowGeometry, f, g, h, c);
              return e(f, d);
            });
          default:
            return h(b, c, 'ArrowBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ArrowBuilder()');
        });
      }, 'ArrowBuilder', []);
      a.ConeBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('ConeBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'ConeBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, f = {};
              if (d.volume) {
                var g = (d.radius ? d.radius : 0.5) / (d.height ? d.height : 1);
                f.radius = Math.pow(3 * g * d.volume / Math.PI, 1 / 3);
                f.height = f.radius / g;
              } else
                f.radius = d.radius ? d.radius : 0.5, f.height = d.height ? d.height : 1;
              c = f;
              f = Sk.ffi.numberToFloatPy(0);
              g = Sk.ffi.numberToFloatPy(c.radius);
              c = Sk.ffi.numberToFloatPy(c.height);
              var h = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), n = Sk.ffi.numberToIntPy(1), k = Sk.ffi.booleanToPy(!1), f = Sk.ffi.callsim(a.CylinderGeometry, f, g, c, h, n, k);
              return e(f, d);
            });
          default:
            return h(b, c, 'ConeBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ConeBuilder()');
        });
      }, 'ConeBuilder', []);
      a.CubeBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('CubeBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'CubeBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'depth':
            return Sk.ffi.callableToPy(a, 'depth', function (a, c) {
              Sk.ffi.checkMethodArgs('depth', arguments, 1, 1);
              Sk.ffi.checkArgType('depth', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.depth = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'width':
            return Sk.ffi.callableToPy(a, 'width', function (a, c) {
              Sk.ffi.checkMethodArgs('width', arguments, 1, 1);
              Sk.ffi.checkArgType('width', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.width = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, f = {};
              if (d.volume) {
                var g = d.width ? d.width : 1;
                c = d.height ? d.height : 1;
                var h = d.depth ? d.depth : 1, n = Math.pow(d.volume / (g * c * h), 1 / 3);
                f.width = n * g;
                f.height = n * c;
                f.depth = n * h;
              } else
                f.width = d.width ? d.width : 1, f.height = d.height ? d.height : 1, f.depth = d.depth ? d.depth : 1;
              c = f;
              f = Sk.ffi.remapToPy(c.width);
              g = Sk.ffi.remapToPy(c.height);
              c = Sk.ffi.remapToPy(c.depth);
              h = Sk.ffi.numberToIntPy(d.segments ? d.segments : 1);
              f = Sk.ffi.callsim(a.CubeGeometry, f, g, c, h, h, h);
              return e(f, d);
            });
          default:
            return h(b, c, 'CubeBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CubeBuilder()');
        });
      }, 'CubeBuilder', []);
      a.CylinderBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('CylinderBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({
            radiusTop: 0.5,
            radiusBottom: 0.5,
            height: 1
          }, 'CylinderBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radiusTop = Sk.ffi.remapToJs(c);
              d.radiusBottom = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radiusTop':
            return Sk.ffi.callableToPy(a, 'radiusTop', function (a, c) {
              Sk.ffi.checkMethodArgs('radiusTop', arguments, 1, 1);
              Sk.ffi.checkArgType('radiusTop', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radiusTop = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radiusBottom':
            return Sk.ffi.callableToPy(a, 'radiusBottom', function (a, c) {
              Sk.ffi.checkMethodArgs('radiusBottom', arguments, 1, 1);
              Sk.ffi.checkArgType('radiusBottom', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radiusBottom = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, f = {};
              if (d.volume) {
                var g = 'number' === typeof d.radiusTop ? d.radiusTop : 0.5;
                c = 'number' === typeof d.radiusBottom ? d.radiusBottom : 0.5;
                var h = 'number' === typeof d.height ? d.height : 1, n = Math.pow(3 * d.volume / (c * (c + g) * h * Math.PI), 1 / 3);
                f.a = n * g;
                f.b = n * c;
                f.h = n * h;
              } else
                f.a = 'number' === typeof d.radiusTop ? d.radiusTop : 0.5, f.b = 'number' === typeof d.radiusBottom ? d.radiusBottom : 0.5, f.h = 'number' === typeof d.height ? d.height : 1;
              c = f;
              f = Sk.ffi.numberToFloatPy(c.a);
              g = Sk.ffi.numberToFloatPy(c.b);
              c = Sk.ffi.numberToFloatPy(c.h);
              var h = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), n = Sk.ffi.numberToIntPy(1), k = Sk.ffi.booleanToPy(!1), f = Sk.ffi.callsim(a.CylinderGeometry, f, g, c, h, n, k);
              return e(f, d);
            });
          default:
            return h(b, c, 'CylinderBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CylinderBuilder()');
        });
      }, 'CylinderBuilder', []);
      a.PlaneBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('PlaneBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'PlaneBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'width':
            return Sk.ffi.callableToPy(a, 'width', function (a, c) {
              Sk.ffi.checkMethodArgs('width', arguments, 1, 1);
              Sk.ffi.checkArgType('width', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.width = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, f = {};
              if (d.volume) {
                c = d.width ? d.width : 1;
                var g = d.height ? d.height : 1, h = Math.pow(d.volume / (c * g), 0.5);
                f.width = h * c;
                f.height = h * g;
              } else
                f.width = d.width ? d.width : 1, f.height = d.height ? d.height : 1;
              c = f;
              f = Sk.ffi.remapToPy(c.width);
              c = Sk.ffi.remapToPy(c.height);
              g = Sk.ffi.numberToIntPy(d.segments ? d.segments : 1);
              f = Sk.ffi.callsim(a.PlaneGeometry, f, c, g, g);
              return e(f, d);
            });
          default:
            return h(b, c, 'PlaneBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('PlaneBuilder()');
        });
      }, 'PlaneBuilder', []);
      a.SphereBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('SphereBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'SphereBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c;
              c = d.volume ? Math.pow(3 * d.volume / (4 * Math.PI), 1 / 3) : d.radius ? d.radius : 0.5;
              c = Sk.ffi.remapToPy(c);
              var f = Sk.ffi.numberToIntPy(d.segments ? d.segments : 24), g = Sk.ffi.numberToIntPy(d.segments ? d.segments : 18);
              c = Sk.ffi.callsim(a.SphereGeometry, c, f, g);
              return e(c, d);
            });
          default:
            return h(b, c, 'SphereBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('SphereBuilder()');
        });
      }, 'SphereBuilder', []);
      a.VortexBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('VortexBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'VortexBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c = {};
              if (d.volume) {
                var f = d.radius ? d.radius : 1, g = d.height ? d.height : 1, h = Math.pow(d.volume / (f * g), 0.5);
                c.width = h * f;
                c.height = h * g;
              } else
                c.radius = d.radius ? d.radius : 1, c.height = d.height ? d.height : 1;
              var c = Sk.ffi.remapToPy(c.radius), f = Sk.ffi.remapToPy(0.08), g = Sk.ffi.remapToPy(0.01), h = Sk.ffi.remapToPy(0.2), n = Sk.ffi.remapToPy(0.8), k = Sk.ffi.numberToIntPy(8), l = Sk.ffi.numberToIntPy(32), c = Sk.ffi.callsim(a.VortexGeometry, c, f, g, h, n, k, l);
              return e(c, d);
            });
          default:
            return h(b, c, 'VortexBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('VortexBuilder()');
        });
      }, 'VortexBuilder', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineNode = function (a) {
      Sk.ffi.checkFunctionArgs('defineNode', arguments, 1, 1);
      var b = function (b) {
        return b ? Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(b, 'Node')) : Sk.ffi.remapToPy(null);
      };
      a.Node = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('Node', arguments, 1, 1);
          Sk.ffi.checkArgType('node', 'Node', Sk.ffi.isInstance(b, 'Node'), b);
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Node', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var g = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'clientHeight':
            return Sk.ffi.numberToFloatPy(g.clientHeight);
          case 'clientWidth':
            return Sk.ffi.numberToFloatPy(g.clientWidth);
          case 'dir':
            return Sk.ffi.stringToPy(g.dir);
          case 'firstChild':
            return b(g.firstChild);
          case 'lastChild':
            return b(g.lastChild);
          case 'nextSibling':
            return b(g.nextSibling);
          case 'offsetHeight':
            return Sk.ffi.numberToIntPy(g.offsetHeight);
          case 'offsetWidth':
            return Sk.ffi.numberToIntPy(g.offsetWidth);
          case 'parentNode':
            return b(g.parentNode);
          case 'previousSibling':
            return b(g.previousSibling);
          case 'height':
            return Sk.builtin.assk$(g.height, Sk.builtin.nmber.int$);
          case 'width':
            return Sk.builtin.assk$(g.width, Sk.builtin.nmber.int$);
          case 'style':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'style';
                a.v = g.style;
              });
              b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
                var c = Sk.ffi.remapToJs(a);
                switch (b) {
                case 'height':
                  return Sk.ffi.stringToPy(c.height);
                case 'left':
                  return Sk.ffi.stringToPy(c.left);
                case 'position':
                  return Sk.ffi.stringToPy(c.position);
                case 'top':
                  return Sk.ffi.stringToPy(c.top);
                case 'width':
                  return Sk.ffi.stringToPy(c.width);
                }
              });
              b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
                a = Sk.ffi.remapToJs(a);
                c = Sk.ffi.remapToJs(c);
                switch (b) {
                case 'height':
                  a.height = c;
                  break;
                case 'left':
                  a.left = c;
                  break;
                case 'position':
                  a.position = c;
                  break;
                case 'top':
                  a.top = c;
                  break;
                case 'width':
                  a.width = c;
                  break;
                default:
                  throw new Sk.builtin.AssertionError(b + ' is not a writeable attribute of style');
                }
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('style');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('style');
              });
            }, 'style', []));
          case 'appendChild':
            return Sk.ffi.callableToPy(a, 'appendChild', function (a, c) {
              Sk.ffi.checkMethodArgs('appendChild', arguments, 1, 1);
              Sk.ffi.checkArgType('child', 'Node', Sk.ffi.isInstance(c, 'Node'), c);
              var d = Sk.ffi.remapToJs(c);
              return b(g.appendChild(d));
            });
          case 'getContext':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getContext';
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c, d) {
                b = Sk.ffi.remapToJs(c);
                d = Sk.ffi.remapToJs(d);
                var e = g.getContext(b, d);
                return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                  c.__init__ = Sk.ffi.functionPy(function (a) {
                    a.tp$name = 'CanvasRenderingContext2D';
                    a.v = e;
                  });
                  c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                    switch (c) {
                    case 'fillStyle':
                      return Sk.ffi.stringToPy(e.fillStyle);
                    case 'font':
                      return Sk.ffi.stringToPy(e.font);
                    case 'lineCap':
                      return Sk.ffi.stringToPy(e.lineCap);
                    case 'lineJoin':
                      return Sk.ffi.stringToPy(e.lineJoin);
                    case 'lineWidth':
                      return Sk.builtin.assk$(e.lineWidth, Sk.builtin.nmber.int$);
                    case 'shadowBlur':
                      return Sk.builtin.assk$(e.shadowBlur, Sk.builtin.nmber.int$);
                    case 'shadowColor':
                      return Sk.ffi.stringToPy(e.shadowColor);
                    case 'shadowOffsetX':
                      return Sk.builtin.assk$(e.shadowOffsetX, Sk.builtin.nmber.int$);
                    case 'shadowOffsetY':
                      return Sk.builtin.assk$(e.shadowOffsetY, Sk.builtin.nmber.int$);
                    case 'strokeStyle':
                      return Sk.ffi.stringToPy(e.strokeStyle);
                    case 'textAlign':
                      return Sk.ffi.stringToPy(e.textAlign);
                    case 'textBaseline':
                      return Sk.ffi.stringToPy(e.textBaseline);
                    case 'webkitBackingStorePixelRatio':
                      return Sk.builtin.assk$(e.webkitBackingStorePixelRatio, Sk.builtin.nmber.int$);
                    case 'arc':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'arc';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          e.arc(b, c, d, f, g, h);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('arc');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('arc');
                        });
                      }, 'arc', []));
                    case 'arcTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'arcTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h, n) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          n = Sk.ffi.remapToJs(n);
                          e.arcTo(b, c, d, f, g, h, n);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('arcTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('arcTo');
                        });
                      }, 'arcTo', []));
                    case 'beginPath':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'beginPath';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.beginPath();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('beginPath');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('beginPath');
                        });
                      }, 'beginPath', []));
                    case 'bezierCurveTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'bezierCurveTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          e.bezierCurveTo(b, c, d, f, g, h);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('bezierCurveTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('bezierCurveTo');
                        });
                      }, 'bezierCurveTo', []));
                    case 'clearRect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'clearRect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.clearRect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('clearRect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('clearRect');
                        });
                      }, 'clearRect', []));
                    case 'clip':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'clip';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.clip();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('clip');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('clip');
                        });
                      }, 'clip', []));
                    case 'closePath':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'closePath';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.closePath();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('closePath');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('closePath');
                        });
                      }, 'closePath', []));
                    case 'createLinearGradient':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'createLinearGradient';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (b, c, d, f, g) {
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          var h = e.createLinearGradient(c, d, f, g);
                          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                            c.__init__ = Sk.ffi.functionPy(function (a) {
                              a.tp$name = 'CanvasGradient';
                              a.v = h;
                            });
                            c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                              switch (c) {
                              case 'addColorStop':
                                return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                                  b.__init__ = Sk.ffi.functionPy(function (a) {
                                    a.tp$name = 'addColorStop';
                                  });
                                  b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                                    b = Sk.ffi.remapToJs(b);
                                    c = Sk.ffi.remapToJs(c);
                                    h.addColorStop(b, c);
                                  });
                                  b.__str__ = Sk.ffi.functionPy(function (a) {
                                    return Sk.ffi.stringToPy('addColorStop');
                                  });
                                  b.__repr__ = Sk.ffi.functionPy(function (a) {
                                    return Sk.ffi.stringToPy('addColorStop');
                                  });
                                }, 'addColorStop', []));
                              }
                            });
                            c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
                              Sk.ffi.remapToJs(c);
                              switch (b) {
                              default:
                                throw new Sk.builtin.AssertionError(b + ' is not a writeable attribute of CanvasGradient');
                              }
                            });
                            c.__str__ = Sk.ffi.functionPy(function (a) {
                              return Sk.ffi.stringToPy('CanvasGradient');
                            });
                            c.__repr__ = Sk.ffi.functionPy(function (a) {
                              return Sk.ffi.stringToPy('CanvasGradient');
                            });
                          }, 'CanvasGradient', []));
                        });
                        c.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('createLinearGradient');
                        });
                        c.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('createLinearGradient');
                        });
                      }, 'createLinearGradient', []));
                    case 'fill':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'fill';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.fill();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fill');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fill');
                        });
                      }, 'fill', []));
                    case 'fillRect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'fillRect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.fillRect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fillRect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fillRect');
                        });
                      }, 'fillRect', []));
                    case 'fillText':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'fillText';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          a = Sk.ffi.remapToJs(f);
                          if ('undefined' === typeof a)
                            e.fillText(b, c, d);
                          else if ('number' === typeof a)
                            e.fillText(b, c, d, a);
                          else
                            throw new Sk.builtin.TypeError('maxWidth');
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fillText');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fillText');
                        });
                      }, 'fillText', []));
                    case 'lineTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'lineTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.lineTo(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('lineTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('lineTo');
                        });
                      }, 'lineTo', []));
                    case 'moveTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'moveTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.moveTo(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('moveTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('moveTo');
                        });
                      }, 'moveTo', []));
                    case 'quadraticCurveTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'quadraticCurveTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.quadraticCurveTo(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('quadraticCurveTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('quadraticCurveTo');
                        });
                      }, 'quadraticCurveTo', []));
                    case 'rect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'rect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.rect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('rect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('rect');
                        });
                      }, 'rect', []));
                    case 'restore':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'restore';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.restore();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('restore');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('restore');
                        });
                      }, 'restore', []));
                    case 'rotate':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'rotate';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b) {
                          b = Sk.ffi.remapToJs(b);
                          e.rotate(b);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('rotate');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('rotate');
                        });
                      }, 'rotate', []));
                    case 'save':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'save';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.save();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('save');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('save');
                        });
                      }, 'save', []));
                    case 'scale':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'scale';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.scale(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('scale');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('scale');
                        });
                      }, 'scale', []));
                    case 'setTransform':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'setTransform';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          e.setTransform(b, c, d, f, g, h);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('setTransform');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('setTransform');
                        });
                      }, 'setTransform', []));
                    case 'stroke':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'stroke';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.stroke();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('stroke');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('stroke');
                        });
                      }, 'stroke', []));
                    case 'strokeRect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'strokeRect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.strokeRect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('strokeRect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('strokeRect');
                        });
                      }, 'strokeRect', []));
                    case 'strokeText':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'strokeText';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          a = Sk.ffi.remapToJs(f);
                          if ('undefined' === typeof a)
                            e.strokeText(b, c, d);
                          else if ('number' === typeof a)
                            e.strokeText(b, c, d, a);
                          else
                            throw new Sk.builtin.TypeError('maxWidth');
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('strokeText');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('strokeText');
                        });
                      }, 'strokeText', []));
                    case 'transform':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'transform';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          e.transform(b, c, d, f, g, h);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('transform');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('transform');
                        });
                      }, 'transform', []));
                    case 'translate':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'translate';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.translate(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('translate');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('translate');
                        });
                      }, 'translate', []));
                    }
                  });
                  c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
                    a = Sk.ffi.remapToJs(a);
                    c = Sk.ffi.remapToJs(c);
                    switch (b) {
                    case 'fillStyle':
                      a.fillStyle = c;
                      break;
                    case 'font':
                      a.font = c;
                      break;
                    case 'lineCap':
                      a.lineCap = c;
                      break;
                    case 'lineJoin':
                      a.lineJoin = c;
                      break;
                    case 'lineWidth':
                      a.lineWidth = c;
                      break;
                    case 'shadowBlur':
                      a.shadowBlur = c;
                      break;
                    case 'shadowColor':
                      a.shadowColor = c;
                      break;
                    case 'shadowOffsetX':
                      a.shadowOffsetX = c;
                      break;
                    case 'shadowOffsetY':
                      a.shadowOffsetY = c;
                      break;
                    case 'strokeStyle':
                      a.strokeStyle = c;
                      break;
                    case 'textAlign':
                      a.textAlign = c;
                      break;
                    case 'textBaseline':
                      a.textBaseline = c;
                      break;
                    default:
                      throw new Sk.builtin.AssertionError(b + ' is not a writeable attribute of CanvasRenderingContext2D');
                    }
                  });
                  c.__str__ = Sk.ffi.functionPy(function (a) {
                    return Sk.ffi.stringToPy('CanvasRenderingContext2D');
                  });
                  c.__repr__ = Sk.ffi.functionPy(function (a) {
                    return Sk.ffi.stringToPy('CanvasRenderingContext2D');
                  });
                }, 'CanvasRenderingContext2D', []));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('getContext');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('getContext');
              });
            }, 'getContext', []));
          case 'insertBefore':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'insertBefore';
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d) {
                return b(g.insertBefore(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d)));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('insertBefore');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('insertBefore');
              });
            }, 'insertBefore', []));
          case 'removeChild':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'removeChild';
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                return b(g.removeChild(Sk.ffi.remapToJs(c)));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('removeChild');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('removeChild');
              });
            }, 'removeChild', []));
          case 'setAttribute':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setAttribute';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                Sk.ffi.checkMethodArgs('setAttribute', arguments, 2, 2);
                Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(b), b);
                g.setAttribute(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c));
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setAttribute');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setAttribute');
              });
            }, 'setAttribute', []));
          default:
            throw Sk.ffi.err.attribute(d).isNotGetableOnType('Node');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          var d = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'dir':
            a.dir = d;
            break;
          case 'id':
            a.setAttribute(b, d);
            break;
          case 'height':
            a.height = d;
            break;
          case 'innerHTML':
            Sk.ffi.checkArgType('innerHTML', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            a.innerHTML = Sk.ffi.remapToJs(c);
            break;
          case 'width':
            a.width = d;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Node');
          }
        });
        d.getCSS = Sk.ffi.functionPy(function (a, b) {
          return Sk.ffi.stringToPy(a.v.style[b.v]);
        });
        d.setCSS = Sk.ffi.functionPy(function (a, b, c) {
          a.v.style[b.v] = c.v;
        });
        d.getAttribute = Sk.ffi.functionPy(function (a, b) {
          var c = a.v.getAttribute(b.v);
          return c ? Sk.ffi.stringToPy(c) : null;
        });
        d.setAttribute = Sk.ffi.functionPy(function (a, b, c) {
          a.v.setAttribute(b.v, c.v);
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(a.v.tagName);
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Node');
        });
      }, 'Node', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineProbeE3 = function (a, b) {
      Sk.ffi.checkFunctionArgs('defineProbeE3', arguments, 2, 2);
      var c = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      a.ProbeE3 = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('ProbeE3', arguments, 4, 4);
          var m = {};
          m.grade0 = b;
          m.grade1 = c;
          m.grade2 = d;
          m.grade3 = e;
          m.quantity = Sk.ffi.none.None;
          Sk.ffi.referenceToPy(m, 'ProbeE3', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'grade0':
            return c.grade0;
          case 'grade1':
            return c.grade1;
          case 'grade2':
            return c.grade2;
          case 'grade3':
            return c.grade3;
          case 'quantity':
            return c.quantity;
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('ProbeE3');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, c, d) {
          a = Sk.ffi.remapToJs(a);
          switch (c) {
          case 'position':
            Sk.ffi.checkArgType('position', 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
            d = Sk.ffi.remapToJs(d).vector;
            var e = Sk.ffi.remapToJs(a.grade0);
            e.position = d;
            e = Sk.ffi.remapToJs(a.grade1);
            e.position = d;
            var l = Sk.ffi.remapToJs(a.grade2);
            l.position = d;
            c = Sk.ffi.remapToJs(a.grade3);
            c.position = d;
            break;
          case 'quantity':
            Sk.ffi.checkArgType('quantity', 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
            c = function (a, c, d) {
              if (-1 !== d) {
                var e = 1 / Math.sqrt(2 * (1 + d));
                return new b.Quaternion(-(+e * c), -(-e * a), -0, e * (1 + d));
              }
              return new b.Quaternion(1, 0, 0, 0);
            };
            var m = Sk.ffi.remapToJs(d), n = m.w, l = m.x, p = m.y, q = m.z, r = m.xy, v = m.yz, s = m.zx, m = m.xyz, e = Sk.ffi.remapToJs(a.grade0), n = Math.abs(n);
            e.scale.set(n, n, n);
            e = Sk.ffi.remapToJs(a.grade1);
            n = Math.sqrt(l * l + p * p + q * q);
            e.scale.set(n, n, n);
            e.quaternion = c(l / n, p / n, q / n);
            l = Sk.ffi.remapToJs(a.grade2);
            p = Math.sqrt(r * r + v * v + s * s);
            q = Math.pow(p, 0.5);
            l.scale.set(q, q, q);
            l.quaternion = c(v / p, s / p, r / p);
            c = Sk.ffi.remapToJs(a.grade3);
            r = Math.pow(Math.abs(m), 1 / 3);
            c.scale.set(r, r, r);
            a.quantity = d;
            break;
          default:
            throw Sk.ffi.err.attribute(c).isNotSetableOnType('ProbeE3');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ProbeE3');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ProbeE3');
        });
      }, 'ProbeE3', []);
      a.ProbeBuilderE3 = Sk.ffi.buildClass(a, function (b, e) {
        e.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('ProbeBuilderE3', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'ProbeBuilderE3', void 0, a);
        });
        e.__getattr__ = Sk.ffi.functionPy(function (b, d) {
          var e = Sk.ffi.remapToJs(b);
          switch (d) {
          case 'color':
            return Sk.ffi.callableToPy(a, d, function (a, l) {
              Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
              Sk.ffi.checkArgType(d, c, Sk.ffi.isNum(l) || Sk.ffi.isStr(l) || Sk.ffi.isInstance(l, 'Color'), l);
              e.color = l;
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, d, function (b) {
              b = [
                'SphereBuilder',
                'ArrowBuilder',
                'VortexBuilder',
                'CubeBuilder'
              ].map(function (b) {
                b = Sk.ffi.callsim(a[b]);
                e.color && Sk.ffi.callsim(Sk.ffi.gattr(b, 'color'), e.color);
                return Sk.ffi.callsim(Sk.ffi.gattr(b, 'build'));
              });
              return Sk.ffi.callsim(a.ProbeE3, b[0], b[1], b[2], b[3]);
            });
          default:
            throw Sk.ffi.err.attribute(d).isNotGetableOnType('ProbeBuilderE3');
          }
        });
        e.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('ProbeBuilderE3');
          }
        });
        e.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ProbeBuilderE3');
        });
        e.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ProbeBuilderE3');
        });
      }, 'ProbeBuilderE3', []);
    };
  }.call(this));
  Sk.builtin.buildWindowClass = function (a) {
    var b = {};
    return Sk.misceval.buildClass(a, function (c, d) {
      d.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(window, 'Window', void 0, a);
      });
      d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
        switch (d) {
        case 'animationTime':
          return Sk.ffi.numberToFloatPy(window.animationTime);
        case 'document':
          return a.document;
        case 'innerHeight':
          return Sk.ffi.numberToIntPy(window.innerHeight);
        case 'innerWidth':
          return Sk.ffi.numberToIntPy(window.innerWidth);
        case 'devicePixelRatio':
          return Sk.ffi.numberToIntPy(window.devicePixelRatio);
        case 'addEventListener':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (c, d) {
            d.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'addEventListener';
            });
            d.__call__ = Sk.ffi.functionPy(function (c, d, e, f) {
              c = Sk.ffi.remapToJs(d);
              d = function (b) {
                b = Sk.misceval.callsim(a.Event, Sk.ffi.referenceToPy(b, 'Event'));
                Sk.misceval.callsim(e, b);
              };
              b[c] = d;
              window.addEventListener(c, d, f);
            });
          }, 'addEventListener', []));
        case 'alert':
          return Sk.ffi.callableToPy(a, 'alert', function (a, b) {
            Sk.ffi.checkMethodArgs('alert', arguments, 0, 1);
            window.alert(Sk.ffi.remapToJs(b));
          });
        case 'removeEventListener':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (a, c) {
            c.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'removeEventListener';
            });
            c.__call__ = Sk.ffi.functionPy(function (a, c, d, e) {
              a = Sk.ffi.remapToJs(c);
              d = b[a];
              delete b[a];
              window.removeEventListener(a, d, e);
            });
          }, 'removeEventListener', []));
        case 'cancelAnimationFrame':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'cancelAnimationFrame';
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b) {
              b && window.cancelAnimationFrame(Sk.ffi.remapToJs(b));
            });
          }, 'cancelAnimationFrame', []));
        case 'confirm':
          return Sk.ffi.callableToPy(a, 'confirm', function (a, b) {
            Sk.ffi.checkMethodArgs('confirm', arguments, 0, 1);
            return Sk.ffi.remapToPy(window.confirm(Sk.ffi.remapToJs(b)));
          });
        case 'prompt':
          return Sk.ffi.callableToPy(a, 'prompt', function (a, b, c) {
            Sk.ffi.checkMethodArgs('prompt', arguments, 0, 2);
            return Sk.ffi.remapToPy(window.prompt(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c)));
          });
        case 'requestAnimationFrame':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'requestAnimationFrame';
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b) {
              var c = window.requestAnimationFrame(function (a) {
                  Sk.misceval.callsim(b, Sk.ffi.numberToFloatPy(a));
                });
              return Sk.ffi.numberToFloatPy(c);
            });
          }, 'requestAnimationFrame', []));
        case 'setTimeout':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'setTimeout';
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b, c, d) {
              a = Sk.ffi.remapToJs(c);
              d = Sk.ffi.remapToJs(d);
              d = window.setTimeout(function () {
                Sk.misceval.callsim(b);
              }, a, d);
              return Sk.ffi.numberToFloatPy(d);
            });
          }, 'setTimeout', []));
        }
      });
      d.__str__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy('Window');
      });
      d.__repr__ = Sk.ffi.functionPy(function (a, b) {
        return Sk.ffi.stringToPy('Window');
      });
    }, 'Window', []);
  };
  (function () {
    Sk.builtin.defineEuclidean2 = function (a, b) {
      function c(a) {
        return 'number' === typeof a;
      }
      function d(b, c, d, e) {
        return Sk.ffi.callsim(a.Euclidean2, Sk.ffi.numberToFloatPy(b), Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d), Sk.ffi.numberToFloatPy(e));
      }
      function e(a, b, c) {
        var d, e, f, g, h;
        f = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < f.length && f.push('+') : f.push('-');
            d = Math.abs(a);
            if (1 === d)
              return f.push(b);
            f.push(d.toString());
            if ('1' !== b)
              return f.push(c), f.push(b);
          }
        };
        e = g = 0;
        for (h = a.length - 1; 0 <= h ? g <= h : g >= h; e = 0 <= h ? ++g : --g)
          d(a[e], b[e]);
        return 0 < f.length ? f.join('') : '0';
      }
      function f(a, b, c, e, f, g, h, k, z) {
        var y = +f, C = +g, t = +h, B = -k, G = +(f * y + g * C + h * t - k * B), H = y * G + -0 * C + -0 * t - -0 * B, I = -0 * y + C * G - -0 * t + -0 * B, J = -0 * y + -0 * C + t * G - -0 * B, y = -0 * y + -0 * C - -0 * t + B * G;
        f = f * H + g * I + h * J - k * y;
        H /= f;
        I /= f;
        J /= f;
        k = y / f;
        f = a * H + b * I + c * J - e * k;
        g = a * I + b * H - c * k + e * J;
        h = a * J + b * k + c * H - e * I;
        a = a * k + b * J - c * I + e * H;
        if ('undefined' !== typeof z)
          z.w = f, z.x = g, z.y = h, z.xy = a;
        else
          return d(f, g, h, a);
      }
      Sk.ffi.checkFunctionArgs('defineEuclidean2', arguments, 2, 2);
      Sk.builtin.defineUnits(a, b);
      var g = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], h = [
          'Euclidean2',
          g
        ], k = [
          'Euclidean2',
          'Unit'
        ];
      a.ScalarE2 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('ScalarE2', arguments, 1, 1);
        Sk.ffi.checkArgType('w', g, Sk.ffi.isNum(a), a);
        return d(Sk.ffi.remapToJs(a), 0, 0, 0);
      });
      a.VectorE2 = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs('VectorE2', arguments, 2, 2);
        Sk.ffi.checkArgType('x', g, Sk.ffi.isNum(a), a);
        Sk.ffi.checkArgType('y', g, Sk.ffi.isNum(b), b);
        return d(0, Sk.ffi.remapToJs(a), Sk.ffi.remapToJs(b), 0);
      });
      a.PseudoscalarE2 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('PseudoscalarE2', arguments, 1, 1);
        Sk.ffi.checkArgType('xy', g, Sk.ffi.isNum(a), a);
        return d(0, 0, 0, Sk.ffi.remapToJs(a));
      });
      a.Euclidean2 = Sk.ffi.buildClass(a, function (l, m) {
        m.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.checkMethodArgs('Euclidean2', arguments, 1, 4);
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            Sk.ffi.checkMethodArgs('Euclidean2', arguments, 4, 4);
            Sk.ffi.checkArgType('w', g, Sk.ffi.isNum(c), c);
            Sk.ffi.checkArgType('x', g, Sk.ffi.isNum(d), d);
            Sk.ffi.checkArgType('y', g, Sk.ffi.isNum(e), e);
            Sk.ffi.checkArgType('xy', g, Sk.ffi.isNum(f), f);
            Sk.ffi.referenceToPy(new b.Euclidean2(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f)), 'Euclidean2', void 0, a);
            break;
          case Sk.ffi.PyType.INSTANCE:
            Sk.ffi.checkMethodArgs('Euclidean2', arguments, 1, 1);
            Sk.ffi.checkArgType('w', g, Sk.ffi.isInstance(c, 'Euclidean2'), c);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Euclidean2', void 0, a);
            break;
          default:
            Sk.ffi.checkArgType('w', g, !1, c);
          }
        });
        m.__add__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return d(c.w + e, c.x, c.y, c.xy);
          if (Sk.ffi.isInstance(b, 'Euclidean2'))
            return d(c.w + e.w, c.x + e.x, c.y + e.y, c.xy + e.xy);
          Sk.ffi.checkRhsOperandType('add', h, Sk.ffi.isNum(b), b);
        });
        m.__radd__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          return d(c + e.w, e.x, e.y, e.xy);
        });
        m.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return c.w += d, a;
          if (Sk.ffi.isInstance(b, 'Euclidean2'))
            return c.w += d.w, c.x += d.x, c.y += d.y, c.xy += d.xy, a;
          Sk.ffi.checkRhsOperandType('add', h, Sk.ffi.isNum(b), b);
        });
        m.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return d(c.w - e, c.x, c.y, c.xy);
          if (Sk.ffi.isInstance(b, 'Euclidean2'))
            return d(c.w - e.w, c.x - e.x, c.y - e.y, c.xy - e.xy);
          Sk.ffi.checkRhsOperandType('subtract', h, Sk.ffi.isNum(b), b);
        });
        m.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          return d(c - e.w, -e.x, -e.y, -e.xy);
        });
        m.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? d.w -= e : (d.w -= e.w, d.x -= e.x, d.y -= e.y, d.xy -= e.xy);
          return a;
        });
        m.__mul__ = Sk.ffi.functionPy(function (b, c) {
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(c)) {
            case 'Euclidean2':
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c), g = e.w, h = e.x, l = e.y, e = e.xy, m = f.w, C = f.x, t = f.y, f = f.xy;
              return d(g * m + h * C + l * t - e * f, g * C + h * m - l * f + e * t, g * t + h * f + l * m - e * C, g * f + h * t - l * C + e * m);
            case 'Unit':
              return Sk.ffi.callsim(a.Measure, b, c);
            default:
              Sk.ffi.checkLhsOperandType('multiply', k, !1, c);
            }
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            return e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c), d(e.w * f, e.x * f, e.y * f, e.xy * f);
          default:
            Sk.ffi.checkLhsOperandType('multiply', k, !1, c);
          }
        });
        m.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' * ' + JSON.stringify(a, null, 2));
        });
        m.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, B = e.y, e = e.xy;
            d.w = f * l + g * m + h * B - k * e;
            d.x = f * m + g * l - h * e + k * B;
            d.y = f * B + g * e + h * l - k * m;
            d.xy = f * e + g * B - h * m + k * l;
          }
          return a;
        });
        m.__div__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return c(b) ? f(a.w, a.x, a.y, a.xy, b, 0, 0, 0, void 0) : f(a.w, a.x, a.y, a.xy, b.w, b.x, b.y, b.xy, void 0);
        });
        m.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return f(b, 0, 0, 0, a.w, a.x, a.y, a.xy, void 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' / ' + JSON.stringify(a, null, 2));
        });
        m.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? f(d.w, d.x, d.y, d.xy, e, 0, 0, 0, d) : f(d.w, d.x, d.y, d.xy, e.w, e.x, e.y, e.xy, d);
          return a;
        });
        m.__xor__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, a.x * b, a.y * b, a.xy * b);
          var e = a.w, f = a.x, g = a.y, h = b.w, k = b.x, l = b.y;
          return d(e * h, e * k + f * h, e * l + g * h, e * b.xy + f * l - g * k + a.xy * h);
        });
        m.__rxor__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' ^ ' + JSON.stringify(a, null, 2));
        });
        m.__ixor__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, B = e.y, e = e.xy;
            d.w = f * l;
            d.x = f * m + g * l;
            d.y = f * B + h * l;
            d.xy = f * e + g * B - h * m + k * l;
          }
          return a;
        });
        m.__lshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, 0, 0, 0);
          var e = a.w, f = a.x, g = a.y, h = b.x, k = b.y, l = b.xy;
          return d(e * b.w + f * h + g * k - a.xy * l, e * h - g * l, e * k + f * l, e * l);
        });
        m.__rlshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' << ' + JSON.stringify(a, null, 2));
        });
        m.__ilshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x = 0, d.y = 0, d.xy = 0;
          else {
            var f = d.w, g = d.x, h = d.y, k = e.x, l = e.y, m = e.xy;
            d.w = f * e.w + g * k + h * l - d.xy * m;
            d.x = f * k - h * m;
            d.y = f * l + g * m;
            d.xy = f * m;
          }
          return a;
        });
        m.__rshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, -a.x * b, -a.y * b, a.xy * b);
          var e = a.x, f = a.y, g = a.xy, h = b.w, k = b.x, l = b.y;
          return d(a.w * h + e * k + f * l - g * b.xy, +e * h + g * l, +f * h - g * k, g * h);
        });
        m.__rrshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, 0, 0, 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' >> ' + JSON.stringify(a, null, 2));
        });
        m.__irshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e)) {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e, m = 0, B = 0, G = 0;
            d.w *= e;
            d.x *= -e;
            d.y *= -e;
            d.xy *= e;
          } else
            f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, B = e.y, G = e.xy, d.w = f * l + g * m + h * B - k * G, d.x = +g * l + k * B, d.y = +h * l - k * m, d.xy = k * l;
          return a;
        });
        m.nb$negative = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(-a.w, -a.x, -a.y, -a.xy);
        };
        m.nb$positive = function () {
          return this;
        };
        m.nb$invert = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(a.w, a.x, a.y, -a.xy);
        };
        m.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          switch (b) {
          case 0:
            return d(a.w, 0, 0, 0);
          case 1:
            return d(0, a.x, a.y, 0);
          case 2:
            return d(0, 0, 0, a.xy);
          }
        });
        m.__abs__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.sqrt(a.w * a.w + a.x * a.x + a.y * a.y - a.xy * a.xy));
        });
        m.__cliffordConjugate__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('cliffordConjugate', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return d(b.w, -b.x, -b.y, -b.xy);
        });
        m.__exp__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('exp', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a), c = Math.exp(b.w), e = Math.cos(b.xy), b = Math.sin(b.xy);
          return d(c * e, 0, 0, c * b);
        });
        m.__sqrt__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('sqrt', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return d(Math.sqrt(b.w), 0, 0, 0);
        });
        m.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Euclidean2(' + [
            a.w,
            a.x,
            a.y,
            a.xy
          ].map(function (a) {
            return String(a);
          }).join(', ') + ')');
        });
        m.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return a.isNaN() ? Sk.ffi.stringToPy('NaN') : Sk.ffi.stringToPy(e([
            a.w,
            a.x,
            a.y,
            a.xy
          ], [
            '1',
            'i',
            'j',
            'I'
          ], '*'));
        });
        m.__eq__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.w === b.w && a.x === b.x && a.y === b.y && a.xy === b.xy;
        });
        m.__ne__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.xy !== b.xy;
        });
        m.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'w':
            return Sk.ffi.numberToFloatPy(e.w);
          case 'x':
            return Sk.ffi.numberToFloatPy(e.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(e.y);
          case 'xy':
            return Sk.ffi.numberToFloatPy(e.xy);
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return d(e.w, e.x, e.y, e.xy);
              });
            }, 'clone', []));
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(Math.sqrt(e.w * e.w + e.x * e.x + e.y * e.y - e.xy * e.xy));
              });
            }, 'magnitude', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Euclidean2');
          }
        });
        m.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'w':
          case 'x':
          case 'y':
          case 'xy':
            Sk.ffi.checkArgType(b, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.LONG
            ], Sk.ffi.isNum(c), c);
            a[b] = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Euclidean2');
          }
        });
      }, 'Euclidean2', []);
      a.e1 = d(0, 1, 0, 0);
      a.e2 = d(0, 0, 1, 0);
      a.I = d(0, 0, 0, 1);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineEuclidean3 = function (a, b, c) {
      function d(a) {
        return 'number' === typeof a;
      }
      function e(b, c, d, e, f, g, h, k, l) {
        b = Sk.ffi.numberToFloatPy(b);
        c = Sk.ffi.numberToFloatPy(c);
        d = Sk.ffi.numberToFloatPy(d);
        e = Sk.ffi.numberToFloatPy(e);
        f = Sk.ffi.numberToFloatPy(f);
        g = Sk.ffi.numberToFloatPy(g);
        h = Sk.ffi.numberToFloatPy(h);
        k = Sk.ffi.numberToFloatPy(k);
        l = Sk.ffi.booleanToPy(l);
        return Sk.ffi.callsim(a.Euclidean3, b, c, d, e, f, g, h, k, l);
      }
      function f(a, b) {
        var c, d, e, f, g;
        e = [];
        c = function (a, b) {
          var c;
          if (0 !== a) {
            0 <= a ? 0 < e.length && e.push('+') : e.push('-');
            c = Math.abs(a);
            if (1 === c)
              return e.push(b);
            e.push(c.toString());
            if ('1' !== b)
              return e.push('*'), e.push(b);
          }
        };
        d = f = 0;
        for (g = a.length - 1; 0 <= g ? f <= g : f >= g; d = 0 <= g ? ++f : --f)
          c(a[d], b[d]);
        return 0 < e.length ? e.join('') : '0';
      }
      function g(a, b, c, d, e, f, g, h, k, l, n, m, p, q, r, w, A) {
        a = +a;
        b = +b;
        c = +c;
        d = +d;
        e = +e;
        f = +f;
        g = +g;
        h = +h;
        k = +k;
        l = +l;
        n = +n;
        m = +m;
        p = +p;
        q = +q;
        r = +r;
        w = +w;
        var u = 0;
        switch (~~(A | 0)) {
        case 0:
          u = +(a * k + b * l + c * n + d * m - e * p - f * q - g * r - h * w);
          break;
        case 1:
          u = +(a * l + b * k - c * p + d * r + e * n - f * w - g * m - h * q);
          break;
        case 2:
          u = +(a * n + b * p + c * k - d * q - e * l + f * m - g * w - h * r);
          break;
        case 3:
          u = +(a * m - b * r + c * q + d * k - e * w - f * n + g * l - h * p);
          break;
        case 4:
          u = +(a * p + b * n - c * l + d * w + e * k - f * r + g * q + h * m);
          break;
        case 5:
          u = +(a * q + b * w + c * m - d * n + e * r + f * k - g * p + h * l);
          break;
        case 6:
          u = +(a * r - b * m + c * w + d * l - e * q + f * p + g * k + h * n);
          break;
        case 7:
          u = +(a * w + b * q + c * r + d * p + e * m + f * l + g * n + h * k);
        }
        return +u;
      }
      function h(a, b, c, d, e, f, g, h, k, l, n, m, p, q, r, w, A) {
        a = +a;
        b = +b;
        c = +c;
        d = +d;
        e = +e;
        f = +f;
        g = +g;
        k = +k;
        l = +l;
        n = +n;
        m = +m;
        p = +p;
        q = +q;
        r = +r;
        var u = 0;
        switch (~~(A | 0)) {
        case 0:
          u = +(a * k);
          break;
        case 1:
          u = +(a * l + b * k);
          break;
        case 2:
          u = +(a * n + c * k);
          break;
        case 3:
          u = +(a * m + d * k);
          break;
        case 4:
          u = +(a * p + b * n - c * l + e * k);
          break;
        case 5:
          u = +(a * q + c * m - d * n + f * k);
          break;
        case 6:
          u = +(a * r - b * m + d * l + g * k);
          break;
        case 7:
          u = +(a * +w + b * q + c * r + d * p + e * m + f * l + g * n + +h * k);
        }
        return +u;
      }
      function k(a, b, c, d, e, f, g, h, k, l, n, m, p, q, r, w, A) {
        a = +a;
        b = +b;
        c = +c;
        d = +d;
        e = +e;
        f = +f;
        g = +g;
        l = +l;
        n = +n;
        m = +m;
        p = +p;
        q = +q;
        r = +r;
        w = +w;
        var u = 0;
        switch (~~(A | 0)) {
        case 0:
          u = +(a * +k + b * l + c * n + d * m - e * p - f * q - g * r - +h * w);
          break;
        case 1:
          u = +(a * l - c * p + d * r - f * w);
          break;
        case 2:
          u = +(a * n + b * p - d * q - g * w);
          break;
        case 3:
          u = +(a * m - b * r + c * q - e * w);
          break;
        case 4:
          u = +(a * p + d * w);
          break;
        case 5:
          u = +(a * q + b * w);
          break;
        case 6:
          u = +(a * r + c * w);
          break;
        case 7:
          u = +(a * w);
        }
        return +u;
      }
      function l(a, b, c, d, e, f, g, h, k, l, n, m, p, q, r, w, A) {
        b = +b;
        c = +c;
        d = +d;
        e = +e;
        f = +f;
        g = +g;
        h = +h;
        k = +k;
        l = +l;
        n = +n;
        m = +m;
        p = +p;
        q = +q;
        r = +r;
        var u = 0;
        switch (~~(A | 0)) {
        case 0:
          u = +(+a * k + b * l + c * n + d * m - e * p - f * q - g * r - h * +w);
          break;
        case 1:
          u = +(+b * k + e * n - g * m - h * q);
          break;
        case 2:
          u = +(+c * k - e * l + f * m - h * r);
          break;
        case 3:
          u = +(+d * k - f * n + g * l - h * p);
          break;
        case 4:
          u = +(+e * k + h * m);
          break;
        case 5:
          u = +(+f * k + h * l);
          break;
        case 6:
          u = +(+g * k + h * n);
          break;
        case 7:
          u = +(+h * k);
        }
        return +u;
      }
      function m(a, b, c, d, f, h, k, l, n, m, p, q, r, x, N, w, A) {
        var u = +n, D = +m, E = +p, F = -q, L = +r, O = -x, P = -N, Q = -w, Y = g(n, m, p, r, q, N, -x, w, u, D, E, L, F, P, -O, Q, 0), R = g(n, m, p, r, q, N, -x, w, u, D, E, L, F, P, -O, Q, 1), S = g(n, m, p, r, q, N, -x, w, u, D, E, L, F, P, -O, Q, 2), T = g(n, m, p, r, q, N, -x, w, u, D, E, L, F, P, -O, Q, 3), U = +Y, V = -R, W = -S, X = -T, Z = g(u, D, E, L, F, P, -O, Q, U, V, W, X, -0, -0, 0, 0, 0), $ = g(u, D, E, L, F, P, -O, Q, U, V, W, X, -0, -0, 0, 0, 1), aa = g(u, D, E, L, F, P, -O, Q, U, V, W, X, -0, -0, 0, 0, 2), Y = g(u, D, E, L, F, P, -O, Q, U, V, W, X, -0, -0, 0, 0, 4), R = g(u, D, E, L, F, P, -O, Q, U, V, W, X, -0, -0, 0, 0, 3), S = -g(u, D, E, L, F, P, -O, Q, U, V, W, X, -0, -0, 0, 0, 6), T = g(u, D, E, L, F, P, -O, Q, U, V, W, X, -0, -0, 0, 0, 5), u = g(u, D, E, L, F, P, -O, Q, U, V, W, X, -0, -0, 0, 0, 7);
        r = g(n, m, p, r, q, N, -x, w, Z, $, aa, R, Y, T, -S, u, 0);
        n = Z / r;
        m = $ / r;
        p = aa / r;
        q = Y / r;
        R /= r;
        S /= r;
        T /= r;
        E = u / r;
        r = g(a, b, c, f, d, k, -h, l, n, m, p, R, q, T, -S, E, 0);
        x = g(a, b, c, f, d, k, -h, l, n, m, p, R, q, T, -S, E, 1);
        N = g(a, b, c, f, d, k, -h, l, n, m, p, R, q, T, -S, E, 2);
        w = g(a, b, c, f, d, k, -h, l, n, m, p, R, q, T, -S, E, 4);
        Y = g(a, b, c, f, d, k, -h, l, n, m, p, R, q, T, -S, E, 3);
        D = -g(a, b, c, f, d, k, -h, l, n, m, p, R, q, T, -S, E, 6);
        u = g(a, b, c, f, d, k, -h, l, n, m, p, R, q, T, -S, E, 5);
        a = g(a, b, c, f, d, k, -h, l, n, m, p, R, q, T, -S, E, 7);
        b = -D;
        if ('undefined' !== typeof A)
          A.w = r, A.x = x, A.y = N, A.z = Y, A.xy = w, A.yz = u, A.zx = b, A.xyz = a;
        else
          return e(r, x, N, Y, w, u, b, a);
      }
      function n(a, b) {
        switch (b) {
        case 0:
          return a.w;
        case 1:
          return a.x;
        case 2:
          return a.y;
        case 3:
          return a.z;
        case 4:
          return a.xy;
        case 5:
          return a.yz;
        case 6:
          return a.zx;
        case 7:
          return a.xyz;
        default:
          throw Sk.ffi.assertionError('' + b + ' is not a valid multivector coordinate index');
        }
      }
      function p(a, b, c, d, e) {
        var f, g, h, k, l, n, m, p, q, r, w, A, u, D, E, F, L, O, P, Q;
        d = b.quaternion.w;
        f = b.vector.x;
        g = b.vector.y;
        h = b.vector.z;
        k = -b.quaternion.z;
        l = -b.quaternion.x;
        n = -b.quaternion.y;
        b = b.xyz;
        m = c.quaternion.w;
        p = c.vector.x;
        q = c.vector.y;
        r = c.vector.z;
        w = -c.quaternion.z;
        A = -c.quaternion.x;
        u = -c.quaternion.y;
        D = c.xyz;
        c = a(d, f, g, h, k, l, n, b, m, p, q, r, w, A, u, D, 0);
        E = a(d, f, g, h, k, l, n, b, m, p, q, r, w, A, u, D, 1);
        F = a(d, f, g, h, k, l, n, b, m, p, q, r, w, A, u, D, 2);
        L = a(d, f, g, h, k, l, n, b, m, p, q, r, w, A, u, D, 3);
        O = a(d, f, g, h, k, l, n, b, m, p, q, r, w, A, u, D, 4);
        P = a(d, f, g, h, k, l, n, b, m, p, q, r, w, A, u, D, 5);
        Q = a(d, f, g, h, k, l, n, b, m, p, q, r, w, A, u, D, 6);
        a = a(d, f, g, h, k, l, n, b, m, p, q, r, w, A, u, D, 7);
        return e(c, E, F, L, O, P, Q, a);
      }
      Sk.ffi.checkFunctionArgs('defineEuclidean3', arguments, 3, 3);
      Sk.builtin.defineVector3(a, b);
      Sk.builtin.defineQuaternion(a, b);
      Sk.builtin.defineUnits(a, c);
      var q = Sk.ffi.PyType.INT, r = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      b.Euclidean3 = function (a, b, c, d) {
        if ('object' !== typeof a)
          throw Error('43a75b65-8614-4836-9829-377eaeee7cfe');
        if ('object' !== typeof b)
          throw Error('89fb1d18-dc26-4149-913d-58f192c161d7');
        if ('number' !== typeof c)
          throw Error('09e5e46b-fdf4-4720-9262-5c2503c84dc6');
        this.vector = a;
        this.quaternion = b;
        this._pseudo = c;
        this._mutable = 'boolean' === typeof d ? d : !0;
      };
      b.Euclidean3.prototype = {
        constructor: b.Euclidean3,
        get w() {
          return this.quaternion.w;
        },
        set w(a) {
          this.checkMutable();
          this.quaternion.w = a;
        },
        get x() {
          return this.vector.x;
        },
        set x(a) {
          this.checkMutable();
          this.vector.x = a;
        },
        get y() {
          return this.vector.y;
        },
        set y(a) {
          this.checkMutable();
          this.vector.y = a;
        },
        get z() {
          return this.vector.z;
        },
        set z(a) {
          this.checkMutable();
          this.vector.z = a;
        },
        get xy() {
          return -this.quaternion.z;
        },
        set xy(a) {
          this.checkMutable();
          this.quaternion.z = -a;
        },
        get yz() {
          return -this.quaternion.x;
        },
        set yz(a) {
          this.checkMutable();
          this.quaternion.x = -a;
        },
        get zx() {
          return -this.quaternion.y;
        },
        set zx(a) {
          this.checkMutable();
          this.quaternion.y = -a;
        },
        get xyz() {
          return this._pseudo;
        },
        set xyz(a) {
          this.checkMutable();
          this._pseudo = a;
        },
        get mutable() {
          return this._mutable;
        },
        set mutable(a) {
          this._mutable = a;
        },
        checkMutable: function () {
          if (!this._mutable)
            throw Sk.ffi.assertionError('Quantity is not mutable');
        }
      };
      a.ScalarE3 = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs('ScalarE3', arguments, 1, 2);
        Sk.ffi.checkArgType('w', r, Sk.ffi.isNum(a), a);
        Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(b), b);
        return e(Sk.ffi.numberToJs(a), 0, 0, 0, 0, 0, 0, 0, Sk.ffi.remapToJs(b));
      });
      a.VectorE3 = Sk.ffi.functionPy(function (a, b, c, d) {
        Sk.ffi.checkFunctionArgs('VectorE3', arguments, 3, 4);
        Sk.ffi.checkArgType('x', r, Sk.ffi.isNum(a), a);
        Sk.ffi.checkArgType('y', r, Sk.ffi.isNum(b), b);
        Sk.ffi.checkArgType('z', r, Sk.ffi.isNum(c), c);
        Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
        a = Sk.ffi.numberToJs(a);
        b = Sk.ffi.numberToJs(b);
        c = Sk.ffi.numberToJs(c);
        return e(0, a, b, c, 0, 0, 0, 0, Sk.ffi.remapToJs(d));
      });
      a.BivectorE3 = Sk.ffi.functionPy(function (a, b, c, d) {
        Sk.ffi.checkFunctionArgs('BivectorE3', arguments, 3, 4);
        Sk.ffi.checkArgType('xy', r, Sk.ffi.isNum(a), a);
        Sk.ffi.checkArgType('yz', r, Sk.ffi.isNum(b), b);
        Sk.ffi.checkArgType('zx', r, Sk.ffi.isNum(c), c);
        Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
        a = Sk.ffi.numberToJs(a);
        b = Sk.ffi.numberToJs(b);
        c = Sk.ffi.numberToJs(c);
        return e(0, 0, 0, 0, a, b, c, 0, Sk.ffi.remapToJs(d));
      });
      a.PseudoscalarE3 = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs('PseudoscalarE3', arguments, 1, 2);
        Sk.ffi.checkArgType('xyz', r, Sk.ffi.isNum(a), a);
        Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(b), b);
        a = Sk.ffi.numberToJs(a);
        return e(0, 0, 0, 0, 0, 0, 0, a, Sk.ffi.remapToJs(b));
      });
      a.Euclidean3 = Sk.ffi.buildClass(a, function (v, s) {
        s.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f, g, h, k, l, n) {
          Sk.ffi.checkMethodArgs('Euclidean3', arguments, 1, 9);
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            Sk.ffi.checkMethodArgs('Euclidean3', arguments, 8, 9);
            Sk.ffi.checkArgType('w', r, Sk.ffi.isNum(c), c);
            Sk.ffi.checkArgType('x', r, Sk.ffi.isNum(d), d);
            Sk.ffi.checkArgType('y', r, Sk.ffi.isNum(e), e);
            Sk.ffi.checkArgType('z', r, Sk.ffi.isNum(f), f);
            Sk.ffi.checkArgType('xy', r, Sk.ffi.isNum(g), g);
            Sk.ffi.checkArgType('yz', r, Sk.ffi.isNum(h), h);
            Sk.ffi.checkArgType('zx', r, Sk.ffi.isNum(k), k);
            Sk.ffi.checkArgType('xyz', r, Sk.ffi.isNum(l), l);
            Sk.ffi.isDefined(n) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(n), n);
            c = Sk.ffi.remapToJs(c);
            d = Sk.ffi.remapToJs(d);
            e = Sk.ffi.remapToJs(e);
            f = Sk.ffi.remapToJs(f);
            g = Sk.ffi.remapToJs(g);
            h = Sk.ffi.remapToJs(h);
            k = Sk.ffi.remapToJs(k);
            l = Sk.ffi.remapToJs(l);
            var m = Sk.ffi.remapToJs(n, !0), p = new b.Vector3(d, e, f), q = new b.Quaternion(-h, -k, -g, c);
            Sk.ffi.referenceToPy(new b.Euclidean3(p, q, l, m), 'Euclidean3', void 0, a);
            break;
          case Sk.ffi.PyType.INSTANCE:
            Sk.ffi.checkMethodArgs('Euclidean3', arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Euclidean3', void 0, a);
            break;
          default:
            throw new Sk.builtin.AssertionError('09eaed05-6d9d-4ded-a499-e4c480a9ed68, getType(w) => ' + Sk.ffi.getType(c));
          }
        });
        s.__add__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, f = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return e(f.w + g, d.x, d.y, d.z, -f.z, -f.x, -f.y, c.xyz);
          if (Sk.ffi.isInstance(b, 'Euclidean3'))
            return e(f.w + g.quaternion.w, d.x + g.vector.x, d.y + g.vector.y, d.z + g.vector.z, -(f.z + g.quaternion.z), -(f.x + g.quaternion.x), -(f.y + g.quaternion.y), c.xyz + g.xyz);
          throw Sk.ffi.err.operand('other').toOperation('add').mustHaveType([
            r,
            'Euclidean3'
          ]);
        });
        s.__radd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), f = d.vector, g = d.quaternion;
          if (Sk.ffi.isNum(b))
            return e(c + g.w, f.x, f.y, f.z, -g.z, -g.x, -g.y, d.xyz);
          throw Sk.ffi.err.operand('other').toOperation('add').mustHaveType([
            r,
            'Euclidean3'
          ]);
        });
        s.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, f = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            e.w += f;
          else if (Sk.ffi.isInstance(b, 'Euclidean3')) {
            var g = f.vector, h = f.quaternion;
            e.w += h.w;
            d.x += g.x;
            d.y += g.y;
            d.z += g.z;
            e.z += h.z;
            e.x += h.x;
            e.y += h.y;
            c.xyz += f.xyz;
          } else
            throw Sk.ffi.err.operand('other').toOperation('add').mustHaveType([
              r,
              'Euclidean3'
            ]);
          return a;
        });
        s.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, f = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return e(f.w - g, d.x, d.y, d.z, -f.z, -f.x, -f.y, c.xyz);
          if (Sk.ffi.isInstance(b, 'Euclidean3')) {
            var h = g.vector, k = g.quaternion;
            return e(f.w - k.w, d.x - h.x, d.y - h.y, d.z - h.z, -(f.z - k.z), -(f.x - k.x), -(f.y - k.y), c.xyz - g.xyz);
          }
          throw Sk.ffi.err.operand('other').toOperation('subtract').mustHaveType([
            r,
            'Euclidean3'
          ]);
        });
        s.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), f = d.vector, g = d.quaternion;
          if (Sk.ffi.isNum(b))
            return e(c - g.w, -f.x, -f.y, -f.z, g.z, g.x, g.y, -d.xyz);
          throw Sk.ffi.err.operand('other').toOperation('subtract').mustHaveType([
            r,
            'Euclidean3'
          ]);
        });
        s.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, f = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            e.w -= f;
          else if (Sk.ffi.isInstance(b, 'Euclidean3')) {
            var g = f.vector, h = f.quaternion;
            e.w -= h.w;
            d.x -= g.x;
            d.y -= g.y;
            d.z -= g.z;
            e.z -= h.z;
            e.x -= h.x;
            e.y -= h.y;
            c.xyz -= f.xyz;
          } else
            throw Sk.ffi.err.operand('other').toOperation('subtract').mustHaveType([
              r,
              'Euclidean3'
            ]);
          return a;
        });
        s.__mul__ = Sk.ffi.functionPy(function (b, c) {
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(c)) {
            case 'Euclidean3':
              var d = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              return p(g, d, f, n, e);
            case 'Unit':
              return Sk.ffi.callsim(a.Measure, b, c);
            default:
              throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
                r,
                'Euclidean3',
                'Unit'
              ]);
            }
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            var d = Sk.ffi.remapToJs(b), f = d.vector, h = d.quaternion, k = Sk.ffi.remapToJs(c);
            return e(h.w * k, f.x * k, f.y * k, f.z * k, -h.z * k, -h.x * k, -h.y * k, d.xyz * k);
          default:
            throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
              r,
              'Euclidean3',
              'Unit'
            ]);
          }
        });
        s.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), f = d.vector, g = d.quaternion;
          if (Sk.ffi.isNum(b))
            return e(c * g.w, c * f.x, c * f.y, c * f.z, -c * g.z, -c * g.x, -c * g.y, c * d.xyz);
          throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
            r,
            'Euclidean3',
            'Unit'
          ]);
        });
        s.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, h = c.x, k = c.y, l = c.z, n = c.xy, m = c.yz, p = c.zx, q = c.xyz, r, w, A, u, D, E, F;
          d(e) ? (r = e, e = F = E = D = u = A = w = 0) : (r = e.w, w = e.x, A = e.y, u = e.z, D = e.xy, E = e.yz, F = e.zx, e = e.xyz);
          c.w = g(f, h, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 0);
          c.x = g(f, h, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 1);
          c.y = g(f, h, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 2);
          c.z = g(f, h, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 3);
          c.xy = g(f, h, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 4);
          c.yz = g(f, h, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 5);
          c.zx = g(f, h, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 6);
          c.xyz = g(f, h, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 7);
          return a;
        });
        s.__div__ = Sk.ffi.functionPy(function (b, d) {
          switch (Sk.ffi.getType(d)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(d)) {
            case 'Euclidean3':
              var e = Sk.ffi.remapToJs(b), f = e.vector, g = e.quaternion, h = Sk.ffi.remapToJs(d), k = h.vector, l = h.quaternion;
              return m(g.w, f.x, f.y, -g.z, f.z, g.y, -g.x, e.xyz, l.w, k.x, k.y, -l.z, k.z, l.y, -l.x, h.xyz, void 0);
            case 'Unit':
              return e = Sk.ffi.remapToJs(d), f = new c.Rational(0, 1), f = new c.Unit(1, new c.Dimensions(f, f, f, f), e.labels), Sk.ffi.callsim(a.Measure, b, Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(f.div(e), 'Unit')));
            default:
              throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
                r,
                'Euclidean3',
                'Unit'
              ]);
            }
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            return e = Sk.ffi.remapToJs(b), f = e.vector, g = e.quaternion, h = Sk.ffi.remapToJs(d), m(g.w, f.x, f.y, -g.z, f.z, g.y, -g.x, e.xyz, h, 0, 0, 0, 0, 0, 0, 0, void 0);
          default:
            throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
              r,
              'Euclidean3',
              'Unit'
            ]);
          }
        });
        s.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return m(b, 0, 0, 0, 0, 0, 0, 0, a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, void 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' / ' + JSON.stringify(a, null, 2));
        });
        s.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          d(e) ? m(c.w, c.x, c.y, c.xy, c.z, -c.zx, c.yz, c.xyz, e, 0, 0, 0, 0, 0, 0, 0, c) : m(c.w, c.x, c.y, c.xy, c.z, -c.zx, c.yz, c.xyz, e.w, e.x, e.y, e.xy, e.z, -e.zx, e.yz, e.xyz, c);
          return a;
        });
        s.__mod__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          return Sk.ffi.numberToFloatPy(c.x * d.x + c.y * d.y + c.z * d.z);
        });
        s.__xor__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return d(b) ? e(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b) : p(h, a, b, n, e);
        });
        s.__rxor__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return e(b * a.w, b * a.x, b * a.y, b * a.z, b * a.xy, b * a.yz, b * a.zx, b * a.xyz);
          throw new Sk.builtin.AssertionError();
        });
        s.__ixor__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, k = c.y, l = c.z, n = c.xy, m = c.yz, p = c.zx, q = c.xyz, r, w, A, u, D, E, F;
          d(e) ? (r = e, e = F = E = D = u = A = w = 0) : (r = e.w, w = e.x, A = e.y, u = e.z, D = e.xy, E = e.yz, F = e.zx, e = e.xyz);
          c.w = h(f, g, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 0);
          c.x = h(f, g, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 1);
          c.y = h(f, g, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 2);
          c.z = h(f, g, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 3);
          c.xy = h(f, g, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 4);
          c.yz = h(f, g, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 5);
          c.zx = h(f, g, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 6);
          c.xyz = h(f, g, k, l, n, m, p, q, r, w, A, u, D, E, F, e, 7);
          return a;
        });
        s.__lshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return d(b) ? e(a.w * b, 0, 0, 0, 0, 0, 0, 0) : p(k, a, b, n, e);
        });
        s.__rlshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return e(b * a.w, b * a.x, b * a.y, b * a.z, b * a.xy, b * a.yz, b * a.zx, b * a.xyz);
          throw new Sk.builtin.AssertionError();
        });
        s.__ilshift__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, h = c.y, l = c.z, n = c.xy, m = c.yz, p = c.zx, q = c.xyz, r, w, A, u, D, E, F;
          d(e) ? (r = e, e = F = E = D = u = A = w = 0) : (r = e.w, w = e.x, A = e.y, u = e.z, D = e.xy, E = e.yz, F = e.zx, e = e.xyz);
          c.w = k(f, g, h, l, n, m, p, q, r, w, A, u, D, E, F, e, 0);
          c.x = k(f, g, h, l, n, m, p, q, r, w, A, u, D, E, F, e, 1);
          c.y = k(f, g, h, l, n, m, p, q, r, w, A, u, D, E, F, e, 2);
          c.z = k(f, g, h, l, n, m, p, q, r, w, A, u, D, E, F, e, 3);
          c.xy = k(f, g, h, l, n, m, p, q, r, w, A, u, D, E, F, e, 4);
          c.yz = k(f, g, h, l, n, m, p, q, r, w, A, u, D, E, F, e, 5);
          c.zx = k(f, g, h, l, n, m, p, q, r, w, A, u, D, E, F, e, 6);
          c.xyz = k(f, g, h, l, n, m, p, q, r, w, A, u, D, E, F, e, 7);
          return a;
        });
        s.__rshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return d(b) ? e(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b) : p(l, a, b, n, e);
        });
        s.__rrshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return e(b * a.w, 0, 0, 0, 0, 0, 0, 0);
          throw new Sk.builtin.AssertionError();
        });
        s.__irshift__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, h = c.y, k = c.z, n = c.xy, m = c.yz, p = c.zx, q = c.xyz, r, w, A, u, D, E, F;
          d(e) ? (r = e, e = F = E = D = u = A = w = 0) : (r = e.w, w = e.x, A = e.y, u = e.z, D = e.xy, E = e.yz, F = e.zx, e = e.xyz);
          c.w = l(f, g, h, k, n, m, p, q, r, w, A, u, D, E, F, e, 0);
          c.x = l(f, g, h, k, n, m, p, q, r, w, A, u, D, E, F, e, 1);
          c.y = l(f, g, h, k, n, m, p, q, r, w, A, u, D, E, F, e, 2);
          c.z = l(f, g, h, k, n, m, p, q, r, w, A, u, D, E, F, e, 3);
          c.xy = l(f, g, h, k, n, m, p, q, r, w, A, u, D, E, F, e, 4);
          c.yz = l(f, g, h, k, n, m, p, q, r, w, A, u, D, E, F, e, 5);
          c.zx = l(f, g, h, k, n, m, p, q, r, w, A, u, D, E, F, e, 6);
          c.xyz = l(f, g, h, k, n, m, p, q, r, w, A, u, D, E, F, e, 7);
          return a;
        });
        s.__len__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.numberToFloatPy(8);
        });
        s.__pos__ = Sk.ffi.functionPy(function (a) {
          return a;
        });
        s.__neg__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.vector, c = a.quaternion;
          return e(-c.w, -b.x, -b.y, -b.z, c.z, c.x, c.y, -a.xyz);
        });
        s.__invert__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.vector, c = a.quaternion;
          return e(c.w, b.x, b.y, b.z, c.z, c.x, c.y, -a.xyz);
        });
        s.__eq__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, 'Euclidean3')) {
            var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, f = Sk.ffi.remapToJs(b), g = f.quaternion;
            return d.equals(f.vector) && e.equals(g) && c.xyz === f.xyz;
          }
          return Sk.ffi.bool.False;
        });
        s.__ne__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, 'Euclidean3')) {
            var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, f = Sk.ffi.remapToJs(b), g = f.quaternion;
            return !d.equals(f.vector) || !e.equals(g) || c.xyz !== f.xyz;
          }
          return Sk.ffi.bool.True;
        });
        s.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          Sk.ffi.checkArgType('index', q, Sk.ffi.isInt(b), b);
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), f = d.vector, g = d.quaternion;
          switch (c) {
          case 0:
            return e(g.w, 0, 0, 0, 0, 0, 0, 0);
          case 1:
            return e(0, f.x, f.y, f.z, 0, 0, 0, 0);
          case 2:
            return e(0, 0, 0, 0, -g.z, -g.x, -g.y, 0);
          case 3:
            return e(0, 0, 0, 0, 0, 0, 0, d.xyz);
          }
        });
        s.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), f = d.vector, g = d.quaternion;
          switch (c) {
          case 'w':
            return Sk.ffi.numberToFloatPy(d.w);
          case 'x':
            return Sk.ffi.numberToFloatPy(d.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(d.y);
          case 'z':
            return Sk.ffi.numberToFloatPy(d.z);
          case 'xy':
            return Sk.ffi.numberToFloatPy(d.xy);
          case 'yz':
            return Sk.ffi.numberToFloatPy(d.yz);
          case 'zx':
            return Sk.ffi.numberToFloatPy(d.zx);
          case 'xyz':
            return Sk.ffi.numberToFloatPy(d.xyz);
          case 'mutable':
            return Sk.ffi.booleanToPy(d.mutable);
          case 'vector':
            return Sk.ffi.callsim(a.Vector3, Sk.ffi.referenceToPy(d.vector, 'Vector3'));
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'add':
            return Sk.ffi.callableToPy(a, 'add', function (a, c) {
              Sk.ffi.checkMethodArgs('add', arguments, 1, 1);
              Sk.ffi.checkArgType('other', 'Euclidean3', Sk.ffi.isInstance(c, 'Euclidean3'), c);
              var e = Sk.ffi.remapToJs(c);
              g.w += e.quaternion.w;
              f.x += e.vector.x;
              f.y += e.vector.y;
              f.z += e.vector.z;
              g.x += e.quaternion.x;
              g.y += e.quaternion.y;
              g.z += e.quaternion.z;
              d.xyz += e.xyz;
              return b;
            });
          case 'constantify':
            return Sk.ffi.callableToPy(a, 'constantify', function (a) {
              Sk.ffi.checkMethodArgs('constantify', arguments, 0, 0);
              d.mutable = !1;
              return b;
            });
          case 'cross':
            return Sk.ffi.callableToPy(a, 'cross', function (a, b) {
              Sk.ffi.checkMethodArgs('cross', arguments, 1, 1);
              Sk.ffi.checkArgType('other', 'Euclidean3', Sk.ffi.isInstance(b, 'Euclidean3'), b);
              var c = Sk.ffi.remapToJs(b), f = d.x, g = d.y, h = d.z, k = c.x, l = c.y, c = c.z;
              return e(0, g * c - h * l, h * k - f * c, f * l - g * k, 0, 0, 0, 0);
            });
          case 'dot':
            return Sk.ffi.callableToPy(a, 'dot', function (a, b) {
              Sk.ffi.checkMethodArgs('dot', arguments, 1, 1);
              Sk.ffi.checkArgType('other', 'Euclidean3', Sk.ffi.isInstance(b, 'Euclidean3'), b);
              var c = Sk.ffi.remapToJs(b);
              return Sk.ffi.numberToFloatPy(f.dot(c.vector));
            });
          case 'setX':
            return Sk.ffi.callableToPy(a, 'setX', function (a, c) {
              Sk.ffi.checkMethodArgs('setX', arguments, 1, 1);
              Sk.ffi.checkArgType('x', r, Sk.ffi.isNum(c), c);
              d.x = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'setY':
            return Sk.ffi.callableToPy(a, 'setY', function (a, c) {
              Sk.ffi.checkMethodArgs('setY', arguments, 1, 1);
              Sk.ffi.checkArgType('y', r, Sk.ffi.isNum(c), c);
              d.y = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'setZ':
            return Sk.ffi.callableToPy(a, 'setZ', function (a, c) {
              Sk.ffi.checkMethodArgs('setZ', arguments, 1, 1);
              Sk.ffi.checkArgType('z', r, Sk.ffi.isNum(c), c);
              d.z = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'getComponent':
            return Sk.ffi.callableToPy(a, 'getComponent', function (a, b) {
              Sk.ffi.checkMethodArgs('getComponent', arguments, 1, 1);
              Sk.ffi.checkArgType('index', q, Sk.ffi.isInt(b), b);
              var c = Sk.ffi.remapToJs(b);
              return Sk.ffi.numberToFloatPy(f.getComponent(c));
            });
          case 'setComponent':
            return Sk.ffi.callableToPy(a, 'setComponent', function (a, c, d) {
              Sk.ffi.checkMethodArgs('setComponent', arguments, 1, 1);
              Sk.ffi.checkArgType('index', q, Sk.ffi.isInt(c), c);
              Sk.ffi.checkArgType('value', r, Sk.ffi.isNum(d), d);
              var e = Sk.ffi.remapToJs(c), g = Sk.ffi.remapToJs(d);
              f.setComponent(e, g);
              return b;
            });
          case 'set':
            return Sk.ffi.callableToPy(a, 'set', function (a, c, d, e) {
              Sk.ffi.checkMethodArgs('set', arguments, 3, 3);
              Sk.ffi.checkArgType('x', r, Sk.ffi.isNum(c), c);
              Sk.ffi.checkArgType('y', r, Sk.ffi.isNum(d), d);
              Sk.ffi.checkArgType('z', r, Sk.ffi.isNum(e), e);
              var g = Sk.ffi.remapToJs(c), h = Sk.ffi.remapToJs(d), k = Sk.ffi.remapToJs(e);
              f.set(g, h, k);
              return b;
            });
          case 'clone':
            return Sk.ffi.callableToPy(a, 'clone', function (a) {
              Sk.ffi.checkMethodArgs('clone', arguments, 0, 0);
              return e(g.w, f.x, f.y, f.z, -g.z, -g.x, -g.y, d.xyz);
            });
          case 'magnitude':
            return Sk.ffi.callableToPy(a, 'magnitude', function (a) {
              Sk.ffi.checkMethodArgs('magnitude', arguments, 0, 0);
              return Sk.ffi.numberToFloatPy(f.length());
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              f.normalize();
              return b;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Euclidean3');
          }
        });
        s.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkArgType('self', 'Euclidean3', Sk.ffi.isInstance(a, 'Euclidean3'), a);
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'w':
          case 'x':
          case 'y':
          case 'z':
          case 'xy':
          case 'yz':
          case 'zx':
          case 'xyz':
            Sk.ffi.checkArgType(b, r, Sk.ffi.isNum(c), c);
            try {
              a[b] = Sk.ffi.remapToJs(c);
            } catch (d) {
              throw Sk.ffi.assertionError(d.message);
            }
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Euclidean3');
          }
        });
        s.__cliffordConjugate__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('cliffordConjugate', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return e(b.w, -b.x, -b.y, -b.z, -b.xy, -b.yz, -b.zx, b.xyz);
        });
        s.__exp__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('exp', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a).quaternion, c = -b.z, d = -b.x, b = -b.y, f = Math.sqrt(c * c + d * d + b * b), g = Math.cos(f), f = Math.sin(f) / f;
          return e(g, 0, 0, 0, f * c, f * d, f * b, 0);
        });
        s.__sqrt__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('sqrt', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return e(Math.sqrt(b.w), 0, 0, 0, 0, 0, 0, 0);
        });
        s.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a), c = b.vector, d = b.quaternion;
          a = d.w;
          var e = c.x, f = c.y, c = c.z, g = -d.z, h = -d.x, d = -d.y, b = b.xyz, k = 0 !== a, l = 0 !== e || 0 != f || 0 !== c, n = 0 !== g || 0 !== h || 0 !== d, m = 0 !== b;
          if (!k || l || n || m) {
            if (k || !l || n || m) {
              if (k || l || !n || m) {
                if (k || l || n || !m)
                  return a = [
                    a,
                    e,
                    f,
                    c,
                    g,
                    h,
                    d,
                    b
                  ], Sk.ffi.stringToPy('Euclidean3(' + a.join(', ') + ')');
                a = [b];
                return Sk.ffi.stringToPy('PseudoscalarE3(' + a.join(', ') + ')');
              }
              a = [
                g,
                h,
                d
              ];
              return Sk.ffi.stringToPy('BivectorE3(' + a.join(', ') + ')');
            }
            a = [
              e,
              f,
              c
            ];
            return Sk.ffi.stringToPy('VectorE3(' + a.join(', ') + ')');
          }
          a = [a];
          return Sk.ffi.stringToPy('ScalarE3(' + a.join(', ') + ')');
        });
        s.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkFunctionArgs('str', arguments, 1, 1);
          Sk.ffi.checkArgType('self', 'Euclidean3', Sk.ffi.isInstance(a, 'Euclidean3'), a);
          var b = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy(f([
            b.w,
            b.x,
            b.y,
            b.z,
            b.xy,
            b.yz,
            b.zx,
            b.xyz
          ], '1 i j k ij jk ki I'.split(' ')));
        });
      }, 'Euclidean3', []);
      a.e1 = e(0, 1, 0, 0, 0, 0, 0, 0, !1);
      a.e2 = e(0, 0, 1, 0, 0, 0, 0, 0, !1);
      a.e3 = e(0, 0, 0, 1, 0, 0, 0, 0, !1);
      a.I = e(0, 0, 0, 0, 0, 0, 0, 1, !1);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineLorentzian = function (a, b) {
      function c(a) {
        return 'number' === typeof a;
      }
      function d(b, c, d, e) {
        return Sk.ffi.callsim(a.Lorentzian, Sk.ffi.numberToFloatPy(b), Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d), Sk.ffi.numberToFloatPy(e));
      }
      function e(a, b, c) {
        var d, e, f, g, h;
        f = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < f.length && f.push('+') : f.push('-');
            d = Math.abs(a);
            if (1 === d)
              return f.push(b);
            f.push(d.toString());
            if ('1' !== b)
              return f.push(c), f.push(b);
          }
        };
        e = g = 0;
        for (h = a.length - 1; 0 <= h ? g <= h : g >= h; e = 0 <= h ? ++g : --g)
          d(a[e], b[e]);
        return 0 < f.length ? f.join('') : '0';
      }
      function f(a, b, c, e, f, g, h, k, z) {
        var y = +f, C = +g, t = +h, B = -k, G = +(f * y + g * C + h * t - k * B), H = y * G + -0 * C + -0 * t - -0 * B, I = -0 * y + C * G - -0 * t + -0 * B, J = -0 * y + -0 * C + t * G - -0 * B, y = -0 * y + -0 * C - -0 * t + B * G;
        f = f * H + g * I + h * J - k * y;
        H /= f;
        I /= f;
        J /= f;
        k = y / f;
        f = a * H + b * I + c * J - e * k;
        g = a * I + b * H - c * k + e * J;
        h = a * J + b * k + c * H - e * I;
        a = a * k + b * J - c * I + e * H;
        if ('undefined' !== typeof z)
          z.w = f, z.x = g, z.y = h, z.xy = a;
        else
          return d(f, g, h, a);
      }
      Sk.ffi.checkFunctionArgs('defineLorentzian', arguments, 2, 2);
      Sk.builtin.defineUnits(a, b);
      var g = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], h = [
          'Lorentzian',
          g
        ], k = function (a) {
          return Sk.ffi.isInstance(a, 'Lorentzian');
        };
      a.ScalarL4 = Sk.ffi.functionPy(function (b) {
        Sk.ffi.checkFunctionArgs('ScalarL4', arguments, 1, 1);
        var c = Sk.ffi.numberToFloatPy(0);
        return Sk.ffi.callsim(a.Lorentzian, b, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c);
      });
      a.VectorL4 = Sk.ffi.functionPy(function (b, c, d, e) {
        Sk.ffi.checkFunctionArgs('VectorL4', arguments, 4, 4);
        var f = Sk.ffi.numberToFloatPy(0);
        return Sk.ffi.callsim(a.Lorentzian, f, b, c, f, d, f, f, f, e, f, f, f, f, f, f, f);
      });
      a.PseudoscalarE2 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('PseudoscalarE2', arguments, 1, 1);
        Sk.ffi.checkArgType('xy', g, Sk.ffi.isNum(a), a);
        return d(0, 0, 0, Sk.ffi.remapToJs(a));
      });
      a.Lorentzian = Sk.ffi.buildClass(a, function (b, g) {
        g.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g, h, l, m, B, G, H, I, J, M, K) {
          Sk.ffi.checkMethodArgs('Lorentzian', arguments, 1, 16);
          if (k(b))
            Sk.ffi.checkMethodArgs('Lorentzian', arguments, 1, 1), Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Lorentzian', void 0, a);
          else {
            Sk.ffi.checkMethodArgs('Lorentzian', arguments, 16, 16);
            var x = {};
            x[0] = b;
            x[1] = c;
            x[2] = d;
            x[3] = e;
            x[4] = f;
            x[5] = g;
            x[6] = h;
            x[7] = l;
            x[8] = m;
            x[9] = B;
            x[10] = G;
            x[11] = H;
            x[12] = I;
            x[13] = J;
            x[14] = M;
            x[15] = K;
            Sk.ffi.referenceToPy(x, 'Lorentzian', void 0, a);
          }
        });
        g.__add__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          if (k(c)) {
            var f = Sk.ffi.numberToFloatPy(0), g = Sk.ffh.add(d[0], e[0]), l = Sk.ffh.add(d[1], e[1]), m = Sk.ffh.add(d[2], e[2]), C = f, t = Sk.ffh.add(d[4], e[4]), B = f, G = f, H = f, d = Sk.ffh.add(d[8], e[8]);
            return Sk.ffi.callsim(a.Lorentzian, g, l, m, C, t, B, G, H, d, f, f, f, f, f, f, f);
          }
          if (Sk.ffi.isNum(c))
            return f = Sk.ffi.numberToFloatPy(0), g = Sk.ffh.add(d[0], e), l = d[1], m = d[2], t = d[4], d = d[8], Sk.ffi.callsim(a.Lorentzian, g, l, m, f, t, f, f, f, d, f, f, f, f, f, f, f);
          Sk.ffi.checkRhsOperandType('add', h, !1, c);
        });
        g.__radd__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(c), c);
          var d = Sk.ffi.remapToJs(c), e = Sk.ffi.remapToJs(b), f = Sk.ffi.numberToFloatPy(0), g;
          try {
            g = Sk.ffh.add(d, e[0]);
          } catch (k) {
            g = Sk.ffh.add(e[0], d);
          }
          return Sk.ffi.callsim(a.Lorentzian, g, e[1], e[2], f, e[4], f, f, f, e[8], f, f, f, f, f, f, f);
        });
        g.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return c.w += d, a;
          if (k(b))
            return c.w += d.w, c.x += d.x, c.y += d.y, c.xy += d.xy, a;
          Sk.ffi.checkRhsOperandType('add', h, Sk.ffi.isNum(b), b);
        });
        g.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return d(c.w - e, c.x, c.y, c.xy);
          if (k(b))
            return d(c.w - e.w, c.x - e.x, c.y - e.y, c.xy - e.xy);
          Sk.ffi.checkRhsOperandType('subtract', h, Sk.ffi.isNum(b), b);
        });
        g.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          return d(c - e.w, -e.x, -e.y, -e.xy);
        });
        g.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? d.w -= e : (d.w -= e.w, d.x -= e.x, d.y -= e.y, d.xy -= e.xy);
          return a;
        });
        g.__mul__ = Sk.ffi.functionPy(function (b, c) {
          function d(a) {
            for (var b = Sk.ffi.numberToIntPy(0), c = 0; c < a.length; c++)
              b = Sk.ffh.add(b, a[c]);
            return b;
          }
          function e(a) {
            return a.map(function (a) {
              var b = a[0];
              a = Sk.ffh.multiply(f[a[1]], g[a[2]]);
              return 0 < b ? a : Sk.ffh.negative(a);
            });
          }
          var f = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(c);
          if (k(c)) {
            Sk.ffi.numberToFloatPy(0);
            var l = d(e([
                [
                  1,
                  0,
                  0
                ],
                [
                  1,
                  1,
                  1
                ],
                [
                  1,
                  2,
                  2
                ],
                [
                  -1,
                  3,
                  3
                ],
                [
                  1,
                  4,
                  4
                ],
                [
                  -1,
                  5,
                  5
                ],
                [
                  -1,
                  6,
                  6
                ],
                [
                  -1,
                  7,
                  7
                ],
                [
                  1,
                  8,
                  8
                ],
                [
                  -1,
                  9,
                  9
                ],
                [
                  -1,
                  10,
                  10
                ],
                [
                  1,
                  11,
                  11
                ],
                [
                  -1,
                  12,
                  12
                ],
                [
                  1,
                  13,
                  13
                ],
                [
                  1,
                  14,
                  14
                ],
                [
                  -1,
                  15,
                  15
                ]
              ])), m = d(e([
                [
                  1,
                  1,
                  0
                ],
                [
                  1,
                  0,
                  1
                ],
                [
                  1,
                  3,
                  2
                ],
                [
                  -1,
                  2,
                  3
                ],
                [
                  1,
                  5,
                  4
                ],
                [
                  -1,
                  4,
                  5
                ],
                [
                  -1,
                  7,
                  6
                ],
                [
                  -1,
                  6,
                  7
                ],
                [
                  -1,
                  9,
                  8
                ],
                [
                  1,
                  8,
                  9
                ],
                [
                  -1,
                  11,
                  10
                ]
              ])), C = d(e([
                [
                  1,
                  2,
                  0
                ],
                [
                  -1,
                  3,
                  1
                ],
                [
                  1,
                  0,
                  2
                ]
              ])), t = d(e([
                [
                  1,
                  3,
                  0
                ],
                [
                  -1,
                  2,
                  1
                ],
                [
                  1,
                  1,
                  2
                ],
                [
                  1,
                  0,
                  3
                ],
                [
                  1,
                  7,
                  4
                ],
                [
                  1,
                  6,
                  5
                ],
                [
                  -1,
                  5,
                  6
                ],
                [
                  1,
                  4,
                  7
                ],
                [
                  -1,
                  11,
                  8
                ],
                [
                  -1,
                  10,
                  9
                ],
                [
                  1,
                  9,
                  10
                ],
                [
                  -1,
                  8,
                  11
                ],
                [
                  -1,
                  15,
                  12
                ],
                [
                  -1,
                  14,
                  13
                ],
                [
                  1,
                  13,
                  14
                ],
                [
                  1,
                  12,
                  15
                ]
              ])), B = d(e([[
                  1,
                  4,
                  0
                ]])), G = d(e([[
                  1,
                  5,
                  0
                ]])), H = d(e([[
                  1,
                  6,
                  0
                ]])), I = d(e([[
                  1,
                  7,
                  0
                ]])), J = d(e([[
                  1,
                  8,
                  0
                ]])), M = d(e([[
                  1,
                  9,
                  0
                ]])), K = d(e([[
                  1,
                  10,
                  0
                ]])), x = d(e([[
                  1,
                  11,
                  0
                ]])), N = d(e([[
                  1,
                  12,
                  0
                ]])), w = d(e([[
                  1,
                  13,
                  0
                ]])), A = d(e([[
                  1,
                  14,
                  0
                ]])), u = d(e([[
                  1,
                  15,
                  0
                ]]));
            return Sk.ffi.callsim(a.Lorentzian, l, m, C, t, B, G, H, I, J, M, K, x, N, w, A, u);
          }
          if (Sk.ffi.isNum(c))
            return l = Sk.ffh.add(f[0], g), m = Sk.ffh.add(f[1], g), C = Sk.ffh.add(f[2], g), t = Sk.ffh.add(f[3], g), B = Sk.ffh.add(f[4], g), G = Sk.ffh.add(f[5], g), H = Sk.ffh.add(f[6], g), I = Sk.ffh.add(f[7], g), J = Sk.ffh.add(f[8], g), M = Sk.ffh.add(f[9], g), K = Sk.ffh.add(f[10], g), x = Sk.ffh.add(f[11], g), N = Sk.ffh.add(f[12], g), w = Sk.ffh.add(f[13], g), A = Sk.ffh.add(f[14], g), u = Sk.ffh.add(f[15], g), Sk.ffi.callsim(a.Lorentzian, l, m, C, t, B, G, H, I, J, M, K, x, N, w, A, u);
          Sk.ffi.checkRhsOperandType('multiply', h, !1, c);
        });
        g.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' * ' + JSON.stringify(a, null, 2));
        });
        g.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, B = e.y, e = e.xy;
            d.w = f * l + g * m + h * B - k * e;
            d.x = f * m + g * l - h * e + k * B;
            d.y = f * B + g * e + h * l - k * m;
            d.xy = f * e + g * B - h * m + k * l;
          }
          return a;
        });
        g.__div__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return c(b) ? f(a.w, a.x, a.y, a.xy, b, 0, 0, 0, void 0) : f(a.w, a.x, a.y, a.xy, b.w, b.x, b.y, b.xy, void 0);
        });
        g.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return f(b, 0, 0, 0, a.w, a.x, a.y, a.xy, void 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' / ' + JSON.stringify(a, null, 2));
        });
        g.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? f(d.w, d.x, d.y, d.xy, e, 0, 0, 0, d) : f(d.w, d.x, d.y, d.xy, e.w, e.x, e.y, e.xy, d);
          return a;
        });
        g.__xor__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, a.x * b, a.y * b, a.xy * b);
          var e = a.w, f = a.x, g = a.y, h = b.w, k = b.x, l = b.y;
          return d(e * h, e * k + f * h, e * l + g * h, e * b.xy + f * l - g * k + a.xy * h);
        });
        g.__rxor__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' ^ ' + JSON.stringify(a, null, 2));
        });
        g.__ixor__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, B = e.y, e = e.xy;
            d.w = f * l;
            d.x = f * m + g * l;
            d.y = f * B + h * l;
            d.xy = f * e + g * B - h * m + k * l;
          }
          return a;
        });
        g.__lshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, 0, 0, 0);
          var e = a.w, f = a.x, g = a.y, h = b.x, k = b.y, l = b.xy;
          return d(e * b.w + f * h + g * k - a.xy * l, e * h - g * l, e * k + f * l, e * l);
        });
        g.__rlshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' << ' + JSON.stringify(a, null, 2));
        });
        g.__ilshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x = 0, d.y = 0, d.xy = 0;
          else {
            var f = d.w, g = d.x, h = d.y, k = e.x, l = e.y, m = e.xy;
            d.w = f * e.w + g * k + h * l - d.xy * m;
            d.x = f * k - h * m;
            d.y = f * l + g * m;
            d.xy = f * m;
          }
          return a;
        });
        g.__rshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, -a.x * b, -a.y * b, a.xy * b);
          var e = a.x, f = a.y, g = a.xy, h = b.w, k = b.x, l = b.y;
          return d(a.w * h + e * k + f * l - g * b.xy, +e * h + g * l, +f * h - g * k, g * h);
        });
        g.__rrshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, 0, 0, 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' >> ' + JSON.stringify(a, null, 2));
        });
        g.__irshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e)) {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e, m = 0, B = 0, G = 0;
            d.w *= e;
            d.x *= -e;
            d.y *= -e;
            d.xy *= e;
          } else
            f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, B = e.y, G = e.xy, d.w = f * l + g * m + h * B - k * G, d.x = +g * l + k * B, d.y = +h * l - k * m, d.xy = k * l;
          return a;
        });
        g.nb$negative = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(-a.w, -a.x, -a.y, -a.xy);
        };
        g.nb$positive = function () {
          return this;
        };
        g.nb$invert = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(a.w, a.x, a.y, -a.xy);
        };
        g.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          switch (b) {
          case 0:
            return d(a.w, 0, 0, 0);
          case 1:
            return d(0, a.x, a.y, 0);
          case 2:
            return d(0, 0, 0, a.xy);
          }
        });
        g.__abs__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.sqrt(a.w * a.w + a.x * a.x + a.y * a.y - a.xy * a.xy));
        });
        g.__exp__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Math.exp(b.w);
          var c = Math.cos(b.xy), b = Math.sin(b.xy);
          return d(a * c, 0, 0, a * b);
        });
        g.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Lorentzian(' + [
            a.w,
            a.x,
            a.y,
            a.xy
          ].map(function (a) {
            return String(a);
          }).join(', ') + ')');
        });
        g.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return a.isNaN() ? Sk.ffi.stringToPy('NaN') : Sk.ffi.stringToPy(e([
            a.w,
            a.x,
            a.y,
            a.xy
          ], [
            '1',
            'i',
            'j',
            'I'
          ], '*'));
        });
        g.__eq__ = Sk.ffi.functionPy(function (a, b) {
          return Sk.ffi.bool.True;
        });
        g.__ne__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.xy !== b.xy;
        });
        g.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'w':
            return e[0];
          case 'x':
            return e[1];
          case 'y':
            return e[2];
          case 'xy':
            return e[3];
          case 'yx':
            return Sk.ffh.negative(e[3]);
          case 'z':
            return e[4];
          case 'xz':
            return e[5];
          case 'zx':
            return Sk.ffh.negative(e[5]);
          case 'yz':
            return e[6];
          case 'zy':
            return Sk.ffh.negative(e[6]);
          case 'xyz':
            return e[7];
          case 't':
            return e[8];
          case 'xt':
            return e[9];
          case 'tx':
            return Sk.ffh.negative(e[9]);
          case 'yt':
            return e[10];
          case 'ty':
            return Sk.ffh.negative(e[10]);
          case 'xyt':
            return e[11];
          case 'zt':
            return e[12];
          case 'tz':
            return Sk.ffh.negative(e[12]);
          case 'xzt':
            return e[13];
          case 'zxt':
            return Sk.ffh.negative(e[13]);
          case 'yzt':
            return e[14];
          case 'xyzt':
            return e[15];
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return d(e.w, e.x, e.y, e.xy);
              });
            }, 'clone', []));
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(Math.sqrt(e.w * e.w + e.x * e.x + e.y * e.y - e.xy * e.xy));
              });
            }, 'magnitude', []));
          case 'quadrance':
            return Sk.ffi.callableToPy(a, c, function (a) {
              a = Sk.ffh.multiply(e[0], e[0]);
              a = Sk.ffh.add(a, Sk.ffh.multiply(e[1], e[1]));
              a = Sk.ffh.add(a, Sk.ffh.multiply(e[2], e[2]));
              a = Sk.ffh.add(a, Sk.ffh.multiply(e[4], e[4]));
              return a = Sk.ffh.subtract(a, Sk.ffh.multiply(e[8], e[8]));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Lorentzian');
          }
        });
        g.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'w':
          case 'x':
          case 'y':
          case 'xy':
            Sk.ffi.checkArgType(b, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.LONG
            ], Sk.ffi.isNum(c), c);
            a[b] = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Lorentzian');
          }
        });
      }, 'Lorentzian', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineSymbolic = function (a, b) {
      Sk.ffi.checkFunctionArgs('defineSymbolic', arguments, 2, 2);
      a.Environment = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Environment', arguments, 0, 2);
          var d = { bindings: {} };
          'undefined' === typeof b || Sk.ffi.isNone(b) || (Sk.ffi.checkArgType('parent', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b), d.parent = b);
          if ('undefined' !== typeof c && !Sk.ffi.isNone(c)) {
            Sk.ffi.checkArgType('binding', 'Binding', Sk.ffi.isInstance(c, 'Binding'), c);
            var k = Sk.ffi.gattr(c, 'name');
            Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(k), k);
            var l = Sk.ffi.gattr(c, 'expr');
            d.bindings[Sk.ffi.remapToJs(k)] = l;
          }
          Sk.ffi.referenceToPy(d, 'Environment', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Environment, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'lookup':
            return Sk.ffi.callableToPy(a, 'lookup', function (a, b) {
              Sk.ffi.checkMethodArgs('lookup', arguments, 1, 1);
              Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(b), b);
              var c = Sk.ffi.remapToJs(b);
              return 'undefined' !== typeof d.bindings[c] ? d.bindings[c] : 'undefined' !== typeof d.parent ? Sk.ffi.callsim(Sk.ffi.gattr(d.parent, 'lookup'), b) : Sk.ffi.none.None;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Environment');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Environment()');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Environment');
        });
      }, 'Environment', []);
      a.Variable = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('Variable', arguments, 1, 1);
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(b), b);
          Sk.ffi.referenceToPy({ name: b }, 'Variable', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__radd__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, c, b);
        });
        d.__sub__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('-', arguments, 1, 1);
          return Sk.ffi.callsim(a.Subtract, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(c, 'Environment'), c);
              var f = Sk.ffi.gattr(c, 'lookup'), f = Sk.ffi.callsim(f, d.name);
              return Sk.ffi.isNone(f) ? b : f;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Variable');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Variable("' + Sk.ffi.remapToJs(a.name) + '")');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.remapToJs(a).name;
        });
      }, 'Variable', []);
      a.Binding = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Binding', arguments, 2, 2);
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(b), b);
          var d = {};
          d.name = b;
          d.expr = c;
          Sk.ffi.referenceToPy(d, 'Binding', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'name':
            return c.name;
          case 'expr':
            return c.expr;
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('Binding');
          }
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            '"' + Sk.ffi.remapToJs(a.name) + '"',
            Sk.ffi.remapToJs(Sk.ffh.repr(a.expr))
          ].join(', ');
          return Sk.ffi.stringToPy('Binding(' + a + ')');
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            Sk.ffi.remapToJs(a.name),
            Sk.ffi.remapToJs(Sk.ffh.str(a.expr))
          ].join(' => ');
          return Sk.ffi.stringToPy(a);
        });
      }, 'Binding', []);
      a.Add = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Add', arguments, 2, 2);
          Sk.ffi.referenceToPy({
            lhs: b,
            rhs: c
          }, 'Add', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, b) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b);
              var c = Sk.ffh.evaluate(d.lhs, b), e = Sk.ffh.evaluate(d.rhs, b);
              return Sk.ffh.add(c, e);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Variable');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy('Add(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' + ');
          return Sk.ffi.stringToPy(a);
        });
      }, 'Add', []);
      a.Subtract = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Subtract', arguments, 2, 2);
          Sk.ffi.referenceToPy({
            lhs: b,
            rhs: c
          }, 'Subtract', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, b) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b);
              var c = Sk.ffh.evaluate(d.lhs, b), e = Sk.ffh.evaluate(d.rhs, b);
              return Sk.ffh.subtract(c, e);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Variable');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy('Subtract(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' - ');
          return Sk.ffi.stringToPy(a);
        });
      }, 'Subtract', []);
      a.Multiply = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Multiply', arguments, 2, 2);
          Sk.ffi.referenceToPy({
            lhs: b,
            rhs: c
          }, 'Multiply', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, b) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b);
              var c = Sk.ffh.evaluate(d.lhs, b), e = Sk.ffh.evaluate(d.rhs, b);
              return Sk.ffh.multiply(c, e);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Variable');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy('Multiply(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' * ');
          return Sk.ffi.stringToPy(a);
        });
      }, 'Multiply', []);
      a.PointE2 = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('PointE2', arguments, 2, 2);
          var d = {};
          d.x = b;
          d.y = c;
          Sk.ffi.referenceToPy(d, 'PointE2', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(c, 'Environment'), c);
              var e = Sk.ffh.evaluate(d.x, c), f = Sk.ffh.evaluate(d.y, c);
              return Sk.ffi.callsim(a.PointE2, e, f);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('PointE2');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.x,
            a.y
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy('PointE2(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.x,
            a.y
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(', ');
          return Sk.ffi.stringToPy('[' + a + ']');
        });
      }, 'PointE2', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineUnits = function (a, b) {
      Sk.ffi.checkFunctionArgs('defineUnits', arguments, 2, 2);
      a.yocto = Sk.ffi.numberToFloatPy(1e-24);
      a.zepto = Sk.ffi.numberToFloatPy(1e-21);
      a.atto = Sk.ffi.numberToFloatPy(1e-18);
      a.femto = Sk.ffi.numberToFloatPy(1e-15);
      a.pico = Sk.ffi.numberToFloatPy(1e-12);
      a.nano = Sk.ffi.numberToFloatPy(1e-9);
      a.micro = Sk.ffi.numberToFloatPy(0.000001);
      a.milli = Sk.ffi.numberToFloatPy(0.001);
      a.centi = Sk.ffi.numberToFloatPy(0.01);
      a.deci = Sk.ffi.numberToFloatPy(0.1);
      a.deka = Sk.ffi.numberToFloatPy(10);
      a.hecto = Sk.ffi.numberToFloatPy(100);
      a.kilo = Sk.ffi.numberToFloatPy(1000);
      a.mega = Sk.ffi.numberToFloatPy(1000000);
      a.giga = Sk.ffi.numberToFloatPy(1000000000);
      a.tera = Sk.ffi.numberToFloatPy(1000000000000);
      a.peta = Sk.ffi.numberToFloatPy(1000000000000000);
      a.exa = Sk.ffi.numberToFloatPy(1000000000000000000);
      a.zetta = Sk.ffi.numberToFloatPy(1e+21);
      a.yotta = Sk.ffi.numberToFloatPy(1e+24);
      var c = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], d = [
          'kg',
          'm',
          's',
          'C'
        ], e = function (a) {
          return Sk.ffi.isInstance(a, 'Measure');
        };
      Sk.builtin.defineFractions(a, 'Rational', function (a, c) {
        return new b.Rational(a, c);
      });
      a.Dimensions = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.checkMethodArgs('Dimensions', arguments, 1, 4);
          Sk.ffi.checkArgType('M', 'Rational', Sk.ffi.isInstance(c, 'Rational') || Sk.ffi.isInstance(c, 'Dimensions'), c);
          switch (Sk.ffi.typeName(c)) {
          case 'Rational':
            Sk.ffi.checkMethodArgs('Dimensions', arguments, 4, 4);
            Sk.ffi.checkArgType('L', 'Rational', Sk.ffi.isInstance(d, 'Rational'), d);
            Sk.ffi.checkArgType('T', 'Rational', Sk.ffi.isInstance(e, 'Rational'), e);
            Sk.ffi.checkArgType('Q', 'Rational', Sk.ffi.isInstance(f, 'Rational'), f);
            Sk.ffi.referenceToPy(new b.Dimensions(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f)), 'Dimensions', void 0, a);
            break;
          case 'Dimensions':
            Sk.ffi.checkMethodArgs('Dimensions', arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Dimensions', void 0, a);
            break;
          default:
            throw Sk.ffi.err.argument('M').inFunction('Dimensions').mustHaveType([
              'Rational',
              'Dimensions'
            ]);
          }
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'M':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.remapToPy(d.M, 'Rational'));
          case 'L':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.remapToPy(d.L, 'Rational'));
          case 'T':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.remapToPy(d.T, 'Rational'));
          case 'Q':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.remapToPy(d.Q, 'Rational'));
          }
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkRhsOperandType('multiply', 'Dimensions', Sk.ffi.isInstance(c, 'Dimensions'), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.mul(e);
          return Sk.ffi.callsim(a.Dimensions, Sk.ffi.remapToPy(d.M, 'Rational'), Sk.ffi.remapToPy(d.L, 'Rational'), Sk.ffi.remapToPy(d.T, 'Rational'), Sk.ffi.remapToPy(d.Q, 'Rational'));
        });
        d.__div__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.div(e);
          return Sk.ffi.callsim(a.Dimensions, Sk.ffi.remapToPy(d.M, 'Rational'), Sk.ffi.remapToPy(d.L, 'Rational'), Sk.ffi.remapToPy(d.T, 'Rational', Sk.ffi.remapToPy(d.Q, 'Rational')));
        });
        d.__pow__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkFunctionArgs('**', arguments, 2, 2);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.pow(e);
          return Sk.ffi.callsim(a.Dimensions, Sk.ffi.remapToPy(d.M, 'Rational'), Sk.ffi.remapToPy(d.L, 'Rational'), Sk.ffi.remapToPy(d.T, 'Rational', Sk.ffi.remapToPy(d.Q, 'Rational')));
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.remapToPy('' + a);
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = [
              'M',
              'L',
              'T',
              'Q'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffi.callsim(a.__repr__, a));
            });
          return Sk.ffi.remapToPy('Dimensions(' + b.join(' , ') + ')');
        });
      }, 'Dimensions', []);
      a.Unit = Sk.ffi.buildClass(a, function (d, e) {
        e.__init__ = Sk.ffi.functionPy(function (a, c, d, e) {
          Sk.ffi.checkMethodArgs('Unit', arguments, 1, 3);
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            Sk.ffi.checkMethodArgs('Unit', arguments, 3, 3);
            var f = Sk.ffi.remapToJs(c), g = Sk.ffi.remapToJs(d), q = Sk.ffi.remapToJs(e);
            Sk.ffi.referenceToPy(new b.Unit(f, g, q), 'Unit', void 0, a);
            break;
          case Sk.ffi.PyType.INSTANCE:
            Sk.ffi.checkMethodArgs('Unit', arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Unit', void 0, a);
            break;
          default:
            throw Error('Unit (__init__) ' + Sk.ffi.getType(c));
          }
        });
        e.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var e = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'scale':
            return Sk.ffi.remapToPy(e.scale);
          case 'dimensions':
            return Sk.ffi.callsim(a.Dimensions, Sk.ffi.remapToPy(e.dimensions, 'Dimensions'));
          case 'labels':
            return Sk.ffi.remapToPy(e.labels);
          case 'compatible':
            return Sk.ffi.callableToPy(a, 'compatible', function (a, b) {
              Sk.ffi.checkMethodArgs('compatible', arguments, 1, 1);
              Sk.ffi.checkArgType('other', 'Unit', Sk.ffi.isInstance(b, 'Unit'), b);
              var d = Sk.ffi.remapToJs(b);
              try {
                e.compatible(d);
              } catch (f) {
                throw Sk.ffi.assertionError(f.message);
              }
              return c;
            });
          case 'cos':
            return Sk.ffi.callableToPy(a, 'cos', function (c) {
              Sk.ffi.checkMethodArgs('cos', arguments, 0, 0);
              var d = e.dimensions, f = e.labels, d = new b.Unit(Math.cos(e.scale), d, f);
              return Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(d, 'Unit'));
            });
          case 'sin':
            return Sk.ffi.callableToPy(a, 'sin', function (c) {
              Sk.ffi.checkMethodArgs('sin', arguments, 0, 0);
              var d = e.dimensions, f = e.labels, d = new b.Unit(Math.sin(e.scale), d, f);
              return Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(d, 'Unit'));
            });
          default:
            throw Sk.ffi.err.attribute(d).isNotGetableOnType('Unit');
          }
        });
        e.__add__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          try {
            var f = d.add(e);
            return Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(f.scale), Sk.ffi.remapToPy(f.dimensions, 'Dimensions'), Sk.ffi.remapToPy(f.labels));
          } catch (g) {
            throw Sk.ffi.assertionError(g.message);
          }
        });
        e.__sub__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          try {
            var f = d.sub(e);
            return Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(f.scale), Sk.ffi.remapToPy(f.dimensions, 'Dimensions'), Sk.ffi.remapToPy(f.labels));
          } catch (g) {
            throw Sk.ffi.assertionError(g.message);
          }
        });
        e.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkRhsOperandType('multiply', 'Unit', Sk.ffi.isInstance(c, 'Unit'), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.mul(e);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(d.scale), Sk.ffi.remapToPy(d.dimensions, 'Dimensions'), Sk.ffi.remapToPy(d.labels));
        });
        e.__rmul__ = Sk.ffi.functionPy(function (b, d) {
          Sk.ffi.checkLhsOperandType('multiply', c, Sk.ffi.isNum(d), d);
          var e = Sk.ffi.remapToJs(d), f = Sk.ffi.remapToJs(b);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(e * f.scale), Sk.ffi.remapToPy(f.dimensions, 'Dimensions'), Sk.ffi.remapToPy(f.labels));
        });
        e.__div__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.div(e);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(d.scale), Sk.ffi.remapToPy(d.dimensions, 'Dimensions'), Sk.ffi.remapToPy(d.labels));
        });
        e.__rdiv__ = Sk.ffi.functionPy(function (d, e) {
          Sk.ffi.checkLhsOperandType('multiply', c, Sk.ffi.isNum(e), e);
          var f = Sk.ffi.remapToJs(e), g = Sk.ffi.remapToJs(d), f = f / g.scale, n = new b.Rational(-g.dimensions.M.numer, g.dimensions.M.denom), p = new b.Rational(-g.dimensions.L.numer, g.dimensions.L.denom), q = new b.Rational(-g.dimensions.T.numer, g.dimensions.T.denom), r = new b.Rational(-g.dimensions.Q.numer, g.dimensions.Q.denom), n = new b.Dimensions(n, p, q, r), g = g.labels;
          return Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(f), Sk.ffi.remapToPy(n, 'Dimensions'), Sk.ffi.remapToPy(g));
        });
        e.__pow__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.pow(e);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(d.scale), Sk.ffi.remapToPy(d.dimensions, 'Dimensions'), Sk.ffi.remapToPy(d.labels));
        });
        e.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.remapToPy('' + a);
        });
        e.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = [{
                name: 'dimensions',
                kind: '__repr__'
              }].map(function (b) {
              return {
                value: Sk.ffi.gattr(a, b.name),
                prop: b
              };
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffi.callsim(a.value[a.prop.kind], a.value));
            }), c = Sk.ffi.remapToJs(a), d = '' + c.scale, b = b[0], c = '[' + c.labels.map(function (a) {
              return '\'' + a + '\'';
            }).join(' , ') + ']';
          return Sk.ffi.remapToPy('Unit(' + [
            d,
            b,
            c
          ].join(' , ') + ')');
        });
      }, 'Unit', []);
      a.Measure = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (b, c, d) {
          Sk.ffi.checkMethodArgs('Measure', arguments, 1, 2);
          Sk.ffi.checkArgType('quantity', 'Quantity', Sk.ffi.isInstance(c), c);
          if ('Measure' === Sk.ffi.typeName(c))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Measure', c.custom, b);
          else {
            var e = Sk.ffi.gattr(d, 'scale');
            if (1 === Sk.ffi.remapToJs(e)) {
              var f = {};
              f.qtyPy = c;
              f.uomPy = d;
            } else
              f = {}, f.qtyPy = Sk.ffh.multiply(c, e), f.uomPy = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.gattr(d, 'dimensions'), Sk.ffi.gattr(d, 'labels'));
            Sk.ffi.referenceToPy(f, 'Measure', void 0, b);
          }
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'quantity':
            return d.qtyPy;
          case 'uom':
            return d.uomPy;
          case 'exp':
            return Sk.ffi.callableToPy(a, 'exp', function (b) {
              Sk.ffi.checkMethodArgs('exp', arguments, 0, 0);
              return Sk.ffi.callsim(a.Measure, Sk.ffi.callsim(Sk.ffi.gattr(d.qtyPy, 'exp')), d.uomPy);
            });
          }
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkArgType('other', 'Measure', e(c), c);
          var d = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
          return Sk.ffi.callsim(a.Measure, Sk.ffh.add(d.qtyPy, f.qtyPy), Sk.ffi.callsim(Sk.ffi.gattr(d.uomPy, 'compatible'), f.uomPy));
        });
        d.__sub__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkArgType('other', 'Measure', e(c), c);
          var d = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
          return Sk.ffi.callsim(a.Measure, Sk.ffh.subtract(d.qtyPy, f.qtyPy), Sk.ffi.callsim(Sk.ffi.gattr(d.uomPy, 'compatible'), f.uomPy));
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.multiply(f.qtyPy, g.qtyPy), Sk.ffh.multiply(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.multiply(f.qtyPy, d), f.uomPy);
          Sk.ffi.checkArgType('other', [
            'Measure',
            c
          ], !1, d);
        });
        d.__rmul__ = Sk.ffi.functionPy(function (b, d) {
          var e = Sk.ffi.remapToJs(b);
          Sk.ffi.checkArgType('other', c, Sk.ffi.isNum(d), d);
          return Sk.ffi.callsim(a.Measure, Sk.ffh.multiply(e.qtyPy, d), e.uomPy);
        });
        d.__div__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.divide(f.qtyPy, g.qtyPy), Sk.ffh.divide(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.divide(f.qtyPy, d), f.uomPy);
          if (Sk.ffi.isInstance(d, 'Unit'))
            return Sk.ffi.callsim(a.Measure, f.qtyPy, Sk.ffh.divide(f.uomPy, d));
          Sk.ffi.checkArgType('other', [
            'Measure',
            c,
            'Unit'
          ], !1, d);
        });
        d.__xor__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.xor(f.qtyPy, g.qtyPy), Sk.ffh.multiply(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.xor(f.qtyPy, d), f.uomPy);
          Sk.ffi.checkArgType('other', [
            'Measure',
            c
          ], !1, d);
        });
        d.__lshift__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.lshift(f.qtyPy, g.qtyPy), Sk.ffh.multiply(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.lshift(f.qtyPy, d), f.uomPy);
          Sk.ffi.checkArgType('other', [
            'Measure',
            c
          ], !1, d);
        });
        d.__rshift__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.rshift(f.qtyPy, g.qtyPy), Sk.ffh.multiply(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.rshift(f.qtyPy, d), f.uomPy);
          Sk.ffi.checkArgType('other', [
            'Measure',
            c
          ], !1, d);
        });
        d.__pos__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.positive(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        d.__neg__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.negative(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        d.__invert__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.invert(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        d.__exp__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.exp(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Sk.ffi.remapToJs(Sk.ffh.str(b.qtyPy));
          b = Sk.ffi.remapToJs(Sk.ffh.str(b.uomPy));
          return Sk.ffi.remapToPy('' + a + ' ' + b);
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Sk.ffi.remapToJs(Sk.ffh.repr(b.qtyPy));
          b = Sk.ffi.remapToJs(Sk.ffh.repr(b.uomPy));
          return Sk.ffi.remapToPy('Measure(' + a + ', ' + b + ')');
        });
      }, 'Measure', []);
      a.kilogram = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(1, 0, 0, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.meter = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(0, 1, 0, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.second = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(0, 0, 1, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.coulomb = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(0, 0, 0, 1), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.gram = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(0.001), Sk.ffi.remapToPy(new b.Dimensions(1, 0, 0, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.cm = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(0.01), Sk.ffi.remapToPy(new b.Dimensions(0, 1, 0, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.newton = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(1, 1, -2, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.joule = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(1, 2, -2, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.watt = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(1, 2, -3, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.ampere = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(0, 0, -1, 1), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.volt = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(1, 2, -2, -1), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.tesla = Sk.ffi.callsim(a.Unit, Sk.ffi.remapToPy(1), Sk.ffi.remapToPy(new b.Dimensions(1, 1, -2, -1), 'Dimensions'), Sk.ffi.remapToPy(d));
    };
  }.call(this));
  (function () {
    Sk.stdlib.defineThree = function (a, b, c) {
      function d(a) {
        return 'boolean' === typeof a;
      }
      function e(a) {
        return 'number' === typeof a;
      }
      function f(a) {
        return 'string' === typeof a;
      }
      function g(a) {
        return 'undefined' === typeof a;
      }
      function h(a) {
        return 'object' === typeof a && null === a;
      }
      function k(a) {
        return Sk.ffi.isInstance(a, 'Euclidean3');
      }
      function l(c) {
        c = new b.Euclidean3(new b.Vector3(0, 0, 0), c, 0);
        return Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(c, 'Euclidean3'));
      }
      function m(a, b, c, d, e) {
        Sk.ffi.checkArgType('target', a, Sk.ffi.isInstance(b, a), b);
        e = e || c;
        Sk.ffi.checkArgType(e, 'Euclidean3', k(d), d);
        a = Sk.ffi.gattr(d, 'quaternion');
        Sk.ffi.checkArgType(e, 'Quaternion', Sk.ffi.isInstance(a, 'Quaternion'), a);
        Sk.ffi.remapToJs(b)[c] = Sk.ffi.remapToJs(a);
      }
      function n(c) {
        c = new b.Euclidean3(c, new b.Quaternion(0, 0, 0, 0), 0);
        return Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(c, 'Euclidean3'));
      }
      function p(a, b, c, d) {
        d = d || b;
        Sk.ffi.checkArgType(d, 'Euclidean3', k(c), c);
        c = Sk.ffi.gattr(c, 'vector');
        Sk.ffi.checkArgType(d, 'Vector3', Sk.ffi.isInstance(c, 'Vector3'), c);
        a[b] = Sk.ffi.remapToJs(c);
      }
      function q(b) {
        if ('object' !== typeof b)
          throw Sk.ffi.assertionError('target must be an object.');
        if ('function' !== typeof b.add)
          throw Sk.ffi.assertionError('target must have an \'add\' function.');
        return Sk.ffi.callableToPy(a, 'add', function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          b.add(d);
        });
      }
      function r(b) {
        return Sk.ffi.callableToPy(a, 'lookAt', function (a, c) {
          Sk.ffi.checkMethodArgs('lookAt', arguments, 1, 1);
          Sk.ffi.checkArgType('vector', 'Euclidean3', k(c), c);
          var d = Sk.ffi.gattr(c, 'vector');
          Sk.ffi.checkArgType('vector', 'Vector3', Sk.ffi.isInstance(d, 'Vector3'), d);
          Sk.ffi.remapToJs(b).lookAt(Sk.ffi.remapToJs(d));
          return b;
        });
      }
      function v(b) {
        if ('object' !== typeof b)
          throw Sk.ffi.assertionError('target must be an object.');
        if ('function' !== typeof b.remove)
          throw Sk.ffi.assertionError('target must have a \'remove\' function.');
        return Sk.ffi.callableToPy(a, 'add', function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          b.remove(d);
        });
      }
      function s(b) {
        return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
          d.__init__ = Sk.ffi.functionPy(function (a) {
            Sk.ffi.referenceToPy(b, 'vertices', void 0, a);
          });
          d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
            switch (d) {
            case 'append':
              return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                c.__init__ = Sk.ffi.functionPy(function (a) {
                  a.tp$name = 'append';
                });
                c.__call__ = Sk.ffi.functionPy(function (a, c) {
                  b.push(Sk.ffi.remapToJs(c));
                });
                c.__str__ = Sk.ffi.functionPy(function (a) {
                  return Sk.ffi.stringToPy('append');
                });
                c.__repr__ = Sk.ffi.functionPy(function (a) {
                  return Sk.ffi.stringToPy('append');
                });
              }, 'append', []));
            }
          });
          d.__getitem__ = Sk.ffi.functionPy(function (a, c) {
            var d = Sk.ffi.remapToJs(c);
            return n(b[d]);
          });
          d.mp$length = function () {
            return b.length;
          };
          d.__str__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffi.stringToPy('vertices');
          });
          d.__repr__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffi.stringToPy('vertices');
          });
        }, 'vertices', []));
      }
      function z(a, b, c, e) {
        if (g(b))
          throw Error('argName must be specified');
        if (g(c))
          throw Error('functionName must be specified');
        e = g(e) ? !0 : d(e) ? e : !0;
        if (g(a)) {
          if (e)
            return a;
          throw new Sk.builtin.TypeError(c + '.' + b + ' must be convertible to a number, but was Missing.');
        }
        if (h(a)) {
          if (e)
            return a;
          throw new Sk.builtin.TypeError(c + '.' + b + ' must be convertible to a number, but was None.');
        }
        if (d(a))
          throw new Sk.builtin.TypeError(c + '.' + b + ' must be convertible to a number, but was a Boolean.');
        if (a.skType)
          switch (a.skType) {
          case 'float':
            return a.v;
          case 'int':
            return a.v;
          default:
            throw new Sk.builtin.TypeError(c + '(' + b + ': ' + a.skType + ') must be convertible to a number.');
          }
        else {
          if (a.v && f(a.v))
            throw new Sk.builtin.TypeError(c + '.' + b + ' must be convertible to a number, but was a String.');
          throw new Sk.builtin.AssertionError(c + '.' + b + ' is unknown.');
        }
      }
      function y(a, b, c) {
        if (g(a))
          return a;
        if (h(a))
          return null;
        if (a.skType)
          switch (a.skType) {
          case 'float':
            return a.v;
          case 'int':
            return a.v;
          }
        throw new Sk.builtin.AssertionError(c + '.' + b + ' must be an integer.');
      }
      function C(b, c, d) {
        var e = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'aspect':
          return Sk.builtin.assk$(e.aspect, Sk.builtin.nmber.float$);
        case 'position':
          return n(e.position);
        case 'quaternion':
          return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(e.quaternion, 'Quaternion'));
        case 'rotation':
          return n(e.rotation);
        case 'eulerOrder':
          return Sk.ffi.stringToPy(e.eulerOrder);
        case 'scale':
          return n(e.scale);
        case 'up':
          return n(e.up);
        case 'useQuaternion':
          return e.useQuaternion;
        case 'lookAt':
          return r(b);
        case 'updateProjectionMatrix':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'updateProjectionMatrix';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              e[c]();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('updateProjectionMatrix');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('updateProjectionMatrix');
            });
          }, 'updateProjectionMatrix', []));
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(d);
        }
      }
      function t(a, b, c) {
        b = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'id':
          return Sk.ffi.numberToIntPy(b.id);
        case 'name':
          return Sk.ffi.stringToPy(b.name);
        case 'uuid':
          return Sk.ffi.stringToPy(b.uuid);
        case 'vertices':
          return s(b.vertices);
        default:
          throw Sk.ffi.err.attribute(c).isNotGetableOnType(a);
        }
      }
      function B(a, b, c, d) {
        b = Sk.ffi.remapToJs(b);
        var e = Sk.ffi.remapToJs(d);
        switch (c) {
        case 'name':
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
          b.name = e;
          break;
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(a);
        }
      }
      function G(b, c, d) {
        c = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'id':
          return Sk.ffi.numberToIntPy(c.id);
        case 'name':
          return Sk.ffi.stringToPy(c.name);
        case 'uuid':
          return Sk.ffi.stringToPy(c.uuid);
        case 'attitude':
          return l(c.quaternion);
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          return n(c[d]);
        case 'quaternion':
          return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(c.quaternion, 'Quaternion'));
        case 'eulerOrder':
          return Sk.ffi.stringToPy(c.eulerOrder);
        case 'useQuaternion':
          return c.useQuaternion;
        case 'charge':
        case 'mass':
        case 'momentum':
        case 'velocity':
          c = c[d];
          if (k(c))
            return c;
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        case 'add':
          return q(c);
        case 'remove':
          return v(c);
        default:
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        }
      }
      function H(a, b, c, d) {
        var e = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(d);
        switch (c) {
        case 'attitude':
          m(a, b, 'quaternion', d, c);
          break;
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          p(e, c, d);
          break;
        case 'quaternion':
          e.quaternion = g;
          break;
        case 'eulerOrder':
          if (f(g))
            e.eulerOrder = g;
          else
            throw Error(c + ' must be a string');
          break;
        case 'useQuaternion':
          e.useQuaternion = g;
          break;
        case 'charge':
        case 'mass':
        case 'momentum':
        case 'velocity':
          Sk.ffi.checkArgType(c, 'Euclidean3', k(d), d);
          e[c] = d;
          break;
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(a);
        }
      }
      function I(b, c, d) {
        var e = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'color':
          return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(e.color, 'Color'));
        default:
          return G(b, c, d);
        }
      }
      function J(a, c, d, e) {
        var f = Sk.ffi.remapToJs(c), g = Sk.ffi.remapToJs(e);
        switch (d) {
        case 'color':
          f.color = new b.Color(g);
          break;
        default:
          return H(a, c, d, e);
        }
      }
      function M(a, b, c) {
        b = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'id':
          return Sk.ffi.numberToIntPy(b.id);
        case 'name':
          return Sk.ffi.stringToPy(b.name);
        case 'needsUpdate':
          return Sk.ffi.booleanToPy(b.needsUpdate);
        case 'opacity':
          return Sk.ffi.numberToFloatPy(b.opacity);
        case 'overdraw':
          return Sk.ffi.numberToFloatPy(b.overdraw);
        case 'transparent':
          return Sk.ffi.booleanToPy(b.transparent);
        case 'uuid':
          return Sk.ffi.stringToPy(b.uuid);
        case 'visible':
          return Sk.ffi.booleanToPy(b.visible);
        default:
          throw Sk.ffi.err.attribute(c).isNotGetableOnType(a);
        }
      }
      Sk.ffi.checkFunctionArgs('defineThree', arguments, 3, 3);
      Sk.builtin.defineNode(a);
      var K = Sk.ffi.PyType.INT, x = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      Sk.stdlib.CylinderGeometry = function (a, c, d, e, f, g) {
        b.Geometry.call(this);
        this.radiusTop = a = void 0 !== a ? a : 20;
        this.radiusBottom = c = void 0 !== c ? c : 20;
        this.height = d = void 0 !== d ? d : 100;
        this.radialSegments = e = e || 8;
        this.heightSegments = f = f || 1;
        this.openEnded = g = void 0 !== g ? g : !1;
        var h = d / 2, k, l, m = [], n = [];
        for (l = 0; l <= f; l++) {
          var p = [], q = [], r = l / f, s = r * (c - a) + a;
          for (k = 0; k <= e; k++) {
            var t = k / e, v = new b.Vector3();
            v.y = s * Math.sin(2 * t * Math.PI);
            v.z = -r * d + h;
            v.x = s * Math.cos(2 * t * Math.PI);
            this.vertices.push(v);
            p.push(this.vertices.length - 1);
            q.push(new b.Vector2(t, 1 - r));
          }
          m.push(p);
          n.push(q);
        }
        d = (c - a) / d;
        for (k = 0; k < e; k++)
          for (0 !== a ? (p = this.vertices[m[0][k]].clone(), q = this.vertices[m[0][k + 1]].clone()) : (p = this.vertices[m[1][k]].clone(), q = this.vertices[m[1][k + 1]].clone()), p.setY(Math.sqrt(p.x * p.x + p.z * p.z) * d).normalize(), q.setY(Math.sqrt(q.x * q.x + q.z * q.z) * d).normalize(), l = 0; l < f; l++) {
            var r = m[l][k], s = m[l + 1][k], t = m[l + 1][k + 1], v = m[l][k + 1], x = p.clone(), y = p.clone(), z = q.clone(), B = q.clone(), C = n[l][k].clone(), G = n[l + 1][k].clone(), H = n[l + 1][k + 1].clone(), I = n[l][k + 1].clone();
            this.faces.push(new b.Face3(r, s, v, [
              x,
              y,
              B
            ]));
            this.faceVertexUvs[0].push([
              C,
              G,
              I
            ]);
            this.faces.push(new b.Face3(s, t, v, [
              y,
              z,
              B
            ]));
            this.faceVertexUvs[0].push([
              G,
              H,
              I
            ]);
          }
        if (!1 === g && 0 < a)
          for (this.vertices.push(new b.Vector3(0, 0, h)), k = 0; k < e; k++)
            r = m[0][k], s = m[0][k + 1], t = this.vertices.length - 1, x = new b.Vector3(0, 1, 0), y = new b.Vector3(0, 1, 0), z = new b.Vector3(0, 1, 0), C = n[0][k].clone(), G = n[0][k + 1].clone(), H = new b.Vector2(G.u, 0), this.faces.push(new b.Face3(r, s, t, [
              x,
              y,
              z
            ])), this.faceVertexUvs[0].push([
              C,
              G,
              H
            ]);
        if (!1 === g && 0 < c)
          for (this.vertices.push(new b.Vector3(0, 0, -h)), k = 0; k < e; k++)
            r = m[l][k + 1], s = m[l][k], t = this.vertices.length - 1, x = new b.Vector3(0, -1, 0), y = new b.Vector3(0, -1, 0), z = new b.Vector3(0, -1, 0), C = n[l][k + 1].clone(), G = n[l][k].clone(), H = new b.Vector2(G.u, 1), this.faces.push(new b.Face3(r, s, t, [
              x,
              y,
              z
            ])), this.faceVertexUvs[0].push([
              C,
              G,
              H
            ]);
        this.computeCentroids();
        this.computeFaceNormals();
      };
      Sk.stdlib.CylinderGeometry.prototype = Object.create(b.Geometry.prototype);
      Sk.stdlib.PlaneGeometry = function (a, c, d, e) {
        b.Geometry.call(this);
        this.width = a;
        this.height = c;
        this.widthSegments = d || 1;
        this.heightSegments = e || 1;
        var f = a / 2, g = c / 2;
        d = this.widthSegments;
        e = this.heightSegments;
        var h = d + 1, k = e + 1, l = this.width / d, m = this.height / e, n = new b.Vector3(0, 0, 1);
        for (a = 0; a < k; a++)
          for (c = 0; c < h; c++)
            this.vertices.push(new b.Vector3(c * l - f, -(a * m - g), 0));
        for (a = 0; a < e; a++)
          for (c = 0; c < d; c++) {
            var p = c + h * a, f = c + h * (a + 1), g = c + 1 + h * (a + 1), k = c + 1 + h * a, l = new b.Vector2(c / d, 1 - a / e), m = new b.Vector2(c / d, 1 - (a + 1) / e), q = new b.Vector2((c + 1) / d, 1 - (a + 1) / e), r = new b.Vector2((c + 1) / d, 1 - a / e), p = new b.Face3(p, f, k);
            p.normal.copy(n);
            p.vertexNormals.push(n.clone(), n.clone(), n.clone());
            this.faces.push(p);
            this.faceVertexUvs[0].push([
              l,
              m,
              r
            ]);
            p = new b.Face3(f, g, k);
            p.normal.copy(n);
            p.vertexNormals.push(n.clone(), n.clone(), n.clone());
            this.faces.push(p);
            this.faceVertexUvs[0].push([
              m.clone(),
              q,
              r.clone()
            ]);
          }
        this.computeCentroids();
      };
      Sk.stdlib.PlaneGeometry.prototype = Object.create(b.Geometry.prototype);
      Sk.stdlib.RevolutionGeometry = function (a, c, d, e, f, g) {
        b.Geometry.call(this);
        d = d || 12;
        e = e || 0;
        f = f || 2 * Math.PI;
        var h = 0.0001 > Math.abs(2 * Math.PI - Math.abs(f - e)) ? d : d + 1, k = 1 / d, l = (f - e) * k;
        f = 0;
        for (var m = h; f < m; f++)
          for (var n = (e + f * l) / 2, p = Math.cos(n), n = Math.sin(n), q = new b.Quaternion(c.x * n, c.y * n, c.z * n, p), p = 0, n = a.length; p < n; p++) {
            var r = a[p], r = new b.Vector3(r.x, r.y, r.z);
            r.applyQuaternion(q);
            g && r.applyQuaternion(g);
            this.vertices.push(r);
          }
        c = 1 / (a.length - 1);
        e = a.length;
        h *= e;
        f = 0;
        for (m = d; f < m; f++)
          for (p = 0, n = a.length - 1; p < n; p++) {
            d = p + e * f;
            g = (d + e) % h;
            var l = (d + 1 + e) % h, q = (d + 1) % h, r = f * k, s = p * c, t = r + k, v = s + c;
            this.faces.push(new b.Face3(q, g, d % h));
            this.faceVertexUvs[0].push([
              new b.Vector2(r, s),
              new b.Vector2(t, s),
              new b.Vector2(r, v)
            ]);
            this.faces.push(new b.Face3(q, l, g));
            this.faceVertexUvs[0].push([
              new b.Vector2(t, s),
              new b.Vector2(t, v),
              new b.Vector2(r, v)
            ]);
          }
        this.computeCentroids();
        this.computeFaceNormals();
        this.computeVertexNormals();
      };
      Sk.stdlib.RevolutionGeometry.prototype = Object.create(b.Geometry.prototype);
      Sk.stdlib.TorusGeometry = function (a, c, d, e, f) {
        b.Geometry.call(this);
        this.radius = a || 100;
        this.tube = c || 40;
        this.radialSegments = d || 8;
        this.tubularSegments = e || 6;
        this.arc = f || 2 * Math.PI;
        f = new b.Vector3();
        a = [];
        c = [];
        for (d = 0; d <= this.radialSegments; d++)
          for (e = 0; e <= this.tubularSegments; e++) {
            var g = e / this.tubularSegments * this.arc, h = 2 * d / this.radialSegments * Math.PI;
            f.x = this.radius * Math.cos(g);
            f.y = this.radius * Math.sin(g);
            var k = new b.Vector3();
            k.x = (this.radius + this.tube * Math.cos(h)) * Math.cos(g);
            k.y = (this.radius + this.tube * Math.cos(h)) * Math.sin(g);
            k.z = this.tube * Math.sin(h);
            this.vertices.push(k);
            a.push(new b.Vector2(e / this.tubularSegments, d / this.radialSegments));
            c.push(k.clone().sub(f).normalize());
          }
        for (d = 1; d <= this.radialSegments; d++)
          for (e = 1; e <= this.tubularSegments; e++) {
            f = (this.tubularSegments + 1) * d + e - 1;
            var g = (this.tubularSegments + 1) * (d - 1) + e - 1, h = (this.tubularSegments + 1) * (d - 1) + e, k = (this.tubularSegments + 1) * d + e, l = new b.Face3(f, g, k, [
                c[f],
                c[g],
                c[k]
              ]);
            l.normal.add(c[f]);
            l.normal.add(c[g]);
            l.normal.add(c[k]);
            l.normal.normalize();
            this.faces.push(l);
            this.faceVertexUvs[0].push([
              a[f].clone(),
              a[g].clone(),
              a[k].clone()
            ]);
            l = new b.Face3(g, h, k, [
              c[g],
              c[h],
              c[k]
            ]);
            l.normal.add(c[g]);
            l.normal.add(c[h]);
            l.normal.add(c[k]);
            l.normal.normalize();
            this.faces.push(l);
            this.faceVertexUvs[0].push([
              a[g].clone(),
              a[h].clone(),
              a[k].clone()
            ]);
          }
        this.computeCentroids();
      };
      Sk.stdlib.TorusGeometry.prototype = Object.create(b.Geometry.prototype);
      Sk.stdlib.VortexGeometry = function (a, c, d, e, f, g, h) {
        function k(a, b) {
          var c = b % l;
          return c === l - 1 ? k(a, b - 1) : p * ((b - c) / l + c * q);
        }
        b.Geometry.call(this);
        var l = 9;
        this.radius = a || 1;
        this.radiusCone = c || 0.08;
        this.radiusShaft = d || 0.01;
        this.lengthCone = e || 0.2;
        this.lengthShaft = f || 0.8;
        g = g || 6;
        this.circleSegments = g * l;
        this.radialSegments = h || 8;
        h = 2 * Math.PI;
        var m = this.radius, n = new b.Vector3();
        a = [];
        e = [];
        var p = h / g, q = this.lengthShaft / (this.lengthCone + this.lengthShaft) / (l - 2);
        for (g = 0; g <= this.radialSegments; g++) {
          f = h * g / this.radialSegments;
          var r = Math.cos(f), s = Math.sin(f);
          for (f = 0; f <= this.circleSegments; f++) {
            var t = k(this.circleSegments, f), v = Math.cos(t), t = Math.sin(t);
            n.x = m * v;
            n.y = m * t;
            var x = new b.Vector3(), y = f % l === l - 1 ? c : d;
            x.x = (m + y * r) * v;
            x.y = (m + y * r) * t;
            x.z = y * s;
            this.vertices.push(x);
            a.push(new b.Vector2(f / this.circleSegments, g / this.radialSegments));
            e.push(x.clone().sub(n).normalize());
          }
        }
        for (g = 1; g <= this.radialSegments; g++)
          for (f = 1; f <= this.circleSegments; f++)
            c = (this.circleSegments + 1) * g + f - 1, d = (this.circleSegments + 1) * (g - 1) + f - 1, h = (this.circleSegments + 1) * (g - 1) + f, m = (this.circleSegments + 1) * g + f, n = new b.Face3(c, d, m, [
              e[c],
              e[d],
              e[m]
            ]), n.normal.add(e[c]), n.normal.add(e[d]), n.normal.add(e[m]), n.normal.normalize(), this.faces.push(n), this.faceVertexUvs[0].push([
              a[c].clone(),
              a[d].clone(),
              a[m].clone()
            ]), n = new b.Face3(d, h, m, [
              e[d],
              e[h],
              e[m]
            ]), n.normal.add(e[d]), n.normal.add(e[h]), n.normal.add(e[m]), n.normal.normalize(), this.faces.push(n), this.faceVertexUvs[0].push([
              a[d].clone(),
              a[h].clone(),
              a[m].clone()
            ]);
        this.computeCentroids();
      };
      Sk.stdlib.VortexGeometry.prototype = Object.create(b.Geometry.prototype);
      Sk.builtin.defineEuclidean3(a, b, c);
      a.Scene = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.isUndefined(c) ? (Sk.ffi.checkMethodArgs('Scene', arguments, 0, 0), Sk.ffi.referenceToPy(new b.Scene(), 'Scene', void 0, a)) : Sk.ffi.isInstance(c, 'Scene') ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Scene', void 0, a) : Sk.ffi.checkMethodArgs('Scene', arguments, 0, 0);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'position':
            return n(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return n(d.rotation);
          case 'eulerOrder':
            return Sk.ffi.stringToPy(d.eulerOrder);
          case 'scale':
            return n(d.scale);
          case 'up':
            return n(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return r(b);
          case 'add':
            return q(d);
          case 'remove':
            return v(d);
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          var d = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            p(a, b, c);
            break;
          case 'quaternion':
            a.quaternion = d;
            break;
          case 'eulerOrder':
            if (f(d))
              a.eulerOrder = d;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            a.useQuaternion = d;
            break;
          default:
            throw Error(b + ' is not a write attribute of Scene');
          }
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Scene');
        });
      }, 'Scene', []);
      a.CanvasRenderer = Sk.ffi.buildClass(a, function (c, e) {
        e.__init__ = Sk.ffi.functionPy(function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new b.CanvasRenderer(d), 'CanvasRenderer', void 0, a);
        });
        e.setSize = Sk.ffi.functionPy(function (a, b, c) {
          a.v.setSize(Sk.builtin.asnum$(b), Sk.builtin.asnum$(c));
        });
        e.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'autoClear':
            return d.autoClear;
          case 'gammaInput':
            return d.gammaInput;
          case 'gammaOutput':
            return d.gammaOutput;
          case 'sortObjects':
            return d.sortObjects;
          case 'canvas':
          case 'domElement':
            return Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(d.domElement, 'Node'));
          case 'render':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'render';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                d.render(b, c);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('render');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('render');
              });
            }, 'render', []));
          case 'getClearColor':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getClearColor';
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.getClearColor(), 'Color'));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('getClearColor');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('getClearColor');
              });
            }, 'getClearColor', []));
          case 'setClearColor':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setClearColor';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                d.setClearColor(b, c);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setClearColor');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setClearColor');
              });
            }, 'setClearColor', []));
          case 'setSize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setSize';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, e) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.setSize(b, c, e);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setSize');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setSize');
              });
            }, 'setSize', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('CanvasRenderer');
          }
        });
        e.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'autoClear':
            if (d(c))
              a.autoClear = c;
            else
              throw new Sk.builtin.TypeError('\'autoClear\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaInput':
            if (d(c))
              a.gammaInput = c;
            else
              throw new Sk.builtin.TypeError('\'gammaInput\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaOutput':
            if (d(c))
              a.gammaOutput = c;
            else
              throw new Sk.builtin.TypeError('\'gammaOutput\' attribute must be a <type \'bool\'>.');
            break;
          case 'sortObjects':
            if (d(c))
              a.sortObjects = c;
            else
              throw new Sk.builtin.TypeError('\'sortObjects\' attribute must be a <type \'bool\'>.');
            break;
          case 'size':
            b = Sk.builtin.asnum$(c[0]);
            c = Sk.builtin.asnum$(c[1]);
            a.setSize(b, c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('CanvasRenderer');
          }
        });
        e.__str__ = Sk.ffi.functionPy(function (a) {
          a = a.v;
          var b = {};
          b.autoClear = a.autoClear;
          b.gammaInput = a.gammaInput;
          b.gammaOutput = a.gammaOutput;
          return Sk.ffi.stringToPy('CanvasRenderer(' + JSON.stringify(b) + ')');
        });
        e.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CanvasRenderer(' + [{ autoClear: a.v.autoClear }].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CanvasRenderer', []);
      a.WebGLRenderer = Sk.ffi.buildClass(a, function (c, e) {
        e.__init__ = Sk.ffi.functionPy(function (a, c) {
          0 < Sk.ffi.checkMethodArgs('WebGLRenderer', arguments, 0, 1) && Sk.ffi.checkArgType('parameters', Sk.ffi.PyType.DICT, Sk.ffi.isDict(c), c);
          var d = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new b.WebGLRenderer(d), 'WebGLRenderer', void 0, a);
        });
        e.setSize = Sk.ffi.functionPy(function (a, b, c) {
          a.v.setSize(Sk.builtin.asnum$(b), Sk.builtin.asnum$(c));
        });
        e.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'autoClear':
            return Sk.ffi.booleanToPy(d.autoClear);
          case 'gammaInput':
            return Sk.ffi.booleanToPy(d.gammaInput);
          case 'gammaOutput':
            return Sk.ffi.booleanToPy(d.gammaOutput);
          case 'sortObjects':
            return d.sortObjects;
          case 'canvas':
          case 'domElement':
            return Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(d.domElement, 'Node'));
          case 'render':
            return Sk.ffi.callableToPy(a, 'render', function (a, b, c) {
              Sk.ffi.checkMethodArgs('getClearColor', arguments, 2, 2);
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              return Sk.ffi.remapToPy(d.render(e, f));
            });
          case 'getClearColor':
            return Sk.ffi.callableToPy(a, 'getClearColor', function (b) {
              Sk.ffi.checkMethodArgs('getClearColor', arguments, 0, 0);
              return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.getClearColor(), 'Color'));
            });
          case 'setClearColor':
            return Sk.ffi.callableToPy(a, 'setClearColor', function (a, b, c) {
              Sk.ffi.checkMethodArgs('setClearColor', arguments, 2, 2);
              Sk.ffi.checkArgType('color', [
                'Color',
                Sk.ffi.PyType.INT
              ], Sk.ffi.isInstance(b, 'Color') || Sk.ffi.isInt(b), b);
              Sk.ffi.checkArgType('alpha', x, Sk.ffi.isNum(c), c);
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              return Sk.ffi.remapToPy(d.setClearColor(e, f));
            });
          case 'setSize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setSize';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, e) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.setSize(b, c, e);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setSize');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setSize');
              });
            }, 'setSize', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('WebGLRenderer');
          }
        });
        e.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'autoClear':
            if (d(c))
              a.autoClear = c;
            else
              throw new Sk.builtin.TypeError('\'autoClear\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaInput':
            if (d(c))
              a.gammaInput = c;
            else
              throw new Sk.builtin.TypeError('\'gammaInput\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaOutput':
            if (d(c))
              a.gammaOutput = c;
            else
              throw new Sk.builtin.TypeError('\'gammaOutput\' attribute must be a <type \'bool\'>.');
            break;
          case 'sortObjects':
            if (d(c))
              a.sortObjects = c;
            else
              throw new Sk.builtin.TypeError('\'sortObjects\' attribute must be a <type \'bool\'>.');
            break;
          case 'size':
            b = Sk.builtin.asnum$(c[0]);
            c = Sk.builtin.asnum$(c[1]);
            a.setSize(b, c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('WebGLRenderer');
          }
        });
        e.__str__ = Sk.ffi.functionPy(function (a) {
          a = a.v;
          var b = {};
          b.autoClear = a.autoClear;
          b.gammaInput = a.gammaInput;
          b.gammaOutput = a.gammaOutput;
          return Sk.ffi.stringToPy('WebGLRenderer(' + JSON.stringify(b) + ')');
        });
        e.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('WebGLRenderer(' + [{ autoClear: a.v.autoClear }].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'WebGLRenderer', []);
      a.Color = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          Sk.ffi.isUndefined(c) ? Sk.ffi.referenceToPy(new b.Color(), 'Color', void 0, a) : Sk.ffi.isInt(c) || Sk.ffi.isStr(c) ? Sk.ffi.referenceToPy(new b.Color(d), 'Color', void 0, a) : Sk.ffi.isInstance(c, 'Color') ? Sk.ffi.referenceToPy(d, 'Color', void 0, a) : Sk.ffi.checkArgType('value', [
            Sk.ffi.PyType.INT,
            Sk.ffi.PyType.STR,
            'Color'
          ], !1, d);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'r':
            return Sk.ffi.numberToIntPy(d.r);
          case 'g':
            return Sk.ffi.numberToIntPy(d.g);
          case 'b':
            return Sk.ffi.numberToIntPy(d.b);
          case 'getHex':
            return Sk.ffi.callableToPy(a, 'getHex', function (a) {
              return Sk.ffi.numberToIntPy(d.getHex());
            });
          case 'getHexString':
            return Sk.ffi.callableToPy(a, 'getHexString', function (a) {
              return Sk.ffi.stringToPy(d.getHexString());
            });
          case 'setRGB':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setRGB';
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f) {
                a = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                d.setRGB(a, e, f);
                return b;
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setRGB');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setRGB');
              });
            }, 'setRGB', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Color');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'r':
          case 'g':
          case 'b':
            Sk.ffi.checkArgType(b, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT
            ], Sk.ffi.isFloat(c) || Sk.ffi.isInt(c), c);
            a.r = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Color');
          }
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.r = a.r;
          b.g = a.g;
          b.b = a.b;
          return Sk.ffi.stringToPy('Color(' + JSON.stringify(b) + ')');
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Color(' + [
            a.r,
            a.g,
            a.b
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'Color', []);
      a.PerspectiveCamera = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.checkMethodArgs('PerspectiveCamera', arguments, 0, 4);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('fov', x, Sk.ffi.isNum(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('aspect', x, Sk.ffi.isNum(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('near', x, Sk.ffi.isNum(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('far', x, Sk.ffi.isNum(f), f);
          var g = Sk.ffi.remapToJs(c), h = Sk.ffi.remapToJs(d), k = Sk.ffi.remapToJs(e), l = Sk.ffi.remapToJs(f);
          Sk.ffi.referenceToPy(new b.PerspectiveCamera(g, h, k, l), 'PerspectiveCamera', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'aspect':
            return Sk.builtin.assk$(d.aspect, Sk.builtin.nmber.float$);
          case 'position':
            return n(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return n(d.rotation);
          case 'eulerOrder':
            return Sk.ffi.stringToPy(d.eulerOrder);
          case 'scale':
            return n(d.scale);
          case 'up':
            return n(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return r(b);
          case 'updateProjectionMatrix':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'updateProjectionMatrix';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                d[c]();
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('updateProjectionMatrix');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('updateProjectionMatrix');
              });
            }, 'updateProjectionMatrix', []));
          default:
            return C(b, c, 'PerspectiveCamera');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'aspect':
            d.aspect = e;
            break;
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            p(d, b, c);
            break;
          case 'quaternion':
            d.quaternion = e;
            break;
          case 'eulerOrder':
            if (f(e))
              d.eulerOrder = e;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            d.useQuaternion = e;
            break;
          default:
            switch (a = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(c), b) {
            case 'position':
            case 'rotation':
            case 'scale':
            case 'up':
              p(a, b, c);
              break;
            case 'quaternion':
              a.quaternion = d;
              break;
            case 'eulerOrder':
              if (f(d))
                a.eulerOrder = d;
              else
                throw Error(b + ' must be a string');
              break;
            case 'useQuaternion':
              a.useQuaternion = d;
              break;
            default:
              throw Sk.ffi.err.attribute(b).isNotSetableOnType('PerspectiveCamera');
            }
          }
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.fov = a.fov;
          b.aspect = a.aspect;
          b.near = a.near;
          b.far = a.far;
          return Sk.ffi.stringToPy('PerspectiveCamera(' + JSON.stringify(b) + ')');
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('PerspectiveCamera(' + [
            a.fov,
            a.aspect,
            a.near,
            a.far
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'PerspectiveCamera', []);
      a.OrthographicCamera = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f, g, h) {
          c = Sk.builtin.asnum$(c);
          d = Sk.builtin.asnum$(d);
          e = Sk.builtin.asnum$(e);
          f = Sk.builtin.asnum$(f);
          g = Sk.builtin.asnum$(g);
          h = Sk.builtin.asnum$(h);
          a.v = new b.OrthographicCamera(c, d, e, f, g, h);
          a.tp$name = 'OrthographicCamera';
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'aspect':
            return Sk.ffi.numberToFloatPy(d.aspect);
          case 'position':
            return n(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return n(d.rotation);
          case 'eulerOrder':
            return Sk.ffi.stringToPy(d.eulerOrder);
          case 'scale':
            return n(d.scale);
          case 'up':
            return n(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return r(b);
          case 'updateProjectionMatrix':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'updateProjectionMatrix';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                d[c]();
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('updateProjectionMatrix');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('updateProjectionMatrix');
              });
            }, 'updateProjectionMatrix', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('OrthographicCamera');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          var d = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'left':
            a.left = d;
            break;
          case 'right':
            a.right = d;
            break;
          case 'top':
            a.top = d;
            break;
          case 'bottom':
            a.bottom = d;
            break;
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            p(a, b, c);
            break;
          case 'quaternion':
            a.quaternion = d;
            break;
          case 'eulerOrder':
            if (f(d))
              a.eulerOrder = d;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            a.useQuaternion = d;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('OrthographicCamera');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('OrthographicCamera(' + [
            a.left,
            a.right,
            a.top,
            a.bottom,
            a.near,
            a.far
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('OrthographicCamera');
        });
      }, 'OrthographicCamera', []);
      a.ArrowGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f, g, h, k) {
          Sk.ffi.checkMethodArgs('ArrowGeometry', arguments, 0, 6);
          var l, m, n;
          if (Sk.ffi.isDefined(c)) {
            if (Sk.ffi.isInstance(c, 'ArrowGeometry')) {
              Sk.ffi.checkMethodArgs('ArrowGeometry', arguments, 1, 1);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'ArrowGeometry', void 0, a);
              return;
            }
            Sk.ffi.checkArgType('scale', x, Sk.ffi.isNum(c), c);
            l = Sk.ffi.remapToJs(c);
          } else
            l = 1;
          Sk.ffi.isDefined(d) ? (Sk.ffi.checkArgType('attitude', 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d), m = Sk.ffi.remapToJs(d).quaternion) : m = new b.Quaternion(0, 0, 0, 1);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('segments', K, Sk.ffi.isNum(e), e);
          Sk.ffi.isDefined(f) ? (Sk.ffi.checkArgType('scale', x, Sk.ffi.isNum(f), f), n = Sk.ffi.remapToJs(f) * l) : n = l;
          var p = Sk.ffi.remapToJs(e);
          g = (Sk.ffi.remapToJs(g) || 0.01) * l;
          h = (Sk.ffi.remapToJs(h) || 0.08) * l;
          k = (Sk.ffi.remapToJs(k) || 0.2) * l;
          var q = n - k, r = n / 2;
          n = new b.Vector3(0, 0, r);
          l = new b.Vector3(h, 0, q - r);
          var q = new b.Vector3(g, 0, q - r), w = new b.Vector3(g, 0, -r), r = new b.Vector3(0, 0, -r);
          n = [
            n,
            l,
            q,
            w,
            r
          ];
          l = new b.Quaternion(0, 0, 1, 0);
          Sk.ffi.referenceToPy(new Sk.stdlib.RevolutionGeometry(n, l, p, 0, 2 * Math.PI, m), 'ArrowGeometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'id':
            return Sk.ffi.numberToIntPy(c.id);
          case 'uuid':
            return Sk.ffi.stringToPy(c.uuid);
          case 'name':
            return Sk.ffi.stringToPy(c.name);
          case 'vertices':
            return s(c.vertices);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('ArrowGeometry');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'name':
            Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            a.name = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('ArrowGeometry');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ArrowGeometry(' + JSON.stringify({}) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ArrowGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'ArrowGeometry', []);
      a.CircleGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.checkMethodArgs('CircleGeometry', arguments, 0, 4);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('radius', x, Sk.ffi.isNum(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('segments', K, Sk.ffi.isInt(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('thetaStart', x, Sk.ffi.isNum(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('thetaLength', x, Sk.ffi.isNum(f), f);
          Sk.ffi.referenceToPy(new b.CircleGeometry(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f)), 'CircleGeometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'id':
            return Sk.ffi.numberToIntPy(c.id);
          case 'uuid':
            return Sk.ffi.stringToPy(c.uuid);
          case 'name':
            return Sk.ffi.stringToPy(c.name);
          case 'vertices':
            return s(c.vertices);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('CircleGeometry');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'name':
            Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            a.name = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('CircleGeometry');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CircleGeometry(' + JSON.stringify({}) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CircleGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CircleGeometry', []);
      a.CubeGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f, g, h) {
          Sk.ffi.checkMethodArgs('CubeGeometry', arguments, 3, 6);
          Sk.ffi.checkArgType('width', x, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('height', x, Sk.ffi.isNum(d), d);
          Sk.ffi.checkArgType('depth', x, Sk.ffi.isNum(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('widthSegments', K, Sk.ffi.isInt(f), f);
          Sk.ffi.isDefined(g) && Sk.ffi.checkArgType('heightSegments', K, Sk.ffi.isInt(g), g);
          Sk.ffi.isDefined(h) && Sk.ffi.checkArgType('depthSegments', K, Sk.ffi.isInt(h), h);
          var k = Sk.ffi.remapToJs(c), l = Sk.ffi.remapToJs(d), m = Sk.ffi.remapToJs(e), n = Sk.ffi.remapToJs(f), p = Sk.ffi.remapToJs(g), q = Sk.ffi.remapToJs(h);
          Sk.ffi.referenceToPy(new b.CubeGeometry(k, l, m, n, p, q), 'CubeGeometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'width':
          case 'height':
          case 'depth':
            return Sk.ffi.numberToFloatPy(c[b]);
          case 'widthSegments':
          case 'heightSegments':
          case 'depthSegments':
            return Sk.ffi.numberToIntPy(c[b]);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('CubeGeometry');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('CubeGeometry');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.width = a.width;
          b.height = a.height;
          b.depth = a.depth;
          return Sk.ffi.stringToPy('CubeGeometry(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('CubeGeometry(' + [
            a.width,
            a.height,
            a.depth,
            a.widthSegments,
            a.heightSegments,
            a.depthSegments
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CubeGeometry', []);
      a.CylinderGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g) {
          if (Sk.ffi.isInstance(b, 'CylinderGeometry'))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'CylinderGeometry', void 0, a);
          else {
            Sk.ffi.checkMethodArgs('CylinderGeometry', arguments, 0, 6);
            Sk.ffi.checkArgType('radiusTop', x, Sk.ffi.isNum(b) || Sk.ffi.isUndefined(b), b);
            Sk.ffi.checkArgType('radiusBottom', x, Sk.ffi.isNum(c) || Sk.ffi.isUndefined(c), c);
            Sk.ffi.checkArgType('height', x, Sk.ffi.isNum(d) || Sk.ffi.isUndefined(d), d);
            Sk.ffi.checkArgType('radialSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(e) || Sk.ffi.isUndefined(e), e);
            Sk.ffi.checkArgType('heightSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(f) || Sk.ffi.isUndefined(f), f);
            Sk.ffi.checkArgType('openEnded', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(g) || Sk.ffi.isUndefined(g), g);
            var h = Sk.ffi.remapToJs(b), k = Sk.ffi.remapToJs(c), l = Sk.ffi.remapToJs(d), m = Sk.ffi.remapToJs(e), n = Sk.ffi.remapToJs(f), p = Sk.ffi.remapToJs(g);
            Sk.ffi.referenceToPy(new Sk.stdlib.CylinderGeometry(h, k, l, m, n, p), 'CylinderGeometry', void 0, a);
          }
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radiusTop':
            return Sk.ffi.numberToFloatPy(c.radiusTop);
          case 'radiusBottom':
            return Sk.ffi.numberToFloatPy(c.radiusBottom);
          case 'height':
            return Sk.ffi.numberToFloatPy(c.height);
          case 'radialSegments':
            return Sk.ffi.numberToIntPy(c.radialSegments);
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          case 'openEnded':
            return Sk.ffi.booleanToPy(c.openEnded);
          default:
            return t('CylinderGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return B('CylinderGeometry', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radiusTop = a.radiusTop;
          b.radiusBottom = a.radiusBottom;
          b.height = a.height;
          b.openEnded = a.openEnded;
          return Sk.ffi.stringToPy('CylinderGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('CylinderGeometry(' + [
            a.radiusTop,
            a.radiusBottom,
            a.height,
            a.radialSegments,
            a.heightSegments,
            a.openEnded
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CylinderGeometry', []);
      a.LatheGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.checkMethodArgs('LatheGeometry', arguments, 1, 4);
          var g = Sk.ffi.remapToJs(c).map(function (a) {
              return new b.Vector3(a.x, a.y, a.z);
            }), h = new b.Quaternion(0, 0, 1, 0);
          Sk.ffi.referenceToPy(new Sk.stdlib.RevolutionGeometry(g, h, Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f)), 'LatheGeometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'id':
            return Sk.ffi.numberToIntPy(c.id);
          case 'name':
            return Sk.ffi.stringToPy(c.name);
          case 'vertices':
            return s(c.vertices);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('LatheGeometry');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          case 'name':
            Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            a.name = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('LatheGeometry');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('LatheGeometry(' + JSON.stringify({}) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('LatheGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'LatheGeometry', []);
      a.IcosahedronGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.ffi.checkMethodArgs('IcosahedronGeometry', arguments, 0, 2);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('radius', x, Sk.ffi.isNum(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('detail', K, Sk.ffi.isInt(d), d);
          var e = Sk.ffi.remapToJs(c), f = Sk.ffi.remapToJs(d);
          Sk.ffi.referenceToPy(new b.IcosahedronGeometry(e, f), 'IcosahedronGeometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'detail':
            return Sk.ffi.numberToIntPy(c.detail);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('IcosahedronGeometry');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('IcosahedronGeometry');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.detail = a.detail;
          return Sk.ffi.stringToPy('IcosahedronGeometry(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('IcosahedronGeometry(' + [
            a.radius,
            a.detail
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'IcosahedronGeometry', []);
      a.OctahedronGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.ffi.checkMethodArgs('OctahedronGeometry', arguments, 0, 2);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('radius', x, Sk.ffi.isNum(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('detail', K, Sk.ffi.isInt(d), d);
          var e = Sk.ffi.remapToJs(c), f = Sk.ffi.remapToJs(d), g = new b.OctahedronGeometry(e, f);
          g.radius = e;
          g.detail = f;
          Sk.ffi.referenceToPy(g, 'OctahedronGeometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'detail':
            return Sk.ffi.numberToIntPy(c.detail);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('OctahedronGeometry');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('OctahedronGeometry');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.detail = a.detail;
          return Sk.ffi.stringToPy('OctahedronGeometry(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('OctahedronGeometry(' + [
            a.radius,
            a.detail
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'OctahedronGeometry', []);
      a.PlaneGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('PlaneGeometry', arguments, 2, 5);
          Sk.ffi.checkArgType('width', x, Sk.ffi.isNum(b), b);
          Sk.ffi.checkArgType('depth', x, Sk.ffi.isNum(c), c);
          var f = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(c);
          d = y(d, 'widthSegments', 'PlaneGeometry');
          e = y(e, 'heightSegments', 'PlaneGeometry');
          Sk.ffi.referenceToPy(new Sk.stdlib.PlaneGeometry(f, g, d, e), 'PlaneGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'width':
            return Sk.ffi.numberToFloatPy(c.width);
          case 'depth':
          case 'height':
            return Sk.ffi.numberToFloatPy(c.height);
          case 'widthSegments':
            return Sk.ffi.numberToIntPy(c.widthSegments);
          case 'depthSegments':
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          default:
            return t('PlaneGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return B('PlaneGeometry', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.width = a.width;
          b.depth = a.height;
          return Sk.ffi.stringToPy('PlaneGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('PlaneGeometry(' + [
            a.width,
            a.height,
            a.widthSegments,
            a.heightSegments
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'PlaneGeometry', []);
      a.RevolutionGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f, g, h) {
          Sk.ffi.checkMethodArgs('RevolutionGeometry', arguments, 2, 5);
          Sk.ffi.checkArgType('points', Sk.ffi.PyType.LIST, Sk.ffi.isList(c), c);
          Sk.ffi.checkArgType('generator', 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('segments', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('phiStart', x, Sk.ffi.isNum(f), f);
          Sk.ffi.isDefined(g) && Sk.ffi.checkArgType('phiLength', x, Sk.ffi.isNum(g), g);
          Sk.ffi.isDefined(h) && Sk.ffi.checkArgType('attitude', 'Euclidean3', Sk.ffi.isInstance(h, 'Euclidean3'), h);
          var k = Sk.ffi.remapToJs(c).map(function (a) {
              return new b.Vector3(a.x, a.y, a.z);
            }), l = Sk.ffi.remapToJs(h), l = Sk.ffi.remapToJs(h) ? Sk.ffi.remapToJs(h).quaternion : void 0;
          Sk.ffi.referenceToPy(new Sk.stdlib.RevolutionGeometry(k, Sk.ffi.remapToJs(d).quaternion, Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f), Sk.ffi.remapToJs(g), l), 'RevolutionGeometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'vertices':
            return s(c.vertices);
          default:
            return t('RevolutionGeometry', a, b);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            return B('RevolutionGeometry', a, b, c);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('RevolutionGeometry(' + JSON.stringify({}) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('RevolutionGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'RevolutionGeometry', []);
      a.SphereGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f, g, h, k) {
          if (Sk.ffi.isDefined(c)) {
            if (Sk.ffi.isInstance(c, 'SphereGeometry')) {
              Sk.ffi.checkMethodArgs('SphereGeometry', arguments, 1, 1);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'SphereGeometry', void 0, a);
              return;
            }
            Sk.ffi.checkArgType('radius', x, Sk.ffi.isNum(c), c);
          }
          var l = Sk.ffi.remapToJs(c);
          d = y(d, 'widthSegments', 'SphereGeometry');
          e = y(e, 'heightSegments', 'SphereGeometry');
          f = z(f, 'phiStart', 'SphereGeometry');
          g = z(g, 'phiLength', 'SphereGeometry');
          h = z(h, 'thetaStart', 'SphereGeometry');
          k = z(k, 'thetaLength', 'SphereGeometry');
          Sk.ffi.referenceToPy(new b.SphereGeometry(l, d, e, f, g, h, k), 'SphereGeometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'widthSegments':
            return Sk.ffi.numberToIntPy(c.widthSegments);
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          case 'phiStart':
            return Sk.ffi.numberToFloatPy(c.phiStart);
          case 'phiLength':
            return Sk.ffi.numberToFloatPy(c.phiLength);
          case 'thetaStart':
            return Sk.ffi.numberToFloatPy(c.thetaStart);
          case 'thetaLength':
            return Sk.ffi.numberToFloatPy(c.thetaLength);
          default:
            return t('SphereGeometry', a, b);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return B('SphereGeometry', a, b, c);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a).radius;
          var b = {};
          b.radius = a;
          return Sk.ffi.stringToPy('SphereGeometry(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('SphereGeometry(' + [
            a.radius,
            a.widthSegments,
            a.heightSegments,
            a.phiStart,
            a.phiLength,
            a.thetaStart,
            a.thetaLength
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'SphereGeometry', []);
      a.TetrahedronGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.ffi.checkMethodArgs('TetrahedronGeometry', arguments, 2, 2);
          Sk.ffi.checkArgType('radius', x, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('detail', K, Sk.ffi.isInt(d), d);
          var e = Sk.ffi.remapToJs(c), f = Sk.ffi.remapToJs(d), g = new b.TetrahedronGeometry(e, f);
          g.radius = e;
          g.detail = f;
          Sk.ffi.referenceToPy(g, 'TetrahedronGeometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'detail':
            return Sk.ffi.numberToIntPy(c.detail);
          default:
            return t('TetrahedronGeometry', a, b);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return B('TetrahedronGeometry', a, b, c);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.detail = a.detail;
          return Sk.ffi.stringToPy('TetrahedronGeometry(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('TetrahedronGeometry(' + [
            a.radius,
            a.detail
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'TetrahedronGeometry', []);
      a.TextGeometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          c = Sk.ffi.remapToJs(c);
          d = Sk.ffi.remapToJs(d);
          a.v = new b.TextGeometry(c, d);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('TextGeometry');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Error(b + ' is not an attribute of TextGeometry');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('TextGeometry(' + JSON.stringify({}) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('TextGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'TextGeometry', []);
      a.TorusGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f) {
          Sk.ffi.checkMethodArgs('TorusGeometry', arguments, 0, 5);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('radius', x, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('tube', x, Sk.ffi.isNum(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('radialSegments', K, Sk.ffi.isInt(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('tubularSegments', K, Sk.ffi.isInt(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('arc', x, Sk.ffi.isNum(f), f);
          var g = Sk.ffi.remapToJs(b), h = Sk.ffi.remapToJs(c), k = Sk.ffi.remapToJs(d), l = Sk.ffi.remapToJs(e), m = Sk.ffi.remapToJs(f), g = new Sk.stdlib.TorusGeometry(g, h, k, l, m);
          Sk.ffi.referenceToPy(g, 'TorusGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'tube':
            return Sk.ffi.numberToFloatPy(c.tube);
          case 'radialSegments':
            return Sk.ffi.numberToIntPy(c.radialSegments);
          case 'tubularSegments':
            return Sk.ffi.numberToIntPy(c.tubularSegments);
          case 'arc':
            return Sk.ffi.numberToFloatPy(c.arc);
          default:
            return t('TorusGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return B('TorusGeometry', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.tube = a.tube;
          b.arc = a.arc;
          return Sk.ffi.stringToPy('TorusGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('TorusGeometry(' + [
            a.radius,
            a.tube,
            a.radialSegments,
            a.tubularSegments,
            a.arc
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'TorusGeometry', []);
      a.VortexGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g, h) {
          Sk.ffi.checkMethodArgs('VortexGeometry', arguments, 7, 7);
          Sk.ffi.checkArgType('radius', x, Sk.ffi.isNum(b), b);
          Sk.ffi.checkArgType('radiusCone', x, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('radiusShaft', x, Sk.ffi.isNum(d), d);
          var k = Sk.ffi.remapToJs(b), l = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(d), n = Sk.ffi.remapToJs(e), p = Sk.ffi.remapToJs(f);
          g = y(g, 'widthSegments', 'VortexGeometry');
          h = y(h, 'heightSegments', 'VortexGeometry');
          k = new Sk.stdlib.VortexGeometry(k, l, m, n, p, g, h);
          Sk.ffi.referenceToPy(k, 'VortexGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'radiusShaft':
            return Sk.ffi.numberToFloatPy(c.radiusShaft);
          case 'widthSegments':
            return Sk.ffi.numberToIntPy(c.widthSegments);
          case 'depthSegments':
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          default:
            return t('VortexGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return B('VortexGeometry', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.width = a.width;
          b.depth = a.height;
          return Sk.ffi.stringToPy('VortexGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('VortexGeometry(' + [
            a.width,
            a.height,
            a.widthSegments,
            a.heightSegments
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'VortexGeometry', []);
      a.Geometry = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c) {
          'undefined' !== typeof c ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Geometry', void 0, a) : Sk.ffi.referenceToPy(new b.Geometry(), 'Geometry', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return t('Geometry', a, b);
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return B('Geometry', a, b, c);
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Geometry(' + JSON.stringify({}) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Geometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'Geometry', []);
      a.Object3D = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.referenceToPy(new b.Object3D(), 'Object3D', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return G('Object3D', a, b);
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return H('Object3D', a, b, c);
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Object3D(' + JSON.stringify({}) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Object3D(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'Object3D', []);
      a.AmbientLight = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new b.AmbientLight(d), 'AmbientLight', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return I('AmbientLight', a, b);
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return J('AmbientLight', a, b, c);
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          return Sk.ffi.stringToPy('AmbientLight(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = [Sk.ffi.remapToJs(a).color];
          return Sk.ffi.stringToPy('AmbientLight(' + a.map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'AmbientLight', []);
      a.DirectionalLight = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.ffi.checkMethodArgs('DirectionalLight', arguments, 1, 2);
          Sk.ffi.checkArgType('intensity', x, Sk.ffi.isNum(d) || Sk.ffi.isUndefined(d), d);
          var e = Sk.ffi.remapToJs(c), f = Sk.ffi.remapToJs(d);
          Sk.ffi.referenceToPy(new b.DirectionalLight(e, f), 'DirectionalLight', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'intensity':
            return Sk.ffi.numberToFloatPy(c.intensity);
          default:
            return I('DirectionalLight', a, b);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'intensity':
            Sk.ffi.checkArgType('intensity', x, Sk.ffi.isNum(c), c);
            d.intensity = e;
            break;
          default:
            return J('DirectionalLight', a, b, c);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.intensity = a.intensity;
          b.distance = a.distance;
          return Sk.ffi.stringToPy('DirectionalLight(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('DirectionalLight(' + [
            a.color,
            a.intensity,
            a.distance
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'DirectionalLight', []);
      a.PointLight = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c, d, e) {
          Sk.ffi.checkMethodArgs('PointLight', arguments, 1, 3);
          Sk.ffi.checkArgType('color', [
            'Color',
            Sk.ffi.PyType.INT
          ], Sk.ffi.isInstance(c, 'Color') || Sk.ffi.isInt(c), c);
          Sk.ffi.checkArgType('intensity', x, Sk.ffi.isNum(d) || Sk.ffi.isUndefined(d), d);
          Sk.ffi.checkArgType('distance', x, Sk.ffi.isNum(e) || Sk.ffi.isUndefined(e), e);
          var f = Sk.ffi.remapToJs(c), g = Sk.ffi.remapToJs(d), h = Sk.ffi.remapToJs(e);
          Sk.ffi.referenceToPy(new b.PointLight(f, g, h), 'PointLight', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          case 'distance':
            return Sk.ffi.numberToFloatPy(Sk.ffi.remapToJs(a).distance);
          case 'intensity':
            return Sk.ffi.numberToFloatPy(Sk.ffi.remapToJs(a).intensity);
          default:
            return I('PointLight', a, b);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          case 'distance':
            Sk.ffi.checkArgType('distance', x, Sk.ffi.isNum(c), c);
            Sk.ffi.remapToJs(a).distance = Sk.ffi.remapToJs(c);
            break;
          case 'intensity':
            Sk.ffi.checkArgType('intensity', x, Sk.ffi.isNum(c), c);
            Sk.ffi.remapToJs(a).intensity = Sk.ffi.remapToJs(c);
            break;
          default:
            return J('PointLight', a, b, c);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.intensity = a.intensity;
          b.distance = a.distance;
          return Sk.ffi.stringToPy('PointLight(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('PointLight(' + [
            a.color,
            a.intensity,
            a.distance
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'PointLight', []);
      a.Line = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d, e) {
          c = Sk.ffi.remapToJs(c);
          d = Sk.ffi.remapToJs(d);
          e = Sk.ffi.remapToJs(e);
          a.v = new b.Line(c, d, e);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'position':
            return n(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return n(d.rotation);
          case 'eulerOrder':
            return Sk.ffi.stringToPy(d.eulerOrder);
          case 'scale':
            return n(d.scale);
          case 'up':
            return n(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return r(b);
          case 'type':
            return Sk.ffi.numberToIntPy(d.type);
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'type':
            if (e(c))
              a.type = c;
            else
              throw Error('type must be either LineStrip or LinePieces');
            break;
          default:
            throw Error(b + ' is not an attribute of Line');
          }
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Line');
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Line');
        });
      }, 'Line', []);
      a.LineBasicMaterial = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          a.tp$name = 'LineBasicMaterial';
          c = Sk.ffi.remapToJs(c);
          a.v = new b.LineBasicMaterial(c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          b = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(b.color, 'Color'));
          case 'opacity':
            return Sk.ffi.numberToFloatPy(b.opacity);
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'color':
            b = c;
            b = 'undefined' !== typeof b ? b.hasOwnProperty('r') && b.hasOwnProperty('g') && b.hasOwnProperty('b') ? e(b.r) && e(b.g) && e(b.b) : !1 : !1;
            if (b)
              a.color = c;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'Color\'>.');
            break;
          case 'opacity':
            if (e(c))
              a.opacity = c;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'float\'>.');
            break;
          default:
            throw Error(b + ' is not an attribute of LineBasicMaterial');
          }
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.opacity = a.opacity;
          return Sk.ffi.stringToPy('LineBasicMaterial(' + JSON.stringify(b) + ')');
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('LineBasicMaterial(' + [{}].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'LineBasicMaterial', []);
      a.Mesh = Sk.ffi.buildClass(a, function (c, e) {
        e.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.ffi.checkMethodArgs('Mesh', arguments, 1, 2);
          Sk.ffi.checkArgType('geometry', 'Geometry', Sk.ffi.isInstance(c), c);
          Sk.ffi.checkArgType('material', 'Material', Sk.ffi.isInstance(d), d);
          var e = {};
          e.geometry = Sk.ffi.typeName(c);
          e.material = Sk.ffi.typeName(d);
          Sk.ffi.referenceToPy(new b.Mesh(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d)), 'Mesh', e, a);
        });
        e.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'attitude':
            return l(e.quaternion);
          case 'id':
            return Sk.ffi.numberToIntPy(e.id);
          case 'geometry':
            var f = b.custom.geometry;
            return Sk.ffi.callsim(a[f], Sk.ffi.referenceToPy(e.geometry, f));
          case 'material':
            var g = e.material, f = b.custom.material;
            return Sk.ffi.callsim(a[f], Sk.ffi.referenceToPy(g, f));
          case 'matrixAutoUpdate':
            return e.matrixAutoUpdate;
          case 'name':
            return Sk.ffi.stringToPy(e.name);
          case 'overdraw':
            return d(e.overdraw) ? e.overdraw : null;
          case 'position':
            return n(e.position);
          case 'rotation':
            return n(e.rotation);
          case 'eulerOrder':
            return Sk.ffi.stringToPy(e.eulerOrder);
          case 'scale':
            return n(e.scale);
          case 'up':
            return n(e.up);
          case 'visible':
            return e.visible;
          case 'lookAt':
            return r(b);
          case 'rotateOnAxis':
            return Sk.ffi.callableToPy(a, 'rotateOnAxis', function (a, c, d) {
              Sk.ffi.checkMethodArgs('rotateOnAxis', arguments, 2, 2);
              Sk.ffi.checkArgType('axis', 'Vector3', Sk.ffi.isInstance(c, 'Vector3'), c);
              Sk.ffi.checkArgType('angle', x, Sk.ffi.isNum(d), d);
              e.rotateOnAxis(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d));
              return b;
            });
          case 'rotateX':
          case 'rotateY':
          case 'rotateZ':
            return Sk.ffi.callableToPy(a, c, function (a, d) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('axis', x, Sk.ffi.isNum(d), d);
              e[c](Sk.ffi.remapToJs(d));
              return b;
            });
          case 'setGeometry':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setGeometry';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                var c = Sk.ffi.remapToJs(b);
                e.setGeometry(c);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setGeometry');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setGeometry');
              });
            }, 'setGeometry', []));
          case 'translateOnAxis':
            return Sk.ffi.callableToPy(a, 'translateOnAxis', function (a, c, d) {
              Sk.ffi.checkMethodArgs('translateOnAxis', arguments, 2, 2);
              Sk.ffi.checkArgType('axis', 'Vector3', Sk.ffi.isInstance(c, 'Vector3'), c);
              Sk.ffi.checkArgType('distance', x, Sk.ffi.isNum(d), d);
              e.translateOnAxis(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d));
              return b;
            });
          case 'translateX':
          case 'translateY':
          case 'translateZ':
            return Sk.ffi.callableToPy(a, c, function (a, d) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('distance', x, Sk.ffi.isNum(d), d);
              e[c](Sk.ffi.remapToJs(d));
              return b;
            });
          case 'updateMatrix':
            return Sk.ffi.callableToPy(a, 'updateMatrix', function (a) {
              Sk.ffi.checkMethodArgs('updateMatrix', arguments, 0, 0);
              e.updateMatrix();
            });
          default:
            return G('Mesh', b, c);
          }
        });
        e.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var e = Sk.ffi.remapToJs(a), g = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'attitude':
            m('Mesh', a, 'quaternion', c, b);
            break;
          case 'matrixAutoUpdate':
            Sk.ffi.checkArgType('matrixAutoUpdate', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            a = Sk.ffi.remapToJs(c);
            e.matrixAutoUpdate = a;
            break;
          case 'name':
            Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            e.name = g;
            break;
          case 'overdraw':
            if (d(g))
              e.overdraw = g;
            else if (h(g))
              e.overdraw = null;
            else
              throw Error(b + ' must be either Boolean or None');
            break;
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            p(e, b, c);
            break;
          case 'quaternion':
            e.quaternion = g;
            break;
          case 'eulerOrder':
            if (f(g))
              e.eulerOrder = g;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            e.useQuaternion = g;
            break;
          case 'visible':
            Sk.ffi.checkArgType('visible', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            e.visible = g;
            break;
          default:
            return H('Mesh', a, b, c);
          }
        });
        e.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.id = a.id;
          b.name = a.name;
          return Sk.ffi.stringToPy('Mesh(' + JSON.stringify(b) + ')');
        });
        e.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Mesh(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'Mesh', []);
      a.MeshBasicMaterial = Sk.ffi.buildClass(a, function (c, g) {
        g.__init__ = Sk.ffi.functionPy(function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new b.MeshBasicMaterial(d), 'MeshBasicMaterial', void 0, a);
        });
        g.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.color, 'Color'));
          case 'wireframe':
            return d.wireframe;
          case 'wireframeLinewidth':
            return Sk.ffi.numberToFloatPy(d.wireframeLinewidth);
          default:
            return M('MeshBasicMaterial', b, c);
          }
        });
        g.__setattr__ = Sk.ffi.functionPy(function (a, c, g) {
          var h = Sk.ffi.remapToJs(a), k = Sk.ffi.remapToJs(g);
          switch (c) {
          case 'color':
            h.color = new b.Color(k);
            break;
          case 'name':
            if (f(k))
              h.name = k;
            else
              throw Error(c + ' must be a string');
            break;
          case 'needsUpdate':
            if (d(k))
              h.needsUpdate = k;
            else
              throw Error(c + ' must be Boolean');
            break;
          case 'opacity':
            if (e(k))
              h.opacity = k;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'float\'>.');
            break;
          case 'overdraw':
            if (d(k))
              h.overdraw = k;
            else
              throw Error(c + ' must be Boolean');
            break;
          case 'transparent':
            if (d(k))
              h.transparent = k;
            else
              throw Error(c + ' must be Boolean');
            break;
          case 'wireframe':
            if (d(k))
              h.wireframe = k;
            else
              throw Error(c + ' must be Boolean');
            break;
          case 'wireframeLinewidth':
            if (e(k))
              h.wireframeLinewidth = k;
            else
              throw Error(c + ' must be a number');
            break;
          case 'visible':
            if (d(k))
              h.visible = k;
            else
              throw Error(c + ' must be Boolean');
            break;
          default:
            switch (a = Sk.ffi.remapToJs(a), h = Sk.ffi.remapToJs(g), c) {
            case 'name':
              Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(g), g);
              a.name = h;
              break;
            default:
              throw Sk.ffi.err.attribute(c).isNotSetableOnType('MeshBasicMaterial');
            }
          }
        });
        g.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.wireframe = a.wireframe;
          b.wireframeLinewidth = a.wireframeLinewidth;
          return Sk.ffi.stringToPy('MeshBasicMaterial(' + JSON.stringify(b) + ')');
        });
        g.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.wireframe = a.wireframe;
          b.wireframeLinewidth = a.wireframeLinewidth;
          return Sk.ffi.stringToPy('MeshBasicMaterial(' + [b].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshBasicMaterial', []);
      a.MeshLambertMaterial = Sk.ffi.buildClass(a, function (c, g) {
        g.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('MeshLambertMaterial', arguments, 0, 1);
          var d = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new b.MeshLambertMaterial(d), 'MeshLambertMaterial', void 0, a);
        });
        g.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'id':
            return Sk.ffi.numberToIntPy(d.id);
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.color, 'Color'));
          case 'name':
            return Sk.ffi.stringToPy(d.name);
          case 'needsUpdate':
            return d.needsUpdate;
          case 'opacity':
            return Sk.ffi.numberToFloatPy(d.opacity);
          case 'overdraw':
            return d.overdraw;
          case 'transparent':
            return d.transparent;
          case 'visible':
            return d.visible;
          }
        });
        g.__setattr__ = Sk.ffi.functionPy(function (a, c, g) {
          a = Sk.ffi.remapToJs(a);
          g = Sk.ffi.remapToJs(g);
          switch (c) {
          case 'color':
            a.color = new b.Color(g);
            break;
          case 'name':
            if (f(g))
              a.name = g;
            else
              throw Error(c + ' must be a string');
            break;
          case 'needsUpdate':
            if (d(g))
              a.needsUpdate = g;
            else
              throw Error(c + ' must be Boolean');
            break;
          case 'opacity':
            if (e(g))
              a.opacity = g;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'float\'>.');
            break;
          case 'overdraw':
            if (d(g))
              a.overdraw = g;
            else
              throw Error(c + ' must be Boolean');
            break;
          case 'transparent':
            if (d(g))
              a.transparent = g;
            else
              throw Error(c + ' must be Boolean');
            break;
          case 'wireframe':
            if (d(g))
              a.wireframe = g;
            else
              throw Error(c + ' must be Boolean');
            break;
          case 'wireframeLinewidth':
            if (e(g))
              a.wireframeLinewidth = g;
            else
              throw Error(c + ' must be a number');
            break;
          case 'visible':
            if (d(g))
              a.visible = g;
            else
              throw Error(c + ' must be Boolean');
            break;
          default:
            throw Error(c + ' is not an attribute of MeshLambertMaterial');
          }
        });
        g.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('MeshLambertMaterial(' + JSON.stringify({}) + ')');
        });
        g.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          return Sk.ffi.stringToPy('MeshLambertMaterial(' + [b].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshLambertMaterial', []);
      a.MeshNormalMaterial = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c) {
          a.tp$name = 'MeshNormalMaterial';
          c = Sk.ffi.remapToJs(c);
          a.v = new b.MeshNormalMaterial(c);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          default:
            throw Error(b + ' is not an attribute of MeshNormalMaterial');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('MeshNormalMaterial(' + JSON.stringify({}) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('MeshNormalMaterial(' + [{}].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshNormalMaterial', []);
      a.MeshPhongMaterial = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c) {
          a.tp$name = 'MeshPhongMaterial';
          c = Sk.ffi.remapToJs(c);
          a.v = new b.MeshPhongMaterial(c);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          default:
            throw Error(b + ' is not an attribute of MeshPhongMaterial');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Error(b + ' is not an attribute of MeshPhongMaterial');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('MeshPhongMaterial(' + JSON.stringify({}) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('MeshPhongMaterial(' + [{}].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshPhongMaterial', []);
      'undefined' !== typeof b && (a.LineStrip = Sk.builtin.assk$(b.LineStrip, Sk.builtin.nmber.int$), a.LinePieces = Sk.builtin.assk$(b.LinePieces, Sk.builtin.nmber.int$), a.FlatShading = Sk.builtin.assk$(b.FlatShading, Sk.builtin.nmber.int$), a.NoShading = Sk.builtin.assk$(b.NoShading, Sk.builtin.nmber.int$), a.SmoothShading = Sk.builtin.assk$(b.SmoothShading, Sk.builtin.nmber.int$));
    };
  }.call(this));
  (function () {
    var a = function (a, b) {
        var c, g, h, k, l;
        h = [];
        c = function (a, b) {
          var c;
          if (0 !== a) {
            0 <= a ? 0 < h.length && h.push('+') : h.push('-');
            c = Math.abs(a);
            if (1 === c)
              return h.push(b);
            h.push(c.toString());
            if ('1' !== b)
              return h.push('*'), h.push(b);
          }
        };
        g = k = 0;
        for (l = a.length - 1; 0 <= l ? k <= l : k >= l; g = 0 <= l ? ++k : --k)
          c(a[g], b[g]);
        return 0 < h.length ? h.join('') : '0';
      }, b = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ], c = Sk.ffi.PyType.INT;
    Sk.builtin.defineVector3 = function (d, e) {
      Sk.ffi.checkFunctionArgs('defineVector3', arguments, 2, 2);
      var f = function (a) {
          return Sk.ffi.isInstance(a, 'Vector3');
        }, g = function (a, b, c) {
          return Sk.ffi.callsim(d.Vector3, Sk.ffi.numberToFloatPy(a), Sk.ffi.numberToFloatPy(b), Sk.ffi.numberToFloatPy(c));
        };
      d.Vector3 = Sk.ffi.buildClass(d, function (h, k) {
        k.__init__ = Sk.ffi.functionPy(function (a, c, d, g) {
          Sk.ffi.checkMethodArgs('Vector3', arguments, 0, 4);
          if (Sk.ffi.isUndefined(c) && Sk.ffi.isUndefined(d) && Sk.ffi.isUndefined(g))
            Sk.ffi.referenceToPy(new e.Vector3(), 'Vector3', void 0, a);
          else
            switch (Sk.ffi.getType(c)) {
            case Sk.ffi.PyType.INSTANCE:
              Sk.ffi.checkMethodArgs('Vector3', arguments, 1, 1);
              Sk.ffi.checkArgType('x', 'Vector3', f(c), c);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Vector3', void 0, a);
              break;
            case Sk.ffi.PyType.FLOAT:
            case Sk.ffi.PyType.INT:
            case Sk.ffi.PyType.LONG:
              Sk.ffi.checkMethodArgs('Vector3', arguments, 3, 3);
              Sk.ffi.checkArgType('x', b, Sk.ffi.isNum(c), c);
              Sk.ffi.checkArgType('y', b, Sk.ffi.isNum(d), d);
              Sk.ffi.checkArgType('z', b, Sk.ffi.isNum(g), g);
              Sk.ffi.referenceToPy(new e.Vector3(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(g)), 'Vector3', void 0, a);
              break;
            default:
              Sk.ffi.checkArgType('x', [
                b,
                'Vector3'
              ], !1, c);
            }
        });
        k.__add__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('add', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          return g(c.x + d.x, c.y + d.y, c.z + d.z);
        });
        k.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('add', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          c.x += d.x;
          c.y += d.y;
          c.z += d.z;
          return a;
        });
        k.__sub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('subtract', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('subtract', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          return g(c.x - d.x, c.y - d.y, c.z - d.z);
        });
        k.__isub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('add', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          c.x -= d.x;
          c.y -= d.y;
          c.z -= d.z;
          return a;
        });
        k.__mul__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('multiply', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('multiply', b, Sk.ffi.isNum(c), c);
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          return g(d.x * e, d.y * e, d.z * e);
        });
        k.__rmul__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('multiply', b, Sk.ffi.isNum(c), c);
          Sk.ffi.checkRhsOperandType('multiply', 'Vector3', f(a), a);
          var d = Sk.ffi.remapToJs(c), e = Sk.ffi.remapToJs(a);
          return g(d * e.x, d * e.y, d * e.z);
        });
        k.__div__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('divide', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('divide', b, Sk.ffi.isNum(c), c);
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          return g(d.x / e, d.y / e, d.z / e);
        });
        k.__rdiv__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('divide', b, Sk.ffi.isNum(c), c);
          Sk.ffi.checkRhsOperandType('divide', 'Vector3', f(a), a);
          var d = Sk.ffi.remapToJs(c), e = Sk.ffi.remapToJs(a);
          return g(e.x / d, e.y / d, e.z / d);
        });
        k.__getattr__ = Sk.ffi.functionPy(function (a, e) {
          var f = Sk.ffi.remapToJs(a);
          switch (e) {
          case 'x':
          case 'y':
          case 'z':
            return Sk.ffi.numberToFloatPy(f[e]);
          case 'applyQuaternion':
            return Sk.ffi.callableToPy(d, 'applyQuaternion', function (b, c) {
              Sk.ffi.checkMethodArgs('applyQuaternion', arguments, 1, 1);
              Sk.ffi.checkArgType('q', 'Quaternion', Sk.ffi.isInstance(c, 'Quaternion'), c);
              f.applyQuaternion(Sk.ffi.remapToJs(c));
              return a;
            });
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(d, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'clone';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return g(f.x, f.y, f.z);
              });
            }, 'clone', []));
          case 'getComponent':
            return Sk.ffi.callableToPy(d, 'getComponent', function (a, b) {
              Sk.ffi.checkMethodArgs('getComponent', arguments, 1, 1);
              Sk.ffi.checkArgType('index', c, Sk.ffi.isNum(b), b);
              return Sk.ffi.remapToPy(f.getComponent(Sk.ffi.remapToJs(b)));
            });
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(d, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'magnitude';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(f.length());
              });
            }, 'magnitude', []));
          case 'normalize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(d, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'normalize';
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                Sk.ffi.checkMethodArgs('Vector3', arguments, 0, 0);
                f.normalize();
                return a;
              });
            }, 'normalize', []));
          case 'set':
            return Sk.ffi.callableToPy(d, 'set', function (c, d, e, g) {
              Sk.ffi.checkMethodArgs('set', arguments, 3, 3);
              Sk.ffi.checkArgType('x', b, Sk.ffi.isNum(d), d);
              Sk.ffi.checkArgType('y', b, Sk.ffi.isNum(e), e);
              Sk.ffi.checkArgType('z', b, Sk.ffi.isNum(g), g);
              d = Sk.ffi.remapToJs(d);
              e = Sk.ffi.remapToJs(e);
              g = Sk.ffi.remapToJs(g);
              f.set(d, e, g);
              return a;
            });
          case 'setComponent':
            return Sk.ffi.callableToPy(d, 'setComponent', function (d, e, g) {
              Sk.ffi.checkMethodArgs('setComponent', arguments, 2, 2);
              Sk.ffi.checkArgType('index', c, Sk.ffi.isInt(e), e);
              Sk.ffi.checkArgType('value', b, Sk.ffi.isNum(g), g);
              var h = Sk.ffi.remapToJs(e), k = Sk.ffi.remapToJs(g);
              f.setComponent(h, k);
              return a;
            });
          case 'setX':
          case 'setY':
          case 'setZ':
            return Sk.ffi.callableToPy(d, e, function (c, d) {
              Sk.ffi.checkMethodArgs(e, arguments, 1, 1);
              Sk.ffi.checkArgType('value', b, Sk.ffi.isNum(d), d);
              f[e](Sk.ffi.remapToJs(d));
              return a;
            });
          default:
            throw Sk.ffi.err.attribute(e).isNotGetableOnType('Vector3');
          }
        });
        k.__setattr__ = Sk.ffi.functionPy(function (a, c, d) {
          switch (c) {
          case 'x':
          case 'y':
          case 'z':
            Sk.ffi.checkArgType(c, b, Sk.ffi.isNum(d), d);
            Sk.ffi.remapToJs(a)[c] = Sk.ffi.remapToJs(d);
            break;
          default:
            throw Sk.ffi.err.attribute(c).isNotSetableOnType('Vector3');
          }
        });
        k.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Vector3(' + [
            a.x,
            a.y,
            a.z
          ].join(', ') + ')');
        });
        k.__str__ = Sk.ffi.functionPy(function (b) {
          b = Sk.ffi.remapToJs(b);
          return Sk.ffi.stringToPy(a([
            b.x,
            b.y,
            b.z
          ], [
            'i',
            'j',
            'k'
          ]));
        });
      }, 'Vector3', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineFractions = function (a, b, c) {
      Sk.ffi.checkFunctionArgs('defineFractions', arguments, 3, 3);
      var d = function (a) {
          return Sk.ffi.isInstance(a, b);
        }, e = [
          b,
          Sk.ffi.PyType.INT
        ];
      a[b] = Sk.ffi.buildClass(a, function (f, g) {
        g.__init__ = Sk.ffi.functionPy(function (a, e, f) {
          if (Sk.ffi.isUndefined(f))
            Sk.ffi.isUndefined(e) ? Sk.ffi.referenceToPy(c(0, 1), b, void 0, a) : d(e) ? (Sk.ffi.checkMethodArgs(b, arguments, 1, 1), Sk.ffi.referenceToPy(Sk.ffi.remapToJs(e), b, void 0, a)) : Sk.ffi.isNum(e) ? (Sk.ffi.checkArgType('numerator', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e), g = Sk.ffi.remapToJs(e), Sk.ffi.referenceToPy(c(g, 1), b, void 0, a)) : Sk.ffi.checkMethodArgs(b, arguments, 2, 2);
          else {
            Sk.ffi.checkMethodArgs(b, arguments, 2, 2);
            Sk.ffi.checkArgType('numerator', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e);
            Sk.ffi.checkArgType('denominator', Sk.ffi.PyType.INT, Sk.ffi.isInt(f), f);
            var g = Sk.ffi.remapToJs(e), n = Sk.ffi.remapToJs(f);
            if (0 != n)
              Sk.ffi.referenceToPy(c(g, n), b, void 0, a);
            else
              throw new Sk.builtin.ZeroDivisionError('denominator must not be zero');
          }
        });
        g.__getattr__ = Sk.ffi.functionPy(function (a, c) {
          var d = Sk.ffi.remapToJs(a);
          switch (c) {
          case 'numer':
          case 'numerator':
            return Sk.ffi.numberToIntPy(d.numer);
          case 'denom':
          case 'denominator':
            return Sk.ffi.numberToIntPy(d.denom);
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(b);
          }
        });
        g.__add__ = Sk.ffi.functionPy(function (c, f) {
          Sk.ffi.checkRhsOperandType('add', e, d(f) || Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          return Sk.ffi.callsim(a[b], Sk.ffi.remapToPy(g.add(m), b));
        });
        g.__radd__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('add', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          return Sk.ffi.callsim(a[b], Sk.ffi.remapToPy(m.add(g), b));
        });
        g.__sub__ = Sk.ffi.functionPy(function (c, f) {
          Sk.ffi.checkRhsOperandType('subtract', e, d(f) || Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          return Sk.ffi.callsim(a[b], Sk.ffi.remapToPy(g.sub(m), b));
        });
        g.__rsub__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('subtract', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          return Sk.ffi.callsim(a[b], Sk.ffi.remapToPy(m.sub(g), b));
        });
        g.__mul__ = Sk.ffi.functionPy(function (c, f) {
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          if (Sk.ffi.isNum(f))
            return Sk.ffi.checkRhsOperandType('multiply', e, Sk.ffi.isInt(f), f), Sk.ffi.callsim(a[b], Sk.ffi.numberToIntPy(g.numer * m), Sk.ffi.numberToIntPy(g.denom));
          Sk.ffi.checkRhsOperandType('multiply', e, d(f), f);
          return Sk.ffi.callsim(a[b], Sk.ffi.remapToPy(g.mul(m), b));
        });
        g.__rmul__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('multiply', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          return Sk.ffi.callsim(a[b], Sk.ffi.remapToPy(m.mul(g), b));
        });
        g.__div__ = Sk.ffi.functionPy(function (c, f) {
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          if (Sk.ffi.isNum(f)) {
            if (Sk.ffi.checkRhsOperandType('divide', e, Sk.ffi.isInt(f), f), 0 != m)
              return Sk.ffi.callsim(a[b], Sk.ffi.numberToIntPy(g.numer), Sk.ffi.numberToIntPy(g.denom * m));
          } else if (Sk.ffi.checkRhsOperandType('divide', e, d(f), f), 0 != m.numer)
            return Sk.ffi.callsim(a[b], Sk.ffi.remapToPy(g.div(m), b));
          throw new Sk.builtin.ZeroDivisionError('denominator must not be zero');
        });
        g.__rdiv__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('divide', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          if (0 != g.numer)
            return Sk.ffi.callsim(a[b], Sk.ffi.remapToPy(m.div(g), b));
          throw new Sk.builtin.ZeroDivisionError('denominator must not be zero');
        });
        g.__eq__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkFunctionArgs('equal', arguments, 2, 2);
          if (d(a) && d(b)) {
            var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
            return Sk.ffi.booleanToPy(c.equals(e));
          }
          return Sk.ffi.bool.False;
        });
        g.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.remapToPy(b + '(' + a.numer + ',' + a.denom + ')');
        });
        g.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.remapToPy('' + a);
        });
      }, b, []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineWorkbench = function (a) {
      function b(a) {
        a = document.getElementsByTagName(a);
        for (var b = a.length - 1; 0 <= b; b--) {
          var e = a[b];
          e.parentNode.removeChild(e);
        }
      }
      Sk.ffi.checkFunctionArgs('defineWorkbench', arguments, 1, 1);
      a.Workbench2D = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('Workbench2D', arguments, 1, 1);
          Sk.ffi.checkArgType('canvas', 'Element', Sk.ffi.isInstance(b), b);
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy({
            canvas: c,
            onWindowResize: function (a) {
              a = window.innerHeight;
              c.width = window.innerWidth;
              c.height = a;
            }
          }, 'Workbench2D', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var g = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'setUp':
            return Sk.ffi.callableToPy(a, 'setUp', function (a) {
              Sk.ffi.checkMethodArgs('setUp', arguments, 0, 0);
              document.body.insertBefore(g.canvas, document.body.firstChild);
              window.addEventListener('resize', g.onWindowResize, !1);
              g.onWindowResize(null);
            });
          case 'tearDown':
            return Sk.ffi.callableToPy(a, 'tearDown', function (a) {
              window.removeEventListener('resize', g.onWindowResize, !1);
              b('canvas');
            });
          }
        });
      }, 'Workbench2D', []);
      a.Workbench3D = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c, d) {
          Sk.ffi.checkMethodArgs('Workbench3D', arguments, 3, 3);
          Sk.ffi.checkArgType('canvas', 'Element', Sk.ffi.isInstance(b), b);
          var k = Sk.ffi.remapToJs(b), l = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(d);
          Sk.ffi.referenceToPy({
            canvas: k,
            renderer: l,
            camera: m,
            onWindowResize: function (a) {
              a = window.innerWidth;
              var b = window.innerHeight;
              l.setSize(a, b);
              m.aspect = a / b;
              m.updateProjectionMatrix();
            }
          }, 'Workbench3D', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var g = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'setUp':
            return Sk.ffi.callableToPy(a, 'setUp', function (a) {
              document.body.insertBefore(g.canvas, document.body.firstChild);
              window.addEventListener('resize', g.onWindowResize, !1);
              g.onWindowResize(null);
            });
          case 'tearDown':
            return Sk.ffi.callableToPy(a, 'tearDown', function (a) {
              window.removeEventListener('resize', g.onWindowResize, !1);
              b('canvas');
            });
          }
        });
      }, 'Workbench3D', []);
      a.Workbench = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Workbench', arguments, 2, 2);
          var d = Sk.ffi.remapToJs(b), k = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy({
            renderer: d,
            camera: k,
            onWindowResize: function (a) {
              a = window.innerWidth;
              var b = window.innerHeight;
              d.setSize(a, b);
              k.aspect = a / b;
              k.updateProjectionMatrix();
            }
          }, 'Workbench', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var g = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'setUp':
            return Sk.ffi.callableToPy(a, 'setUp', function (a) {
              document.body.insertBefore(g.renderer.domElement, document.body.firstChild);
              window.addEventListener('resize', g.onWindowResize, !1);
              g.onWindowResize(null);
            });
          case 'tearDown':
            return Sk.ffi.callableToPy(a, 'tearDown', function (a) {
              window.removeEventListener('resize', g.onWindowResize, !1);
              b('canvas');
            });
          }
        });
      }, 'Workbench', []);
    };
  }.call(this));
  (function () {
    this.BLADE = this.BLADE || {};
  }.call(this));
  (function () {
    var a, b, c;
    a = this.BLADE = this.BLADE || {};
    c = function (a, b) {
      return 0 === a.numer ? null : 1 === a.denom ? 1 === a.numer ? '' + b : '' + b + ' ** ' + a.numer : '' + b + ' ** ' + a;
    };
    b = function () {
      function b(c, d, g, h) {
        if ('number' === typeof c)
          this.M = new a.Rational(c, 1);
        else if (c instanceof a.Rational)
          this.M = c;
        else
          throw Error('mass must be a Rational or number');
        this.L = 'number' === typeof d ? new a.Rational(d, 1) : d;
        this.T = 'number' === typeof g ? new a.Rational(g, 1) : g;
        if ('number' === typeof h)
          this.Q = new a.Rational(h, 1);
        else if (h instanceof a.Rational)
          this.Q = h;
        else
          throw {
            name: 'DimensionError',
            message: 'charge must be a Rational or number'
          };
      }
      b.prototype.compatible = function (a) {
        if (this.M.equals(a.M) && this.L.equals(a.L) && this.T.equals(a.T) && this.Q.equals(a.Q))
          return this;
        throw {
          name: 'DimensionError',
          message: 'Dimensions must be equal +(' + this + ', ' + a + ')'
        };
      };
      b.prototype.mul = function (b) {
        return new a.Dimensions(this.M.add(b.M), this.L.add(b.L), this.T.add(b.T), this.Q.add(b.Q));
      };
      b.prototype.div = function (b) {
        return new a.Dimensions(this.M.sub(b.M), this.L.sub(b.L), this.T.sub(b.T), this.Q.sub(b.Q));
      };
      b.prototype.pow = function (b) {
        return new a.Dimensions(this.M.mul(b), this.L.mul(b), this.T.mul(b), this.Q.mul(b));
      };
      b.prototype.dimensionless = function () {
        return this.M.isZero() && this.L.isZero() && this.T.isZero() && this.Q.isZero();
      };
      b.prototype.toString = function () {
        return [
          c(this.M, 'M'),
          c(this.L, 'L'),
          c(this.T, 'T'),
          c(this.Q, 'Q')
        ].filter(function (a) {
          return 'string' === typeof a;
        }).join(' * ');
      };
      return b;
    }();
    this.BLADE.Dimensions = b;
  }.call(this));
  (function () {
    var a, b, c;
    a = this.BLADE = this.BLADE || {};
    c = function (b, c, f, g, h, k, l, m, n) {
      var p, q, r, v, s, z, y, C;
      s = +h;
      z = +k;
      y = +l;
      C = -m;
      p = +(h * s + k * z + l * y - m * C);
      q = s * p + -0 * z + -0 * y - -0 * C;
      r = -0 * s + z * p - -0 * y + -0 * C;
      v = -0 * s + -0 * z + y * p - -0 * C;
      p = -0 * s + -0 * z - -0 * y + C * p;
      h = h * q + k * r + l * v - m * p;
      q /= h;
      r /= h;
      v /= h;
      m = p / h;
      h = b * q + c * r + f * v - g * m;
      k = b * r + c * q - f * m + g * v;
      l = b * v + c * m + f * q - g * r;
      b = b * m + c * v - f * r + g * q;
      return 'undefined' !== typeof n ? (n.w = h, n.x = k, n.y = l, n.xy = b) : new a.Euclidean2(h, k, l, b);
    };
    b = function () {
      function b(a, c, d, h) {
        this.w = a || 0;
        this.x = c;
        this.y = d;
        this.xy = h;
      }
      b.fromCartesian = function (b, c, d, h) {
        return new a.Euclidean2(b, c, d, h);
      };
      b.fromPolar = function (b, c, d, h) {
        return new a.Euclidean2(b, c * Math.cos(d), c * Math.sin(d), h);
      };
      b.prototype.coordinates = function () {
        return [
          this.w,
          this.x,
          this.y,
          this.xy
        ];
      };
      b.prototype.coordinate = function (a) {
        switch (a) {
        case 0:
          return this.w;
        case 1:
          return this.x;
        case 2:
          return this.y;
        case 3:
          return this.xy;
        default:
          throw Error('index must be in the range [0..3]');
        }
      };
      b.add = function (b, c) {
        var d, h, k, l, m, n, p, q, r, v, s;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        r = a.e2gaASM.add00(d, h, k, l, m, n, p, q);
        v = a.e2gaASM.add01(d, h, k, l, m, n, p, q);
        s = a.e2gaASM.add10(d, h, k, l, m, n, p, q);
        d = a.e2gaASM.add11(d, h, k, l, m, n, p, q);
        return [
          r,
          v,
          s,
          d
        ];
      };
      b.prototype.add = function (c) {
        c = b.add(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.sub = function (b, c) {
        var d, h, k, l, m, n, p, q, r, v, s;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        r = a.bladeASM.subE2(d, h, k, l, m, n, p, q, 0);
        v = a.bladeASM.subE2(d, h, k, l, m, n, p, q, 1);
        s = a.bladeASM.subE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.subE2(d, h, k, l, m, n, p, q, 3);
        return [
          r,
          v,
          s,
          d
        ];
      };
      b.prototype.sub = function (c) {
        c = b.sub(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.mul = function (b, c) {
        var d, h, k, l, m, n, p, q, r, v, s;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        r = a.bladeASM.mulE2(d, h, k, l, m, n, p, q, 0);
        v = a.bladeASM.mulE2(d, h, k, l, m, n, p, q, 1);
        s = a.bladeASM.mulE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.mulE2(d, h, k, l, m, n, p, q, 3);
        return [
          r,
          v,
          s,
          d
        ];
      };
      b.prototype.mul = function (c) {
        if ('number' === typeof c)
          return new a.Euclidean2(this.w * c, this.x * c, this.y * c, this.xy * c);
        c = b.mul(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.prototype.div = function (b) {
        return 'number' === typeof b ? new a.Euclidean2(this.w / b, this.x / b, this.y / b, this.xy / b) : c(this.w, this.x, this.y, this.xy, b.w, b.x, b.y, b.xy, void 0);
      };
      b.wedge = function (b, c) {
        var d, h, k, l, m, n, p, q, r, v, s;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        r = a.bladeASM.extE2(d, h, k, l, m, n, p, q, 0);
        v = a.bladeASM.extE2(d, h, k, l, m, n, p, q, 1);
        s = a.bladeASM.extE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.extE2(d, h, k, l, m, n, p, q, 3);
        return [
          r,
          v,
          s,
          d
        ];
      };
      b.prototype.wedge = function (c) {
        c = b.wedge(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.lshift = function (b, c) {
        var d, h, k, l, m, n, p, q, r, v, s;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        r = a.bladeASM.lcoE2(d, h, k, l, m, n, p, q, 0);
        v = a.bladeASM.lcoE2(d, h, k, l, m, n, p, q, 1);
        s = a.bladeASM.lcoE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.lcoE2(d, h, k, l, m, n, p, q, 3);
        return [
          r,
          v,
          s,
          d
        ];
      };
      b.prototype.lshift = function (c) {
        c = b.lshift(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.rshift = function (b, c) {
        var d, h, k, l, m, n, p, q, r, v, s;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        r = a.bladeASM.rcoE2(d, h, k, l, m, n, p, q, 0);
        v = a.bladeASM.rcoE2(d, h, k, l, m, n, p, q, 1);
        s = a.bladeASM.rcoE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.rcoE2(d, h, k, l, m, n, p, q, 3);
        return [
          r,
          v,
          s,
          d
        ];
      };
      b.prototype.rshift = function (c) {
        c = b.rshift(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.prototype.grade = function (b) {
        switch (b) {
        case 0:
          return new a.Euclidean2(this.w, 0, 0, 0);
        case 1:
          return new a.Euclidean2(0, this.x, this.y, 0);
        case 2:
          return new a.Euclidean2(0, 0, 0, this.xy);
        default:
          return new a.Euclidean2(0, 0, 0, 0);
        }
      };
      b.prototype.quadrance = function () {
        var a, b, c, d;
        a = this.w;
        b = this.x;
        d = this.y;
        c = this.xy;
        return a * a + b * b + d * d + c * c;
      };
      b.prototype.isNaN = function () {
        return isNaN(this.w) || isNaN(this.x) || isNaN(this.y) || isNaN(this.xy);
      };
      b.prototype.toString = function () {
        return a.bladeSTR.stringFromCoordinates([
          this.w,
          this.x,
          this.y,
          this.xy
        ], [
          '1',
          'e1',
          'e2',
          'e12'
        ]);
      };
      b.prototype.toStringIJK = function () {
        return a.bladeSTR.stringFromCoordinates(this.coordinates(), [
          '1',
          'i',
          'j',
          'I'
        ]);
      };
      b.prototype.toStringLATEX = function () {
        return a.bladeSTR.stringFromCoordinates(this.coordinates(), [
          '1',
          'e_{1}',
          'e_{2}',
          'e_{12}'
        ]);
      };
      return b;
    }();
    this.BLADE.Euclidean2 = b;
  }.call(this));
  (function () {
    var a, b, c, d;
    a = this.BLADE = this.BLADE || {};
    d = function (a, b, c, d, k, l, m, n, p, q, r, v, s, z, y, C, t) {
      var B;
      a = +a;
      b = +b;
      c = +c;
      d = +d;
      k = +k;
      l = +l;
      m = +m;
      n = +n;
      p = +p;
      q = +q;
      r = +r;
      v = +v;
      s = +s;
      z = +z;
      y = +y;
      C = +C;
      B = 0;
      switch (~~(t | 0)) {
      case 0:
        B = +(a * p + b * q + c * r + d * v - k * s - l * z - m * y - n * C);
        break;
      case 1:
        B = +(a * q + b * p - c * s + d * y + k * r - l * C - m * v - n * z);
        break;
      case 2:
        B = +(a * r + b * s + c * p - d * z - k * q + l * v - m * C - n * y);
        break;
      case 3:
        B = +(a * v - b * y + c * z + d * p - k * C - l * r + m * q - n * s);
        break;
      case 4:
        B = +(a * s + b * r - c * q + d * C + k * p - l * y + m * z + n * v);
        break;
      case 5:
        B = +(a * z + b * C + c * v - d * r + k * y + l * p - m * s + n * q);
        break;
      case 6:
        B = +(a * y - b * v + c * C + d * q - k * z + l * s + m * p + n * r);
        break;
      case 7:
        B = +(a * C + b * z + c * y + d * s + k * v + l * q + m * r + n * p);
      }
      return +B;
    };
    c = function (b, c, g, h, k, l, m, n, p, q, r, v, s, z, y, C, t) {
      var B, G, H, I, J, M, K, x, N, w, A, u, D, E, F, L, O, P, Q;
      w = +p;
      A = +q;
      x = +r;
      u = -v;
      D = +s;
      E = -z;
      F = -y;
      L = -C;
      N = d(p, q, r, s, v, y, -z, C, w, A, x, D, u, F, -E, L, 0);
      J = d(p, q, r, s, v, y, -z, C, w, A, x, D, u, F, -E, L, 1);
      M = d(p, q, r, s, v, y, -z, C, w, A, x, D, u, F, -E, L, 2);
      K = d(p, q, r, s, v, y, -z, C, w, A, x, D, u, F, -E, L, 3);
      B = +N;
      G = -J;
      H = -M;
      I = -K;
      O = d(w, A, x, D, u, F, -E, L, B, G, H, I, -0, -0, 0, 0, 0);
      P = d(w, A, x, D, u, F, -E, L, B, G, H, I, -0, -0, 0, 0, 1);
      Q = d(w, A, x, D, u, F, -E, L, B, G, H, I, -0, -0, 0, 0, 2);
      N = d(w, A, x, D, u, F, -E, L, B, G, H, I, -0, -0, 0, 0, 4);
      J = d(w, A, x, D, u, F, -E, L, B, G, H, I, -0, -0, 0, 0, 3);
      M = -d(w, A, x, D, u, F, -E, L, B, G, H, I, -0, -0, 0, 0, 6);
      K = d(w, A, x, D, u, F, -E, L, B, G, H, I, -0, -0, 0, 0, 5);
      w = d(w, A, x, D, u, F, -E, L, B, G, H, I, -0, -0, 0, 0, 7);
      s = d(p, q, r, s, v, y, -z, C, O, P, Q, J, N, K, -M, w, 0);
      p = O / s;
      q = P / s;
      r = Q / s;
      v = N / s;
      J /= s;
      M /= s;
      K /= s;
      x = w / s;
      s = d(b, c, g, k, h, m, -l, n, p, q, r, J, v, K, -M, x, 0);
      z = d(b, c, g, k, h, m, -l, n, p, q, r, J, v, K, -M, x, 1);
      y = d(b, c, g, k, h, m, -l, n, p, q, r, J, v, K, -M, x, 2);
      C = d(b, c, g, k, h, m, -l, n, p, q, r, J, v, K, -M, x, 4);
      N = d(b, c, g, k, h, m, -l, n, p, q, r, J, v, K, -M, x, 3);
      A = -d(b, c, g, k, h, m, -l, n, p, q, r, J, v, K, -M, x, 6);
      w = d(b, c, g, k, h, m, -l, n, p, q, r, J, v, K, -M, x, 5);
      b = d(b, c, g, k, h, m, -l, n, p, q, r, J, v, K, -M, x, 7);
      c = -A;
      return 'undefined' !== typeof t ? (t.w = s, t.x = z, t.y = y, t.z = N, t.xy = C, t.yz = w, t.zx = c, t.xyz = b) : new a.Euclidean3(s, z, y, N, C, w, c, b);
    };
    b = function () {
      function b(a, c, d, e, l, m, n, p) {
        this.w = a || 0;
        this.x = c || 0;
        this.y = d || 0;
        this.z = e || 0;
        this.xy = l || 0;
        this.yz = m || 0;
        this.zx = n || 0;
        this.xyz = p || 0;
      }
      b.fromCartesian = function (b, c, d, e, l, m, n, p) {
        return new a.Euclidean3(b, c, d, e, l, m, n, p);
      };
      b.prototype.coordinates = function () {
        return [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ];
      };
      b.prototype.coordinate = function (a) {
        switch (a) {
        case 0:
          return this.w;
        case 1:
          return this.x;
        case 2:
          return this.y;
        case 3:
          return this.z;
        case 4:
          return this.xy;
        case 5:
          return this.yz;
        case 6:
          return this.zx;
        case 7:
          return this.xyz;
        default:
          throw Error('index must be in the range [0..7]');
        }
      };
      b.compute = function (a, b, c, d, e) {
        var m, n, p, q, r, v, s, z, y, C, t, B, G, H, I, J, M, K, x, N;
        m = d(b, 0);
        n = d(b, 1);
        p = d(b, 2);
        q = d(b, 3);
        r = d(b, 4);
        v = d(b, 5);
        s = d(b, 6);
        b = d(b, 7);
        z = d(c, 0);
        y = d(c, 1);
        C = d(c, 2);
        t = d(c, 3);
        B = d(c, 4);
        G = d(c, 5);
        H = d(c, 6);
        I = d(c, 7);
        c = a(m, n, p, q, r, v, s, b, z, y, C, t, B, G, H, I, 0);
        d = a(m, n, p, q, r, v, s, b, z, y, C, t, B, G, H, I, 1);
        J = a(m, n, p, q, r, v, s, b, z, y, C, t, B, G, H, I, 2);
        M = a(m, n, p, q, r, v, s, b, z, y, C, t, B, G, H, I, 3);
        K = a(m, n, p, q, r, v, s, b, z, y, C, t, B, G, H, I, 4);
        x = a(m, n, p, q, r, v, s, b, z, y, C, t, B, G, H, I, 5);
        N = a(m, n, p, q, r, v, s, b, z, y, C, t, B, G, H, I, 6);
        a = a(m, n, p, q, r, v, s, b, z, y, C, t, B, G, H, I, 7);
        return e(c, d, J, M, K, x, N, a);
      };
      b.prototype.add = function (c) {
        return b.compute(a.bladeASM.addE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.sub = function (c) {
        return b.compute(a.bladeASM.subE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.mul = function (c) {
        return 'number' === typeof c ? new a.Euclidean3(this.w * c, this.x * c, this.y * c, this.z * c, this.xy * c, this.yz * c, this.zx * c, this.xyz * c) : b.compute(a.bladeASM.mulE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.div = function (b) {
        return 'number' === typeof b ? new a.Euclidean3(this.w / b, this.x / b, this.y / b, this.z / b, this.xy / b, this.yz / b, this.zx / b, this.xyz / b) : c(this.w, this.x, this.y, this.xy, this.z, -this.zx, this.yz, this.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz, void 0);
      };
      b.prototype.wedge = function (c) {
        return b.compute(a.bladeASM.extE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.lshift = function (c) {
        return b.compute(a.bladeASM.lcoE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.rshift = function (c) {
        return b.compute(a.bladeASM.rcoE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.grade = function (a) {
        switch (a) {
        case 0:
          return b.fromCartesian(this.w, 0, 0, 0, 0, 0, 0, 0);
        case 1:
          return b.fromCartesian(0, this.x, this.y, this.z, 0, 0, 0, 0);
        case 2:
          return b.fromCartesian(0, 0, 0, 0, this.xy, this.yz, this.zx, 0);
        case 3:
          return b.fromCartesian(0, 0, 0, 0, 0, 0, 0, this.xyz);
        default:
          return b.fromCartesian(0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      b.prototype.dot = function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
      };
      b.prototype.cross = function (b) {
        var c, d, e, l, m;
        c = this.x;
        e = this.y;
        m = this.z;
        d = b.x;
        l = b.y;
        b = b.z;
        return new a.Euclidean3(0, e * b - m * l, m * d - c * b, c * l - e * d, 0, 0, 0, 0);
      };
      b.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      };
      b.prototype.toString = function () {
        return a.bladeSTR.stringFromCoordinates([
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], '1 e1 e2 e3 e12 e23 e31 e123'.split(' '));
      };
      b.prototype.toStringIJK = function () {
        return a.bladeSTR.stringFromCoordinates([
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], '1 i j k ij jk ki I'.split(' '));
      };
      b.prototype.toStringLATEX = function () {
        return a.bladeSTR.stringFromCoordinates([
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], '1 e_{1} e_{2} e_{3} e_{12} e_{23} e_{31} e_{123}'.split(' '));
      };
      return b;
    }();
    this.BLADE.Euclidean3 = b;
  }.call(this));
  (function () {
    var a, b;
    a = this.BLADE = this.BLADE || {};
    b = function () {
      function b(a, c, f) {
        this.a = a;
        this.b = c;
        this.c = f;
      }
      b.prototype.meetWithLine = function (b) {
        var c, f, g, h, k, l;
        c = this.a;
        g = this.b;
        k = this.c;
        f = b.a;
        h = b.b;
        b = b.c;
        l = c * h - f * g;
        return new a.Point2((g * b - h * k) / l, (f * k - c * b) / l);
      };
      b.prototype.passesThroughPoint = function (a, b) {
        return Math.abs(this.a * a.x + this.b * a.y + this.c) < b;
      };
      b.prototype.reflectPoint = function (b) {
        var c, f, g, h, k, l;
        c = this.a;
        f = c * c;
        g = this.b;
        h = g * g;
        k = this.c;
        l = f - h;
        f += h;
        h = b.x;
        b = b.y;
        return new a.Point2(-(2 * c * (g * b + k) + h * f) / l, (2 * g * (c * h + k) + b * f) / l);
      };
      return b;
    }();
    this.BLADE.Line2 = b;
  }.call(this));
  (function () {
    var a, b;
    a = this.BLADE = this.BLADE || {};
    b = function () {
      function b(c, e) {
        var f;
        f = e.scale;
        1 === f ? (this.quantity = c, this.uom = e) : (this.quantity = c.mul(f), this.uom = new a.Unit(1, e.dimensions, e.labels));
      }
      b.prototype.add = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.add(b.quantity), this.uom.compatible(b.uom));
        throw Error('Measure.add(rhs): rhs must be a Measure.');
      };
      b.prototype.sub = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.sub(b.quantity), this.uom.compatible(b.uom));
        throw Error('Measure.sub(rhs): rhs must be a Measure.');
      };
      b.prototype.mul = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.mul(b.quantity), this.uom.mul(b.uom));
        if (b instanceof a.Unit)
          return new a.Measure(this.quantity, this.uom.mul(b));
        if ('number' === typeof b)
          return new a.Measure(this.quantity.mul(b), this.uom);
        throw Error('Measure.mul(rhs): rhs must be a [Measure, Unit, number]');
      };
      b.prototype.div = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.div(b.quantity), this.uom.div(b.uom));
        if (b instanceof a.Unit)
          return new a.Measure(this.quantity, this.uom.div(b));
        if ('number' === typeof b)
          return new a.Measure(this.quantity.div(b), this.uom);
        throw Error('Measure.div(rhs): rhs must be a [Measure, Unit, number]');
      };
      b.prototype.wedge = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.wedge(b.quantity), this.uom.mul(b.uom));
        throw Error('Measure.wedge(rhs): rhs must be a Measure');
      };
      b.prototype.toString = function () {
        return '' + this.quantity + ' ' + this.uom;
      };
      return b;
    }();
    this.BLADE.Measure = b;
  }.call(this));
  (function () {
    var a, b;
    a = this.BLADE = this.BLADE || {};
    b = function () {
      function b(a, c) {
        this.x = a;
        this.y = c;
      }
      b.prototype.joinToPoint = function (b) {
        var c, f, g;
        c = this.x;
        g = this.y;
        f = b.x;
        b = b.y;
        return new a.Line2(g - b, f - c, c * b - f * g);
      };
      b.prototype.liesOnLine = function (a, b) {
        return Math.abs(a.a * this.x + a.b * this.y + a.c) < b;
      };
      b.prototype.quadrance = function (a) {
        var b, c, g;
        b = this.x;
        c = this.y;
        g = a.x;
        a = a.y;
        b = g - b;
        c = a - c;
        return b * b + c * c;
      };
      b.prototype.reflectAboutLine = function (b) {
        var c, f, g, h, k, l;
        c = b.a;
        f = c * c;
        g = b.b;
        h = g * g;
        b = b.c;
        k = f - h;
        f += h;
        h = this.x;
        l = this.y;
        return new a.Point2(-(2 * c * (g * l + b) + h * f) / k, (2 * g * (c * h + b) + l * f) / k);
      };
      b.prototype.signedArea = function (b, c) {
        var f, g;
        f = this.vectorTo(b);
        g = this.vectorTo(c);
        return f.wedge(g).mul(new a.Euclidean2(0.5, 0, 0, 0));
      };
      b.prototype.vectorTo = function (b) {
        return new a.Euclidean2(0, b.x - this.x, b.y - this.y, 0);
      };
      return b;
    }();
    this.BLADE.Point2 = b;
  }.call(this));
  (function () {
    var a, b, c;
    a = this.BLADE = this.BLADE || {};
    c = function (a, b) {
      var c;
      0 > a && (a = -a);
      0 > b && (b = -b);
      b > a && (c = a, a = b, b = c);
      for (;;) {
        a %= b;
        if (0 === a)
          return b;
        b %= a;
        if (0 === b)
          return a;
      }
    };
    b = function () {
      function b(a, d) {
        var g;
        if (0 === d)
          throw Error('denominator must not be zero');
        g = 0 === a ? 1 : c(Math.abs(a), Math.abs(d));
        0 > d && (a = -a, d = -d);
        this.numer = a / g;
        this.denom = d / g;
      }
      b.prototype.add = function (b) {
        return 'number' === typeof b ? new a.Rational(this.numer + this.denom * b, this.denom) : new a.Rational(this.numer * b.denom + this.denom * b.numer, this.denom * b.denom);
      };
      b.prototype.sub = function (b) {
        return 'number' === typeof b ? new a.Rational(this.numer - this.denom * b, this.denom) : new a.Rational(this.numer * b.denom - this.denom * b.numer, this.denom * b.denom);
      };
      b.prototype.mul = function (b) {
        return 'number' === typeof b ? new a.Rational(this.numer * b, this.denom) : new a.Rational(this.numer * b.numer, this.denom * b.denom);
      };
      b.prototype.div = function (b) {
        return new a.Rational(this.numer * b.denom, this.denom * b.numer);
      };
      b.prototype.isZero = function () {
        return 0 === this.numer;
      };
      b.prototype.equals = function (b) {
        return b instanceof a.Rational ? this.numer * b.denom === this.denom * b.numer : !1;
      };
      b.prototype.toString = function () {
        return '' + this.numer + '/' + this.denom;
      };
      return b;
    }();
    this.BLADE.Rational = b;
  }.call(this));
  (function () {
    var a, b, c;
    a = this.BLADE = this.BLADE || {};
    c = function (a, b) {
      return 0 === a.numer ? null : 1 === a.denom ? 1 === a.numer ? '' + b : '' + b + ' ** ' + a.numer : '' + b + ' ** ' + a;
    };
    b = function () {
      function b(a, c, d) {
        this.scale = a;
        this.dimensions = c;
        this.labels = d;
      }
      b.prototype.compatible = function (a) {
        if (a instanceof b)
          return this.dimensions.compatible(a.dimensions), this;
        throw Error('Illegal Argument for Unit.compatible: ' + a);
      };
      b.prototype.add = function (c) {
        if (c instanceof b)
          return new a.Unit(this.scale + c.scale, this.dimensions.compatible(c.dimensions), this.labels);
        throw Error('Illegal Argument for Unit.add: ' + c);
      };
      b.prototype.sub = function (c) {
        if (c instanceof b)
          return new a.Unit(this.scale - c.scale, this.dimensions.compatible(c.dimensions), this.labels);
        throw Error('Illegal Argument for Unit.sub: ' + c);
      };
      b.prototype.mul = function (c) {
        if ('number' === typeof c)
          return new a.Unit(this.scale * c, this.dimensions, this.labels);
        if (c instanceof b)
          return new a.Unit(this.scale * c.scale, this.dimensions.mul(c.dimensions), this.labels);
        throw Error('Illegal Argument for mul: ' + c);
      };
      b.prototype.div = function (c) {
        if ('number' === typeof c)
          return new a.Unit(this.scale / c, this.dimensions, this.labels);
        if (c instanceof b)
          return new a.Unit(this.scale / c.scale, this.dimensions.div(c.dimensions), this.labels);
        throw Error('Illegal Argument for div: ' + c);
      };
      b.prototype.pow = function (b) {
        if ('number' === typeof b)
          return new a.Unit(Math.pow(this.scale, b), this.dimensions.pow(b), this.labels);
        throw Error('Illegal Argument for div: ' + b);
      };
      b.prototype.toString = function () {
        var a, b, d;
        a = 1 === this.scale || this.dimensions.dimensionless() ? '' : ' ';
        b = 1 === this.scale ? '' : '' + this.scale;
        d = [
          c(this.dimensions.M, this.labels[0]),
          c(this.dimensions.L, this.labels[1]),
          c(this.dimensions.T, this.labels[2]),
          c(this.dimensions.Q, this.labels[3])
        ].filter(function (a) {
          return 'string' === typeof a;
        }).join(' ');
        return '' + b + a + d;
      };
      return b;
    }();
    this.BLADE.Unit = b;
  }.call(this));
  (function () {
    this.BLADE = this.BLADE || {};
    this.BLADE.bladeASM = function (a, b, c) {
      return {
        addE2: function (a, b, c, g, h, k, l, m, n) {
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(+a + +h);
            break;
          case 1:
            p = +(+b + +k);
            break;
          case 2:
            p = +(+c + +l);
            break;
          case 3:
            p = +(+g + +m);
          }
          return +p;
        },
        subE2: function (a, b, c, g, h, k, l, m, n) {
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(+a - +h);
            break;
          case 1:
            p = +(+b - +k);
            break;
          case 2:
            p = +(+c - +l);
            break;
          case 3:
            p = +(+g - +m);
          }
          return +p;
        },
        mulE2: function (a, b, c, g, h, k, l, m, n) {
          a = +a;
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          m = +m;
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(a * h + b * k + c * l - g * m);
            break;
          case 1:
            p = +(a * k + b * h - c * m + g * l);
            break;
          case 2:
            p = +(a * l + b * m + c * h - g * k);
            break;
          case 3:
            p = +(a * m + b * l - c * k + g * h);
          }
          return +p;
        },
        extE2: function (a, b, c, g, h, k, l, m, n) {
          a = +a;
          b = +b;
          c = +c;
          h = +h;
          k = +k;
          l = +l;
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(a * h);
            break;
          case 1:
            p = +(a * k + b * h);
            break;
          case 2:
            p = +(a * l + c * h);
            break;
          case 3:
            p = +(a * +m + b * l - c * k + +g * h);
          }
          return +p;
        },
        lcoE2: function (a, b, c, g, h, k, l, m, n) {
          a = +a;
          b = +b;
          c = +c;
          k = +k;
          l = +l;
          m = +m;
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(a * +h + b * k + c * l - +g * m);
            break;
          case 1:
            p = +(a * k - c * m);
            break;
          case 2:
            p = +(a * l + b * m);
            break;
          case 3:
            p = +(a * m);
          }
          return +p;
        },
        rcoE2: function (a, b, c, g, h, k, l, m, n) {
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(+a * h + b * k + c * l - g * +m);
            break;
          case 1:
            p = +(-b * h - g * l);
            break;
          case 2:
            p = +(-c * h + g * k);
            break;
          case 3:
            p = +(g * h);
          }
          return +p;
        },
        addE3: function (a, b, c, g, h, k, l, m, n, p, q, r, v, s, z, y, C) {
          var t = 0;
          switch (~~(C | 0)) {
          case 0:
            t = +(+a + +n);
            break;
          case 1:
            t = +(+b + +p);
            break;
          case 2:
            t = +(+c + +q);
            break;
          case 3:
            t = +(+g + +r);
            break;
          case 4:
            t = +(+h + +v);
            break;
          case 5:
            t = +(+k + +s);
            break;
          case 6:
            t = +(+l + +z);
            break;
          case 7:
            t = +(+m + +y);
          }
          return +t;
        },
        subE3: function (a, b, c, g, h, k, l, m, n, p, q, r, v, s, z, y, C) {
          var t = 0;
          switch (~~(C | 0)) {
          case 0:
            t = +(+a - +n);
            break;
          case 1:
            t = +(+b - +p);
            break;
          case 2:
            t = +(+c - +q);
            break;
          case 3:
            t = +(+g - +r);
            break;
          case 4:
            t = +(+h - +v);
            break;
          case 5:
            t = +(+k - +s);
            break;
          case 6:
            t = +(+l - +z);
            break;
          case 7:
            t = +(+m - +y);
          }
          return +t;
        },
        mulE3: function (a, b, c, g, h, k, l, m, n, p, q, r, v, s, z, y, C) {
          a = +a;
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          m = +m;
          n = +n;
          p = +p;
          q = +q;
          r = +r;
          v = +v;
          s = +s;
          z = +z;
          y = +y;
          var t = 0;
          switch (~~(C | 0)) {
          case 0:
            t = +(a * n + b * p + c * q + g * r - h * v - k * s - l * z - m * y);
            break;
          case 1:
            t = +(a * p + b * n - c * v + g * z + h * q - k * y - l * r - m * s);
            break;
          case 2:
            t = +(a * q + b * v + c * n - g * s - h * p + k * r - l * y - m * z);
            break;
          case 3:
            t = +(a * r - b * z + c * s + g * n - h * y - k * q + l * p - m * v);
            break;
          case 4:
            t = +(a * v + b * q - c * p + g * y + h * n - k * z + l * s + m * r);
            break;
          case 5:
            t = +(a * s + b * y + c * r - g * q + h * z + k * n - l * v + m * p);
            break;
          case 6:
            t = +(a * z - b * r + c * y + g * p - h * s + k * v + l * n + m * q);
            break;
          case 7:
            t = +(a * y + b * s + c * z + g * v + h * r + k * p + l * q + m * n);
          }
          return +t;
        },
        extE3: function (a, b, c, g, h, k, l, m, n, p, q, r, v, s, z, y, C) {
          a = +a;
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          n = +n;
          p = +p;
          q = +q;
          r = +r;
          v = +v;
          s = +s;
          z = +z;
          var t = 0;
          switch (~~(C | 0)) {
          case 0:
            t = +(a * n);
            break;
          case 1:
            t = +(a * p + b * n);
            break;
          case 2:
            t = +(a * q + c * n);
            break;
          case 3:
            t = +(a * r + g * n);
            break;
          case 4:
            t = +(a * v + b * q - c * p + h * n);
            break;
          case 5:
            t = +(a * s + c * r - g * q + k * n);
            break;
          case 6:
            t = +(a * z - b * r + g * p + l * n);
            break;
          case 7:
            t = +(a * +y + b * s + c * z + g * v + h * r + k * p + l * q + +m * n);
          }
          return +t;
        },
        lcoE3: function (a, b, c, g, h, k, l, m, n, p, q, r, v, s, z, y, C) {
          a = +a;
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          p = +p;
          q = +q;
          r = +r;
          v = +v;
          s = +s;
          z = +z;
          y = +y;
          var t = 0;
          switch (~~(C | 0)) {
          case 0:
            t = +(a * +n + b * p + c * q + g * r - h * v - k * s - l * z - +m * y);
            break;
          case 1:
            t = +(a * p - c * v + g * z - k * y);
            break;
          case 2:
            t = +(a * q + b * v - g * s - l * y);
            break;
          case 3:
            t = +(a * r - b * z + c * s - h * y);
            break;
          case 4:
            t = +(a * v + g * y);
            break;
          case 5:
            t = +(a * s + b * y);
            break;
          case 6:
            t = +(a * z + c * y);
            break;
          case 7:
            t = +(a * y);
          }
          return +t;
        },
        rcoE3: function (a, b, c, g, h, k, l, m, n, p, q, r, v, s, z, y, C) {
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          m = +m;
          n = +n;
          p = +p;
          q = +q;
          r = +r;
          v = +v;
          s = +s;
          z = +z;
          var t = 0;
          switch (~~(C | 0)) {
          case 0:
            t = +(+a * n + b * p + c * q + g * r - h * v - k * s - l * z - m * +y);
            break;
          case 1:
            t = +(+b * n + h * q - l * r - m * s);
            break;
          case 2:
            t = +(+c * n - h * p + k * r - m * z);
            break;
          case 3:
            t = +(+g * n - k * q + l * p - m * v);
            break;
          case 4:
            t = +(+h * n + m * r);
            break;
          case 5:
            t = +(+k * n + m * p);
            break;
          case 6:
            t = +(+l * n + m * q);
            break;
          case 7:
            t = +(+m * n);
          }
          return +t;
        }
      };
    }('object' === typeof window ? window : void 0, {}, new ArrayBuffer(4096));
  }.call(this));
  (function () {
    this.BLADE = this.BLADE || {};
    this.BLADE.bladeSTR = function () {
      return {
        stringFromCoordinates: function (a, b) {
          var c, d, e, f, g;
          e = [];
          c = function (a, b) {
            var c;
            if (0 !== a) {
              0 <= a ? 0 < e.length && e.push('+') : e.push('-');
              c = Math.abs(a);
              if (1 === c)
                return e.push(b);
              e.push(c.toString());
              if ('1' !== b)
                return e.push('*'), e.push(b);
            }
          };
          d = f = 0;
          for (g = a.length - 1; 0 <= g ? f <= g : f >= g; d = 0 <= g ? ++f : --f)
            c(a[d], b[d]);
          return 0 < e.length ? e.join('') : '0';
        }
      };
    }();
  }.call(this));
  (function () {
    this.BLADE = this.BLADE || {};
    this.BLADE.e2gaASM = function (a, b, c) {
      return {
        add00: function (a, b, c, g, h, k, l, m) {
          return +(+a + +h);
        },
        add01: function (a, b, c, g, h, k, l, m) {
          return +(+b + +k);
        },
        add10: function (a, b, c, g, h, k, l, m) {
          return +(+c + +l);
        },
        add11: function (a, b, c, g, h, k, l, m) {
          return +(+g + +m);
        }
      };
    }('object' === typeof window ? window : void 0, {}, new ArrayBuffer(4096));
  }.call(this));
}());
Sk.builtinFiles = {
  'files': {
    'src/lib/pythonds/trees/binheap.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n',
    'src/lib/pythonds/basic/stack.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#stack.py\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def push(self, item):\r\n        self.items.append(item)\r\n\r\n    def pop(self):\r\n        return self.items.pop()\r\n\r\n    def peek(self):\r\n        return self.items[len(self.items)-1]\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n\r\n',
    'src/lib/pythonds/trees/bst.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    \'\'\'\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError(\'Error, key not in tree\')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError(\'Error, key not in tree\')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError(\'Error, key not in tree\')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        """The standard inorder traversal of a binary tree."""\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n',
    'src/lib/time/__init__.js': '\n/*\n\tBarebones implementation of the Python time package.\n\n\tFor now, only the time() function is implemented.\n*/\n \nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    mod.time = new Sk.builtin.func(function() {\n\t  return Sk.builtin.assk$(new Date().getTime() / 1000, undefined);\n    });\n\n    return mod;\n}\n',
    'src/lib/image/__init__.js': 'var ImageMod; // the single identifier needed in the global scope\n\nif (! ImageMod) {\n    ImageMod = { };\n    ImageMod.canvasLib = [];\n}\n\n//  todo create an empty image by reading image data from a blank canvas of the appropriate size\n\nvar $builtinmodule = function(name) {\n    var mod = {};\n\n    var image = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,imageId) {\n            self.image = document.getElementById(imageId.v);\n            if (self.image == null) {\n                throw "There is no image on this page named: " + imageId.v;\n            }\n            self.width = self.image.width;\n            self.height = self.image.height;\n            self.canvas = document.createElement("canvas");\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.ctx = self.canvas.getContext("2d");\n            self.ctx.drawImage(self.image,0,0)\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n        $loc.getPixel = new Sk.builtin.func(function(self,x,y) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            var red = self.imagedata.data[index]\n            var green = self.imagedata.data[index+1]\n            var blue = self.imagedata.data[index+2]\n            return Sk.misceval.callsim(mod.Pixel,red,green,blue);\n        });\n\n        $loc.setPixel = new Sk.builtin.func(function(self, x, y, pix) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            self.imagedata.data[index] = Sk.misceval.callsim(pix.getRed,pix);\n            self.imagedata.data[index+1] = Sk.misceval.callsim(pix.getGreen,pix);\n            self.imagedata.data[index+2] = Sk.misceval.callsim(pix.getBlue,pix);\n            self.imagedata.data[index+3] = 255;\n        });\n\n        $loc.getHeight = new Sk.builtin.func(function(self) {\n            return self.image.height;\n        });\n\n        $loc.getWidth = new Sk.builtin.func(function(self,titlestring) {\n            return self.image.width;\n        });\n\n        $loc.draw = new Sk.builtin.func(function(self,win,ulx,uly) {\n\t\t\twin = Sk.builtin.asnum$(win);\n\t\t\tulx = Sk.builtin.asnum$(ulx);\n\t\t\tuly = Sk.builtin.asnum$(uly);\n            var can = Sk.misceval.callsim(win.getWin,win);\n            var ctx = can.getContext("2d");\n            //ctx.putImageData(self.imagedata,0,0,0,0,self.imagedata.width,self.imagedata.height);\n            if (! ulx) {\n                ulx = 0;\n                uly = 0;\n            }\n            ctx.putImageData(self.imagedata,ulx,uly);\n        });\n\n        // toList\n\n    }\n\n    mod.Image = Sk.misceval.buildClass(mod, image, \'Image\', []);\n\n    var eImage = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            self.width = Sk.builtin.asnum$(width);\n            self.height = Sk.builtin.asnum$(height);\n            self.canvas = document.createElement("canvas");\n            self.ctx = self.canvas.getContext(\'2d\');\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n    }\n\n    mod.EmptyImage = Sk.misceval.buildClass(mod, eImage, \'EmptyImage\', [mod.Image]);\n\n    // create a ListImage object\n\n    \n    var pixel = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,r,g,b) {\n            self.red = Sk.builtin.asnum$(r);\n            self.green = Sk.builtin.asnum$(g);\n            self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.getRed = new Sk.builtin.func(function(self) {\n           return self.red;\n        });\n\n        $loc.getGreen = new Sk.builtin.func(function(self) {\n           return self.green;\n        });\n\n        $loc.getBlue = new Sk.builtin.func(function(self) {\n           return self.blue;\n        });\n\n        $loc.setRed = new Sk.builtin.func(function(self,r) {\n           self.red = Sk.builtin.asnum$(r);\n        });\n\n        $loc.setGreen = new Sk.builtin.func(function(self,g) {\n           self.green = Sk.builtin.asnum$(g);\n        });\n\n        $loc.setBlue = new Sk.builtin.func(function(self,b) {\n           self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.__getitem__ = new Sk.builtin.func(function(self,k) {\n\t\t   k = Sk.builtin.asnum$(k);\n           if(k == 0) {\n               return self.red;\n           } else if (k == 1) {\n               return self.green;\n           } else if (k == 2) {\n               return self.blue;\n           }\n        });\n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            return "[" + self.red + "," + self.green + "," + self.blue + "]"\n        });\n        \n        //getColorTuple\n        $loc.getColorTuple = new Sk.builtin.func(function(self,x,y) {\n\n        });\n\n        //setRange -- change from 0..255 to 0.0 .. 1.0\n        $loc.setRange = new Sk.builtin.func(function(self,mx) {\n            self.max = Sk.builtin.asnum$(mx);\n        });\n\n    }\n    mod.Pixel = Sk.misceval.buildClass(mod, pixel, \'Pixel\', []);\n\n\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            var currentCanvas = ImageMod.canvasLib[Sk.canvas];\n            if (currentCanvas === undefined) {\n                self.theScreen = document.getElementById(Sk.canvas);\n                if (width !== undefined) {\n                    self.theScreen.height = height;\n                    self.theScreen.width = width;\n                }\n\n                ImageMod.canvasLib[Sk.canvas] = self.theScreen;\n            } else {\n                self.theScreen = currentCanvas;\n                self.theScreen.height = self.theScreen.height;\n            }\n            self.theScreen.style.display = "block";\n        });\n\n        $loc.getWin = new Sk.builtin.func(function(self) {\n           return self.theScreen;\n        });\n\n        // exitonclick\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            var canvas_id = self.theScreen.id;\n            self.theScreen.onclick = function() {\n                document.getElementById(canvas_id).style.display = \'none\';\n                document.getElementById(canvas_id).onclick = null;\n                delete ImageMod.canvasLib[canvas_id];\n            }\n\n        });\n        //getMouse\n    }\n\n    mod.ImageWin = Sk.misceval.buildClass(mod, screen, \'ImageWin\', []);\n\n    return mod\n}\n',
    'src/lib/browser/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n\n  var EVENT                    = \'Event\';\n  var FUNCTION                 = Sk.ffi.PyType.FUNCTION;\n  var NODE                     = \'Node\';\n  var WINDOW                   = \'Window\';\n  var WINDOW_ANIMATION_RUNNER  = \'WindowAnimationRunner\';\n  var WORKBENCH                = \'Workbench\';\n  var METHOD_START             = \'start\';\n\n  Sk.builtin.defineEvent(mod);\n\n  Sk.builtin.defineNode(mod);\n\n  mod[\'window\'] = Sk.ffi.callsim(Sk.builtin.buildWindowClass(mod));\n\n  mod[\'document\'] = Sk.ffi.callsim(Sk.builtin.buildDocumentClass(mod));\n\n  mod[WINDOW_ANIMATION_RUNNER] = Sk.ffi.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = Sk.ffi.functionPy(function(selfPy, tickPy, terminatePy, setUpPy, tearDownPy) {\n      Sk.ffi.checkMethodArgs(WINDOW_ANIMATION_RUNNER, arguments, 4, 4);\n      Sk.ffi.checkArgType("tick",      FUNCTION, Sk.ffi.isFunction(tickPy));\n      Sk.ffi.checkArgType("terminate", FUNCTION, Sk.ffi.isFunction(terminatePy));\n      Sk.ffi.checkArgType("setUp",     FUNCTION, Sk.ffi.isFunction(setUpPy));\n      Sk.ffi.checkArgType("tearDown",  FUNCTION, Sk.ffi.isFunction(tearDownPy));\n      var WindowAnimationRunner = function() {\n        this.tick      = Sk.ffi.remapToJs(tickPy);\n        this.terminate = Sk.ffi.remapToJs(terminatePy);\n        this.setUp     = Sk.ffi.remapToJs(setUpPy);\n        this.tearDown  = Sk.ffi.remapToJs(tearDownPy);\n        this.startTime = null;\n        this.elapsed   = null;\n        this.requestID = null;\n      };\n      WindowAnimationRunner.prototype = {\n        constructor: WindowAnimationRunner,\n        start: function() {\n          var war = this;\n          war.setUp();\n          var animate = function(timestamp) {\n            if (war.startTime) {\n              war.elapsed = timestamp - war.startTime;\n            }\n            else {\n              if (timestamp) {\n                war.startTime = timestamp;\n              }\n              else {\n                war.elapsed = 0;\n              }\n            }\n            if (war.terminate(war.elapsed / 1000)) {\n              window.cancelAnimationFrame(war.requestID);\n              war.tearDown();\n            }\n            else {\n              war.requestID = window.requestAnimationFrame(animate);\n              war.tick(war.elapsed / 1000);\n            }\n          };\n          animate(null);\n        },\n        toString: function() {\n          return WINDOW_ANIMATION_RUNNER;\n        }\n      };\n      Sk.ffi.referenceToPy(new WindowAnimationRunner(), WINDOW_ANIMATION_RUNNER, undefined, selfPy);\n    });\n    $loc.__getattr__ = Sk.ffi.functionPy(function(selfPy, name) {\n      var war = Sk.ffi.remapToJs(selfPy);\n      switch(name) {\n        case METHOD_START: {\n          return Sk.ffi.callableToPy(mod, METHOD_START, function(methodPy) {\n            Sk.ffi.checkMethodArgs(METHOD_START, arguments, 0, 0);\n            war.start();\n          });\n        }\n      }\n    });\n    $loc.__str__ = Sk.ffi.functionPy(function(selfPy) {\n      return Sk.ffi.stringToPy(WINDOW_ANIMATION_RUNNER);\n    });\n    $loc.__repr__ = Sk.ffi.functionPy(function(selfPy) {\n      return Sk.ffi.stringToPy(WINDOW_ANIMATION_RUNNER + "(" + ")");\n    });\n  }, WINDOW_ANIMATION_RUNNER, []);\n\n  return mod;\n}\n',
    'src/lib/fractions/__init__.js': '/**\n * fractions - Rational numbers\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var FRACTION = "Fraction";\n\n  Sk.builtin.defineFractions(mod, FRACTION, function(n, d) {return new BLADE.Rational(n, d)});\n\n  return mod;\n};',
    'src/lib/pythonds/basic/__init__.py': '\n#__all__ = ["stack"]\n\n\n#from .stack import Stack\n#from .queue import Queue\n\n\n\n',
    'src/lib/geometry/__init__.js': 'var $builtinmodule = function(moduleNamePy) {\n  var mod = {};\n  Sk.stdlib.defineThree(mod, THREE, BLADE);\n  Sk.builtin.defineGeometry(mod, THREE, Sk.ffi.remapToJs(moduleNamePy));\n  Sk.builtin.defineProbeE3(mod, THREE);\n  return mod;\n}\n',
    'src/lib/sprite/__init__.js': '//\n//\n// Sprite Graphics Module for DaVinci.\n//\n// Based on the turtle module by Brad Miller.\n//\n// Dependencies:\n//   jQuery\n//\n//\n\nvar SpriteGraphics; // the single identifier needed in the global scope\n\nif (! SpriteGraphics) {\n  SpriteGraphics = {};\n}\n\n\n(function () {\n\n  var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians.\n  var Rad2Degree = 180.0 / Math.PI; // conversion factor for radians to degrees.\n\n  function SpriteCanvas(options) {\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n\n    this.canvas = document.getElementById(this.canvasID);\n    this.context = this.canvas.getContext(\'2d\');\n    $(this.canvas).fadeIn();\n\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.setup(this.canvas.width,this.canvas.height);\n    SpriteGraphics.canvasInit = true;\n    this.tlist = []\n\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n    this.segmentLength = 10;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    SpriteGraphics.canvasLib[this.canvasID] = this;\n    //  This can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    Sk.tg.fadeOnExit = true;\n  }\n\n  SpriteCanvas.prototype.setup = function(width, height) {\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n\n    if (SpriteGraphics.canvasInit == false) {\n      this.context.save();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      SpriteGraphics.canvasInit = true;\n      SpriteGraphics.eventCount = 0;\n      SpriteGraphics.renderClock = 0;\n      SpriteGraphics.renderTime = 0;\n    }\n    else {\n      this.context.restore();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  SpriteCanvas.prototype.addToCanvas = function(t) {\n    this.tlist.push(t);\n  }\n\n  SpriteCanvas.prototype.onCanvas = function(t) {\n    return (this.tlist.indexOf(t) >= 0);\n  }\n\n  SpriteCanvas.prototype.isAnimating = function() {\n    return (this.tlist.length > 0);\n  }\n\n  SpriteCanvas.prototype.startAnimating = function(t) {\n    if (! this.isAnimating()) {\n      this.intervalId = setTimeout(render, this.delay);\n    }\n    // Added in case startAnimating is called after it\'s already been added.\n    if (!this.onCanvas(t)) {\n      this.addToCanvas(t);\n    }\n    Sk.isSpriteProgram = true;\n  }\n\n  SpriteCanvas.prototype.doneAnimating = function(t) {\n    this.tlist.splice(0,this.tlist.length);\n    clearTimeout(this.intervalId);\n    $(Sk.runButton).removeAttr(\'disabled\');\n  }\n\n  SpriteCanvas.prototype.cancelAnimation = function() {\n    if (this.intervalId) {\n      clearTimeout(this.intervalId);\n    }\n\n    for (var t in this.tlist) {\n      this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n    }\n    render();\n  }\n\n  SpriteCanvas.prototype.setSpeedDelay = function(s) {\n    var df = 10 - (s % 11) + 1;\n    this.delay = df * this.timeFactor;\n  }\n\n  SpriteCanvas.prototype.setDelay = function(d) {\n    this.delay = d;\n  }\n\n  SpriteCanvas.prototype.getDelay = function(s) {\n    return this.delay;\n  }\n\n  SpriteCanvas.prototype.setCounter = function(s) {\n    if (!s || s <= 0) {\n      s = 1;\n    }\n    this.renderCounter = s;\n  }\n\n  SpriteCanvas.prototype.getCounter = function() {\n    return this.renderCounter;\n  }\n\n  SpriteCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.context.restore();\n    this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n    if (lly == 0) {\n      this.context.translate(-llx, lly - (ury - lly));\n    }\n    else if (lly > 0) {\n      this.context.translate(-llx, -lly * 2);\n    }\n    else {\n      this.context.translate(-llx, -ury);\n    }\n\n    var xlinescale = (urx - llx) / this.canvas.width;\n    var ylinescale = (ury - lly) / this.canvas.height;\n    this.xptscale = xlinescale;\n    this.yptscale = ylinescale;\n    this.lineScale = Math.min(xlinescale,ylinescale);\n    this.context.save();\n\n    this.llx = llx;\n    this.lly = lly;\n    this.urx = urx;\n    this.ury = ury;\n\n  }\n\n  SpriteCanvas.prototype.window_width = function() {\n    return this.canvas.width;\n  }\n\n  SpriteCanvas.prototype.window_height = function() {\n    return this.canvas.height;\n  }\n\n  SpriteCanvas.prototype.bgcolor = function(c) {\n    this.background_color = c;\n    $(this.canvas).css("background-color",c.v);\n  }\n\n  SpriteCanvas.prototype.setSegmentLength = function(s) {\n    this.segmentLength = s;\n  }\n\n  SpriteCanvas.prototype.getSegmentLength = function() {\n    return this.segmentLength;\n  }\n\n  // todo: if animating, this should be deferred until the proper time\n  SpriteCanvas.prototype.exitonclick = function () {\n    var canvas_id = this.canvasID;\n    var theCanvas = this;\n    $(this.canvas).click(function() {\n      if (! theCanvas.isAnimating()) {\n        if (Sk.tg.fadeOnExit) {\n         $("#"+canvas_id).hide();\n       }\n       $("#"+canvas_id).unbind(\'click\');\n       Sk.tg.canvasInit = false;\n       delete Sk.tg.canvasLib[canvas_id];\n     }\n   });\n  }\n\n  SpriteCanvas.prototype.sprites = function() {\n    return SpriteGraphics.spriteList;\n  }\n\n /**\n  * New version NOT attached to a sprite (as per real sprite)\n  */\n  SpriteCanvas.prototype.tracer = function(t, d) {\n    this.setCounter(t);\n    if (t == 0) {\n      for (var i in this.spriteList) {\n        this.spriteList[i].animate = false;\n      }\n      this.cancelAnimation();\n    }\n    if (d !== undefined) {\n      this.setDelay(d);\n    }\n  }\n\n  // check if all sprites are done\n  allDone = function() {\n    var allDone = true;\n    for (var tix in SpriteGraphics.spriteList) {\n      var theT = SpriteGraphics.spriteList[tix];\n      allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n    }\n    return allDone;\n  }\n\n  //\n  //  This is the function that provides the animation\n  //\n  render = function () {\n    var context = document.getElementById(SpriteGraphics.defaults.canvasID).getContext(\'2d\');\n    with (context) {\n      with (SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID]) {\n        clearRect(llx, lly, (urx - llx), (ury - lly));\n      }\n      var incr = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID].getCounter();\n      var lastCanvas = null;\n\n      SpriteGraphics.renderClock += incr;\n\n      for (var tix in SpriteGraphics.spriteList) {\n        var t = SpriteGraphics.spriteList[tix]\n        lastCanvas = t.spriteCanvas \n        if (t.aCount >= t.drawingEvents.length) {\n          t.aCount = t.drawingEvents.length - 1;\n        }\n        moveTo(0, 0);\n        var currentPos = new Vector(0,0,0);\n        var currentHead = new Vector(1,0,0);\n        lineWidth = t.get_pen_width();\n        lineCap = \'round\';\n        lineJoin = \'round\';\n        strokeStyle = \'black\';\n        var filling = false;\n        if (isNaN(t.spriteCanvas.delay)) {\n          t.spriteCanvas.delay = 0\n        }\n        for (var i = t.clearPoint; (i <= t.aCount || t.spriteCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n          if (i > t.aCount) {\n            // If se jump past aCount, jump it ahead\n            t.aCount = i\n          }\n          var oper = t.drawingEvents[i];\n          var ts = oper[oper.length-1];\n          if (ts <= SpriteGraphics.renderClock || t.spriteCanvas.delay == 0) {\n            if (ts > SpriteGraphics.renderClock) {\n              // If we go past the render clock, jump it ahead\n              SpriteGraphics.renderClock = ts\n            }\n            if (oper[0] == "LT") {  //  line to\n              if (! filling) {\n                beginPath();\n                moveTo(oper[1], oper[2]);\n              }\n              lineTo(oper[3], oper[4]);\n              strokeStyle = oper[5];\n              stroke();\n              currentPos = new Vector(oper[3],oper[4],0);\n              if (! filling)\n                closePath();\n            }\n            else if (oper[0] == "MT") {  // move to\n              moveTo(oper[3], oper[4]);\n              currentPos = new Vector(oper[3],oper[4],0);\n            }\n            else if (oper[0] == "BF") {  // begin fill\n              beginPath();\n              moveTo(oper[1], oper[2]);\n              filling = true;\n            }\n            else if (oper[0] == "EF") {  // end fill\n              fillStyle = oper[3];\n              stroke();\n              fill();\n              closePath();\n              filling = false;\n            }\n            else if (oper[0] == "FC") {  // fill color\n              fillStyle = oper[1];\n            }\n            else if (oper[0] == "TC") {  // sprite color\n              strokeStyle = oper[1];\n            }\n            else if (oper[0] == "PW") {  // Pen width\n              lineWidth = oper[1];\n            }\n            else if (oper[0] == "DT") {  // Dot\n              var col = fillStyle;\n              fillStyle = oper[2];\n              var size = oper[1];\n              fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n              fillStyle = col;\n            }\n            else if (oper[0] == "CI") {  // Circle\n              if (!filling)\n                beginPath();\n              arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n              currentPos = new Vector(oper[1]+Math.cos(oper[5])*oper[3],\n                oper[2]+Math.sin(oper[5])*oper[3],0);\n              stroke();\n              if (! filling) {\n                closePath();\n              }\n            }\n            else if (oper[0] == "WT") { // write\n              if (font)\n                font = oper[2];\n              scale(1, -1);\n              fillText(oper[1], oper[3], -oper[4]);\n              scale(1, -1);\n            } else if (oper[0] == "ST") {  // stamp\n              t.drawSprite(oper[3], new Vector(oper[1], oper[2], 0));\n            } else if (oper[0] == "HT") { // hide sprite\n              t.visible = false;\n            } else if (oper[0] == "SH") { // show sprite\n              t.visible = true;\n            } else if (oper[0] == "TT") {\n              currentHead = oper[1];\n            } else if (oper[0] == "CL") { // RNL clear\n              clear_canvas(t.canvasID);\n              t.clearPoint = i; // Different from reset that calls clear because it leaves the sprites where they are\n            } else if (oper[0] == "DL") { // RNL delay\n              var df = oper[1];\n              t.spriteCanvas.delay = df\n            } else if (oper[0] == "SC") { // RNL speed change\n              var s = oper[1]\n              if (s < 0)\n                s = 0\n              if (s > 10)\n                s = 10\n              var df = (10 - (s % 11) + 1) * t.spriteCanvas.timeFactor  //  10\n              if (s == 0) {\n                df = 0\n              }\n              // t.spriteCanvas.intervalId = clearInterval(t.spriteCanvas.intervalId);\n              t.spriteCanvas.delay = df;\n              // t.spriteCanvas.intervalId = setInterval(render, t.spriteCanvas.delay)\n              if (oper[2]) {\n                t.spriteCanvas.setSegmentLength(oper[2]);\n              }\n            } else if (oper[0] == "NO") {\n              // RNL no op\n            } else {\n            } // end of oper[0] test\n          } // end of if ts < render clock\n        } // end of for\n        t.aCount += incr;\n        if (t.visible) {\n          // draw the sprite\n          t.drawSprite(currentHead.toAngle(), currentPos); // just use currentHead\n        }\n      }\n      // if (t.aCount >= t.drawingEvents.length) {\n      if (SpriteGraphics.renderClock > SpriteGraphics.eventCount ){ // && allDone() ){\n        // t.spriteCanvas.doneAnimating(t);\n        if (lastCanvas) lastCanvas.doneAnimating(t);\n      }\n      else {\n        // t.spriteCanvas.intervalId = setTimeout(render, t.spriteCanvas.delay)\n        if (lastCanvas) {\n          lastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n        }\n      }\n    }\n  }\n\n  // Constructor for Sprite objects\n  function Sprite() {\n    if (arguments.length >= 1) {\n      this.initialize(arguments[0]);\n    }\n    else {\n      this.initialize();\n    }\n    SpriteGraphics.spriteList.push(this);\n  }\n\n  Sprite.prototype.go_home = function () {\n    // Put sprite in initial state\n    // sprite is headed to the right\n    // with position 0,0,0 in the middle of the canvas.\n    // x grows to the right\n    // y grows towards the top of the canvas\n    with (this) {\n      position = home;\n      context.moveTo(home[0], home[1]);\n      heading = new Vector([1.0, 0.0, 0.0]); // to the right; in sprite space x+ direction\n      normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n    }\n  };\n\n  Sprite.prototype.initialize = function () {\n    // Initialize the sprite.\n    var options = { };\n\n    if (arguments.length >= 1) {\n      options = arguments[0];\n    }\n\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n    this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n    this.animate = SpriteGraphics.defaults.animate;\n\n    with (this.context) {\n      if (SpriteGraphics.canvasInit == false) {\n        save();\n        translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n        scale(1, -1); // scaling like this flips the y axis the right way.\n        if (! SpriteGraphics.canvasLib[this.canvasID]) {\n          SpriteGraphics.canvasLib[this.canvasID] = new SpriteCanvas(options);\n        }\n        SpriteGraphics.canvasInit = true;\n      }\n      else {\n        clear_canvas(this.canvasID);\n      }\n\n      this.spriteCanvas = SpriteGraphics.canvasLib[this.canvasID];\n      this.home = new Vector([0.0, 0.0, 0.0]);\n      this.visible = true;\n      this.shapeStore = {};\n      this.shapeStore[\'turtle\'] = turtleShapePoints();\n      this.shapeStore[\'arrow\'] = defaultShapePoints();\n      this.shapeStore[\'circle\'] = circleShapePoints();\n      this.shapeStore[\'classic\'] = classicShapePoints();\n      this.currentShape = \'classic\';\n      this.drawingEvents = [];\n\n      this.filling = false;\n      this.pen = true;\n      this.penStyle = \'black\';\n      this.penWidth = 2;\n      this.fillStyle = \'black\';\n      this.position = [ ];\n      this.heading = [ ];\n      this.normal = [ ];\n      this.go_home();\n      this.aCount = 0;\n      this.clearPoint = 0;\n    }\n  }\n\n  function turtleShapePoints() {\n    var pl = [\n    [0,16],\n    [-2,14],\n    [-1,10],\n    [-4,7],\n    [-7,9],\n    [-9,8],\n    [-6,5],\n    [-7,1],\n    [-5,-3],\n    [-8,-6],\n    [-6,-8],\n    [-4,-5],\n    [0,-7],\n    [4,-5],\n    [6,-8],\n    [8,-6],\n    [5,-3],\n    [7,1],\n    [6,5],\n    [9,8],\n    [7,9],\n    [4,7],\n    [1,10],\n    [2,14]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function defaultShapePoints() {\n    var pl = [\n    [-10,0],\n    [10,0],\n    [0,10]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function circleShapePoints() {\n    var pl = [\n    [10,0],\n    [9.51,3.09],\n    [8.09,5.88],\n    [5.88,8.09],\n    [3.09,9.51],\n    [0,10],\n    [-3.09,9.51],\n    [-5.88,8.09],\n    [-8.09,5.88],\n    [-9.51,3.09],\n    [-10,0],\n    [-9.51,-3.09],\n    [-8.09,-5.88],\n    [-5.88,-8.09],\n    [-3.09,-9.51],\n    [-0.00,-10.00],\n    [3.09,-9.51],\n    [5.88,-8.09],\n    [8.09,-5.88],\n    [9.51,-3.09]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function classicShapePoints() {\n    var pl = [\n    [0,0],\n    [-5,-9],\n    [0,-7],\n    [5,-9]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  Sprite.prototype.clean = function () {\n    // Clean the canvas\n    // Optional second argument is color\n    with (this) {\n      if (arguments.length >= 1) {\n        clear_canvas(canvasID, arguments[0]);\n      }\n      else {\n        clear_canvas(canvasID);\n      }\n      initialize();\n    }\n  }\n\n  Sprite.prototype.addDrawingEvent = function(eventList) {\n    SpriteGraphics.eventCount += 1;\n    eventList.push(SpriteGraphics.eventCount);\n    this.drawingEvents.push(eventList);\n  }\n\n  //  \n  //  Drawing Functions\n  //\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n      var head = ep.sub(sp).normalize();\n      var numSegs = Math.floor(ep.sub(sp).len() / sL);\n      var res = [];\n      var oldp = sp;\n      var newp;\n      var op = ""\n      if (pen)\n        op = "LT"\n      else\n        op = "MT"\n      for (var i = 0; i < numSegs; i++) {\n        newp = oldp.linear(1, sL, head);\n        res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n        oldp = newp;\n      }\n      if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n        res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n      return res;\n    }\n\n    Sprite.prototype.draw_line = function(newposition) {\n      with (this) {\n        with (context) {\n          if (! animate) {\n            if (! filling) {\n              beginPath();\n              moveTo(position[0], position[1]);\n            }\n            lineCap = \'round\';\n            lineJoin = \'round\';\n            lineWidth = get_pen_width();\n            strokeStyle = penStyle;\n            lineTo(newposition[0], newposition[1]);\n            stroke();\n            if (! filling)\n              closePath();\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r) {\n              r[s].push(penStyle);\n              addDrawingEvent(r[s]);\n            }\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n      }\n    }\n\n    Sprite.prototype.forward = function (d) {\n      with (this) {\n        var newposition = position.linear(1, d, heading);\n        goto(newposition);\n      }\n    }\n\n    Sprite.prototype.backward = function(d) {\n      this.forward(-d);\n    }\n\n    // This is an internal function that sets the position without doing any drawing\n    Sprite.prototype.teleport_to = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      this.context.moveTo(newposition[0], newposition[1]);\n      this.position = newposition;\n    }\n\n    Sprite.prototype.goto = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      with (this) {\n        if (pen) {\n          draw_line(newposition);\n        } else {\n          if (! animate) {\n            context.moveTo(newposition[0], newposition[1]);\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r)\n              addDrawingEvent(r[s]);\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n        position = newposition;\n      }\n    }\n\n    Sprite.prototype.delay = function(d) {\n      if (d != null) {\n        if (d < 0) {\n          d = -d;\n        }\n        if (!this.animate) {\n          this.spriteCanvas.setDelay(d);\n        } \n        else {\n          this.spriteCanvas.setDelay(d);\n          this.addDrawingEvent(["DL", d]);\n          this.addDrawingEvent(["NO"]);\n        }\n      }\n      return this.spriteCanvas.getDelay();\n    }\n\n    Sprite.prototype.speed = function(s,t) {\n      if (s > 0 && !this.animate) {\n        this.animate = true;\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else if (s == 0 && !this.animate) {\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else {\n        // this.animate = false;\n        // this.spriteCanvas.cancelAnimation();\n        this.addDrawingEvent(["SC", s, t]);\n        this.addDrawingEvent(["NO"]);\n      }\n      if (t) {\n        this.spriteCanvas.setSegmentLength(t);\n        // set the number of units to divide a segment into\n      }\n      else {\n        this.spriteCanvas.setSegmentLength(10);\n      }\n    }\n\n    Sprite.prototype.tracer = function(t, d) {\n      this.spriteCanvas.setCounter(t);\n      if (t == 0) {\n       this.animate=false;\n       this.spriteCanvas.cancelAnimation();\n     }\n     if (d !== undefined)\n       this.spriteCanvas.setDelay(d);\n   }\n\n   Sprite.prototype.getRenderCounter = function() {\n    return this.spriteCanvas.getCounter();\n  }\n\n  Sprite.prototype.turn = function (phi) {\n    with (this) {\n      var alpha = phi * Degree2Rad;\n      var left = normal.cross(heading);\n      var newheading = heading.rotateNormal(left, normal, alpha);\n      heading = newheading;\n\n      if (animate) {\n        addDrawingEvent(["TT",heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.right = Sprite.prototype.turn;\n\n  Sprite.prototype.left = function(phi) {\n    this.turn(-phi);\n  }\n\n  Sprite.prototype.get_heading = function () {\n    if (SpriteGraphics.defaults.degrees)\n      return this.heading.toAngle()\n    else\n      return this.heading\n  }\n\n  Sprite.prototype.get_position = function () {\n    return this.position;\n  }\n\n  Sprite.prototype.getx = function () {\n    return this.position[0];\n  }\n\n  Sprite.prototype.gety = function () {\n    return this.position[1];\n  }\n\n  Sprite.prototype.set_heading = function(newhead) {\n    if ((typeof(newhead)).toLowerCase() === \'number\') {\n      this.heading = Vector.angle2vec(newhead);\n    } else {\n      this.heading = newhead;\n    }\n  }\n\n  Sprite.prototype.towards = function(to, y) {\n    // set heading vector to point towards another point.\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    else if (! (to instanceof Vector)) {\n      to = new Vector(to);\n    }\n    var res = to.sub(this.position);\n    res = res.normalize();\n    if (SpriteGraphics.defaults.degrees)\n      return res.toAngle();\n    else\n      return res;\n  }\n\n  Sprite.prototype.distance = function(to, y) {\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    return this.position.sub(new Vector(to)).len();\n  }\n\n  Sprite.prototype.dot = function() {\n    var size = 2;\n    if (arguments.length >= 1) size = arguments[0];\n    size = size * this.spriteCanvas.lineScale;\n    with (this) {\n      with (context) {\n        var color = penStyle;\n        var nc = arguments[1] || color;\n        if (! animate) {\n          fillStyle = nc;\n          fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n          fillStyle = color;\n        } else {\n          addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n        }\n      }\n    }\n  }\n\n  Sprite.prototype.circle = function(radius, extent) {\n    if (extent === undefined) {\n      extent = 360\n    }\n    if (this.animate) {\n     var arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n     var segLen = this.spriteCanvas.getSegmentLength();\n     if (arcLen <= segLen)\n      this.arc(radius,extent);\n    else {\n        //  Break the arc into segments for animation\n        var extentPart = (segLen / arcLen) * extent;\n        var extentLeft = extent;\n        while (Math.abs(extentLeft) > Math.abs(extentPart)) {\n          this.arc(radius, extentPart);\n          extentLeft = extentLeft - extentPart;\n        }\n        if (Math.abs(extentLeft) > 0.01)\n          this.arc(radius, extentLeft);\n      }\n    } else {\n      this.arc(radius,extent);\n    }\n  }\n  \n  Sprite.prototype.arc = function(radius, extent) {\n    //  Figure out where the sprite is and which way it\'s facing\n    var spriteHeading = this.get_heading()\n    var tx = this.position[0]\n    var ty = this.position[1]\n\n    //  Figure out the circle center\n    var cx = tx + (radius * Math.cos((spriteHeading + 90) * Degree2Rad));\n    var cy = ty + (radius * Math.sin((spriteHeading + 90) * Degree2Rad));\n\n    //  Canvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Sprite\n\n    //  Figure out our arc angles\n    var startAngleDeg;\n    if (radius >= 0)\n      startAngleDeg = spriteHeading - 90;\n    else\n      startAngleDeg = spriteHeading + 90;\n\n    var endAngleDeg;\n    if (extent) {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + extent;\n      else\n        endAngleDeg = startAngleDeg - extent;\n    }\n    else {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + 360;\n      else\n        endAngleDeg = startAngleDeg - 360;\n    }\n\n    //  Canvas angles are opposite\n    startAngleDeg = 360 - startAngleDeg\n    endAngleDeg   = 360 - endAngleDeg\n\n    //  Becuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n    startAngleDeg = -startAngleDeg\n    endAngleDeg   = -endAngleDeg\n\n    //  Convert to radians\n    var startAngle = startAngleDeg * Degree2Rad;\n    var endAngle   = endAngleDeg   * Degree2Rad;\n\n\n    //  Do the drawing\n    if (! this.animate) {\n      if (!this.filling)\n        this.context.beginPath();\n      this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n      this.context.stroke();\n      if (!this.filling)\n        this.context.closePath();\n    }\n    else {\n      this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n    }\n\n    //  Move the sprite only if we have to\n    if (extent && (extent % 360) != 0) {\n      var turtleArc;\n      if (radius >= 0)\n        turtleArc = extent;\n      else \n        turtleArc = -extent;\n      var newHeading = (spriteHeading + turtleArc) % 360;\n      if (newHeading < 0)\n        newHeading = newHeading + 360;\n\n      var nx = cx + (radius * Math.cos((newHeading - 90) * Degree2Rad));\n      var ny = cy + (radius * Math.sin((newHeading - 90) * Degree2Rad));  //  y coord is inverted in sprite\n\n      //  Move it internally\n      this.set_heading(newHeading);\n      this.teleport_to(nx,ny);\n\n      //  If we\'re animating the sprite, move it on the screen\n      if (this.animate) {\n        this.addDrawingEvent(["TT", this.heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.write = function(theText, move, align, font) {\n    if (! this.animate) {\n      if (font)\n        this.context.font = font.v;\n      this.context.scale(1, -1);\n      this.context.fillText(theText, this.position[0], -this.position[1]);\n      this.context.scale(1, -1);\n    } else {\n      var fontspec;\n      if (font)\n        fontspec = font.v\n      this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.spriteCanvas.setworldcoordinates(llx, lly, urx, ury);\n  }\n\n  //\n  // Pen and Style functions\n  //\n  Sprite.prototype.pen_down = function () {\n    this.pen = true;\n  }\n\n  Sprite.prototype.down = Sprite.prototype.pen_down;\n\n  Sprite.prototype.pen_up = function () {\n    this.pen = false;\n  }\n\n  Sprite.prototype.up = Sprite.prototype.pen_up;\n\n  Sprite.prototype.get_pen = function () {\n    return this.pen;\n  }\n\n  Sprite.prototype.set_pen_width = function (w) {\n    if (this.animate)\n      this.addDrawingEvent(["PW", w * this.spriteCanvas.lineScale]);\n    else\n      this.penWidth = w;\n  }\n\n  Sprite.prototype.get_pen_width = function() {\n    return this.penWidth * this.spriteCanvas.lineScale;\n  }\n\n  Sprite.prototype.set_pen_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.penStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      }\n      else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16);\n      gs = c1.toString(16);\n      bs = c2.toString(16);\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.penStyle = c;\n    }\n\n    this.context.strokeStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["TC", c]);\n  }\n\n  Sprite.prototype.set_fill_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.fillStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      } else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16)\n      gs = c1.toString(16)\n      bs = c2.toString(16)\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.fillStyle = c;\n    }\n\n    this.context.fillStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["FC", c]);\n  }\n\n  Sprite.prototype.begin_fill = function () {\n    if (! this.animate) {\n      this.filling = true;\n      this.context.beginPath();\n      this.context.moveTo(this.position[0], this.position[1]);\n    }\n    else {\n      this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.end_fill = function () {\n    if (! this.animate) {\n      this.context.stroke();\n      this.context.fill();\n      this.context.closePath();\n      this.filling = false;\n    } else\n    this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n  }\n\n  Sprite.prototype.showturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["SH"]);\n    }\n    this.visible = true;\n  }\n\n  Sprite.prototype.hideturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["HT"]);\n    }\n    this.visible = false;\n  }\n\n  Sprite.prototype.isvisible = function() {\n    return this.visible;\n  }\n\n  // \n  // Appearance\n  //\n\n  Sprite.prototype.shape = function(s) {\n    if (this.shapeStore[s])\n      this.currentShape = s;\n    else {\n    }\n  }\n\n  Sprite.prototype.drawSprite = function(heading, position) {\n    var rtPoints = [];\n    var plist = this.shapeStore[this.currentShape];\n    var head;\n    if (! (heading === undefined))\n      head = heading - 90.0;\n    else\n      head = this.heading.toAngle() - 90.0;\n    if (! position)\n      position = this.position\n    for (p in plist) {\n      rtPoints.push(plist[p].scale(this.spriteCanvas.xptscale,this.spriteCanvas.yptscale).rotate(head).add(position));\n    }\n    this.context.beginPath();\n    this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n    for (var i = 1; i < rtPoints.length; i++) {\n      this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n    }\n    this.context.closePath();\n    this.context.stroke();\n    if (this.fillStyle) {\n      this.context.fill();\n    }\n  }\n\n  Sprite.prototype.stamp = function() {\n    // either call drawSprite or just add a DT with current position and heading to the drawingEvents list.\n    if (this.animate) {\n      this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n    } else\n    this.drawSprite();\n  }\n\n  Sprite.prototype.clear = function () {\n    if (this.animate) {\n      this.addDrawingEvent(["CL"])\n    }\n    else {\n      clear_canvas(this.canvasID);\n    }\n  }\n\n  function clear_canvas(canId) {\n    with (document.getElementById(canId).getContext(\'2d\')) {\n      if (arguments.length >= 2) {\n        // fillStyle = arguments[1];\n        // fillRect(0, 0, canvas.width, canvas.height);\n      }\n      clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n    }\n  }\n\n\n  // Create a 3d Vector class for manipulating sprite heading, and position.\n\n  function Vector(x, y, z) {\n    if ((typeof(x)).toLowerCase() === \'number\') {\n      Array.prototype.push.call(this, x);\n      Array.prototype.push.call(this, y);\n      Array.prototype.push.call(this, z);\n    }\n    else {\n      for (var i in x) {\n        Array.prototype.push.call(this, x[i]);\n      }\n    }\n  }\n\n\n  // Create a vector object given a direction as an angle.\n  Vector.angle2vec = function(phi) {\n    var res = new Vector([0.0,0.0,0.0]);\n    phi = phi * Degree2Rad;\n    res[0] = Math.cos(phi);\n    res[1] = Math.sin(phi);\n    return res.normalize();\n  }\n\n  // This trick allows you to access a Vector object like an array\n  // myVec[0] == x\n  // myVec[1] == y\n  // myVec[2] == z\n  // we really only need the z for the convenience of rotating!\n  // If we were using Geometric Algebra we wouldn\'t need it at all and could stay in the plane.\n  Vector.prototype.addItem = function(item) {\n    Array.prototype.push.call(this, item);\n  }\n\n  Vector.prototype.linear = function(a, b, v) {\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = a * this[c] + b * v[c];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.cross = function(v) {\n    // Return cross product of this and v\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.rotate = function(angle) {\n    // Rotate this counter clockwise by angle.\n    var perp = new Vector(-this[1], this[0], 0);\n    angle = angle * Degree2Rad;\n    var c = Math.cos(angle);\n    var s = Math.sin(angle);\n    return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n  }\n\n  Vector.prototype.rotateNormal = function(v, w, alpha) {\n    // Return rotation of this in direction of v about w over alpha\n    // Requires: v, w are vectors; alpha is angle in radians\n    //   this, v, w are orthonormal\n    return this.linear(Math.cos(alpha), Math.sin(alpha), v);\n  }\n\n  Vector.prototype.normalize = function() {\n    var n = this.len();\n    var res = this.div(n);\n    return res;\n  }\n\n  Vector.prototype.toAngle = function() {\n    // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n    if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n    if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n    var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n    var deg = rads * Rad2Degree;\n    if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n    else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n    else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n    return deg;\n  }\n\n  // divide all vector components by the same value\n  Vector.prototype.div = function(n) {\n    res = []\n    res[0] = this[0] / n;\n    res[1] = this[1] / n;\n    res[2] = this[2] / n;\n    return new Vector(res);\n  }\n\n  // subtract one vector from another\n  Vector.prototype.sub = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] - v[0];\n    res[1] = this[1] - v[1];\n    res[2] = this[2] - v[2];\n    return res;\n  }\n\n  Vector.prototype.add = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] + v[0];\n    res[1] = this[1] + v[1];\n    res[2] = this[2] + v[2];\n    return res;\n  }\n\n  Vector.prototype.smul = function(k) {  // scalar multiplication\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] * k;\n    res[1] = this[1] * k;\n    res[2] = this[2] * k;\n    return res;\n  }\n\n  Vector.prototype.scale = function(xs,ys) {\n    res = new Vector(0,0,0);\n    res[0] =  this[0] * ys;\n    res[1] =  this[1] * xs;\n    res[2] = 1.0;\n    return res;\n  }\n\n  Vector.prototype.len = function() {\n    return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n  }\n\n  SpriteGraphics.defaults = {canvasID: \'mycanvas\', degrees: true, animate: true};\n  SpriteGraphics.spriteList = [];\n  SpriteGraphics.Sprite = Sprite;\n  SpriteGraphics.SpriteCanvas = SpriteCanvas;\n  SpriteGraphics.canvasLib = {};\n  SpriteGraphics.clear_canvas = clear_canvas;\n  SpriteGraphics.Vector = Vector;\n  SpriteGraphics.canvasInit = false;\n  SpriteGraphics.eventCount = 0;\n  SpriteGraphics.renderClock = 0;\n  SpriteGraphics.renderTime  = 0;\n\n})();\n\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  Sk.builtin.defineEuclidean2(mod, BLADE);\n\n  // The exported name of the SPRITE class.\n  var SPRITE = "Sprite";\n\n  // First we create an object, this will end up being the class\n  Sk.tg = SpriteGraphics;\n\n  var checkArgs = function(expected, actual, func) {\n    if (actual != expected ) {\n      throw new Sk.builtin.TypeError(func + " takes exactly " + expected + " positional argument (" + actual + " given)");\n    }\n  }\n\n  var sprite = function($gbl, $loc) {\n\n    $loc.__init__ = new Sk.builtin.func(function(self, options) {\n      SpriteGraphics.defaults = {"canvasID": Sk.canvas, "animate": true, "degrees": true};\n      self.skType = SPRITE;\n      self.tp$name = SPRITE;\n      self.v = new SpriteGraphics.Sprite();\n      if (options instanceof Sk.builtin.dict) {\n        for (var iter = options.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n          var v = options.mp$subscript(k);\n          if (v === undefined) {\n            v = null;\n          }\n          var kAsJs = Sk.ffi.remapToJs(k);\n          var vAsJs = Sk.ffi.remapToJs(v);\n          Sk.misceval.callsim(self[\'__setattr__\'], self, kAsJs, v);\n        }\n      }\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n\n      var BACKWARD = "backward";\n      var BEGIN_FILL = "begin_fill";\n      // color is implemented as a callable attribute for compatibility.\n      var COLOR = "color";\n      var DOWN = "down";\n      var END_FILL = "end_fill";\n      // FILL_COLOR is implemented as a callable attribute for backwcompatibility.\n      var FILL_COLOR = "fillcolor";\n      var FORWARD = "forward";\n      var GOTO = "goto";\n      var LEFT = "left";\n      var POSITION = "position";\n      var RIGHT = "right";\n      // shape is implemented as a callable attribute for compatibility.\n      var SHAPE = "shape";\n      var STAMP = "stamp";\n      var UP = "up";\n      // Capture the target of the attribute operation.\n      var target = self.v;\n\n      switch(key) {\n        case BACKWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BACKWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, BACKWARD);\n              target.forward(-distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n          }, BACKWARD, []));\n        }\n        case BEGIN_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BEGIN_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, BEGIN_FILL);\n              target.begin_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n          }, BEGIN_FILL, []));\n        }\n        case COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if(color) {\n                if (blue) {\n                  target.set_pen_color(color, green, blue);\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_pen_color(color);\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return [target.penStyle, target.fillStyle];\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n          }, COLOR, []));\n        }\n        case DOWN: {\n          return Sk.ffi.callableToPy(mod, DOWN, function(methodPy) {\n            Sk.ffi.checkMethodArgs(DOWN, arguments, 0, 0);\n            target.pen_down();\n          });\n        }\n        case END_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = END_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, END_FILL);\n              target.end_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n          }, END_FILL, []));\n        }\n        case FILL_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FILL_COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if (color) {\n                if (blue) {\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return target.fillStyle;\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n          }, FILL_COLOR, []));\n        }\n        case FORWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FORWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, FORWARD);\n              target.forward(distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n          }, FORWARD, []));\n        }\n        case GOTO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = GOTO;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, nx, ny) {\n              nx = Sk.builtin.asnum$(nx);\n              ny = Sk.builtin.asnum$(ny);\n              checkArgs(3, arguments.length, GOTO);\n              target.goto(nx, ny);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n          }, GOTO, []));\n        }\n        case LEFT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = LEFT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, LEFT);\n              target.turn(-angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n          }, LEFT, []));\n        }\n        case POSITION: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = POSITION;\n              checkArgs(1, arguments.length, POSITION);\n            });\n\n            $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n              switch(key) {\n                case "x": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[0], Sk.builtin.nmber.float$);\n                }\n                break;\n                case "y": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[1], Sk.builtin.nmber.float$);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__setattr__ = new Sk.builtin.func(function(self, key, value) {\n              switch(key) {\n                case "x": {\n                  var nx = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(nx, target.gety());\n                }\n                break;\n                case "y": {\n                  var ny = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(target.getx(), ny);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n          }, POSITION, []));\n        }\n        case RIGHT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = RIGHT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, RIGHT);\n              target.turn(angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n          }, RIGHT, []));\n        }\n        case SHAPE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = SHAPE;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, shape) {\n              checkArgs(2, arguments.length, SHAPE);\n              target.shape(shape.v);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n          }, SHAPE, []));\n        }\n        case STAMP: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = STAMP;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, STAMP);\n              target.stamp();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n          }, STAMP, []));\n        }\n        case UP: {\n          return Sk.ffi.callableToPy(mod, UP, function(methodPy) {\n            Sk.ffi.checkMethodArgs(UP, arguments, 0, 0);\n            target.pen_up();\n          });\n        }\n        default: {\n          // Do nothing\n        }\n      }\n    });\n\n    $loc.__setattr__ = new Sk.builtin.func(function(selfPy, name, valuePy) {\n\n      var COLOR = "color";\n      var FILL_COLOR = "fillcolor";\n      var POSITION = "position";\n      var SHAPE = "shape";\n      var EUCLIDEAN_2 = "Euclidean2";\n\n      switch(name) {\n        case COLOR: {\n          if(valuePy) {\n            var color = valuePy.v || selfPy.v.context.fillStyle;\n            selfPy.v.set_pen_color(color);\n            selfPy.v.set_fill_color(color);\n          }\n        }\n        break;\n        case FILL_COLOR: {\n          if (valuePy) {\n            selfPy.v.set_fill_color(valuePy.v || selfPy.v.context.fillStyle);\n          }\n        }\n        break;\n        case POSITION: {\n          Sk.ffi.checkArgType("value", EUCLIDEAN_2, Sk.ffi.isInstance(valuePy) && Sk.ffi.typeName(valuePy) === EUCLIDEAN_2);\n          var xPy = Sk.ffi.gattr(valuePy, "x");\n          var yPy = Sk.ffi.gattr(valuePy, "y");\n          selfPy.v.goto(Sk.ffi.remapToJs(xPy), Sk.ffi.remapToJs(yPy));\n        }\n        break;\n        case SHAPE: {\n          if (valuePy) {\n            checkArgs(3, arguments.length, SHAPE);\n            selfPy.v.shape(valuePy.v);\n          }\n        }\n        break;\n        default: {\n//          throw new Sk.builtin.AttributeError("\'" + SPRITE + "\' object has no attribute setter \'" + name + "\'.");\n        }\n      }\n    });\n\n    $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n      nx = Sk.builtin.asnum$(nx);\n      ny = Sk.builtin.asnum$(ny);\n      checkArgs(3,arguments.length,"setposition()");\n      self.v.up();\n      self.v.goto(nx,ny);\n      self.v.down();\n    });\n\n    $loc.setpos = $loc.setposition;\n\n    $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n      newhead = Sk.builtin.asnum$(newhead);\n      checkArgs(2,arguments.length,"setheading()");\n      return self.v.set_heading(newhead);\n    });\n\n    $loc.seth = $loc.setheading;\n\n    $loc.home = new Sk.builtin.func(function(self) {\n      self.v.go_home();\n    });\n\n    $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n      size = Sk.builtin.asnum$(size);\n      size = size || 1;\n      if (color) {\n        color = color.v || self.v.penStyle;\n      }\n      self.v.dot(size, color);\n    });\n\n    $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n      radius = Sk.builtin.asnum$(radius);\n      extent = Sk.builtin.asnum$(extent);\n      self.v.circle(radius, extent);\n    });\n\n    $loc.delay = new Sk.builtin.func(function(self, d) {\n      d = Sk.builtin.asnum$(d);\n      return self.v.delay(d);\n    });\n\n    $loc.speed = new Sk.builtin.func(function(self, s, t) {\n      s = Sk.builtin.asnum$(s);\n      t = Sk.builtin.asnum$(t);\n      self.v.speed(s,t);\n    });\n\n    $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n      t = Sk.builtin.asnum$(t);\n      d = Sk.builtin.asnum$(d);\n      self.v.tracer(t, d);\n    });\n\n    $loc.update = new Sk.builtin.func(function(self) {\n      //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n    });\n\n    $loc.heading = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"heading()");\n      return self.v.get_heading();\n    });\n\n    $loc.xcor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"xcor()");\n      var res = self.v.getx();\n      return res;\n    });\n\n    $loc.ycor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"ycor()");\n      var res = self.v.gety();\n      return res;\n    });\n\n    $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\')\n        tx = [tx, ty, 0];\n      return self.v.towards(tx);\n    });\n\n    // tx can be either a number or a vector position.\n    // tx can not be a sprite at this time as multiple sprites have not been implemented yet.\n    $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\') {\n        tx = [tx, ty, 0];\n      }\n      else {\n        tx = [tx.v.getx(), tx.v.gety(), 0];\n      }\n      return self.v.distance(tx);\n    });\n\n    //\n    // Setting and Measurement\n    //\n\n    $loc.width = new Sk.builtin.func(function(self, w) {\n     w = Sk.builtin.asnum$(w);\n     checkArgs(2,arguments.length,"width()");\n     self.v.set_pen_width(w);\n   });\n\n    $loc.pensize = $loc.width;\n\n    $loc.isdown = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isdown()");\n      return self.v.get_pen();\n    });\n\n    $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n      if (color) {\n        if (blue) {\n          color = Sk.builtin.asnum$(color);\n          green = Sk.builtin.asnum$(green);\n          blue = Sk.builtin.asnum$(blue);\n          self.v.set_pen_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n        }\n      }\n      else {\n        return self.v.penStyle;\n      }\n    });\n\n    $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n      if(color) {\n        if (blue) {\n          self.v.set_pen_color(color, green, blue);\n          self.v.set_fill_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n          self.v.set_fill_color(color);\n        }\n      }\n      else {\n        return [self.v.penStyle, self.v.fillStyle];\n      }\n    });\n\n    $loc.fill = new Sk.builtin.func(function(self, fillt) {\n      if (fillt === undefined)\n        return self.v.filling;\n      if (fillt)\n        self.v.begin_fill();\n      else\n        self.v.end_fill();\n    });\n\n    //\n    // More drawing control\n    //\n\n    $loc.reset = new Sk.builtin.func(function(self) {\n      self.v.clean();\n    });\n\n    $loc.showturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"showturtle()");\n      self.v.showturtle();\n    });\n\n    $loc.st = $loc.showturtle;\n\n    $loc.hideturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"hideturtle()");\n      self.v.hideturtle();\n    });\n\n    $loc.ht = $loc.hideturtle;\n\n    $loc.isvisible = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isvisible()");\n      self.v.isvisible()\n    });\n\n    // todo the move, align, and font parameters should be kwargs...\n    $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n      self.v.write(mystr.v, move, align, font);\n    });\n\n    // todo clean  -- again multiple sprites\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n      llx = Sk.builtin.asnum$(llx);\n      lly = Sk.builtin.asnum$(lly);\n      urx = Sk.builtin.asnum$(urx);\n      ury = Sk.builtin.asnum$(ury);\n      self.v.setworldcoordinates(llx, lly, urx, ury);\n    });\n\n    $loc.clear = new Sk.builtin.func(function(self) {\n      self.v.clear()\n    });\n  }\n\n  mod[SPRITE] = Sk.misceval.buildClass(mod, sprite, SPRITE, []);\n\n  var screen = function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      SpriteGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n      var currentCanvas = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID];\n      if (currentCanvas === undefined) {\n        self.theScreen = new SpriteGraphics.SpriteCanvas(SpriteGraphics.defaults);\n      } else {\n        self.theScreen = currentCanvas;\n      }\n    });\n\n    $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n      self.theScreen.bgcolor(c);\n    });\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n     llx = Sk.builtin.asnum$(llx);\n     lly = Sk.builtin.asnum$(lly);\n     urx = Sk.builtin.asnum$(urx);\n     ury = Sk.builtin.asnum$(ury);\n     self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n   });\n\n    $loc.exitonclick = new Sk.builtin.func(function(self) {\n      self.theScreen.exitonclick();\n    });\n\n    $loc.title = new Sk.builtin.func(function(self,titlestring) {\n      // no op....\n    });\n\n    $loc.window_width = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_width();\n    });\n\n    $loc.window_height = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_height();\n    });\n\n    $loc.sprites = new Sk.builtin.func(function(self) {\n      return self.theScreen.sprites();\n    });\n\n    $loc.colormode = new Sk.builtin.func(function(self) {\n      //  Empty function to emulate compatibility\n    });\n\n    var myfunc = function(self, width, height, startx, starty) {\n      width = Sk.builtin.asnum$(width);\n      height = Sk.builtin.asnum$(height);\n      self.theScreen.setup(width,height);\n    }\n    // this should allow for named parameters\n    myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n    myfunc.$defaults = [null,500,500,0,0];\n    $loc.setup = new Sk.builtin.func(myfunc);\n  }\n\n  mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n  mod.tracer = new Sk.builtin.func(function(t, d) {\n    t = Sk.builtin.asnum$(t);\n    d = Sk.builtin.asnum$(d);\n    for (var i in Sk.tg.canvasLib) {\n      Sk.tg.canvasLib[i].tracer(t, d);\n    }\n  });\n\n  mod.update = new Sk.builtin.func(function(self) {\n    //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n  });\n\n  return mod\n}\n',
    'src/lib/unittestgui/__init__.py': '__author__ = \'bmiller\'\n\nimport document\n\n\nclass unittest:\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.divid = document.currentDiv()\n        self.mydiv = document.getElementById(self.divid)\n        res = document.getElementById(self.divid+\'_unit_results\')\n        if res:\n            self.resdiv = res\n            res.innerHTML = \'\'\n        else:\n            self.resdiv = document.createElement(\'div\')\n            self.resdiv.setAttribute(\'id\',self.divid+\'_unit_results\')\n            self.resdiv.setAttribute(\'class\',\'unittest-results\')\n        self.mydiv.appendChild(self.resdiv)\n\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == \'test\' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setup(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def main(self):\n        l = document.createElement(\'ul\')\n        self.resdiv.appendChild(l)\n        self.resList = l\n\n        for func in self.tlist:\n            try:\n                self.setup()\n                func()\n                self.tearDown()\n            except:\n                self.appendResult(\'Error\')\n                self.numFailed += 1\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=""):\n        res = actual==expected\n        self.appendResult(res,str(actual)+\' to be equal to \',expected, feedback)\n\n    def assertNotEqual(actual, expected, feedback=""):\n        res = actual != expected\n        self.appendResult(res,str(actual)+\' to not equal \',expected,feedback)\n\n    def assertTrue(self,x, feedback=""):\n        res = x\n        self.appendResult(res,str(x)+\' to be \',True,feedback)\n\n    def assertFalse(self,x, feedback=""):\n        res = not x\n        self.appendResult(res,str(x)+\' to be \',False,feedback)\n\n    def assertIs(self,a,b, feedback=""):\n        res = a is b\n        self.appendResult(res,str(a)+\' to be the same object as \',b,feedback)\n\n    def assertIsNot(self,a,b, feedback=""):\n        res = a is not b\n        self.appendResult(res,str(a)+\' to not be the same object as \',b,feedback)\n\n    def assertIsNone(self,x, feedback=""):\n        res = x is None\n        self.appendResult(res,x,None,feedback)\n\n    def assertIsNotNone(self,x, feedback=""):\n        res = x is not None\n        self.appendResult(res,str(x)+\' to not be \',None,feedback)\n\n    def assertIn(self,a,b, feedback=""):\n        res = a in b\n        self.appendResult(res,str(a)+\' to be in \',b,feedback)\n\n    def assertNotIn(self,a,b, feedback=""):\n        res = a not in b\n        self.appendResult(res,str(a)+\' to not be in \',b,feedback)\n\n    def assertIsInstance(self,a,b, feedback=""):\n        res = isinstance(a,b)\n        self.appendResult(res,str(a)+\' to be an instance of \',b,feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=""):\n        res = not isinstance(a,b)\n        self.appendResult(res,str(a)+\' to not be an instance of \',b,feedback)\n\n    def assertAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) == 0\n        self.appendResult(res,str(a)+\' to equal \',b,feedback)\n\n    def assertNotAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) != 0\n        self.appendResult(res,str(a)+\' to not equal \',b,feedback)\n\n    def assertGreater(self,a,b, feedback=""):\n        res = a > b\n        self.appendResult(res,str(a)+\' to be greater than \',b,feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=""):\n        res = a >= b\n        self.appendResult(res,str(a)+\' to be greater than or equal to \',b,feedback)\n\n    def assertLess(self,a,b, feedback=""):\n        res = a < b\n        self.appendResult(res,str(a)+\' to be less than \',b,feedback)\n\n    def assertLessEqual(self,a,b, feedback=""):\n        res = a <= b\n        self.appendResult(res,str(a)+\' to be less than or equal to \',b,feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res == \'Error\':\n            msg = \'Error\'\n        elif res:\n            msg = \'Pass\'\n            self.numPassed += 1\n        else:\n            msg = \'Fail: expected %s  %s \' % (str(actual),str(expected)) + feedback\n            self.numFailed += 1\n\n        pTag = document.createElement(\'li\')\n        pTag.innerHTML = msg\n        self.resList.appendChild(pTag)\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        pTag = document.createElement(\'p\')\n        pTag.innerHTML = "You passed: " + str(pct) + "% of the tests"\n        self.resdiv.appendChild(pTag)\n        if pct < 90:\n            self.resdiv.setCSS(\'background-color\',\'#de8e96\')\n        else:\n            self.resdiv.setCSS(\'background-color\',\'#83d382\')\n\n\n\n',
    'src/lib/webgl/matrix4.js': '// more from \'tdl\'\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var temp0v3_ = new Float32Array(3);\n    var temp1v3_ = new Float32Array(3);\n    var temp2v3_ = new Float32Array(3);\n\n    var temp0v4_ = new Float32Array(4);\n    var temp1v4_ = new Float32Array(4);\n    var temp2v4_ = new Float32Array(4);\n\n    var temp0m4_ = new Float32Array(16);\n    var temp1m4_ = new Float32Array(16);\n    var temp2m4_ = new Float32Array(16);\n\n    var normalize = function(dst, a) {\n        var n = 0.0;\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            n += a[i] * a[i];\n        n = Math.sqrt(n);\n        if (n > 0.00001) {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = a[i] / n;\n        } else {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = 0;\n        }\n        return dst;\n    };\n\n    var cross = function(dst, a, b) {\n        dst[0] = a[1] * b[2] - a[2] * b[1];\n        dst[1] = a[2] * b[0] - a[0] * b[2];\n        dst[2] = a[0] * b[1] - a[1] * b[0];\n        return dst;\n    };\n\n    var subVector = function(dst, a, b) {\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            dst[i] = a[i] - b[i];\n        return dst;\n    };\n\n    var dot = function(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    };\n\n    mod.lookAt = new Sk.builtin.func(function(view, eye, target, up)\n            {\n                var t0 = temp0v3_;\n                var t1 = temp1v3_;\n                var t2 = temp2v3_;\n\n                var vz = normalize(t0, subVector(t0, eye.v, target.v));\n                var vx = normalize(t1, cross(t1, up.v, vz));\n                var vy = cross(t2, vz, vx);\n\n                var dst = view.v;\n                dst[ 0] = vx[0];\n                dst[ 1] = vy[0];\n                dst[ 2] = vz[0];\n                dst[ 3] = 0;\n                dst[ 4] = vx[1];\n                dst[ 5] = vy[1];\n                dst[ 6] = vz[1];\n                dst[ 7] = 0;\n                dst[ 8] = vx[2];\n                dst[ 9] = vy[2];\n                dst[10] = vz[2];\n                dst[11] = 0;\n                dst[12] = -dot(vx, eye.v);\n                dst[13] = -dot(vy, eye.v);\n                dst[14] = -dot(vz, eye.v);\n                dst[15] = 1;\n\n                return view;\n            });\n\n    mod.perspective = new Sk.builtin.func(function(proj, angle, aspect, near, far)\n            {\n                var f = Math.tan(Math.PI * 0.5 - 0.5 * (angle * Math.PI / 180));\n                var rangeInv = 1.0 / (near - far);\n\n                var dst = proj.v;\n\n                dst[0]  = f / aspect;\n                dst[1]  = 0;\n                dst[2]  = 0;\n                dst[3]  = 0;\n\n                dst[4]  = 0;\n                dst[5]  = f;\n                dst[6]  = 0;\n                dst[7]  = 0;\n\n                dst[8]  = 0;\n                dst[9]  = 0;\n                dst[10] = (near + far) * rangeInv;\n                dst[11] = -1;\n\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = near * far * rangeInv * 2;\n                dst[15] = 0;\n\n                return proj;\n            });\n\n    // builds, not appending\n    mod.rotationY = new Sk.builtin.func(function(target, angle)\n            {\n                var dst = target.v;\n                var c = Math.cos(angle * Math.PI / 180);\n                var s = Math.sin(angle * Math.PI / 180);\n\n                dst[ 0] = c;\n                dst[ 1] = 0;\n                dst[ 2] = -s;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = s;\n                dst[ 9] = 0;\n                dst[10] = c;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n\n                return target;\n            });\n\n    mod.identity = new Sk.builtin.func(function(target)\n            {\n                var dst = target.v;\n                dst[ 0] = 1;\n                dst[ 1] = 0;\n                dst[ 2] = 0;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = 0;\n                dst[ 9] = 0;\n                dst[10] = 1;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n                return target;\n            });\n\n    // row major\n    mod.mul = new Sk.builtin.func(function(target, x, y)\n            {\n                var dst = target.v;\n                var a = x.v;\n                var b = y.v;\n                var a00 = a[0];\n                var a01 = a[1];\n                var a02 = a[2];\n                var a03 = a[3];\n                var a10 = a[ 4 + 0];\n                var a11 = a[ 4 + 1];\n                var a12 = a[ 4 + 2];\n                var a13 = a[ 4 + 3];\n                var a20 = a[ 8 + 0];\n                var a21 = a[ 8 + 1];\n                var a22 = a[ 8 + 2];\n                var a23 = a[ 8 + 3];\n                var a30 = a[12 + 0];\n                var a31 = a[12 + 1];\n                var a32 = a[12 + 2];\n                var a33 = a[12 + 3];\n                var b00 = b[0];\n                var b01 = b[1];\n                var b02 = b[2];\n                var b03 = b[3];\n                var b10 = b[ 4 + 0];\n                var b11 = b[ 4 + 1];\n                var b12 = b[ 4 + 2];\n                var b13 = b[ 4 + 3];\n                var b20 = b[ 8 + 0];\n                var b21 = b[ 8 + 1];\n                var b22 = b[ 8 + 2];\n                var b23 = b[ 8 + 3];\n                var b30 = b[12 + 0];\n                var b31 = b[12 + 1];\n                var b32 = b[12 + 2];\n                var b33 = b[12 + 3];\n                dst[ 0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n                dst[ 1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n                dst[ 2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n                dst[ 3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n                dst[ 4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n                dst[ 5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n                dst[ 6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n                dst[ 7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n                dst[ 8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n                dst[ 9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n                dst[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n                dst[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n                dst[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n                dst[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n                dst[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n                dst[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n                return target;\n            });\n\n    mod.invert = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                var m00 = m[0 * 4 + 0];\n                var m01 = m[0 * 4 + 1];\n                var m02 = m[0 * 4 + 2];\n                var m03 = m[0 * 4 + 3];\n                var m10 = m[1 * 4 + 0];\n                var m11 = m[1 * 4 + 1];\n                var m12 = m[1 * 4 + 2];\n                var m13 = m[1 * 4 + 3];\n                var m20 = m[2 * 4 + 0];\n                var m21 = m[2 * 4 + 1];\n                var m22 = m[2 * 4 + 2];\n                var m23 = m[2 * 4 + 3];\n                var m30 = m[3 * 4 + 0];\n                var m31 = m[3 * 4 + 1];\n                var m32 = m[3 * 4 + 2];\n                var m33 = m[3 * 4 + 3];\n                var tmp_0  = m22 * m33;\n                var tmp_1  = m32 * m23;\n                var tmp_2  = m12 * m33;\n                var tmp_3  = m32 * m13;\n                var tmp_4  = m12 * m23;\n                var tmp_5  = m22 * m13;\n                var tmp_6  = m02 * m33;\n                var tmp_7  = m32 * m03;\n                var tmp_8  = m02 * m23;\n                var tmp_9  = m22 * m03;\n                var tmp_10 = m02 * m13;\n                var tmp_11 = m12 * m03;\n                var tmp_12 = m20 * m31;\n                var tmp_13 = m30 * m21;\n                var tmp_14 = m10 * m31;\n                var tmp_15 = m30 * m11;\n                var tmp_16 = m10 * m21;\n                var tmp_17 = m20 * m11;\n                var tmp_18 = m00 * m31;\n                var tmp_19 = m30 * m01;\n                var tmp_20 = m00 * m21;\n                var tmp_21 = m20 * m01;\n                var tmp_22 = m00 * m11;\n                var tmp_23 = m10 * m01;\n\n                var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\n                    (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\n                var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\n                    (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\n                var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\n                    (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\n                var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\n                    (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\n\n                var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n\n                dst[ 0] = d * t0;\n                dst[ 1] = d * t1;\n                dst[ 2] = d * t2;\n                dst[ 3] = d * t3;\n                dst[ 4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\n                        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\n                dst[ 5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\n                        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\n                dst[ 6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\n                        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\n                dst[ 7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\n                        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\n                dst[ 8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\n                        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\n                dst[ 9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\n                        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\n                dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\n                        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\n                dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\n                        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\n                dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\n                        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\n                dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\n                        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\n                dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\n                        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\n                dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\n                        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\n                return target;\n            });\n\n    mod.transpose = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                for (var j = 0; j < 4; ++j) {\n                    for (var i = 0; i < 4; ++i)\n                    dst[j * 4 + i] = m[i * 4 + j];\n                }\n                return dst;\n            });\n\n    return mod;\n};\n',
    'src/lib/webgl/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n\n  var makeFailHTML = function(msg) {\n    return \'\' +\n      \'<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>\' +\n      \'<td align="center">\' +\n      \'<div style="display: table-cell; vertical-align: middle;">\' +\n      \'<div style="">\' + msg + \'</div>\' +\n      \'</div>\' +\n      \'</td></tr></table>\';\n  };\n\n  var GET_A_WEBGL_BROWSER = \'\' +\n    \'This page requires a browser that supports WebGL.<br/>\' +\n    \'<a href="http://get.webgl.org">Click here to upgrade your browser.</a>\';\n\n  var NEED_HARDWARE = \'\' +\n    "It doesn\'t appear your computer can support WebGL.<br/>" +\n    \'<a href="http://get.webgl.org">Click here for more information.</a>\';\n  \n  var create3DContext = function(canvas) {\n    var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];\n    var gl = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        gl = canvas.getContext(names[ii]);\n      }\n      catch(e) {\n      }\n      if (gl) {\n          break;\n      }\n    }\n    if (gl) {\n      // Disallow selection by default. This keeps the cursor from changing to an\n      // I-beam when the user clicks and drags. It\'s easier on the eyes.\n      function returnFalse() {\n        return false;\n      }\n\n      canvas.onselectstart = returnFalse;\n      canvas.onmousedown = returnFalse;\n    }\n    return gl;\n  };\n\n  var setupWebGL = function(canvasContainerId, opt_canvas) {\n    var container = document.getElementById(canvasContainerId);\n    var context;\n    if (!opt_canvas) {\n      opt_canvas = container.getElementsByTagName("canvas")[0];\n    }\n    if (!opt_canvas) {\n        // this browser doesn\'t support the canvas tag at all. Not even 2d.\n      container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      return;\n    }\n\n    var gl = create3DContext(opt_canvas);\n    if (!gl) {\n      // TODO(gman): fix to official way to detect that it\'s the user\'s machine, not the browser.\n      var browserStrings = navigator.userAgent.match(/(\\w+\\/.*? )/g);\n      var browsers = {};\n      try {\n        for (var b = 0; b < browserStrings.length; ++b) {\n          var parts = browserStrings[b].match(/(\\w+)/g);\n          var bb = [];\n          for (var ii = 1; ii < parts.length; ++ii) {\n            bb.push(parseInt(parts[ii]));\n          }\n          browsers[parts[0]] = bb;\n        }\n      }\n      catch (e) {\n      }\n      if (browsers.Chrome &&\n           (browsers.Chrome[0] > 7 ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] > 0) ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] == 0 && browsers.Chrome[2] >= 521))) {\n        container.innerHTML = makeFailHTML(NEED_HARDWARE);\n      }\n      else {\n        container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      }\n    }\n    return gl;\n  };\n\n  /**\n   * The Context encapsulates the underlying WebGL native JavaScript API.\n   */\n  mod.Context = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(\n      function(self, canvasid) {\n        var canvas = document.getElementById(canvasid.v);\n        var gl = setupWebGL(canvasid.v, canvas)\n        if (!gl) {\n          throw new Error("Your browser does not appear to support WebGL.");\n        }\n\n        self.gl = gl;\n\n        // Copy symbolic constants and functions from native WebGL, encapsulating where necessary.       \n        for (var k in gl.__proto__) {\n          if (typeof gl.__proto__[k] === \'number\') {\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(k), gl.__proto__[k]);\n          }\n          else if (typeof gl.__proto__[k] === "function") {\n            switch(k) {\n              case \'bufferData\': {\n              }\n              break;\n              case \'clearColor\': {\n              }\n              break;\n              case \'drawArrays\': {\n              }\n              break;\n              case \'getAttribLocation\': {\n              }\n              break;\n              case \'getUniformLocation\': {\n              }\n              break;\n              case \'shaderSource\': {\n              }\n              break;\n              case \'uniformMatrix4fv\': {\n              }\n              break;\n              case \'vertexAttribPointer\': {\n              }\n              break;\n              case \'viewport\': {\n              }\n              break;\n              default: {\n                (function(key) {\n                  Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(k), new Sk.builtin.func(function() {\n                    var f = gl.__proto__[key];\n                    return f.apply(gl, arguments);\n                  }));\n                 }(k));\n              }\n            }\n          }\n        }\n\n        gl.clearColor(100.0/255.0, 149.0/255.0, 237.0/255.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      }\n    );\n\n    $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n    $loc.bufferData = new Sk.builtin.func(\n      function(self, target, data, usage) {\n        self.gl.bufferData(target, data.v, usage);\n      }\n    );\n\n    $loc.clearColor = new Sk.builtin.func(\n      function(self, red, green, blue, alpha) {\n        self.gl.clearColor(Sk.builtin.asnum$(red), Sk.builtin.asnum$(green), Sk.builtin.asnum$(blue), Sk.builtin.asnum$(alpha));\n      }\n    );\n\n    $loc.getAttribLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getAttribLocation(program, name.v);\n      }\n    );\n\n    $loc.getUniformLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getUniformLocation(program, name.v);\n      }\n    );\n\n    $loc.shaderSource = new Sk.builtin.func(\n      function(self, shader, src) {\n        self.gl.shaderSource(shader, src.v);\n      }\n    );\n\n    $loc.drawArrays = new Sk.builtin.func(\n      function(self, mode, first, count) {\n        self.gl.drawArrays(Sk.builtin.asnum$(mode), Sk.builtin.asnum$(first), Sk.builtin.asnum$(count));\n      }\n    );\n\n    $loc.vertexAttribPointer = new Sk.builtin.func(\n      function(self, index, size, type, normalized, stride, dunno) {\n        self.gl.vertexAttribPointer(index, Sk.builtin.asnum$(size), Sk.builtin.asnum$(type), normalized, Sk.builtin.asnum$(stride), Sk.builtin.asnum$(dunno));\n      }\n    );\n\n    $loc.viewport = new Sk.builtin.func(\n      function(self, x, y, width, height) {\n        self.gl.viewport(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y), Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n      }\n    );\n\n    $loc.uniformMatrix4fv = new Sk.builtin.func(\n      function(self, location, transpose, values) {\n//        console.log("location  " + (typeof location));\n//        console.log("transpose " + (typeof transpose));\n//        console.log("values.v  " + (typeof values.v));\n        self.gl.uniformMatrix4fv(Sk.builtin.asnum$(location), transpose, values.v);\n      }\n    );\n\n    $loc.setDrawFunc = new Sk.builtin.func(function(self, func) {\n      var startTime = (new Date()).getTime();\n      var intervalId = setInterval(\n        function() {\n          Sk.misceval.callsim(func, self, (new Date()).getTime() - startTime);\n        }, 1000.0 / 60.0); // 60 fps\n    });\n\n  }, \'Context\', []);\n\n  mod.Float32Array = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      if (typeof data === "number") {\n        self.v = new Float32Array(data);\n      }\n      else {\n        self.v = new Float32Array(Sk.ffi.remapToJs(data));\n      }\n    });\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str("[" + copy.join(\', \') + "]");\n     });\n  }, \'Float32Array\', []);\n\n  /**\n   * A 4x4 (mutable) matrix suitable for OpenGL.\n   *\n   * Mutability is chosen for performance.\n   * The inderlying implementation is Float32Array.\n   * The indexing of the elements is\n   * 0 4  8 12\n   * 1 5  9 13\n   * 2 6 10 14\n   * 3 7 11 15\n   */\n  mod.Matrix4x4 = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      self.v = new Float32Array(Sk.ffi.remapToJs(data));\n    });\n\n    $loc.identity = new Sk.builtin.func(\n      function(self) {\n\n        var m = self.v;\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n      }\n    );\n\n    $loc.perspective = new Sk.builtin.func(\n      function(self, fov, aspect, near, far) {\n        \n        var t = Math.tan(Math.PI * 0.5 - 0.5 * (Sk.builtin.asnum$(fov) * Math.PI / 180));\n        var a = Sk.builtin.asnum$(aspect)\n        var n = Sk.builtin.asnum$(near)\n        var f = Sk.builtin.asnum$(far)\n        var k = 1.0 / (n - f);\n\n        var m = self.v;\n\n        m[0]  = t / a;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = t;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = (n + f) * k;\n        m[11] = -1;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = n * f * k * 2;\n        m[15] = 0;\n      }\n    );\n\n    $loc.translate = new Sk.builtin.func(\n      function(self, translation) {\n\n        var m = self.v;\n        var t = Sk.ffi.remapToJs(translation);\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = t[0];\n        m[13] = t[1];\n        m[14] = t[2];\n        m[15] = 1;\n      }\n    );\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str("[" + copy.join(\', \') + "]");\n     });\n  }, \'Matrix4x4\', []);\n\n  return mod;\n};',
    'src/builtin/sys.js': 'var $builtinmodule = function(name)\n{\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (var i = 0; i < argv.length; ++i)\n        args.push(new Sk.builtin.str(argv[i]));\n    sys.argv = new Sk.builtins[\'list\'](args);\n\n    sys.copyright = Sk.builtin[\'str\']("Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n");\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.getExecutionLimit = new Sk.builtin.func(function() {\n        return Sk.execLimit\n    });\n\n    sys.setExecutionLimit = new Sk.builtin.func(function(t) {\n        if (t !==  undefined) {\n            Sk.execLimit = t\n        }\n    });\n\n    sys.resetTimeout = new Sk.builtin.func(function() {\n        Sk.execStart = new Date();\n    });\n\n    sys.debug = new Sk.builtin.func(function() {\n        debugger;\n    });\n\n    return sys;\n};\n',
    'src/lib/pythonds/trees/balance.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    \'\'\'\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n',
    'src/lib/urllib/request/__init__.js': 'var $builtinmodule = function(name)\n{\n  var request = {};\n\n\n  //~ Classes .................................................................\n\n  // Response class\n  //\n  // Response objects are returned by the request, get, post, etc.\n  // methods, allowing the user to access the response text, status\n  // code, and other information.\n\n  // ------------------------------------------------------------\n  var response = function($gbl, $loc) {\n\n    // ------------------------------------------------------------\n    $loc.__init__ = new Sk.builtin.func(function(self, xhr) {\n      self.data$ = xhr.responseText;\n      self.lineList = self.data$.split("\\n");\n      self.lineList = self.lineList.slice(0,-1);\n      for(var i =0 ; i < self.lineList.length; i++) {\n        self.lineList[i] = self.lineList[i]+\'\\n\';\n      }\n      self.currentLine = 0;\n      self.pos$ = 0;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return Sk.ffi.remapToPy(\'<Response>\');\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__iter__ = new Sk.builtin.func(function(self) {\n      var allLines = self.lineList;\n\n      return Sk.builtin.makeGenerator(function() {\n          if (this.$index >= this.$lines.length) return undefined;\n          return new Sk.builtin.str(this.$lines[this.$index++]);\n        }, {\n          $obj: self,\n          $index: 0,\n          $lines: allLines\n        });\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.read = new Sk.builtin.func(function(self, size) {\n      if (self.closed) throw new Sk.builtin.ValueError("I/O operation on closed file");\n      var len = self.data$.length;\n      if (size === undefined) size = len;\n      var ret = new Sk.builtin.str(self.data$.substr(self.pos$, size));\n      self.pos$ += size;\n      if (self.pos$ >= len) self.pos$ = len;\n      return ret;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readline = new Sk.builtin.func(function(self, size) {\n      var line = "";\n      if (self.currentLine < self.lineList.length) {\n        line = self.lineList[self.currentLine];\n        self.currentLine++;\n      }\n      return new Sk.builtin.str(line);\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readlines = new Sk.builtin.func(function(self, sizehint) {\n      var arr = [];\n      for(var i = self.currentLine; i < self.lineList.length; i++) {\n        arr.push(new Sk.builtin.str(self.lineList[i]));\n      }\n      return new Sk.builtin.list(arr);\n    });\n\n  };\n\n  request.Response =\n    Sk.misceval.buildClass(request, response, \'Response\', []);\n\n\n  //~ Module functions ........................................................\n\n  // ------------------------------------------------------------\n  /**\n   * Constructs and sends a Request. Returns Response object.\n   *\n   * http://docs.python-requests.org/en/latest/api/#requests.request\n   *\n   * For now, this implementation doesn\'t actually construct a Request\n   * object; it just makes the request through jQuery.ajax and then\n   * constructs a Response.\n   */\n  request.urlopen = new Sk.builtin.func(function(url, data, timeout) {\n    var xmlhttp = new XMLHttpRequest();\n    xmlhttp.open("GET",url.v,false);\n    xmlhttp.send(null);\n\n    return Sk.misceval.callsim(request.Response,xmlhttp)\n  });\n\n\n  return request;\n};\n',
    'src/lib/pythonds/basic/queue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#queue.py\r\n\r\nclass Queue:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def enqueue(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def dequeue(self):\r\n        return self.items.pop()\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/three/__init__.js': 'var $builtinmodule = function(namePy) {\n  var mod = {};\n  Sk.stdlib.defineThree(mod, THREE, BLADE);\n  Sk.builtin.defineGeometry(mod, THREE, Sk.ffi.remapToJs(namePy));\n  return mod;\n}\n',
    'src/lib/units/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineUnits(mod, BLADE);\n  return mod;\n};',
    'src/lib/pythonds/graphs/adjGraph.py': '#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = \'white\'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + ":color " + self.color + ":disc " + str(self.disc) + ":fin " + str(self.fin) + ":dist " + str(self.dist) + ":pred \\n\\t[" + str(self.pred)+ "]\\n"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open("test.dat")\n        for line in gFile:\n            fVertex, tVertex = line.split(\'|\')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == \'__main__\':\n    unittest.main()\n              \n',
    'src/lib/easel/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEasel(mod, createjs, BLADE);\n  return mod;\n}\n',
    'src/lib/json/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var FUNCTION_PARSE     = "parse";\n    var FUNCTION_STRINGIFY = "stringify";\n\n    mod[FUNCTION_PARSE] = Sk.ffi.functionPy(function(textPy, reviverPy) {\n        Sk.ffi.checkFunctionArgs(FUNCTION_PARSE, arguments, 1, 1);\n        Sk.ffi.checkArgType("text",    Sk.ffi.PyType.STR,   Sk.ffi.isStr(textPy));\n        Sk.ffi.checkArgType("reviver", Sk.ffi.PyType.FUNCTION, Sk.ffi.isUndefined(reviverPy) || isFunction(reviverPy));\n        var text = Sk.ffi.remapToJs(textPy);\n        var reviver = Sk.ffi.remapToJs(reviverPy);\n        return Sk.ffi.remapToPy(JSON.parse(text, reviver));\n    });\n\n    mod[FUNCTION_STRINGIFY] = Sk.ffi.functionPy(function(valuePy, replacerPy, spacePy) {\n        Sk.ffi.checkFunctionArgs(FUNCTION_STRINGIFY, arguments, 1, 3);\n        Sk.ffi.checkArgType("value", Sk.ffi.PyType.DICT, Sk.ffi.isDict(valuePy));\n        Sk.ffi.checkArgType("replacer", [Sk.ffi.PyType.FUNCTION, Sk.ffi.PyType.NONE, Sk.ffi.PyType.UNDEFINED], Sk.ffi.isUndefined(replacerPy) || Sk.ffi.isNone(replacerPy) || Sk.ffi.isFunction(replacerPy));\n        Sk.ffi.checkArgType("space", [Sk.ffi.PyType.INT, Sk.ffi.PyType.UNDEFINED], Sk.ffi.isUndefined(spacePy) || Sk.ffi.isInt(spacePy));\n        var value = Sk.ffi.remapToJs(valuePy);\n        var replacer = Sk.ffi.remapToJs(replacerPy);\n        var space = Sk.ffi.remapToJs(spacePy);\n        return Sk.ffi.remapToPy(JSON.stringify(value, replacer, space));\n    });\n\n    return mod;\n}',
    'src/lib/turtle/__init__.js': '//\n//\n// Turtle Graphics Module for Skulpt\n//\n// Brad Miller\n//\n//\n//\n\n\nvar TurtleGraphics; // the single identifier needed in the global scope\n\nif (! TurtleGraphics) {\n    TurtleGraphics = { };\n}\n\n\n(function () {\n\n    // Define private constants\n\n    var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians\n    var Rad2Degree = 180.0 / Math.PI\n\n    //\n    // Define TurtleCanvas\n    // \n\n    function TurtleCanvas(options) {\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n\n        this.canvas = document.getElementById(this.canvasID);\n        this.context = this.canvas.getContext(\'2d\');\n        //this.canvas.style.display = \'block\';\n        $(this.canvas).fadeIn();\n\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.setup(this.canvas.width,this.canvas.height);\n        TurtleGraphics.canvasInit = true;\n        this.tlist = []\n\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n        this.segmentLength = 10;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n        TurtleGraphics.canvasLib[this.canvasID] = this;\n\t\tSk.tg.fadeOnExit = true;\t//\tThis can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    }\n\n    TurtleCanvas.prototype.setup = function(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0;\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate ) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n\n        if (TurtleGraphics.canvasInit == false) {\n            this.context.save();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            TurtleGraphics.canvasInit = true;\n            TurtleGraphics.eventCount = 0;\n            TurtleGraphics.renderClock = 0;\n            TurtleGraphics.renderTime = 0;\t// RNL\n        } else {\n            this.context.restore();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2,\n                                    this.canvas.width, this.canvas.height);\n        }\n    }\n    TurtleCanvas.prototype.addToCanvas = function(t) {\n\t        this.tlist.push(t);\n    }\n\n    TurtleCanvas.prototype.onCanvas = function(t) {\n        return (this.tlist.indexOf(t) >= 0);\n    }\n\n    TurtleCanvas.prototype.isAnimating = function() {\n        return (this.tlist.length > 0)\n    }\n\n    TurtleCanvas.prototype.startAnimating = function(t) {\n\t\tif (! this.isAnimating()) {\n        \tthis.intervalId = setTimeout(render, this.delay);\t//\tsetInterval(render, this.delay);\n\t\t}\n    \tif (!this.onCanvas(t))\t//\tAdded by RNL in case startAnimating is called after it\'s already been added\n       \t\tthis.addToCanvas(t);\n        Sk.isTurtleProgram = true;\n    }\n\n    TurtleCanvas.prototype.doneAnimating = function(t) {\n        this.tlist.splice(0,this.tlist.length)\n        clearTimeout(this.intervalId)   \n        $(Sk.runButton).removeAttr(\'disabled\');\n    }\n\n    TurtleCanvas.prototype.cancelAnimation = function() {\n        if (this.intervalId) {\n            clearTimeout(this.intervalId)\t//\tclearInterval(this.intervalId);\n        }\n\n        for (var t in this.tlist) {\n            this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n        }\n        render();\n    }\n\n    TurtleCanvas.prototype.setSpeedDelay = function(s) {\t// RNL\n        var df = 10 - (s % 11) + 1;\n        this.delay = df * this.timeFactor;\t//\tRNL was 10;\n    }\n\n    TurtleCanvas.prototype.setDelay = function(d) {\n        this.delay = d;\n    }\n\n    TurtleCanvas.prototype.getDelay = function(s) { // RNL\n        return this.delay;\n    }\n\n    TurtleCanvas.prototype.setCounter = function(s) {\n\t\tif (!s || s <= 0)\t//\tDon\'t let this be less than 1\n\t\t\ts = 1;\n        this.renderCounter = s;\n    }\n\n    TurtleCanvas.prototype.getCounter = function() {\n        return this.renderCounter;\n    }\n\n    TurtleCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.context.restore();\n        this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n        if (lly == 0)\n            this.context.translate(-llx, lly - (ury - lly));\n        else if (lly > 0)\n            this.context.translate(-llx, -lly * 2);\n        else\n            this.context.translate(-llx, -ury);\n\n        var xlinescale = (urx - llx) / this.canvas.width;\n        var ylinescale = (ury - lly) / this.canvas.height;\n        this.xptscale = xlinescale;\n        this.yptscale = ylinescale;\n        this.lineScale = Math.min(xlinescale,ylinescale)\n        this.context.save();\n\n        this.llx = llx;\n        this.lly = lly;\n        this.urx = urx;\n        this.ury = ury;\n\n    }\n\n    TurtleCanvas.prototype.window_width = function() {\n        return this.canvas.width;\n    }\n\n    TurtleCanvas.prototype.window_height = function() {\n        return this.canvas.height;\n    }\n\n    TurtleCanvas.prototype.bgcolor = function(c) {\n        this.background_color = c;\n        //this.canvas.style.setProperty("background-color", c.v);\n        $(this.canvas).css("background-color",c.v);\n    }\n\n    TurtleCanvas.prototype.setSegmentLength = function(s) {\n        this.segmentLength = s;\n    }\n\n    TurtleCanvas.prototype.getSegmentLength = function() {\n        return this.segmentLength;\n    }\n    \n    // todo: if animating, this should be deferred until the proper time\n    TurtleCanvas.prototype.exitonclick = function () {\n        var canvas_id = this.canvasID;\n        var theCanvas = this;\n        $(this.canvas).click(function() {\n            if (! theCanvas.isAnimating()) {\n\t\t\t\tif (Sk.tg.fadeOnExit)\t//\tLet\'s this be configurable\n                \t$("#"+canvas_id).hide();\n                $("#"+canvas_id).unbind(\'click\');\n                Sk.tg.canvasInit = false;\n                delete Sk.tg.canvasLib[canvas_id];\n            }\n        });\n    }\n\n    TurtleCanvas.prototype.turtles = function() {\n        return TurtleGraphics.turtleList;\n    }\n\n\tTurtleCanvas.prototype.tracer = function(t, d) {\t//\tNew version NOT attached to a turtle (as per real turtle)\n        this.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tfor (var i in this.turtleList)\n\t\t\t\tthis.turtleList[i].animate = false;\n\t\t\tthis.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.setDelay(d);\n\t}\n\n    // check if all turtles are done\n    allDone = function() {\n        var allDone = true;\n        for (var tix in TurtleGraphics.turtleList) {\n            var theT = TurtleGraphics.turtleList[tix];\n            allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n        }\n        return allDone;\n    }\n    //\n    //  This is the function that provides the animation\n    //\n    render = function () {\n        var context = document.getElementById(TurtleGraphics.defaults.canvasID).getContext(\'2d\');\n        with (context) {\n            with (TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID]) {\n                clearRect(llx, lly, (urx - llx), (ury - lly));\n                //canvas.style.setProperty("background-color",TurtleGraphics.turtleCanvas.bgcolor.v);\n            }\n            var incr = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID].getCounter();\n            var lastCanvas = null\n\n            TurtleGraphics.renderClock += incr;\n\n            for (var tix in TurtleGraphics.turtleList) {\n                var t = TurtleGraphics.turtleList[tix]\n                lastCanvas = t.turtleCanvas \n                if (t.aCount >= t.drawingEvents.length)\n                    t.aCount = t.drawingEvents.length - 1;\n                moveTo(0, 0);\n                var currentPos = new Vector(0,0,0);\n                var currentHead = new Vector(1,0,0);\n                lineWidth = t.get_pen_width();\n                lineCap = \'round\';\n                lineJoin = \'round\';\n                strokeStyle = \'black\';\n                var filling = false;\n                if (isNaN(t.turtleCanvas.delay))\n                \tt.turtleCanvas.delay = 0\n//\t\t\t\tconsole.log(tix + " : " + t.clearPoint + " to " + t.aCount)\n                for (var i = t.clearPoint; (i <= t.aCount || t.turtleCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n                \tif (i > t.aCount)\t//\tIf se jump past aCount, jump it ahead\n                \t\tt.aCount = i\n                    var oper = t.drawingEvents[i];\n                    var ts = oper[oper.length-1];\n//\t\t\t\t\tconsole.log(i + "/" + ts + oper [0] + "{" + oper [1] + "}" + t.turtleCanvas.delay)\n                    if (ts <= TurtleGraphics.renderClock || t.turtleCanvas.delay == 0) {\n                    \tif (ts > TurtleGraphics.renderClock)\t//\tIf we go past the render clock, jump it ahead\n                    \t\tTurtleGraphics.renderClock = ts\n//\t\t\t\t\t\tconsole.log("<==")\n                        if (oper[0] == "LT") {  //  line to\n                            if (! filling) {\n                                beginPath();\n                                moveTo(oper[1], oper[2]);\n                            }\n                            lineTo(oper[3], oper[4]);\n                            strokeStyle = oper[5];\n                            stroke();\n                            currentPos = new Vector(oper[3],oper[4],0);\n                            if (! filling)\n                                closePath();\n                        }\n                        else if (oper[0] == "MT") {  // move to\n                            moveTo(oper[3], oper[4]);\n                            currentPos = new Vector(oper[3],oper[4],0);\n                        }\n                        else if (oper[0] == "BF") {  // begin fill\n                            beginPath();\n                            moveTo(oper[1], oper[2]);\n                            filling = true;\n                        }\n                        else if (oper[0] == "EF") {  // end fill\n                            fillStyle = oper[3];\n                            stroke();\n                            fill();\n                            closePath();\n                            filling = false;\n                        }\n                        else if (oper[0] == "FC") {  // fill color\n                            fillStyle = oper[1];\n                        }\n                        else if (oper[0] == "TC") {  // turtle color\n                            strokeStyle = oper[1];\n                        }\n                        else if (oper[0] == "PW") {  // Pen width\n                            lineWidth = oper[1];\n                        }\n                        else if (oper[0] == "DT") {  // Dot\n                            var col = fillStyle;\n                            fillStyle = oper[2];\n                            var size = oper[1];\n                            fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n                            fillStyle = col;\n                        }\n                        else if (oper[0] == "CI") {  // Circle\n                            if (!filling)\n\t\t\t\t\t\t\t\tbeginPath();\n                            arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n                            currentPos = new Vector(oper[1]+Math.cos(oper[5])*oper[3],\n                                oper[2]+Math.sin(oper[5])*oper[3],0);\n                            stroke();\n                            if (! filling) {\n                                closePath();\n                            }\n                        }\n                        else if (oper[0] == "WT") { // write\n                            if (font)\n                                font = oper[2];\n                            scale(1, -1);\n                            fillText(oper[1], oper[3], -oper[4]);\n                            scale(1, -1);\n                        } else if (oper[0] == "ST") {  // stamp\n                            t.drawturtle(oper[3], new Vector(oper[1], oper[2], 0));\n                        } else if (oper[0] == "HT") { // hide turtle\n                            t.visible = false;\n                        } else if (oper[0] == "SH") { // show turtle\n                            t.visible = true;\n                        } else if (oper[0] == "TT") {\n                            currentHead = oper[1];\n                        } else if (oper[0] == "CL") { // RNL clear\n                        \tclear_canvas(t.canvasID);\n                        \tt.clearPoint = i;\t// Different from reset that calls clear because it leaves the turtles where they are\n                        } else if (oper[0] == "DL") { // RNL delay\n                        \tvar df = oper[1]\n//                      \tconsole.log("animated delay set " + df)\n                        \tt.turtleCanvas.delay = df\n                        } else if (oper[0] == "SC") { // RNL speed change\n                        \tvar s = oper[1]\n                        \tif (s < 0)\n                        \t\ts = 0\n                        \tif (s > 10)\n                        \t\ts = 10\n       \t\t\t\t\t\tvar df = (10 - (s % 11) + 1) * t.turtleCanvas.timeFactor\t//\t10\n       \t\t\t\t\t\tif (s == 0) {\n       \t\t\t\t\t\t\tdf = 0\n       \t\t\t\t\t\t}\n\t                        //\tt.turtleCanvas.intervalId = clearInterval(t.turtleCanvas.intervalId);\n\t       \t\t\t\t\tt.turtleCanvas.delay = df;\n\t       \t\t\t\t\t//\tt.turtleCanvas.intervalId = setInterval(render, t.turtleCanvas.delay)\n       \t\t\t\t\t\tif (oper[2]) {\n       \t\t\t\t\t\t\tt.turtleCanvas.setSegmentLength(oper[2]);\n       \t\t\t\t\t\t}\n       \t\t\t\t\t} else if (oper[0] == "NO") { // RNL no op                \t\n                        } else {\n\t\t\t\t\t\t\tconsole.log("unknown op: " + oper[0]);\n                        } // end of oper[0] test\n                    } // end of if ts < render clock\n                } // end of for\n//\t\t\t\tconsole.log(TurtleGraphics.renderClock + " / " + t.aCount)\n//\t\t\t\tconsole.log("------------------------------")\n                t.aCount += incr;\n                if (t.visible) {\n                    // draw the turtle\n                    t.drawturtle(currentHead.toAngle(), currentPos); // just use currentHead\n                }\n            }\n            //if (t.aCount >= t.drawingEvents.length) {\n            if (TurtleGraphics.renderClock > TurtleGraphics.eventCount ){ // && allDone() ){\n//              t.turtleCanvas.doneAnimating(t);\n//\t\t\t\tconsole.log("done animating")\n                if (lastCanvas) lastCanvas.doneAnimating(t);\n            } else {\n//    \t\t\tt.turtleCanvas.intervalId = setTimeout(render, t.turtleCanvas.delay)\n    \t\t\tif (lastCanvas) {\n    \t\t\t\tlastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n    \t\t\t}\n            }\n        }\n    }\n\n\n\n    // Constructor for Turtle objects\n    function Turtle() {\n        if (arguments.length >= 1) {\n            this.initialize(arguments[0]);\n        }\n        else {\n            this.initialize();\n        }\n        TurtleGraphics.turtleList.push(this);\n    }\n\n\n    Turtle.prototype.go_home = function () {\n        // Put turtle in initial state\n        // turtle is headed to the right\n        // with location 0,0,0 in the middle of the canvas.\n        // x grows to the right\n        // y grows towards the top of the canvas\n        with (this) {\n            position = home;\n            context.moveTo(home[0], home[1]);\n            heading = new Vector([1.0, 0.0, 0.0]); // to the right; in turtle space x+ direction\n            normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n        }\n    };\n\n    Turtle.prototype.initialize = function () {\n        // Initialize the turtle.\n        var options = { };\n\n        if (arguments.length >= 1) {\n            options = arguments[0];\n        }\n\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n        this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n        this.animate = TurtleGraphics.defaults.animate;\n\n        with (this.context) {\n            if (TurtleGraphics.canvasInit == false) {   // This is a workaround until I understand skulpt re-running better\n                // the downside is that this limits us to a single turtle...\n                save();\n                translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n                scale(1, -1); // scaling like this flips the y axis the right way.\n                if (! TurtleGraphics.canvasLib[this.canvasID]) {\n                    TurtleGraphics.canvasLib[this.canvasID] = new TurtleCanvas(options);\n                }\n                TurtleGraphics.canvasInit = true;\n            } else {\n                clear_canvas(this.canvasID);\n            }\n\n            this.turtleCanvas = TurtleGraphics.canvasLib[this.canvasID];\n            this.home = new Vector([0.0, 0.0, 0.0]);\n            this.visible = true;\n            this.shapeStore = {};\n            this.shapeStore[\'turtle\'] = turtleShapePoints();\n            this.shapeStore[\'arrow\'] = defaultShapePoints();\n            this.shapeStore[\'circle\'] = circleShapePoints();\n            this.shapeStore[\'square\'] = squareShapePoints();\n            this.shapeStore[\'triangle\'] = triangleShapePoints();\n            this.shapeStore[\'blank\'] = [new Vector(0,0)];\n            this.shapeStore[\'classic\'] = classicShapePoints();\n            this.currentShape = \'classic\';\n            this.drawingEvents = [];\n\n            this.filling = false;\n            this.pen = true;\n            this.penStyle = \'black\';\n            this.penWidth = 2;\n            this.fillStyle = \'black\';\n            this.position = [ ];\n            this.heading = [ ];\n            this.normal = [ ];\n            this.go_home();\n            this.aCount = 0;\n            this.clearPoint = 0;\t// RNL for clear/clearScreen\n        }\n    }\n    function turtleShapePoints() {\n        var pl = [\n            [0,16],\n            [-2,14],\n            [-1,10],\n            [-4,7],\n            [-7,9],\n            [-9,8],\n            [-6,5],\n            [-7,1],\n            [-5,-3],\n            [-8,-6],\n            [-6,-8],\n            [-4,-5],\n            [0,-7],\n            [4,-5],\n            [6,-8],\n            [8,-6],\n            [5,-3],\n            [7,1],\n            [6,5],\n            [9,8],\n            [7,9],\n            [4,7],\n            [1,10],\n            [2,14]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function defaultShapePoints() {\n        var pl = [\n            [-10,0],\n            [10,0],\n            [0,10]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function circleShapePoints() {\n        var pl = [\n            [10,0],\n            [9.51,3.09],\n            [8.09,5.88],\n            [5.88,8.09],\n            [3.09,9.51],\n            [0,10],\n            [-3.09,9.51],\n            [-5.88,8.09],\n            [-8.09,5.88],\n            [-9.51,3.09],\n            [-10,0],\n            [-9.51,-3.09],\n            [-8.09,-5.88],\n            [-5.88,-8.09],\n            [-3.09,-9.51],\n            [-0.00,-10.00],\n            [3.09,-9.51],\n            [5.88,-8.09],\n            [8.09,-5.88],\n            [9.51,-3.09]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function triangleShapePoints() {\n        var pl = [\n            [10,-5.77],\n            [0,11.55],\n            [-10,-5.77]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function squareShapePoints() {\n        var pl = [\n            [10,-10],\n            [10,10],\n            [-10,10],\n            [-10,-10]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function classicShapePoints() {\n        var pl = [\n            [0,0],\n            [-5,-9],\n            [0,-7],\n            [5,-9]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    Turtle.prototype.clean = function () {\n        // Clean the canvas\n        // Optional second argument is color\n        with (this) {\n            if (arguments.length >= 1) {\n                clear_canvas(canvasID, arguments[0]);\n            }\n            else {\n                clear_canvas(canvasID);\n            }\n            initialize();\n        }\n    }\n\n    Turtle.prototype.addDrawingEvent = function(eventList) {\n        TurtleGraphics.eventCount += 1;\n        eventList.push(TurtleGraphics.eventCount);\n        this.drawingEvents.push(eventList);\n    }\n//  \n//  Drawing Functions\n//\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n        var head = ep.sub(sp).normalize();\n        var numSegs = Math.floor(ep.sub(sp).len() / sL);\n        var res = [];\n        var oldp = sp;\n        var newp;\n        var op = ""\n        if (pen)\n            op = "LT"\n        else\n            op = "MT"\n        for (var i = 0; i < numSegs; i++) {\n            newp = oldp.linear(1, sL, head);\n            res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n            oldp = newp;\n        }\n        if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n            res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n        return res;\n    }\n\n    Turtle.prototype.draw_line = function(newposition) {\n        with (this) {\n            with (context) {\n                if (! animate) {\n                    if (! filling) {\n                        beginPath();\n                        moveTo(position[0], position[1]);\n                    }\n                    lineCap = \'round\';\n                    lineJoin = \'round\';\n                    lineWidth = get_pen_width();\n                    strokeStyle = penStyle;\n                    lineTo(newposition[0], newposition[1]);\n                    stroke();\n                    if (! filling)\n                        closePath();\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r) {\n                        r[s].push(penStyle);\n                        addDrawingEvent(r[s]);\n                    }\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    Turtle.prototype.forward = function (d) {\n        with (this) {\n            var newposition = position.linear(1, d, heading);\n            goto(newposition);\n        }\n    }\n\n    Turtle.prototype.backward = function(d) {\n        this.forward(-d);\n    }\n\n//\tThis is an internal function that sets the position without doing any drawing\n    Turtle.prototype.teleport_to = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        this.context.moveTo(newposition[0], newposition[1]);\n\t\tthis.position = newposition;\n\t}\n\n    Turtle.prototype.goto = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        with (this) {\n            if (pen) {\n                draw_line(newposition);\n            } else {\n                if (! animate) {\n                    context.moveTo(newposition[0], newposition[1]);\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r)\n                        addDrawingEvent(r[s]);\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n            position = newposition;\n\n        }\n    }\n\n    Turtle.prototype.delay = function(d) {\t// RNL\n    \tif (d != null) {\n    \t\tif (d < 0)\n    \t\t\td = -d\n    \t\tif (!this.animate) \n    \t\t\tthis.turtleCanvas.setDelay(d)\n    \t\telse {\n    \t\t\tthis.turtleCanvas.setDelay(d)\n\t    \t\tthis.addDrawingEvent(["DL", d])\n\t    \t\tthis.addDrawingEvent(["NO"])\n    \t\t}\n    \t}\n        return this.turtleCanvas.getDelay();\n    }\n\n    Turtle.prototype.speed = function(s,t) {\n        if (s > 0 && !this.animate) {\n            this.animate = true;\n            this.turtleCanvas.setSpeedDelay(s)\n        } else if (s == 0 && !this.animate) {\n        \tthis.turtleCanvas.setSpeedDelay(s)\n        } else {\n//          this.animate = false;\n//          this.turtleCanvas.cancelAnimation();\n\t\t\tthis.addDrawingEvent(["SC", s, t])\n\t\t\tthis.addDrawingEvent(["NO"])\n        }\n        if (t) {\n            this.turtleCanvas.setSegmentLength(t);\n            // set the number of units to divide a segment into\n        } else {\n            this.turtleCanvas.setSegmentLength(10);\n        }\n    }\n\n    Turtle.prototype.tracer = function(t, d) {\n        this.turtleCanvas.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tthis.animate=false;\n\t\t\tthis.turtleCanvas.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.turtleCanvas.setDelay(d);\n    }\n\n    Turtle.prototype.getRenderCounter = function() {\n        return this.turtleCanvas.getCounter();\n    }\n\n    Turtle.prototype.turn = function (phi) {\n        with (this) {\n            var alpha = phi * Degree2Rad;\n            var left = normal.cross(heading);\n            var newheading = heading.rotateNormal(left, normal, alpha);\n            heading = newheading;\n\n            if (animate) {\n                addDrawingEvent(["TT",heading]);\n            }\n        }\n    }\n\n    Turtle.prototype.right = Turtle.prototype.turn;\n\n    Turtle.prototype.left = function(phi) {\n        this.turn(-phi);\n    }\n\n    Turtle.prototype.get_heading = function () {\n        if (TurtleGraphics.defaults.degrees)\n            return this.heading.toAngle()\n        else\n            return this.heading\n    }\n\n    Turtle.prototype.get_position = function () {\n        return this.position;\n    }\n\n    Turtle.prototype.getx = function () {\n        return this.position[0];\n    }\n\n    Turtle.prototype.gety = function () {\n        return this.position[1];\n    }\n\n    Turtle.prototype.set_heading = function(newhead) {\n        if ((typeof(newhead)).toLowerCase() === \'number\') {\n            this.heading = Vector.angle2vec(newhead);\n        } else {\n            this.heading = newhead;\n        }\n    }\n\n    Turtle.prototype.towards = function(to, y) {\n        // set heading vector to point towards another point.\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        else if (! (to instanceof Vector)) {\n            to = new Vector(to);\n        }\n        var res = to.sub(this.position);\n        res = res.normalize();\n        if (TurtleGraphics.defaults.degrees) {\n            return res.toAngle();\n        }\n        else {\n            return res;\n        }\n    }\n\n    Turtle.prototype.distance = function(to, y) {\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        return this.position.sub(new Vector(to)).len();\n    }\n\n    Turtle.prototype.dot = function() {\n        var size = 2;\n        if (arguments.length >= 1) size = arguments[0];\n        size = size * this.turtleCanvas.lineScale;\n        with (this) {\n            with (context) {\n                var color = penStyle;\n                var nc = arguments[1] || color;\n                if (! animate) {\n                    fillStyle = nc;\n                    fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n                    fillStyle = color;\n                } else {\n                    addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n                }\n            }\n        }\n\n    }\n\n    Turtle.prototype.circle = function(radius, extent) {\n        if (extent === undefined) {\n            extent = 360\n        }\n\t\tif (this.animate) {\n\t\t\tvar arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n\t\t\tvar segLen = this.turtleCanvas.getSegmentLength();\n\t\t\tif (arcLen <= segLen)\n\t\t\t\tthis.arc(radius,extent);\n\t\t\telse {\n\t\t\t\t//\tBreak the arc into segments for animation\n\t\t\t\tvar extentPart = (segLen / arcLen) * extent;\n\t\t\t\tvar extentLeft = extent;\n\t\t\t\twhile (Math.abs(extentLeft) > Math.abs(extentPart)) {\n\t\t\t\t\tthis.arc(radius, extentPart);\n\t\t\t\t\textentLeft = extentLeft - extentPart;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(extentLeft) > 0.01)\n\t\t\t\t\tthis.arc(radius, extentLeft);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.arc(radius,extent);\n\t\t}\n\t}\n\t\n    Turtle.prototype.arc = function(radius, extent) {\n\t\t//\tFigure out where the turtle is and which way it\'s facing\n\t\tvar turtleHeading = this.get_heading()\n\t\tvar tx = this.position[0]\n\t\tvar ty = this.position[1]\n\n\t\t//\tFigure out the circle center\n\t\tvar cx = tx + (radius * Math.cos((turtleHeading + 90) * Degree2Rad));\n\t\tvar cy = ty + (radius * Math.sin((turtleHeading + 90) * Degree2Rad));\n\n\t\t//\tCanvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Turtle\n\n\t\t//\tFigure out our arc angles\n\t\tvar startAngleDeg;\n\t\tif (radius >= 0)\n\t\t\tstartAngleDeg = turtleHeading - 90;\n\t\telse\n\t\t\tstartAngleDeg = turtleHeading + 90;\n\n\t\tvar endAngleDeg;\n        if (extent) {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + extent;\n\t\t\telse\n\t            endAngleDeg = startAngleDeg - extent;\n        } else {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + 360;\n\t\t\telse\n\t\t\t\tendAngleDeg = startAngleDeg - 360;\n\t\t}\n\n\t\t//\tCanvas angles are opposite\n\t\tstartAngleDeg = 360 - startAngleDeg\n\t\tendAngleDeg   = 360 - endAngleDeg\n\n\t\t//\tBecuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n\t\tstartAngleDeg = -startAngleDeg\n\t\tendAngleDeg   = -endAngleDeg\n\n\t\t//\tConvert to radians\n\t\tvar startAngle = startAngleDeg * Degree2Rad;\n\t\tvar endAngle   = endAngleDeg   * Degree2Rad;\n\n\n\t\t//\tDo the drawing\n        if (! this.animate) {\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.beginPath();\n            this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n            this.context.stroke();\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.closePath();\n        } else {\n            this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n        }\n\n\t\t//\tMove the turtle only if we have to\n\t\tif (extent && (extent % 360) != 0) {\n\t\t\tvar turtleArc;\n\t\t\tif (radius >= 0)\n\t\t\t\tturtleArc = extent;\n\t\t\telse \n\t\t\t\tturtleArc = -extent;\n\t\t\tvar newTurtleHeading = (turtleHeading + turtleArc) % 360;\n\t\t\tif (newTurtleHeading < 0)\n\t\t\t\tnewTurtleHeading = newTurtleHeading + 360;\n\n\t\t\tvar nx = cx + (radius * Math.cos((newTurtleHeading - 90) * Degree2Rad));\n\t\t\tvar ny = cy + (radius * Math.sin((newTurtleHeading - 90) * Degree2Rad));\t//\ty coord is inverted in turtle\n\n\t\t\t//\tMove it internally\n\t\t\tthis.set_heading(newTurtleHeading);\n\t\t\tthis.teleport_to(nx,ny);\n\n\t\t\t//\tIf we\'re animating the turtle, move it on the screen\n\t\t\tif (this.animate) {\n\t\t\t\tthis.addDrawingEvent(["TT", this.heading]);\n\t\t\t}\n\t\t}\n\n    }\n\n    Turtle.prototype.write = function(theText, move, align, font) {\n        if (! this.animate) {\n            if (font)\n                this.context.font = font.v;\n            this.context.scale(1, -1);\n            this.context.fillText(theText, this.position[0], -this.position[1]);\n            this.context.scale(1, -1);\n        } else {\n            var fontspec;\n            if (font)\n                fontspec = font.v\n            this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n        }\n    }\n\n    Turtle.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.turtleCanvas.setworldcoordinates(llx, lly, urx, ury);\n    }\n\n//\n// Pen and Style functions\n//\n    Turtle.prototype.pen_down = function () {\n        this.pen = true;\n    }\n\n    Turtle.prototype.down = Turtle.prototype.pen_down;\n\n    Turtle.prototype.pen_up = function () {\n        this.pen = false;\n    }\n\n    Turtle.prototype.up = Turtle.prototype.pen_up;\n\n    Turtle.prototype.get_pen = function () {\n        return this.pen;\n    }\n\n    Turtle.prototype.set_pen_width = function (w) {\n        if (this.animate)\n            this.addDrawingEvent(["PW", w * this.turtleCanvas.lineScale]);\n        else\n            this.penWidth = w;\n    }\n\n    Turtle.prototype.get_pen_width = function() {\n        return this.penWidth * this.turtleCanvas.lineScale;\n    }\n\n    Turtle.prototype.set_pen_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.penStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == "object" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16);\n            gs = c1.toString(16);\n            bs = c2.toString(16);\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.penStyle = c;\n        }\n\n        this.context.strokeStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["TC", c]);\n    }\n\n    Turtle.prototype.set_fill_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.fillStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == "object" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16)\n            gs = c1.toString(16)\n            bs = c2.toString(16)\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.fillStyle = c;\n        }\n\n        this.context.fillStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["FC", c]);\n    }\n\n    Turtle.prototype.begin_fill = function () {\n        if (! this.animate) {\n            this.filling = true;\n            this.context.beginPath();\n            this.context.moveTo(this.position[0], this.position[1]);\n        } else\n            this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n\n    }\n\n    Turtle.prototype.end_fill = function () {\n        if (! this.animate) {\n            this.context.stroke();\n            this.context.fill();\n            this.context.closePath();\n            this.filling = false;\n        } else\n            this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n    }\n\n\n    Turtle.prototype.showturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["SH"]);\n        }\n        this.visible = true;\n    }\n\n    Turtle.prototype.hideturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["HT"]);\n        }\n        this.visible = false;\n    }\n\n    Turtle.prototype.isvisible = function() {\n        return this.visible;\n    }\n\n    // \n    // Appearance\n    //\n\n    Turtle.prototype.shape = function(s) {\n        if (this.shapeStore[s])\n            this.currentShape = s;\n        else {\n        }\n    }\n\n    Turtle.prototype.drawturtle = function(heading, position) {\n        var rtPoints = [];\n        var plist = this.shapeStore[this.currentShape];\n        var head;\n        if (! (heading === undefined))\n            head = heading - 90.0;\n        else\n            head = this.heading.toAngle() - 90.0;\n        if (! position)\n            position = this.position\n        for (p in plist) {\n            rtPoints.push(plist[p].scale(this.turtleCanvas.xptscale,this.turtleCanvas.yptscale).rotate(head).add(position));\n        }\n        this.context.beginPath();\n        this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n        for (var i = 1; i < rtPoints.length; i++) {\n            this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n        }\n        this.context.closePath();\n        this.context.stroke();\n        if (this.fillStyle) {\n            this.context.fill();\n        }\n    }\n\n    Turtle.prototype.stamp = function() {\n        // either call drawTurtle or just add a DT with current position and heading to the drawingEvents list.\n        if (this.animate) {\n            this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n        } else\n            this.drawturtle();\n    }\n    \n    Turtle.prototype.clear = function () {\n    \tif (this.animate) {\n    \t\tthis.addDrawingEvent(["CL"])\n    \t} else {\n    \t\tclear_canvas(this.canvasID);\n    \t}\n    }\n\n    function clear_canvas(canId) {\n        with (document.getElementById(canId).getContext(\'2d\')) {\n            if (arguments.length >= 2) {\n//\t\tfillStyle = arguments[1];\n//\t\tfillRect(0, 0, canvas.width, canvas.height);\n            }\n            clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n        }\n    }\n\n\n    // Create a 3d Vector class for manipulating turtle heading, and position.\n\n    function Vector(x, y, z) {\n        if ((typeof(x)).toLowerCase() === \'number\') {\n            Array.prototype.push.call(this, x);\n            Array.prototype.push.call(this, y);\n            Array.prototype.push.call(this, z);\n        }\n        else {\n            for (var i in x) {\n                Array.prototype.push.call(this, x[i]);\n            }\n        }\n    }\n\n\n    // Create a vector object given a direction as an angle.\n    Vector.angle2vec = function(phi) {\n        var res = new Vector([0.0,0.0,0.0]);\n        phi = phi * Degree2Rad;\n        res[0] = Math.cos(phi);\n        res[1] = Math.sin(phi);\n        return res.normalize();\n    }\n\n    // This trick allows you to access a Vector object like an array\n    // myVec[0] == x\n    // myVec[1] == y\n    // myVec[2] == z\n    // we really only need the z for the convenience of rotating\n    Vector.prototype.addItem = function(item) {\n        Array.prototype.push.call(this, item);\n    }\n\n    Vector.prototype.linear = function(a, b, v) {\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = a * this[c] + b * v[c];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.cross = function(v) {\n        // Return cross product of this and v\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.rotate = function(angle) {\n        // Rotate this counter clockwise by angle.\n        var perp = new Vector(-this[1], this[0], 0);\n        angle = angle * Degree2Rad;\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n    }\n\n    Vector.prototype.rotateNormal = function(v, w, alpha) {\n        // Return rotation of this in direction of v about w over alpha\n        // Requires: v, w are vectors; alpha is angle in radians\n        //   this, v, w are orthonormal\n        return this.linear(Math.cos(alpha), Math.sin(alpha), v);\n    }\n\n    Vector.prototype.normalize = function() {\n        var n = this.len();\n        var res = this.div(n);\n        return res;\n    }\n\n    Vector.prototype.toAngle = function() {\n        // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n        if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n        if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n        var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n        var deg = rads * Rad2Degree;\n        if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n        else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n        else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n        return deg;\n    }\n\n    // divide all vector components by the same value\n    Vector.prototype.div = function(n) {\n        res = []\n        res[0] = this[0] / n;\n        res[1] = this[1] / n;\n        res[2] = this[2] / n;\n        return new Vector(res);\n    }\n\n    // subtract one vector from another\n    Vector.prototype.sub = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] - v[0];\n        res[1] = this[1] - v[1];\n        res[2] = this[2] - v[2];\n        return res;\n    }\n\n    Vector.prototype.add = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] + v[0];\n        res[1] = this[1] + v[1];\n        res[2] = this[2] + v[2];\n        return res;\n    }\n\n    Vector.prototype.smul = function(k) {  // scalar multiplication\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] * k;\n        res[1] = this[1] * k;\n        res[2] = this[2] * k;\n        return res;\n    }\n\n    Vector.prototype.scale = function(xs,ys) {\n        res = new Vector(0,0,0);\n        res[0] =  this[0] * ys;\n        res[1] =  this[1] * xs;\n        res[2] = 1.0;\n        return res;\n    }\n\n    Vector.prototype.len = function() {\n        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n    }\n\n\n    TurtleGraphics.defaults = { canvasID: \'mycanvas\', degrees: true, animate: true }\n    TurtleGraphics.turtleList = [];\n    TurtleGraphics.Turtle = Turtle;\n    TurtleGraphics.TurtleCanvas = TurtleCanvas;\n    TurtleGraphics.canvasLib = {}\n    TurtleGraphics.clear_canvas = clear_canvas;\n    TurtleGraphics.Vector = Vector;\n    TurtleGraphics.canvasInit = false;\n    TurtleGraphics.eventCount = 0;\n    TurtleGraphics.renderClock = 0;\n    TurtleGraphics.renderTime  = 0; // RNL\n\n})();\n\n\n//\n// Wrapper around the Turtle Module starts here.\n//\n//\nvar $builtinmodule = function(name) {\n    var mod = {};\n    // First we create an object, this will end up being the class\n    // class\n    Sk.tg = TurtleGraphics;\n\n    var checkArgs = function(expected, actual, func) {\n        if (actual != expected ) {\n            throw new Sk.builtin.TypeError(func + " takes exactly " + expected +\n                    " positional argument (" + actual + " given)")\n        }\n    }\n\n    var turtle = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            self.theTurtle = new TurtleGraphics.Turtle();\n        });\n\n//\n// Turtle Motion\n//\n        //\n        // Move and Draw\n        //\n        $loc.forward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"forward()");\n            self.theTurtle.forward(dist);\n        });\n\n        $loc.fd = $loc.forward;\n\n        $loc.backward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"backward()");\n            self.theTurtle.forward(-dist);\n        });\n\n        $loc.back = $loc.backward;\n        $loc.bk = $loc.backward;\n\n        $loc.right = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"right()");\n            self.theTurtle.turn(angle);\n        });\n\n        $loc.rt = $loc.right;\n\n        $loc.left = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"left()");\n            self.theTurtle.turn(-angle);\n        });\n\n        $loc.lt = $loc.left;\n\n        $loc.goto_$rw$ = new Sk.builtin.func(function(self, nx, ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"goto()");\n            self.theTurtle.goto(nx, ny);\n        });\n\n        $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"setposition()");\n            self.theTurtle.up();\n            self.theTurtle.goto(nx,ny);\n            self.theTurtle.down();\n        });\n        $loc.setpos = $loc.setposition;\n\n        $loc.setx = new Sk.builtin.func(function(self, nx) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n            checkArgs(2,arguments.length,"setx()");\n            self.theTurtle.goto(nx, self.theTurtle.GetY());\n        });\n\n        $loc.sety = new Sk.builtin.func(function(self, ny) {\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(2,arguments.length,"sety()");\n            self.theTurtle.goto(self.theTurtle.GetX(), ny);\n        });\n\n        $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n\t\t\tnewhead = Sk.builtin.asnum$(newhead);\n            checkArgs(2,arguments.length,"setheading()");\n            return self.theTurtle.set_heading(newhead);\n        });\n\n        $loc.seth = $loc.setheading;\n\n        $loc.home = new Sk.builtin.func(function(self) {\n            self.theTurtle.go_home();\n        });\n\n        $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n\t\t\tsize = Sk.builtin.asnum$(size);\n            size = size || 1;\n            if (color) {\n                color = color.v || self.theTurtle.penStyle;\n            }\n            self.theTurtle.dot(size, color);\n        });\n\n        $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n\t\t\tradius = Sk.builtin.asnum$(radius);\n\t\t\textent = Sk.builtin.asnum$(extent);\n            self.theTurtle.circle(radius, extent);\n        });\n\n        $loc.delay = new Sk.builtin.func(function(self, d) {\n\t\t\td = Sk.builtin.asnum$(d);\n            return self.theTurtle.delay(d);\n        });\n\n        $loc.speed = new Sk.builtin.func(function(self, s, t) {\n\t\t\ts = Sk.builtin.asnum$(s);\n\t\t\tt = Sk.builtin.asnum$(t);\n            self.theTurtle.speed(s,t);\n        });\n\n        $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n\t\t\tt = Sk.builtin.asnum$(t);\n\t\t\td = Sk.builtin.asnum$(d);\n            self.theTurtle.tracer(t, d);\n        });\n\n\t\t$loc.update = new Sk.builtin.func(function(self) {\n\t\t\t//\tDummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n\t\t});\n\n        // todo:  stamp, clearstamp, clearstamps, undo, speed\n\n        //\n        // Tell Turtle\'s state\n        //\n        $loc.heading = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"heading()");\n            return Sk.builtin.assk$(self.theTurtle.get_heading(),Sk.builtin.nmber.float$);\n        });\n\n        $loc.position = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"position()");\n            var res = self.theTurtle.get_position();\n            var x = new Sk.builtin.tuple([Sk.builtin.assk$(res[0],Sk.builtin.nmber.float$),\n                                          Sk.builtin.assk$(res[1],Sk.builtin.nmber.float$) ]);\n            return x;\n        });\n\n        $loc.pos = $loc.position;\n\n        $loc.xcor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"xcor()");\n            var res = self.theTurtle.getx();\n            return Sk.builtin.assk$(res,Sk.builtin.nmber.float$);\n        });\n\n        $loc.ycor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"ycor()");\n            var res = self.theTurtle.gety();\n            return Sk.builtin.assk$(res,Sk.builtin.nmber.float$);\n        });\n\n        $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [Sk.builtin.asnum$(tx.theTurtle.getx()),Sk.builtin.asnum$(tx.theTurtle.gety()),Sk.builtin.asnum$(0)]\n            }\n            return Sk.builtin.assk$(self.theTurtle.towards(tx),Sk.builtin.nmber.float$);\n        });\n\n        // tx can be either a number or a vector position.\n        // tx can not be a turtle at this time as multiple turtles have not been implemented yet.\n        $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [tx.theTurtle.getx(), tx.theTurtle.gety(), 0];\n            }\n            return Sk.builtin.assk$(self.theTurtle.distance(tx),Sk.builtin.nmber.float$);\n        });\n\n        //\n        // Setting and Measurement\n        //\n\n        // todo:  degrees and radians...\n\n//\n// Pen Control\n//\n\n        //\n        // Drawing State\n        //\n\n        $loc.up = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"up()");\n            self.theTurtle.pen_up();\n        });\n\n        $loc.penup = $loc.up;\n        $loc.pu = $loc.up;\n\n        $loc.down = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"down()");\n            self.theTurtle.pen_down();\n        });\n\n        $loc.pendown = $loc.down;\n        $loc.pd = $loc.down;\n\n        $loc.width = new Sk.builtin.func(function(self, w) {\n\t\t\tw = Sk.builtin.asnum$(w);\n            checkArgs(2,arguments.length,"width()");\n            self.theTurtle.set_pen_width(w);\n        });\n\n        $loc.pensize = $loc.width;\n\n        $loc.isdown = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isdown()");\n            return self.theTurtle.get_pen();\n        });\n\n        // todo:  pen  -- return a dictionary full of pen stuff\n\n        //\n        // Color Control\n        //\n\n        $loc.fillcolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else\n                return self.theTurtle.fillStyle;\n        });\n\n        $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n\t\t\t\t\tcolor = Sk.builtin.asnum$(color);\n\t\t\t\t\tgreen = Sk.builtin.asnum$(green);\n\t\t\t\t\tblue = Sk.builtin.asnum$(blue);\n                    self.theTurtle.set_pen_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                }\n            } else\n                return self.theTurtle.penStyle;\n        });\n\n        $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n            if(color) {\n                if (blue) {\n                    self.theTurtle.set_pen_color(color, green, blue);\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else \n                return [self.theTurtle.penStyle, self.theTurtle.fillStyle];            \n        });\n\n        //\n        //  Filling\n        //\n\n        $loc.begin_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"begin_fill()");\n            self.theTurtle.begin_fill();\n        });\n\n        $loc.end_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"end_fill()");\n            self.theTurtle.end_fill();\n        });\n\n        $loc.fill = new Sk.builtin.func(function(self, fillt) {\n\t\t\tif (fillt === undefined)\n\t\t\t\treturn self.theTurtle.filling;\n            if (fillt)\n                self.theTurtle.begin_fill();\n            else\n                self.theTurtle.end_fill();\n        });\n\n        //\n        // More drawing control\n        //\n\n        $loc.reset = new Sk.builtin.func(function(self) {\n            self.theTurtle.clean();\n        });\n\n        $loc.showturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"showturtle()");\n            self.theTurtle.showturtle();\n        });\n        $loc.st = $loc.showturtle;\n\n        $loc.hideturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"hideturtle()");\n            self.theTurtle.hideturtle();\n        });\n        $loc.ht = $loc.hideturtle;\n\n        $loc.isvisible = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isvisible()");\n            self.theTurtle.isvisible()\n        });\n\n        $loc.stamp = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"stamp()");\n            self.theTurtle.stamp();\n        });\n\n        $loc.shape = new Sk.builtin.func(function(self, s) {\n            checkArgs(2,arguments.length,"shape()");\n            self.theTurtle.shape(s.v);\n        });\n\n\n        // todo the move, align, and font parameters should be kwargs...\n        $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n            self.theTurtle.write(mystr.v, move, align, font);\n        });\n\n        // todo clean  -- again multiple turtles\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theTurtle.setworldcoordinates(llx, lly, urx, ury);\n        });\n\n\t\t//\tAdded by RNL\n\n\t\t$loc.clear = new Sk.builtin.func(function(self) {\n\t\t\tself.theTurtle.clear()\n\t\t});\n\n    }\n\n    mod.Turtle = Sk.misceval.buildClass(mod, turtle, \'Turtle\', []);\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            var currentCanvas = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID];\n            if (currentCanvas === undefined) {\n                self.theScreen = new TurtleGraphics.TurtleCanvas(TurtleGraphics.defaults);\n            } else {\n                self.theScreen = currentCanvas;\n            }\n        });\n\n        $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n            self.theScreen.bgcolor(c);\n        });\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n        });\n\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            self.theScreen.exitonclick();\n        });\n\n        $loc.title = new Sk.builtin.func(function(self,titlestring) {\n            // no op....\n        });\n\n        $loc.window_width = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_width();\n        });\n\n        $loc.window_height = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_height();\n        });\n\n        $loc.turtles = new Sk.builtin.func(function(self) {\n            return self.theScreen.turtles();\n        });\n\n\t\t$loc.colormode = new Sk.builtin.func(function(self) {\n\t\t\t//\tEmpty function to emulate compatibility\n\t\t});\n        \n//        $loc.clear = new Sk.builtin.func(function(self) {\n//        \t\n//        });\n\n        var myfunc = function(self, width, height, startx, starty) {\n\t\t\twidth = Sk.builtin.asnum$(width);\n\t\t\theight = Sk.builtin.asnum$(height);\n            self.theScreen.setup(width,height);\n        }\n        // this should allow for named parameters\n        myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n        myfunc.$defaults = [null,500,500,0,0];\n        $loc.setup = new Sk.builtin.func(myfunc);\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n    mod.tracer = new Sk.builtin.func(function(t, d) {\n\t\tt = Sk.builtin.asnum$(t);\n\t\td = Sk.builtin.asnum$(d);\n\t\tfor (var i in Sk.tg.canvasLib)\n\t\t\tSk.tg.canvasLib[i].tracer(t, d);\n    });\n\n\tmod.update = new Sk.builtin.func(function(self) {\n\t\t//\tDummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n\t});\n\n\n    return mod\n}\n',
    'src/lib/webgl/math.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; should probably put this in a math package\n    mod.Mat44 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                        self.stack = [];\n                    });\n\n                $loc.push = new Sk.builtin.func(function(self)\n                    {\n                        self.stack.push(self.elements.slice(0));\n                    });\n\n                $loc.pop = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = self.stack.pop();\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0, 0.0,\n                                         0.0, 0.0, 1.0, 0.0,\n                                         0.0, 0.0, 0.0, 1.0];\n                    });\n\n                $loc.transform3 = new Sk.builtin.func(function(self, v)\n                    {\n                        var e = self.elements;\n                        return Sk.misceval.callsim(mod.Vec3,\n                            e[0] * v.x + e[4] * v.y + e[8] * v.z,\n                            e[1] * v.x + e[5] * v.y + e[9] * v.z,\n                            e[2] * v.x + e[6] * v.y + e[10] * v.z);\n                    });\n\n                $loc.scale = new Sk.builtin.func(function(self, sx, sy, sz)\n                        {\n                            self.elements[0*4+0] *= sx;\n                            self.elements[0*4+1] *= sx;\n                            self.elements[0*4+2] *= sx;\n                            self.elements[0*4+3] *= sx;\n\n                            self.elements[1*4+0] *= sy;\n                            self.elements[1*4+1] *= sy;\n                            self.elements[1*4+2] *= sy;\n                            self.elements[1*4+3] *= sy;\n\n                            self.elements[2*4+0] *= sz;\n                            self.elements[2*4+1] *= sz;\n                            self.elements[2*4+2] *= sz;\n                            self.elements[2*4+3] *= sz;\n\n                            return self;\n                        });\n\n                $loc.translate = new Sk.builtin.func(function(self, tx, ty, tz)\n                        {\n                            self.elements[3*4+0] += self.elements[0*4+0] * tx + self.elements[1*4+0] * ty + self.elements[2*4+0] * tz;\n                            self.elements[3*4+1] += self.elements[0*4+1] * tx + self.elements[1*4+1] * ty + self.elements[2*4+1] * tz;\n                            self.elements[3*4+2] += self.elements[0*4+2] * tx + self.elements[1*4+2] * ty + self.elements[2*4+2] * tz;\n                            self.elements[3*4+3] += self.elements[0*4+3] * tx + self.elements[1*4+3] * ty + self.elements[2*4+3] * tz;\n                            return self;\n                        });\n\n                $loc.rotate = new Sk.builtin.func(function(self, angle, x, y, z)\n                        {\n                            var mag = Math.sqrt(x*x + y*y + z*z);\n                            var sinAngle = Math.sin(angle * Math.PI / 180.0);\n                            var cosAngle = Math.cos(angle * Math.PI / 180.0);\n\n                            if (mag > 0)\n                            {\n                                var xx, yy, zz, xy, yz, zx, xs, ys, zs;\n                                var oneMinusCos;\n                                var rotMat;\n\n                                x /= mag;\n                                y /= mag;\n                                z /= mag;\n\n                                xx = x * x;\n                                yy = y * y;\n                                zz = z * z;\n                                xy = x * y;\n                                yz = y * z;\n                                zx = z * x;\n                                xs = x * sinAngle;\n                                ys = y * sinAngle;\n                                zs = z * sinAngle;\n                                oneMinusCos = 1.0 - cosAngle;\n\n                                rotMat = Sk.misceval.callsim(mod.Mat44);\n\n                                rotMat.elements[0*4+0] = (oneMinusCos * xx) + cosAngle;\n                                rotMat.elements[0*4+1] = (oneMinusCos * xy) - zs;\n                                rotMat.elements[0*4+2] = (oneMinusCos * zx) + ys;\n                                rotMat.elements[0*4+3] = 0.0;\n\n                                rotMat.elements[1*4+0] = (oneMinusCos * xy) + zs;\n                                rotMat.elements[1*4+1] = (oneMinusCos * yy) + cosAngle;\n                                rotMat.elements[1*4+2] = (oneMinusCos * yz) - xs;\n                                rotMat.elements[1*4+3] = 0.0;\n\n                                rotMat.elements[2*4+0] = (oneMinusCos * zx) - ys;\n                                rotMat.elements[2*4+1] = (oneMinusCos * yz) + xs;\n                                rotMat.elements[2*4+2] = (oneMinusCos * zz) + cosAngle;\n                                rotMat.elements[2*4+3] = 0.0;\n\n                                rotMat.elements[3*4+0] = 0.0;\n                                rotMat.elements[3*4+1] = 0.0;\n                                rotMat.elements[3*4+2] = 0.0;\n                                rotMat.elements[3*4+3] = 1.0;\n\n                                rotMat = rotMat.multiply(self);\n                                self.elements = rotMat.elements;\n                            }\n                            return self;\n                        });\n\n                $loc.multiply = new Sk.builtin.func(function(self, right)\n                        {\n                            var tmp = Sk.misceval.callsim(mod.Mat44);\n\n                            for (var i = 0; i < 4; i++)\n                            {\n                                tmp.elements[i*4+0] =\n                                (self.elements[i*4+0] * right.elements[0*4+0]) +\n                                (self.elements[i*4+1] * right.elements[1*4+0]) +\n                                (self.elements[i*4+2] * right.elements[2*4+0]) +\n                                (self.elements[i*4+3] * right.elements[3*4+0]) ;\n\n                                tmp.elements[i*4+1] =\n                                (self.elements[i*4+0] * right.elements[0*4+1]) +\n                                (self.elements[i*4+1] * right.elements[1*4+1]) +\n                                (self.elements[i*4+2] * right.elements[2*4+1]) +\n                                (self.elements[i*4+3] * right.elements[3*4+1]) ;\n\n                                tmp.elements[i*4+2] =\n                                (self.elements[i*4+0] * right.elements[0*4+2]) +\n                                (self.elements[i*4+1] * right.elements[1*4+2]) +\n                                (self.elements[i*4+2] * right.elements[2*4+2]) +\n                                (self.elements[i*4+3] * right.elements[3*4+2]) ;\n\n                                tmp.elements[i*4+3] =\n                                (self.elements[i*4+0] * right.elements[0*4+3]) +\n                                (self.elements[i*4+1] * right.elements[1*4+3]) +\n                                (self.elements[i*4+2] * right.elements[2*4+3]) +\n                                (self.elements[i*4+3] * right.elements[3*4+3]) ;\n                            }\n\n                            self.elements = tmp.elements;\n                            return self;\n                        });\n\n                /* Following gluLookAt implementation is adapted from\n                 * the Mesa 3D Graphics library. http://www.mesa3d.org\n                 */\n                // todo; rewrite this with proper vec/mat ops\n                $loc.lookAt = new Sk.builtin.func(function(self, eyeX, eyeY, eyeZ,\n                                                                 centerX, centerY, centerZ,\n                                                                 upX, upY, upZ)\n                        {\n                            /* Z vector */\n                            var z = [\n                                eyeX - centerX,\n                                eyeY - centerY,\n                                eyeZ - centerZ\n                            ];\n                            var mag = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);\n                            if (mag)\n                            {\n                                z[0] /= mag;\n                                z[1] /= mag;\n                                z[2] /= mag;\n                            }\n\n                            /* Y vector */\n                            var y = [ upX, upY, upZ ];\n\n                            /* X vector = Y cross Z */\n                            var x = [];\n                            x[0] = y[1] * z[2] - y[2] * z[1];\n                            x[1] = -y[0] * z[2] + y[2] * z[0];\n                            x[2] = y[0] * z[1] - y[1] * z[0];\n\n                            /* Recompute Y = Z cross X */\n                            y[0] = z[1] * x[2] - z[2] * x[1];\n                            y[1] = -z[0] * x[2] + z[2] * x[0];\n                            y[2] = z[0] * x[1] - z[1] * x[0];\n\n                            /* mpichler, 19950515 */\n                            /* cross product gives area of parallelogram, which is < 1.0 for\n                            * non-perpendicular unit-length vectors; so normalize x, y here\n                            */\n\n                            mag = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n                            if (mag) {\n                                x[0] /= mag;\n                                x[1] /= mag;\n                                x[2] /= mag;\n                            }\n\n                            mag = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);\n                            if (mag) {\n                                y[0] /= mag;\n                                y[1] /= mag;\n                                y[2] /= mag;\n                            }\n\n                            var lookAt = Sk.misceval.callsim(mod.Mat44);\n                            lookAt.elements[0 * 4 + 0] = x[0];\n                            lookAt.elements[1 * 4 + 0] = x[1];\n                            lookAt.elements[2 * 4 + 0] = x[2];\n                            lookAt.elements[3 * 4 + 0] = 0.;\n                            lookAt.elements[0 * 4 + 1] = y[0];\n                            lookAt.elements[1 * 4 + 1] = y[1];\n                            lookAt.elements[2 * 4 + 1] = y[2];\n                            lookAt.elements[3 * 4 + 1] = 0.;\n                            lookAt.elements[0 * 4 + 2] = z[0];\n                            lookAt.elements[1 * 4 + 2] = z[1];\n                            lookAt.elements[2 * 4 + 2] = z[2];\n                            lookAt.elements[3 * 4 + 2] = 0.;\n                            lookAt.elements[0 * 4 + 3] = 0.;\n                            lookAt.elements[1 * 4 + 3] = 0.;\n                            lookAt.elements[2 * 4 + 3] = 0.;\n                            lookAt.elements[3 * 4 + 3] = 1.;\n\n                            // log(lookAt.elements);\n\n                            lookAt = lookAt.multiply(self);\n                            self.elements = lookAt.elements;\n                            self.translate(-eyeX, -eyeY, -eyeZ);\n\n                            // log(this.elements);\n\n                            return self;\n                        });\n            },\n            \'Mat44\', []);\n\n    // todo; should probably put this in a math package\n    mod.Mat33 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0,\n                                         0.0, 0.0, 1.0];\n                    });\n            },\n            \'Mat33\', []);\n\n    mod.Vec3 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, x, y, z)\n                    {\n                        self.x = x;\n                        self.y = y;\n                        self.z = z;\n                    });\n                $loc.__sub__ = new Sk.builtin.func(function(self, other)\n                    {\n                        return Sk.misceval.callsim(mod.Vec3, self.x - other.x, self.y - other.y, self.z - other.z);\n                    });\n            },\n            \'Vec3\', []);\n    \n    mod.cross = new Sk.builtin.func(function(v1, v2)\n            {\n                goog.asserts.assert(v1 instanceof mod.Vec3 && v2 instanceof mod.Vec3);\n                return Sk.misceval.callsim(mod.Vec3,\n                    v1.y * v2.z - v1.z * v2.y,\n                    v1.z * v2.x - v1.x * v2.z,\n                    v1.x * v2.y - v1.y * v2.x);\n            });\n\n    return mod;\n};\n',
    'src/builtin/unittest.py': '#!/usr/bin/env python\n\'\'\'\nPython unit testing framework, based on Erich Gamma\'s JUnit and Kent Beck\'s\nSmalltalk testing framework.\n\nThis module contains the core framework classes that form the basis of\nspecific test cases and suites (TestCase, TestSuite etc.), and also a\ntext-based utility class for running the tests and reporting the results\n (TextTestRunner).\n\nSimple usage:\n\n    import unittest\n\n    class IntegerArithmenticTestCase(unittest.TestCase):\n        def testAdd(self):  ## test method names begin \'test*\'\n            self.assertEquals((1 + 2), 3)\n            self.assertEquals(0 + 1, 1)\n        def testMultiply(self):\n            self.assertEquals((0 * 10), 0)\n            self.assertEquals((5 * 8), 40)\n\n    if __name__ == \'__main__\':\n        unittest.main()\n\nFurther information is available in the bundled documentation, and from\n\n  http://docs.python.org/lib/module-unittest.html\n\nCopyright (c) 1999-2003 Steve Purcell\nThis module is free software, and you may redistribute it and/or modify\nit under the same terms as Python itself, so long as this copyright message\nand disclaimer are retained in their original form.\n\nIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\nSPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\nTHIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,\nAND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,\nSUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n\'\'\'\n\n__author__ = "Steve Purcell"\n__email__ = "stephen_purcell at yahoo dot com"\n__version__ = "#Revision: 1.63 $"[11:-2]\n\nimport time\nimport sys\nimport traceback\nimport os\nimport types\n\n##############################################################################\n# Exported classes and functions\n##############################################################################\n__all__ = [\'TestResult\', \'TestCase\', \'TestSuite\', \'TextTestRunner\',\n           \'TestLoader\', \'FunctionTestCase\', \'main\', \'defaultTestLoader\']\n\n# Expose obsolete functions for backwards compatibility\n__all__.extend([\'getTestCaseNames\', \'makeSuite\', \'findTestCases\'])\n\n\n##############################################################################\n# Backward compatibility\n##############################################################################\nif sys.version_info[:2] < (2, 2):\n    def isinstance(obj, clsinfo):\n        import __builtin__\n        if type(clsinfo) in (tuple, list):\n            for cls in clsinfo:\n                if cls is type: cls = types.ClassType\n                if __builtin__.isinstance(obj, cls):\n                    return 1\n            return 0\n        else: return __builtin__.isinstance(obj, clsinfo)\n\ndef _CmpToKey(mycmp):\n    \'Convert a cmp= function into a key= function\'\n    class K(object):\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) == -1\n    return K\n\n##############################################################################\n# Test framework core\n##############################################################################\n\n# All classes defined herein are \'new-style\' classes, allowing use of \'super()\'\n__metaclass__ = type\n\ndef _strclass(cls):\n    return "%s.%s" % (cls.__module__, cls.__name__)\n\n__unittest = 1\n\nclass TestResult:\n    """Holder for test result information.\n\n    Test results are automatically managed by the TestCase and TestSuite\n    classes, and do not need to be explicitly manipulated by writers of tests.\n\n    Each instance holds the total number of tests run, and collections of\n    failures and errors that occurred among those test runs. The collections\n    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the\n    formatted traceback of the error that occurred.\n    """\n    def __init__(self):\n        self.failures = []\n        self.errors = []\n        self.testsRun = 0\n        self.shouldStop = False\n\n    def startTest(self, test):\n        "Called when the given test is about to be run"\n        self.testsRun = self.testsRun + 1\n\n    def stopTest(self, test):\n        "Called when the given test has been run"\n        pass\n\n    def addError(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info().\n        """\n        self.errors.append((test, self._exc_info_to_string(err, test)))\n\n    def addFailure(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info()."""\n        self.failures.append((test, self._exc_info_to_string(err, test)))\n\n    def addSuccess(self, test):\n        "Called when a test has completed successfully"\n        pass\n\n    def wasSuccessful(self):\n        "Tells whether or not this result was a success"\n        return len(self.failures) == len(self.errors) == 0\n\n    def stop(self):\n        "Indicates that the tests should be aborted"\n        self.shouldStop = True\n\n    def _exc_info_to_string(self, err, test):\n        """Converts a sys.exc_info()-style tuple of values into a string."""\n        exctype, value, tb = err\n        # Skip test runner traceback levels\n        while tb and self._is_relevant_tb_level(tb):\n            tb = tb.tb_next\n        if exctype is test.failureException:\n            # Skip assert*() traceback levels\n            length = self._count_relevant_tb_levels(tb)\n            return \'\'.join(traceback.format_exception(exctype, value, tb, length))\n        return \'\'.join(traceback.format_exception(exctype, value, tb))\n\n    def _is_relevant_tb_level(self, tb):\n        return \'__unittest\' in tb.tb_frame.f_globals\n\n    def _count_relevant_tb_levels(self, tb):\n        length = 0\n        while tb and not self._is_relevant_tb_level(tb):\n            length += 1\n            tb = tb.tb_next\n        return length\n\n    def __repr__(self):\n        return "<%s run=%i errors=%i failures=%i>" % \\\n               (_strclass(self.__class__), self.testsRun, len(self.errors),\n                len(self.failures))\n\nclass TestCase:\n    """A class whose instances are single test cases.\n\n    By default, the test code itself should be placed in a method named\n    \'runTest\'.\n\n    If the fixture may be used for many test cases, create as\n    many test methods as are needed. When instantiating such a TestCase\n    subclass, specify in the constructor arguments the name of the test method\n    that the instance is to execute.\n\n    Test authors should subclass TestCase for their own tests. Construction\n    and deconstruction of the test\'s environment (\'fixture\') can be\n    implemented by overriding the \'setUp\' and \'tearDown\' methods respectively.\n\n    If it is necessary to override the __init__ method, the base class\n    __init__ method must always be called. It is important that subclasses\n    should not change the signature of their __init__ method, since instances\n    of the classes are instantiated automatically by parts of the framework\n    in order to be run.\n    """\n\n    # This attribute determines which exception will be raised when\n    # the instance\'s assertion methods fail; test methods raising this\n    # exception will be deemed to have \'failed\' rather than \'errored\'\n\n    failureException = AssertionError\n\n    def __init__(self, methodName=\'runTest\'):\n        """Create an instance of the class that will use the named test\n           method when executed. Raises a ValueError if the instance does\n           not have a method with the specified name.\n        """\n        try:\n            self._testMethodName = methodName\n            testMethod = getattr(self, methodName)\n            self._testMethodDoc = testMethod.__doc__\n        except AttributeError:\n            raise ValueError, "no such test method in %s: %s" % \\\n                  (self.__class__, methodName)\n\n    def setUp(self):\n        "Hook method for setting up the test fixture before exercising it."\n        pass\n\n    def tearDown(self):\n        "Hook method for deconstructing the test fixture after testing it."\n        pass\n\n    def countTestCases(self):\n        return 1\n\n    def defaultTestResult(self):\n        return TestResult()\n\n    def shortDescription(self):\n        """Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method\'s docstring.\n        """\n        doc = self._testMethodDoc\n        return doc and doc.split("\\n")[0].strip() or None\n\n    def id(self):\n        return "%s.%s" % (_strclass(self.__class__), self._testMethodName)\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self._testMethodName == other._testMethodName\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self._testMethodName))\n\n    def __str__(self):\n        return "%s (%s)" % (self._testMethodName, _strclass(self.__class__))\n\n    def __repr__(self):\n        return "<%s testMethod=%s>" % \\\n               (_strclass(self.__class__), self._testMethodName)\n\n    def run(self, result=None):\n        if result is None: result = self.defaultTestResult()\n        result.startTest(self)\n        testMethod = getattr(self, self._testMethodName)\n        try:\n            try:\n                self.setUp()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                return\n\n            ok = False\n            try:\n                testMethod()\n                ok = True\n            except self.failureException:\n                result.addFailure(self, self._exc_info())\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n\n            try:\n                self.tearDown()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                ok = False\n            if ok: result.addSuccess(self)\n        finally:\n            result.stopTest(self)\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the test without collecting errors in a TestResult"""\n        self.setUp()\n        getattr(self, self._testMethodName)()\n        self.tearDown()\n\n    def _exc_info(self):\n        """Return a version of sys.exc_info() with the traceback frame\n           minimised; usually the top level of the traceback frame is not\n           needed.\n        """\n        return sys.exc_info()\n\n    def fail(self, msg=None):\n        """Fail immediately, with the given message."""\n        raise self.failureException, msg\n\n    def failIf(self, expr, msg=None):\n        "Fail the test if the expression is true."\n        if expr: raise self.failureException, msg\n\n    def failUnless(self, expr, msg=None):\n        """Fail the test unless the expression is true."""\n        if not expr: raise self.failureException, msg\n\n    def failUnlessRaises(self, excClass, callableObj, *args, **kwargs):\n        """Fail unless an exception of class excClass is thrown\n           by callableObj when invoked with arguments args and keyword\n           arguments kwargs. If a different type of exception is\n           thrown, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n        """\n        try:\n            callableObj(*args, **kwargs)\n        except excClass:\n            return\n        else:\n            if hasattr(excClass,\'__name__\'): excName = excClass.__name__\n            else: excName = str(excClass)\n            raise self.failureException, "%s not raised" % excName\n\n    def failUnlessEqual(self, first, second, msg=None):\n        """Fail if the two objects are unequal as determined by the \'==\'\n           operator.\n        """\n        if not first == second:\n            raise self.failureException, \\\n                  (msg or \'%r != %r\' % (first, second))\n\n    def failIfEqual(self, first, second, msg=None):\n        """Fail if the two objects are equal as determined by the \'==\'\n           operator.\n        """\n        if first == second:\n            raise self.failureException, \\\n                  (msg or \'%r == %r\' % (first, second))\n\n    def failUnlessAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) != 0:\n            raise self.failureException, \\\n                  (msg or \'%r != %r within %r places\' % (first, second, places))\n\n    def failIfAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) == 0:\n            raise self.failureException, \\\n                  (msg or \'%r == %r within %r places\' % (first, second, places))\n\n    # Synonyms for assertion methods\n\n    assertEqual = assertEquals = failUnlessEqual\n\n    assertNotEqual = assertNotEquals = failIfEqual\n\n    assertAlmostEqual = assertAlmostEquals = failUnlessAlmostEqual\n\n    assertNotAlmostEqual = assertNotAlmostEquals = failIfAlmostEqual\n\n    assertRaises = failUnlessRaises\n\n    assert_ = assertTrue = failUnless\n\n    assertFalse = failIf\n\n\n\nclass TestSuite:\n    """A test suite is a composite test consisting of a number of TestCases.\n\n    For use, create an instance of TestSuite, then add test case instances.\n    When all tests have been added, the suite can be passed to a test\n    runner, such as TextTestRunner. It will run the individual test cases\n    in the order in which they were added, aggregating the results. When\n    subclassing, do not forget to call the base class constructor.\n    """\n    def __init__(self, tests=()):\n        self._tests = []\n        self.addTests(tests)\n\n    def __repr__(self):\n        return "<%s tests=%s>" % (_strclass(self.__class__), self._tests)\n\n    __str__ = __repr__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n        return self._tests == other._tests\n\n    def __ne__(self, other):\n        return not self == other\n\n    # Can\'t guarantee hash invariant, so flag as unhashable\n    __hash__ = None\n\n    def __iter__(self):\n        return iter(self._tests)\n\n    def countTestCases(self):\n        cases = 0\n        for test in self._tests:\n            cases += test.countTestCases()\n        return cases\n\n    def addTest(self, test):\n        # sanity checks\n        if not hasattr(test, \'__call__\'):\n            raise TypeError("the test to add must be callable")\n        if (isinstance(test, (type, types.ClassType)) and\n            issubclass(test, (TestCase, TestSuite))):\n            raise TypeError("TestCases and TestSuites must be instantiated "\n                            "before passing them to addTest()")\n        self._tests.append(test)\n\n    def addTests(self, tests):\n        if isinstance(tests, basestring):\n            raise TypeError("tests must be an iterable of tests, not a string")\n        for test in tests:\n            self.addTest(test)\n\n    def run(self, result):\n        for test in self._tests:\n            if result.shouldStop:\n                break\n            test(result)\n        return result\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the tests without collecting errors in a TestResult"""\n        for test in self._tests: test.debug()\n\n\nclass FunctionTestCase(TestCase):\n    """A test case that wraps a test function.\n\n    This is useful for slipping pre-existing test functions into the\n    unittest framework. Optionally, set-up and tidy-up functions can be\n    supplied. As with TestCase, the tidy-up (\'tearDown\') function will\n    always be called if the set-up (\'setUp\') function ran successfully.\n    """\n\n    def __init__(self, testFunc, setUp=None, tearDown=None,\n                 description=None):\n        TestCase.__init__(self)\n        self.__setUpFunc = setUp\n        self.__tearDownFunc = tearDown\n        self.__testFunc = testFunc\n        self.__description = description\n\n    def setUp(self):\n        if self.__setUpFunc is not None:\n            self.__setUpFunc()\n\n    def tearDown(self):\n        if self.__tearDownFunc is not None:\n            self.__tearDownFunc()\n\n    def runTest(self):\n        self.__testFunc()\n\n    def id(self):\n        return self.__testFunc.__name__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self.__setUpFunc == other.__setUpFunc and \\\n               self.__tearDownFunc == other.__tearDownFunc and \\\n               self.__testFunc == other.__testFunc and \\\n               self.__description == other.__description\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self.__setUpFunc, self.__tearDownFunc,\n                                           self.__testFunc, self.__description))\n\n    def __str__(self):\n        return "%s (%s)" % (_strclass(self.__class__), self.__testFunc.__name__)\n\n    def __repr__(self):\n        return "<%s testFunc=%s>" % (_strclass(self.__class__), self.__testFunc)\n\n    def shortDescription(self):\n        if self.__description is not None: return self.__description\n        doc = self.__testFunc.__doc__\n        return doc and doc.split("\\n")[0].strip() or None\n\n\n\n##############################################################################\n# Locating and loading tests\n##############################################################################\n\nclass TestLoader:\n    """This class is responsible for loading tests according to various\n    criteria and returning them wrapped in a TestSuite\n    """\n    testMethodPrefix = \'test\'\n    sortTestMethodsUsing = cmp\n    suiteClass = TestSuite\n\n    def loadTestsFromTestCase(self, testCaseClass):\n        """Return a suite of all tests cases contained in testCaseClass"""\n        if issubclass(testCaseClass, TestSuite):\n            raise TypeError("Test cases should not be derived from TestSuite. Maybe you meant to derive from TestCase?")\n        testCaseNames = self.getTestCaseNames(testCaseClass)\n        if not testCaseNames and hasattr(testCaseClass, \'runTest\'):\n            testCaseNames = [\'runTest\']\n        return self.suiteClass(map(testCaseClass, testCaseNames))\n\n    def loadTestsFromModule(self, module):\n        """Return a suite of all tests cases contained in the given module"""\n        tests = []\n        for name in dir(module):\n            obj = getattr(module, name)\n            if (isinstance(obj, (type, types.ClassType)) and\n                issubclass(obj, TestCase)):\n                tests.append(self.loadTestsFromTestCase(obj))\n        return self.suiteClass(tests)\n\n    def loadTestsFromName(self, name, module=None):\n        """Return a suite of all tests cases given a string specifier.\n\n        The name may resolve either to a module, a test case class, a\n        test method within a test case class, or a callable object which\n        returns a TestCase or TestSuite instance.\n\n        The method optionally resolves the names relative to a given module.\n        """\n        parts = name.split(\'.\')\n        if module is None:\n            parts_copy = parts[:]\n            while parts_copy:\n                try:\n                    module = __import__(\'.\'.join(parts_copy))\n                    break\n                except ImportError:\n                    del parts_copy[-1]\n                    if not parts_copy: raise\n            parts = parts[1:]\n        obj = module\n        for part in parts:\n            parent, obj = obj, getattr(obj, part)\n\n        if type(obj) == types.ModuleType:\n            return self.loadTestsFromModule(obj)\n        elif (isinstance(obj, (type, types.ClassType)) and\n              issubclass(obj, TestCase)):\n            return self.loadTestsFromTestCase(obj)\n        elif (type(obj) == types.UnboundMethodType and\n              isinstance(parent, (type, types.ClassType)) and\n              issubclass(parent, TestCase)):\n            return TestSuite([parent(obj.__name__)])\n        elif isinstance(obj, TestSuite):\n            return obj\n        elif hasattr(obj, \'__call__\'):\n            test = obj()\n            if isinstance(test, TestSuite):\n                return test\n            elif isinstance(test, TestCase):\n                return TestSuite([test])\n            else:\n                raise TypeError("calling %s returned %s, not a test" %\n                                (obj, test))\n        else:\n            raise TypeError("don\'t know how to make test from: %s" % obj)\n\n    def loadTestsFromNames(self, names, module=None):\n        """Return a suite of all tests cases found using the given sequence\n        of string specifiers. See \'loadTestsFromName()\'.\n        """\n        suites = [self.loadTestsFromName(name, module) for name in names]\n        return self.suiteClass(suites)\n\n    def getTestCaseNames(self, testCaseClass):\n        """Return a sorted sequence of method names found within testCaseClass\n        """\n        def isTestMethod(attrname, testCaseClass=testCaseClass, prefix=self.testMethodPrefix):\n            return attrname.startswith(prefix) and hasattr(getattr(testCaseClass, attrname), \'__call__\')\n        testFnNames = filter(isTestMethod, dir(testCaseClass))\n        if self.sortTestMethodsUsing:\n            testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))\n        return testFnNames\n\n\n\ndefaultTestLoader = TestLoader()\n\n\n##############################################################################\n# Patches for old functions: these functions should be considered obsolete\n##############################################################################\n\ndef _makeLoader(prefix, sortUsing, suiteClass=None):\n    loader = TestLoader()\n    loader.sortTestMethodsUsing = sortUsing\n    loader.testMethodPrefix = prefix\n    if suiteClass: loader.suiteClass = suiteClass\n    return loader\n\ndef getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):\n    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)\n\ndef makeSuite(testCaseClass, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)\n\ndef findTestCases(module, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)\n\n\n##############################################################################\n# Text UI\n##############################################################################\n\nclass _WritelnDecorator:\n    """Used to decorate file-like objects with a handy \'writeln\' method"""\n    def __init__(self,stream):\n        self.stream = stream\n\n    def __getattr__(self, attr):\n        return getattr(self.stream,attr)\n\n    def writeln(self, arg=None):\n        if arg: self.write(arg)\n        self.write(\'\\n\') # text-mode streams translate to \\r\\n if needed\n\n\nclass _TextTestResult(TestResult):\n    """A test result class that can print formatted text results to a stream.\n\n    Used by TextTestRunner.\n    """\n    separator1 = \'=\' * 70\n    separator2 = \'-\' * 70\n\n    def __init__(self, stream, descriptions, verbosity):\n        TestResult.__init__(self)\n        self.stream = stream\n        self.showAll = verbosity > 1\n        self.dots = verbosity == 1\n        self.descriptions = descriptions\n\n    def getDescription(self, test):\n        if self.descriptions:\n            return test.shortDescription() or str(test)\n        else:\n            return str(test)\n\n    def startTest(self, test):\n        TestResult.startTest(self, test)\n        if self.showAll:\n            self.stream.write(self.getDescription(test))\n            self.stream.write(" ... ")\n            self.stream.flush()\n\n    def addSuccess(self, test):\n        TestResult.addSuccess(self, test)\n        if self.showAll:\n            self.stream.writeln("ok")\n        elif self.dots:\n            self.stream.write(\'.\')\n            self.stream.flush()\n\n    def addError(self, test, err):\n        TestResult.addError(self, test, err)\n        if self.showAll:\n            self.stream.writeln("ERROR")\n        elif self.dots:\n            self.stream.write(\'E\')\n            self.stream.flush()\n\n    def addFailure(self, test, err):\n        TestResult.addFailure(self, test, err)\n        if self.showAll:\n            self.stream.writeln("FAIL")\n        elif self.dots:\n            self.stream.write(\'F\')\n            self.stream.flush()\n\n    def printErrors(self):\n        if self.dots or self.showAll:\n            self.stream.writeln()\n        self.printErrorList(\'ERROR\', self.errors)\n        self.printErrorList(\'FAIL\', self.failures)\n\n    def printErrorList(self, flavour, errors):\n        for test, err in errors:\n            self.stream.writeln(self.separator1)\n            self.stream.writeln("%s: %s" % (flavour,self.getDescription(test)))\n            self.stream.writeln(self.separator2)\n            self.stream.writeln("%s" % err)\n\n\nclass TextTestRunner:\n    """A test runner class that displays results in textual form.\n\n    It prints out the names of tests as they are run, errors as they\n    occur, and a summary of the results at the end of the test run.\n    """\n    def __init__(self, stream=sys.stderr, descriptions=1, verbosity=1):\n        self.stream = _WritelnDecorator(stream)\n        self.descriptions = descriptions\n        self.verbosity = verbosity\n\n    def _makeResult(self):\n        return _TextTestResult(self.stream, self.descriptions, self.verbosity)\n\n    def run(self, test):\n        "Run the given test case or test suite."\n        result = self._makeResult()\n        startTime = time.time()\n        test(result)\n        stopTime = time.time()\n        timeTaken = stopTime - startTime\n        result.printErrors()\n        self.stream.writeln(result.separator2)\n        run = result.testsRun\n        self.stream.writeln("Ran %d test%s in %.3fs" %\n                            (run, run != 1 and "s" or "", timeTaken))\n        self.stream.writeln()\n        if not result.wasSuccessful():\n            self.stream.write("FAILED (")\n            failed, errored = map(len, (result.failures, result.errors))\n            if failed:\n                self.stream.write("failures=%d" % failed)\n            if errored:\n                if failed: self.stream.write(", ")\n                self.stream.write("errors=%d" % errored)\n            self.stream.writeln(")")\n        else:\n            self.stream.writeln("OK")\n        return result\n\n\n\n##############################################################################\n# Facilities for running tests from the command line\n##############################################################################\n\nclass TestProgram:\n    """A command-line program that runs a set of tests; this is primarily\n       for making test modules conveniently executable.\n    """\n    USAGE = """\\\nUsage: %(progName)s [options] [test] [...]\n\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n\nExamples:\n  %(progName)s                               - run default set of tests\n  %(progName)s MyTestSuite                   - run suite \'MyTestSuite\'\n  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething\n  %(progName)s MyTestCase                    - run all \'test*\' test methods\n                                               in MyTestCase\n"""\n    def __init__(self, module=\'__main__\', defaultTest=None,\n                 argv=None, testRunner=None,\n                 testLoader=defaultTestLoader):\n        if type(module) == type(\'\'):\n            self.module = __import__(module)\n            for part in module.split(\'.\')[1:]:\n                self.module = getattr(self.module, part)\n        else:\n            self.module = module\n        if argv is None:\n            argv = sys.argv\n        self.verbosity = 1\n        self.defaultTest = defaultTest\n        self.testRunner = testRunner\n        self.testLoader = testLoader\n        self.progName = os.path.basename(argv[0])\n        self.parseArgs(argv)\n        self.runTests()\n\n    def usageExit(self, msg=None):\n        if msg: print msg\n        print self.USAGE % self.__dict__\n        sys.exit(2)\n\n    def parseArgs(self, argv):\n        import getopt\n        try:\n            options, args = getopt.getopt(argv[1:], \'hHvq\',\n                                          [\'help\',\'verbose\',\'quiet\'])\n            for opt, value in options:\n                if opt in (\'-h\',\'-H\',\'--help\'):\n                    self.usageExit()\n                if opt in (\'-q\',\'--quiet\'):\n                    self.verbosity = 0\n                if opt in (\'-v\',\'--verbose\'):\n                    self.verbosity = 2\n            if len(args) == 0 and self.defaultTest is None:\n                self.test = self.testLoader.loadTestsFromModule(self.module)\n                return\n            if len(args) > 0:\n                self.testNames = args\n            else:\n                self.testNames = (self.defaultTest,)\n            self.createTests()\n        except getopt.error, msg:\n            self.usageExit(msg)\n\n    def createTests(self):\n        self.test = self.testLoader.loadTestsFromNames(self.testNames,\n                                                       self.module)\n\n    def runTests(self):\n        if self.testRunner is None:\n            self.testRunner = TextTestRunner\n\n        if isinstance(self.testRunner, (type, types.ClassType)):\n            try:\n                testRunner = self.testRunner(verbosity=self.verbosity)\n            except TypeError:\n                # didn\'t accept the verbosity argument\n                testRunner = self.testRunner()\n        else:\n            # it is assumed to be a TestRunner instance\n            testRunner = self.testRunner\n        result = testRunner.run(self.test)\n        sys.exit(not result.wasSuccessful())\n\nmain = TestProgram\n\n\n##############################################################################\n# Executing this module from the command line\n##############################################################################\n\nif __name__ == "__main__":\n    main(module=None)\n',
    'src/lib/pythonds/graphs/__init__.py': '\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n',
    'src/lib/workbench/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineWorkbench(mod);\n  return mod;\n}\n',
    'src/lib/pythonds/graphs/priorityQueue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,\'x\'))\n        self.theHeap.add((3,\'y\'))\n        self.theHeap.add((5,\'z\'))\n        self.theHeap.add((6,\'a\'))\n        self.theHeap.add((4,\'d\'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == \'x\'\n        assert self.theHeap.delMin() == \'y\'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey(\'d\',1)\n        assert self.theHeap.delMin() == \'d\'\n        \nif __name__ == \'__main__\':\n    unittest.main()\n',
    'src/lib/pythonds/__init__.py': '',
    'src/lib/cmath/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineComplex(mod, "complex");\n  return mod;\n};\n',
    'src/lib/pythonds/basic/deque.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#deque.py\r\n\r\n\r\nclass Deque:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def addFront(self, item):\r\n        self.items.append(item)\r\n\r\n    def addRear(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def removeFront(self):\r\n        return self.items.pop()\r\n\r\n    def removeRear(self):\r\n        return self.items.pop(0)\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/lorentz/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineLorentzian(mod, BLADE);\n  return mod;\n}\n',
    'src/lib/processing/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n    var imList = [];\n    var looping = true;\n\n    // We need this to store a reference to the actual processing object which is not created\n    // until the run function is called.  Even then the processing object is passed by the\n    // processing-js sytem as a parameter to the sketchProc function.  Why not set it to None here\n    //\n\n    // See:  http://processingjs.org/reference/\n\n    mod.processing = null\n    mod.p = null\n\n    mod.CENTER = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.RADIUS = Sk.builtin.assk$(2, Sk.builtin.nmber.int$);\n    mod.CORNERS = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.CORNER = Sk.builtin.assk$(0, Sk.builtin.nmber.int$);\n    mod.RGB = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.HSB = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.CMYK = Sk.builtin.assk$(5, Sk.builtin.nmber.int$);\n    mod.MITER = new Sk.builtin.str(\'miter\');\n    mod.BEVEL = new Sk.builtin.str(\'bevel\');\n    mod.ROUND = new Sk.builtin.str(\'round\');\n    mod.SQUARE = new Sk.builtin.str(\'butt\');\n    mod.PROJECT = new Sk.builtin.str(\'square\');\n\n// 2D - Primitives\n    mod.line = new Sk.builtin.func(function(x1, y1, x2, y2) {\n        mod.processing.line(x1.v, y1.v, x2.v, y2.v);\n    });\n    \n    mod.ellipse = new Sk.builtin.func(function(x,y,r1,r2) {\n        mod.processing.ellipse(x.v,y.v,r1.v,r2.v)\n        \n    });\n\n    mod.point = new Sk.builtin.func(function(x1,y1) {\n        mod.processing.point(x1.v,y1.v)\n    });\n        \n    mod.arc = new Sk.builtin.func(function(x, y, width, height, start, stop) {\n        mod.processing.arc(x.v, y.v, width.v, height.v, start.v, stop.v)\n    });\n\n    mod.quad = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3, x4, y4) {\n        mod.processing.quad(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v, x4.v, y4.v)\n    });\n            \n    mod.rect = new Sk.builtin.func(function(x, y, width, height, radius) {\n        if (typeof(radius) == \'undefined\') {\n            var rad = 0\n        } else {\n            var rad = radius.v\n        }\n        mod.processing.rect(x.v, y.v, width.v, height.v, rad)\n    });\n    \n    mod.triangle = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3) {\n            mod.processing.triangle(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v)\n        });\n            \n\n    // 3D Primitives\n\n    // todo:  box, sphere, sphereDetail\n\n    // Color\n    mod.background = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.background(r.v,g,b)\n        \n    });\n\n    mod.fill = new Sk.builtin.func(function(r,g,b) {\n        // r will be either:\n        //      a number in which case the fill will be grayscale\n        //      a color object\n        // g, and b may be undefined.  If they hold values it will\n        // be assumed that we have an r,g,b color tuple\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n    \n        mod.processing.fill(r.v,g,b)\n        \n    });\n\n\n    mod.stroke = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.stroke(r.v,g,b)\n        \n    });\n\n    mod.noStroke = new Sk.builtin.func(function() {\n        mod.processing.noStroke()\n    });\n    \n\n    mod.colorMode = new Sk.builtin.func(function(model, maxV) {\n        if (typeof(maxV) === \'undefined\')\n            maxV = 255\n        else\n            maxV = maxV.v\n        mod.processing.colorMode(model.v, maxV)\n    });\n\n    mod.noFill = new Sk.builtin.func(function() {\n            mod.processing.noFill()\n        });\n            \n\n    // Environment\n\n    mod.loop = new Sk.builtin.func(function() {\n            if (mod.processing === null) {\n                throw new Sk.builtin.Exception("Loop should be called in setup")\n            }\n            looping = true;\n            mod.processing.loop()\n        });\n            \n    mod.noLoop = new Sk.builtin.func(function() {\n        if (mod.processing === null) {\n            throw new Sk.builtin.Exception("noLoop should be called in setup")\n        }\n        looping = false;\n        mod.processing.noLoop()\n    });\n    \n    mod.frameRate = new Sk.builtin.func(function(fr) {\n        mod.processing.frameRate(fr.v)\n        \n    });\n\n    mod.size = new Sk.builtin.func(function(h,w) {\n        mod.processing.size(h.v,w.v)\n        \n    });\n\n    mod.exitp = new Sk.builtin.func(function(h,w) {\n        mod.processing.exit()\n    });\n\n\n    mod.mouseX = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseX, Sk.builtin.nmber.int$);\n        \n    });\n\n    mod.mouseY = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseY, Sk.builtin.nmber.int$);\n        \n    });\n\n    // Attributes\n    mod.rectMode = new Sk.builtin.func(function(mode) {\n        mod.processing.rectMode(mode.v)\n    });\n\n    mod.strokeWeight = new Sk.builtin.func(function(wt) {\n        mod.processing.strokeWeight(wt.v)\n        \n    });\n\n    mod.smooth = new Sk.builtin.func(function() {\n        mod.processing.smooth()\n    });\n\n    mod.noSmooth = new Sk.builtin.func(function() {\n        mod.processing.noSmooth()\n        });\n            \n    mod.ellipseMode = new Sk.builtin.func(function(mode) {\n        mod.processing.ellipseMode(mode.v)\n        });\n\n    mod.strokeCap = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeCap(mode.v)\n        });\n\n    mod.strokeJoin = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeJoin(mode.v)\n    });\n    \n\n\n    // Transforms\n\n    mod.rotate = new Sk.builtin.func(function(rads) {\n        // rotation in radians\n        mod.processing.rotate(rads.v)\n        \n    });\n\n    mod.scale = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.scale(sx.v, sy, sz)\n    });\n\n    mod.translate = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.translate(sx.v, sy, sz)\n    });\n\n    // todo:  applyMatrix, popMatrix, printMatrix??, pushMatrix, resetMatrix, rotate{X,Y,Z}\n    \n\n    //  //////////////////////////////////////////////////////////////////////\n    //  Run\n    // \n    //  Create the processing context and setup of calls to setup, draw etc.\n    //\n    //\n    //  //////////////////////////////////////////////////////////////////////    \n    mod.run = new Sk.builtin.func(function() {\n        function sketchProc(processing) {\n            mod.processing = processing\n\n            // processing.setup = function() {\n            //     if Sk.globals[\'setup\']\n            //         Sk.misceval.callsim(Sk.globals[\'setup\'])\n            // }\n\n            \n            processing.draw = function() {\n                // if there are pending image loads then just use the natural looping calls to \n                // retry until all the images are loaded.  If noLoop was called in setup then make\n                // sure to revert to that after all the images in hand.\n                var wait = false\n                for (var i in imList) {\n                    if (imList[i].width == 0) {\n                        wait = true\n                    }\n                }\n                if (wait == true) {\n                    if (looping == true) \n                        return\n                    else {\n                        processing.loop()\n                        return\n                    }\n\n                } else {\n                    if (looping == false)\n                        processing.noLoop()\n                }\n\n                mod.frameCount = processing.frameCount  \n                if (Sk.globals[\'draw\'])\n                    Sk.misceval.callsim(Sk.globals[\'draw\'])\n            }\n            \n            var callBacks = [\'setup\', \'mouseMoved\',\'mouseClicked\', \'mouseDragged\', \'mouseMoved\', \'mouseOut\',\n             \'mouseOver\', \'mousePressed\', \'mouseReleased\', \'keyPressed\', \'keyReleased\', \'keyTyped\'\n             ];\n\n             for(var cb in callBacks) {\n                if (Sk.globals[callBacks[cb]]) {\n                    console.log(\'defining \' + callBacks[cb])                    \n                    processing[callBacks[cb]] = new Function("Sk.misceval.callsim(Sk.globals[\'"+callBacks[cb]+"\']);")\n                }\n            }\n        }\n        \n        var canvas = document.getElementById(Sk.canvas)\n        $(canvas).show()\n        mod.p = new Processing(canvas, sketchProc)\n\n        \n    });\n\n    var mouseClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'x\') \n                return mod.processing.mouseX;\n            else if (key == \'y\') \n                return mod.processing.mouseY;\n            else if (key == \'px\')\n                return mod.processing.pmouseX;\n            else if (key == \'py\')\n                return mod.processing.pmouseY;\n            else if (key == \'pressed\')\n                return mod.processing.mousePressed;\n            else if (key == \'button\')\n                return mod.processing.mouseButton\n        });\n\n\n    }\n\n\n    mod.Mouse = Sk.misceval.buildClass(mod, mouseClass, \'Mouse\', []);\n\n    mod.mouse = Sk.misceval.callsim(mod.Mouse)\n\n    var keyboardClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'key\') {\n                console.log(mod.processing.key)\n                return new Sk.builtin.str(mod.processing.key.toString())\n            }\n            else if (key == \'keyCode\') \n                return mod.processing.keyCode\n            else if (key == \'keyPressed\')\n                return new Sk.builtin.str(mod.processing.keyPressed) // todo bool\n        });\n\n\n    }\n\n    mod.Keyboard = Sk.misceval.buildClass(mod,keyboardClass,\'Keyboard\', [])\n\n    mod.keyboard = Sk.misceval.callsim(mod.Keyboard)\n\n\n\n    var environmentClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'frameCount\') \n                return mod.processing.frameCount\n            else if (key == \'frameRate\') \n                return mod.processing.frameRate\n            else if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'online\')\n                return mod.processing.online\n            else if (key == \'focused\')\n                return mod.processing.focused\n        });\n\n\n    }\n\n    mod.Environment = Sk.misceval.buildClass(mod,environmentClass,\'Environment\', [])\n\n    mod.environment = Sk.misceval.callsim(mod.Environment)\n\n    var screenClass = function($gbl, $loc) {\n\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            self.pixels = null;\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'pixels\')\n                if (self.pixels == null) {\n                    self.pixels = new Sk.builtin.list(mod.processing.pixels.toArray())\n                }\n                return self.pixels\n        });\n\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod,screenClass,\'Screen\', [])\n\n    mod.screen = Sk.misceval.callsim(mod.Screen)\n\n    mod.loadPixels = new Sk.builtin.func(function() {\n        mod.processing.loadPixels()\n        console.log(mod.processing.pixels)\n    });\n    \n\n    var colorClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self, val1, val2, val3, alpha) {\n            if (typeof(val2) !== \'undefined\')\n                val2 = val2.v\n            if (typeof(val3) !== \'undefined\')\n                val3 = val3.v\n            if (typeof(alpha) !== \'undefined\')\n                alpha = alpha.v\n            self.v = mod.processing.color(val1.v, val2, val3, alpha)\n        })\n    \n    }\n\n    mod.color = Sk.misceval.buildClass(mod,colorClass,\'color\', [])\n\n    mod.red = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.red(clr.v), Sk.builtin.nmber.int$);\n    });\n    \n    mod.green = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.green(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    mod.blue = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.blue(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    // Image class and functions\n    //\n    var imageClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self,im) {\n            self.v = im\n            self.width = Sk.builtin.assk$(im.width, Sk.builtin.nmber.int$);\n            self.height = Sk.builtin.assk$(im.height, Sk.builtin.nmber.int$);\n        })\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'width\') return self.v.width;\n            if (key == \'height\') return self.v.height;\n        });\n    \n    }\n\n    mod.PImage = Sk.misceval.buildClass(mod,imageClass,\'PImage\', [])\n\n    mod.loadImage = new Sk.builtin.func(function(imfile) {\n        var i = mod.processing.loadImage(imfile.v);\n        imList.push(i);\n        return Sk.misceval.callsim(mod.PImage,i);\n    });\n    \n\n    mod.image = new Sk.builtin.func(function(im,x,y) {\n        if (im.v.width > 0)\n            mod.processing.image(im.v,x.v,y.v,im.v.width,im.v.height)\n    });\n\n    mod.get = new Sk.builtin.func(function(x,y) {\n        var clr = mod.processing.get(x.v,y.v)\n        return Sk.misceval.callsim(mod.color,\n            Sk.builtin.assk$(mod.processing.red(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.green(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.blue(clr), Sk.builtin.nmber.int$));\n    });\n\n    mod.set = new Sk.builtin.func(function(x, y, color) {\n        mod.processing.set(x.v, y.v, color.v)\n    });\n    \n// todo  -- add a color class for creating color objects.\n\n\n    return mod;\n}\n',
    'src/lib/webgl/models.js': '// most of this file is from/based on \'tdl\'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var Buffer = function(array, opt_target) {\n        var target = opt_target || gl.ARRAY_BUFFER;\n        var buf = gl.createBuffer();\n        this.target = target;\n        this.buf = buf;\n        this.set(array);\n        this.numComponents_ = array.numComponents;\n        this.numElements_ = array.numElements;\n        this.totalComponents_ = this.numComponents_ * this.numElements_;\n        if (array.buffer instanceof Float32Array) {\n            this.type_ = gl.FLOAT;\n        } else if (array.buffer instanceof Uint8Array) {\n            this.type_ = gl.UNSIGNED_BYTE;\n        } else if (array.buffer instanceof Int8Array) {\n            this.type_ = gl._BYTE;\n        } else if (array.buffer instanceof Uint16Array) {\n            this.type_ = gl.UNSIGNED_SHORT;\n        } else if (array.buffer instanceof Int16Array) {\n            this.type_ = gl.SHORT;\n        } else {\n            throw("unhandled type:" + (typeof array.buffer));\n        }\n    };\n\n    Buffer.prototype.set = function(array) {\n        gl.bindBuffer(this.target, this.buf);\n        gl.bufferData(this.target, array.buffer, gl.STATIC_DRAW);\n    }\n\n    Buffer.prototype.type = function() {\n        return this.type_;\n    };\n\n    Buffer.prototype.numComponents = function() {\n        return this.numComponents_;\n    };\n\n    Buffer.prototype.numElements = function() {\n        return this.numElements_;\n    };\n\n    Buffer.prototype.totalComponents = function() {\n        return this.totalComponents_;\n    };\n\n    Buffer.prototype.buffer = function() {\n        return this.buf;\n    };\n\n    Buffer.prototype.stride = function() {\n        return 0;\n    };\n\n    Buffer.prototype.offset = function() {\n        return 0;\n    };\n\n\n\n    mod.Model = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, shader, arrays, textures)\n                    {\n                        self.buffers = {};\n                        var setBuffer = function(name, array)\n                        {\n                            var target = (name == \'indices\') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n                            b = self.buffers[name];\n                            if (!b)\n                                b = new Buffer(array, target);\n                            else\n                                b.set(array);\n                            self.buffers[name] = b;\n                        };\n                        for (name in arrays)\n                            setBuffer(name, arrays[name]);\n\n                        var textureUnits = {};\n                        var unit = 0;\n                        for (var texture in textures)\n                        {\n                            textureUnits[texture] = unit++;\n                        }\n\n                        self.mode = gl.TRIANGLES;\n                        self.textures = textures.v;\n                        self.textureUnits = textureUnits;\n                        self.shader = shader;\n                    });\n\n                /**\n                * Sets up the shared parts of drawing this model. Uses the\n                * program, binds the buffers, sets the textures.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.drawPrep = new Sk.builtin.func(function(self, uniforms)\n                    {\n                        var shader = self.shader;\n                        var buffers = self.buffers;\n                        var textures = self.textures;\n\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n\n                        Sk.misceval.callsim(shader.use, shader);\n\n                        for (var buffer in buffers) {\n                            var b = buffers[buffer];\n                            if (buffer == \'indices\') {\n                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.buffer());\n                            } else {\n                                var attrib = shader.attrib[buffer];\n                                if (attrib) {\n                                    attrib(b);\n                                }\n                            }\n                        }\n\n                        for (var texture in textures) {\n                            var unit = self.textureUnits[texture];\n                            shader.setUniform$impl(shader, textuer, unit);\n                            textures[texture].bindToUnit(unit);\n                        }\n\n                        for (var uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n                    });\n\n                /**\n                * Draws this model.\n                *\n                * After calling tdl.models.Model.drawPrep you can call this\n                * function multiple times to draw this model.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.draw = new Sk.builtin.func(function(self, uniforms, opt_textures)\n                    {\n                        var shader = self.shader;\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n                        for (uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n\n                        if (opt_textures) {\n                            for (var texture in opt_textures) {\n                                var unit = self.textureUnits[texture];\n                                shader.setUniform$impl(shader, texture, unit);\n                                opt_textures[texture].bindToUnit(unit);\n                            }\n                        }\n\n                        var buffers = self.buffers;\n                        gl.drawElements(self.mode, buffers.indices.totalComponents(), gl.UNSIGNED_SHORT, 0);\n                    });\n            },\n            \'Model\', []);\n\n    return mod;\n};\n',
    'src/lib/pythonds/trees/__init__.py': '\n# from .binaryTree import BinaryTree\n# from .balance import AVLTree\n# from .bst import BinarySearchTree\n# from .binheap import BinHeap\n\n\n',
    'src/lib/pythonds/trees/binaryTree.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    """\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    """    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print(\'(\')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(\')\')\n\n    def postordereval(self):\n        opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print(\'(\')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(\')\') \n\ndef printexp(tree):\n    sVal = ""\n    if tree:\n        sVal = \'(\' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + \')\'\n    return sVal\n\ndef postordereval(tree):\n    opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree(\'*\')\n# x.insertLeft(\'+\')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n',
    'src/lib/math/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineMath(mod);\n  return mod;\n};',
    'src/lib/e3ga/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEuclidean3(mod, THREE, BLADE);\n  return mod;\n}\n',
    'src/lib/webgl/primitives.js': '// most of this file is from \'tdl\'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n\n\n    /**\n     * AttribBuffer manages a TypedArray as an array of vectors.\n     *\n     * @param {number} numComponents Number of components per\n     *     vector.\n     * @param {number|!Array.<number>} numElements Number of vectors or the data.\n     * @param {string} opt_type The type of the TypedArray to\n     *     create. Default = \'Float32Array\'.\n     * @param {!Array.<number>} opt_data The data for the array.\n     */\n    var AttribBuffer = function(\n            numComponents, numElements, opt_type) {\n        opt_type = opt_type || \'Float32Array\';\n        var type = window[opt_type];\n        if (numElements.length) {\n            this.buffer = new type(numElements);\n            numElements = this.buffer.length / numComponents;\n            this.cursor = numElements;\n        } else {\n            this.buffer = new type(numComponents * numElements);\n            this.cursor = 0;\n        }\n        this.numComponents = numComponents;\n        this.numElements = numElements;\n        this.type = opt_type;\n    };\n\n    AttribBuffer.prototype.stride = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.offset = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.getElement = function(index) {\n        var offset = index * this.numComponents;\n        var value = [];\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            value.push(this.buffer[offset + ii]);\n        }\n        return value;\n    };\n\n    AttribBuffer.prototype.setElement = function(index, value) {\n        var offset = index * this.numComponents;\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            this.buffer[offset + ii] = value[ii];\n        }\n    };\n\n    AttribBuffer.prototype.clone = function() {\n        var copy = new AttribBuffer(\n                this.numComponents, this.numElements, this.type);\n        copy.pushArray(this);\n        return copy;\n    }\n\n    AttribBuffer.prototype.push = function(value) {\n        this.setElement(this.cursor++, value);\n    };\n\n    AttribBuffer.prototype.pushArray = function(array) {\n        //  this.buffer.set(array, this.cursor * this.numComponents);\n        //  this.cursor += array.numElements;\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            this.push(array.getElement(ii));\n        }\n    };\n\n    AttribBuffer.prototype.pushArrayWithOffset =\n    function(array, offset) {\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            var elem = array.getElement(ii);\n            for (var jj = 0; jj < offset.length; ++jj) {\n                elem[jj] += offset[jj];\n            }\n            this.push(elem);\n        }\n    };\n\n    /**\n    * Computes the extents\n    * @param {!AttribBuffer} positions The positions\n    * @return {!{min: !tdl.math.Vector3, max:!tdl.math.Vector3}}\n    *     The min and max extents.\n    */\n    AttribBuffer.prototype.computeExtents = function() {\n        var numElements = this.numElements;\n        var numComponents = this.numComponents;\n        var minExtent = this.getElement(0);\n        var maxExtent = this.getElement(0);\n        for (var ii = 1; ii < numElements; ++ii) {\n            var element = this.getElement(ii);\n            for (var jj = 0; jj < numComponents; ++jj) {\n                minExtent[jj] = Math.min(minExtent[jj], element[jj]);\n                maxExtent[jj] = Math.max(maxExtent[jj], element[jj]);\n            }\n        }\n        return {min: minExtent, max: maxExtent};\n    };\n\n\n    /**\n     * Creates the vertices and indices for a cube. The\n     * cube will be created around the origin. (-size / 2, size / 2)\n     *\n     * @param {number} size Width, height and depth of the cube.\n     * @return {!Object.<string, !tdl.primitives.AttribBuffer>} The\n     *         created plane vertices.\n     */\n    mod.createCube = new Sk.builtin.func(function(size)\n            {\n                var CUBE_FACE_INDICES_ = [\n                    [3, 7, 5, 1],\n                    [0, 4, 6, 2],\n                    [6, 7, 3, 2],\n                    [0, 1, 5, 4],\n                    [5, 7, 6, 4],\n                    [2, 3, 1, 0]\n                ];\n\n                var k = size / 2;\n\n                var cornerVertices = [\n                        [-k, -k, -k],\n                        [+k, -k, -k],\n                        [-k, +k, -k],\n                        [+k, +k, -k],\n                        [-k, -k, +k],\n                        [+k, -k, +k],\n                        [-k, +k, +k],\n                        [+k, +k, +k]\n                    ];\n\n                var faceNormals = [\n                        [+1, +0, +0],\n                        [-1, +0, +0],\n                        [+0, +1, +0],\n                        [+0, -1, +0],\n                        [+0, +0, +1],\n                        [+0, +0, -1]\n                    ];\n\n                var uvCoords = [\n                        [0, 0],\n                        [1, 0],\n                        [1, 1],\n                        [0, 1]\n                    ];\n\n                var numVertices = 6 * 4;\n                var positions = new AttribBuffer(3, numVertices);\n                var normals = new AttribBuffer(3, numVertices);\n                var texCoords = new AttribBuffer(2, numVertices);\n                var indices = new AttribBuffer(3, 6 * 2, \'Uint16Array\');\n\n                for (var f = 0; f < 6; ++f) {\n                    var faceIndices = CUBE_FACE_INDICES_[f];\n                    for (var v = 0; v < 4; ++v) {\n                        var position = cornerVertices[faceIndices[v]];\n                        var normal = faceNormals[f];\n                        var uv = uvCoords[v];\n\n                        // Each face needs all four vertices because the normals and texture\n                        // coordinates are not all the same.\n                        positions.push(position);\n                        normals.push(normal);\n                        texCoords.push(uv);\n\n                    }\n                    // Two triangles make a square face.\n                    var offset = 4 * f;\n                    indices.push([offset + 0, offset + 1, offset + 2]);\n                    indices.push([offset + 0, offset + 2, offset + 3]);\n                }\n\n                return {\n                        position: positions,\n                        normal: normals,\n                        texCoord: texCoords,\n                        indices: indices\n                };\n            });\n\n    return mod;\n};\n',
    'src/lib/document/__init__.js': 'var $builtinmodule = function(name) {\n    var mod = {};\n\n    mod.getElementById = new Sk.builtin.func(function(id) {\n        var result = document.getElementById(id.v);\n        if (result) {\n            return Sk.misceval.callsim(mod.Element,result);\n        }\n        return Sk.builtin.none.none$;\n    });\n\n    mod.createElement = new Sk.builtin.func(function(eName) {\n            var r = document.createElement(eName.v);\n            if (r) {\n                return Sk.misceval.callsim(mod.Element,r);\n            }\n        });\n\n\n    mod.getElementsByTagName = new Sk.builtin.func(function(tag) {\n        var r = document.getElementsByTagName(tag.v)\n        var reslist = [];\n        for (var i = r.length - 1; i >= 0; i--) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]))\n        }\n        return new Sk.builtin.list(reslist)\n    });\n\n    mod.getElementsByClassName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByClassName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n    \n    mod.getElementsByName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n        \n    mod.currentDiv = new Sk.builtin.func(function() {\n        if (Sk.divid !== undefined) {\n            return new Sk.builtin.str(Sk.divid)\n        }\n        else {\n            throw new Sk.builtin.AttributeError("There is no value set for divid");\n        }\n    })\n    var elementClass = function($gbl, $loc) {\n        /*\n            Notes:  self[\'$d\'] is the dictionary used by the GenericGetAttr mechanism for an object.\n                    for various reasons  if you create a class in Javascript and have self.xxxx instance\n                    variables, you cannot say instance.xxx and get the value of the instance variable unless \n                    it is stored in the self[\'$d\'] object.  This seems like a duplication of storage to me\n                    but that is how it works right now  (5/2013)\n\n                    Writing your own __getattr__ is also an option but this gets very tricky when an attr is \n                    a method...\n        */\n        $loc.__init__ = new Sk.builtin.func(function(self,elem) {\n            self.v = elem\n            self.innerHTML = elem.innerHTML\n            self.innerText = elem.innerText\n            if (elem.value !== undefined) {\n                self.value = elem.value\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'value\'), new Sk.builtin.str(self.value))                \n            }\n\n            if (elem.checked !== undefined) {\n                self.checked = elem.checked\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'checked\'), new Sk.builtin.str(self.checked))                \n            }\n\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerHTML\'), new Sk.builtin.str(self.innerHTML))\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerText\'), new Sk.builtin.str(self.innerText))            \n\n        })\n\n        $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n        $loc.__setattr__ = new Sk.builtin.func(function(self,key,value) {\n            if (key === \'innerHTML\') {\n                self.innerHTML = value\n                self.v.innerHTML = value.v\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerHTML\'), value)                \n            }\n            if (key === \'innerText\') {\n                self.innerText = value\n                self.v.innerText = value.v\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerText\'), value)            \n            }\n        });\n\n\n        $loc.appendChild = new Sk.builtin.func(function(self,ch) {\n            self.v.appendChild(ch.v);\n        });\n\n        $loc.removeChild = new Sk.builtin.func(function(self,node) {\n            self.v.removeChild(node.v)\n        })\n\n        // getCSS\n                    \n        $loc.getCSS = new Sk.builtin.func(function(self,key) {\n            return new Sk.builtin.str(self.v.style[key.v]);\n        });\n    \n\n        $loc.setCSS = new Sk.builtin.func(function(self,attr,value) {\n            self.v.style[attr.v] = value.v\n\n        })\n\n        $loc.getAttribute = new Sk.builtin.func(function(self,key) {\n            var res = self.v.getAttribute(key.v)\n            if (res) {\n                return new Sk.builtin.str(res)\n            } else {\n                return Sk.builtin.none.none$;\n            }\n        });\n\n        $loc.setAttribute = new Sk.builtin.func(function(self,attr,value) {\n                self.v.setAttribute(attr.v,value.v)\n        });\n            \n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            console.log(self.v.tagName);\n            return new Sk.builtin.str(self.v.tagName)\n        })\n\n        $loc.__repr__ = new Sk.builtin.func(function(self) {\n            return new Sk.builtin.str(\'[DOM Element]\')\n        })\n\n    \n    };\n\n    mod.Element = Sk.misceval.buildClass(mod,elementClass,\'Element\', []);\n\n    return mod;\n\n}   ',
    'src/lib/re/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // Constants (mostly unsupported)\n    mod.I = 2;\n    mod.IGNORECASE = 2;\n    // mod.L = 4;\n    // mod.LOCALE = 4;\n    mod.M = 8;\n    mod.MULTILINE = 8;\n    // mod.S = 16;\n    // mod.DOTALL = 16;\n    // mod.U = 32;\n    // mod.UNICODE = 32;\n    // mod.X = 64;\n    // mod.VERBOSE = 64;\n\n    var validGroups = ["(?:", "(?=", "(?!"];\n\n    var convert = function(pattern) {\n        var newpattern;\n        var match;\n        var i;\n\n        // Look for disallowed constructs\n        match = pattern.match(/\\(\\?./g);\n        if (match) {\n            for (i=0; i<match.length; i++) {\n                if (validGroups.indexOf(match[i]) == -1) {\n                    throw new Sk.builtin.ValueError("Disallowed group in pattern: \'"\n                                                    + match[i] + "\'");\n                };\n            };\n        };\n\n        newpattern = pattern.replace(\'/\\\\/g\', \'\\\\\\\\\');\n        newpattern = pattern.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n\n        return newpattern;\n    };\n\n    var getFlags = function(flags) {\n        var jsflags = "g";\n        if ((flags & mod.IGNORECASE) == mod.IGNORECASE) {\n            jsflags += "i";\n        };\n        if ((flags & mod.MULTILINE) == mod.MULTILINE) {\n            jsflags += "m";\n        }; \n        return jsflags;\n    };\n\n    mod.split = Sk.nativejs.func(function split(pattern, string, maxsplit, flags) {\n        Sk.builtin.pyCheckArgs("split", arguments, 2, 4);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (maxsplit === undefined) {\n            maxsplit = 0;\n        };\n        if (!Sk.builtin.checkNumber(maxsplit)) {\n            throw new Sk.builtin.TypeError("maxsplit must be a number");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n\tmaxsplit = Sk.builtin.asnum$(maxsplit);\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var captured = !(pat.match(/^\\(.*\\)$/) === null);\n        //print("Captured: ", captured);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n        var result = [];\n        var match;\n        var index = 0;\n        var splits = 0;\n        while ((match = regex.exec(str)) != null) {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            if (match.index === regex.lastIndex) {\n                // empty match\n                break;\n            };\n            result.push(new Sk.builtin.str(str.substring(index, match.index)));\n            if (captured) {\n                // Add matching pattern, too\n                result.push(new Sk.builtin.str(match[0]));\n            };\n            index = regex.lastIndex;\n            splits += 1;\n            if (maxsplit && (splits >= maxsplit)) {\n                break;\n            };\n        };\n        result.push(new Sk.builtin.str(str.substring(index)));\n\n        return new Sk.builtin.list(result);\n    });\n\n    mod.findall = Sk.nativejs.func(function findall(pattern, string, flags) {\n        Sk.builtin.pyCheckArgs("findall", arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n\tvar newline_at_end = new RegExp(/\\n$/);\n\tif (str.match(newline_at_end)) {\n\t    str = str.slice(0,-1);\n\t}\n\n        var result = [];\n        var match;\n        while ((match = regex.exec(str)) != null) {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            // print("match: " + JSON.stringify(match));\n            if (match.length < 2) {\n                result.push(new Sk.builtin.str(match[0]));\n            } else if (match.length == 2) {\n                result.push(new Sk.builtin.str(match[1]));\n            } else {\n                var groups = [];\n                for (var i=1; i<match.length; i++) {\n                    groups.push(new Sk.builtin.str(match[i]));  \n                };\n                result.push(new Sk.builtin.tuple(groups));\n            };\n            if (match.index === regex.lastIndex) {\n                regex.lastIndex += 1;\n            };\n        };\n\n        return new Sk.builtin.list(result);\n    });\n\n\n    var matchobj = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,thematch, pattern, string) {\n            self.thematch = thematch;\n\t    self.re = pattern;\n\t    self.string = string;\n        });\n\n\t$loc.groups = new Sk.builtin.func(function(self) {\n\t    return new Sk.builtin.tuple(self.thematch.v.slice(1))\n\t});\n\n\t$loc.group = new Sk.builtin.func(function(self,grpnum) {\n\t    if (grpnum === undefined) {\n                grpnum = 0;\n            }\n            else {\n                grpnum = Sk.builtin.asnum$(grpnum);\n            }\n\t    if(grpnum >= self.thematch.v.length) {\n\t\tthrow new Sk.builtin.IndexError("Index out of range: " + grpnum);\n\t\t}\n\t    return self.thematch.v[grpnum]\n\t});\n\n    }\n\n    mod.MatchObject = Sk.misceval.buildClass(mod, matchobj, \'MatchObject\', []);\n\n    // Internal function to return a Python list of strings \n    // From a JS regular expression string\n    mod._findre = function(res, string) {\n\tres = res.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n        var re = eval(res);\n\tvar patt = new RegExp(\'\\n$\');\n\tif (string.v.match(patt))\n\t    var matches = string.v.slice(0,-1).match(re);\n\telse\n            var matches = string.v.match(re);\n        retval = new Sk.builtin.list();\n        if ( matches == null ) return retval;\n        for (var i = 0; i < matches.length; ++i) {\n            var sitem = new Sk.builtin.str(matches[i]);\n            retval.v.push(sitem);\n        }\n        return retval;\n    }\n\n    mod.search = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs(\'search\', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/"+pattern.v.replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    mod.match = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs(\'match\', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/^"+pattern.v.replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    return mod;\n}\n',
    'src/lib/urllib/__init__.js': 'var $builtinmodule = function(name)\n{\n  var urllib = {};\n\n  return urllib;\n};\n',
    'src/lib/random/__init__.js': '\n/*\n  I\'ve wrapped Makoto Matsumoto and Takuji Nishimura\'s code in a namespace\n  so it\'s better encapsulated. Now you can have multiple random number generators\n  and they won\'t stomp all over eachother\'s state.\n  \n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n  \n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n  \n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/* \n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n \n   Before using, initialize the state by using init_genrand(seed)  \n   or init_by_array(init_key, key_length).\n \n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.                          \n \n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n \n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n \n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n \n     3. The names of its contributors may not be used to endorse or promote \n        products derived from this software without specific prior written \n        permission.\n \n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n \n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n  if (seed == undefined) {\n    seed = new Date().getTime();\n  } \n  /* Period parameters */  \n  this.N = 624;\n  this.M = 397;\n  this.MATRIX_A = 0x9908b0df;   /* constant vector a */\n  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n \n  this.mt = new Array(this.N); /* the array for the state vector */\n  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n  this.init_genrand(seed);\n}  \n \n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function(s) {\n  this.mt[0] = s >>> 0;\n  for (this.mti=1; this.mti<this.N; this.mti++) {\n      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n  + this.mti;\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      this.mt[this.mti] >>>= 0;\n      /* for >32 bit machines */\n  }\n}\n \n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n  var i, j, k;\n  this.init_genrand(19650218);\n  i=1; j=0;\n  k = (this.N>key_length ? this.N : key_length);\n  for (; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n      + init_key[j] + j; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++; j++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n    if (j>=key_length) j=0;\n  }\n  for (k=this.N-1; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n      - i; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n  }\n\n  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */ \n}\n \n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function() {\n  var y;\n  var mag01 = new Array(0x0, this.MATRIX_A);\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (this.mti >= this.N) { /* generate N words at one time */\n    var kk;\n\n    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */\n      this.init_genrand(5489); /* a default initial seed is used */\n\n    for (kk=0;kk<this.N-this.M;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    for (;kk<this.N-1;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n    this.mti = 0;\n  }\n\n  y = this.mt[this.mti++];\n\n  /* Tempering */\n  y ^= (y >>> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >>> 18);\n\n  return y >>> 0;\n}\n \n/* generates a random number on [0,0x7fffffff]-interval */\nMersenneTwister.prototype.genrand_int31 = function() {\n  return (this.genrand_int32()>>>1);\n}\n \n/* generates a random number on [0,1]-real-interval */\nMersenneTwister.prototype.genrand_real1 = function() {\n  return this.genrand_int32()*(1.0/4294967295.0); \n  /* divided by 2^32-1 */ \n}\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n  return this.genrand_int32()*(1.0/4294967296.0); \n  /* divided by 2^32 */\n}\n \n/* generates a random number on (0,1)-real-interval */\nMersenneTwister.prototype.genrand_real3 = function() {\n  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0); \n  /* divided by 2^32 */\n}\n \n/* generates a random number on [0,1) with 53-bit resolution*/\nMersenneTwister.prototype.genrand_res53 = function() { \n  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6; \n  return(a*67108864.0+b)*(1.0/9007199254740992.0); \n} \n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n\n\nvar $builtinmodule = function(name)\n{\n\n    var mod = {};\n\n    var myGenerator = new MersenneTwister();\n\n    mod.seed = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("seed", arguments, 0, 1);\n\tx = Sk.builtin.asnum$(x);\n\n        if (arguments.length > 0)\n            myGenerator = new MersenneTwister(x);\n        else\n            myGenerator = new MersenneTwister();\n\n\treturn Sk.builtin.none.none$;\n    });\n\n    mod.random = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs("random", arguments, 0, 0);\n\n\treturn new Sk.builtin.nmber(myGenerator.genrand_res53(), Sk.builtin.nmber.float$);\n    });\n\n    var toInt = function(num) {\n        return num | 0;\n    };\n\n    var randrange = function(start, stop, step) {\n        // Ported from CPython 2.7\n        var width, n, ret;\n\n        if (!Sk.builtin.checkInt(start)) {\n            throw new Sk.builtin.ValueError("non-integer first argument for randrange()");\n        };\n\n        if (stop === undefined) {\n            // Random in [0, start)\n            return toInt(myGenerator.genrand_res53() * start);\n        };\n\n        if (!Sk.builtin.checkInt(stop)) {\n            throw new Sk.builtin.ValueError("non-integer stop for randrange()");\n        };\n\n        if (step === undefined) {\n            step = 1;\n        };\n\n        width = stop - start;\n\n        if ((step == 1) && (width > 0)) {\n            // Random in [start, stop), must use toInt on product for correct results with negative ranges\n            ret = start + toInt(myGenerator.genrand_res53() * width);\n\t    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n        };\n\n        if (step == 1) {\n            throw new Sk.builtin.ValueError("empty range for randrange() (" + start + ", " + stop + ", " + width + ")");\n        };\n\n        if (!Sk.builtin.checkInt(step)) {\n            throw new Sk.builtin.ValueError("non-integer step for randrange()");\n        };\n\n        if (step > 0) {\n            n = toInt((width + step - 1) / step);\n        } else if (step < 0) {\n            n = toInt((width + step + 1) / step);\n        } else {\n            throw new Sk.builtin.ValueError("zero step for randrange()");\n        };\n\n        if (n <= 0) {\n            throw new Sk.builtin.ValueError("empty range for randrange()");\n        };\n\n        // Random in range(start, stop, step)\n        ret = start + (step * toInt(myGenerator.genrand_res53() * n));\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n    };\n\n    mod.randint = new Sk.builtin.func(function(a, b) {\n        Sk.builtin.pyCheckArgs("randint", arguments, 2, 2);\n\n\ta = Sk.builtin.asnum$(a);\n\tb = Sk.builtin.asnum$(b);\n        return randrange(a, b+1);\n    });\n\n    mod.randrange = new Sk.builtin.func(function(start, stop, step) {\n        Sk.builtin.pyCheckArgs("randrange", arguments, 1, 3);\n\n\tstart = Sk.builtin.asnum$(start);\n\tstop = Sk.builtin.asnum$(stop);\n\tstep = Sk.builtin.asnum$(step);\n        return randrange(start, stop, step);\n    });\n\n    mod.choice = new Sk.builtin.func(function(seq) {\n        Sk.builtin.pyCheckArgs("choice", arguments, 1, 1);\n        Sk.builtin.pyCheckType("seq", "sequence", Sk.builtin.checkSequence(seq));\n\n        if (seq.sq$length !== undefined) {\n            var r = toInt(myGenerator.genrand_res53() * seq.sq$length());\n            return seq.mp$subscript(r);\n        } else {\n            throw new Sk.builtin.TypeError("object has no length");\n        }\n    });\n\n    mod.shuffle = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("shuffle", arguments, 1, 1);\n        Sk.builtin.pyCheckType("x", "sequence", Sk.builtin.checkSequence(x));\n\n        if (x.sq$length !== undefined) {\n            if (x.mp$ass_subscript !== undefined) {\n                for (var i = x.sq$length() - 1; i > 0; i -= 1) {\n                    var r = toInt(myGenerator.genrand_res53() * (i + 1));\n                    var tmp = x.mp$subscript(r);\n                    x.mp$ass_subscript(r, x.mp$subscript(i));\n                    x.mp$ass_subscript(i, tmp);\n                };\n            } else {\n                throw new Sk.builtin.TypeError("object is immutable");\n            };\n        } else {\n            throw new Sk.builtin.TypeError("object has no length");\n        };        \n\n\treturn Sk.builtin.none.none$;\n    });\n\n    return mod;\n}',
    'src/lib/test/__init__.py': '__author__ = \'bmiller\'\n\ndef testEqual(actual, expected):\n    if type(expected) == type(1):\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    elif type(expected) == type(1.11):\n        if abs(actual-expected) < 0.00001:\n            print(\'Pass\')\n            return True\n    else:\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    print(\'Test Failed: expected \' + str(expected) + \' but got \' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n',
    'src/lib/symbolic/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineSymbolic(mod, "symbolic");\n  return mod;\n};\n',
    'src/builtin/this.py': 's = """Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera\'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh\'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg\'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg\'f qb zber bs gubfr!"""\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint "".join([d.get(c, c) for c in s])\n',
    'src/lib/e2ga/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEuclidean2(mod, BLADE);\n  return mod;\n}\n'
  }
};
!function ($) {
  'use strict';
  var Carousel = function (element, options) {
    this.$element = $(element);
    this.$indicators = this.$element.find('.carousel-indicators');
    this.options = options;
    this.options.pause == 'hover' && this.$element.on('mouseenter', $.proxy(this.pause, this)).on('mouseleave', $.proxy(this.cycle, this));
  };
  Carousel.prototype = {
    cycle: function (e) {
      if (!e)
        this.paused = false;
      if (this.interval)
        clearInterval(this.interval);
      this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
      return this;
    },
    getActiveIndex: function () {
      this.$active = this.$element.find('.item.active');
      this.$items = this.$active.parent().children();
      return this.$items.index(this.$active);
    },
    to: function (pos) {
      var activeIndex = this.getActiveIndex(), that = this;
      if (pos > this.$items.length - 1 || pos < 0)
        return;
      if (this.sliding) {
        return this.$element.one('slid', function () {
          that.to(pos);
        });
      }
      if (activeIndex == pos) {
        return this.pause().cycle();
      }
      return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]));
    },
    pause: function (e) {
      if (!e)
        this.paused = true;
      if (this.$element.find('.next, .prev').length && $.support.transition.end) {
        this.$element.trigger($.support.transition.end);
        this.cycle(true);
      }
      clearInterval(this.interval);
      this.interval = null;
      return this;
    },
    next: function () {
      if (this.sliding)
        return;
      return this.slide('next');
    },
    prev: function () {
      if (this.sliding)
        return;
      return this.slide('prev');
    },
    slide: function (type, next) {
      var $active = this.$element.find('.item.active'), $next = next || $active[type](), isCycling = this.interval, direction = type == 'next' ? 'left' : 'right', fallback = type == 'next' ? 'first' : 'last', that = this, e;
      this.sliding = true;
      isCycling && this.pause();
      $next = $next.length ? $next : this.$element.find('.item')[fallback]();
      e = $.Event('slide', {
        relatedTarget: $next[0],
        direction: direction
      });
      if ($next.hasClass('active'))
        return;
      if (this.$indicators.length) {
        this.$indicators.find('.active').removeClass('active');
        this.$element.one('slid', function () {
          var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()]);
          $nextIndicator && $nextIndicator.addClass('active');
        });
      }
      if ($.support.transition && this.$element.hasClass('slide')) {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $next.addClass(type);
        $next[0].offsetWidth;
        $active.addClass(direction);
        $next.addClass(direction);
        this.$element.one($.support.transition.end, function () {
          $next.removeClass([
            type,
            direction
          ].join(' ')).addClass('active');
          $active.removeClass([
            'active',
            direction
          ].join(' '));
          that.sliding = false;
          setTimeout(function () {
            that.$element.trigger('slid');
          }, 0);
        });
      } else {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $active.removeClass('active');
        $next.addClass('active');
        this.sliding = false;
        this.$element.trigger('slid');
      }
      isCycling && this.cycle();
      return this;
    }
  };
  var old = $.fn.carousel;
  $.fn.carousel = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('carousel'), options = $.extend({}, $.fn.carousel.defaults, typeof option == 'object' && option), action = typeof option == 'string' ? option : options.slide;
      if (!data)
        $this.data('carousel', data = new Carousel(this, options));
      if (typeof option == 'number')
        data.to(option);
      else if (action)
        data[action]();
      else if (options.interval)
        data.pause().cycle();
    });
  };
  $.fn.carousel.defaults = {
    interval: 5000,
    pause: 'hover'
  };
  $.fn.carousel.Constructor = Carousel;
  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old;
    return this;
  };
  $(document).on('click.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
    var $this = $(this), href, $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')), options = $.extend({}, $target.data(), $this.data()), slideIndex;
    $target.carousel(options);
    if (slideIndex = $this.attr('data-slide-to')) {
      $target.data('carousel').pause().to(slideIndex).cycle();
    }
    e.preventDefault();
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Collapse = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, $.fn.collapse.defaults, options);
    if (this.options.parent) {
      this.$parent = $(this.options.parent);
    }
    this.options.toggle && this.toggle();
  };
  Collapse.prototype = {
    constructor: Collapse,
    dimension: function () {
      var hasWidth = this.$element.hasClass('width');
      return hasWidth ? 'width' : 'height';
    },
    show: function () {
      var dimension, scroll, actives, hasData;
      if (this.transitioning || this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      scroll = $.camelCase([
        'scroll',
        dimension
      ].join('-'));
      actives = this.$parent && this.$parent.find('> .accordion-group > .in');
      if (actives && actives.length) {
        hasData = actives.data('collapse');
        if (hasData && hasData.transitioning)
          return;
        actives.collapse('hide');
        hasData || actives.data('collapse', null);
      }
      this.$element[dimension](0);
      this.transition('addClass', $.Event('show'), 'shown');
      $.support.transition && this.$element[dimension](this.$element[0][scroll]);
    },
    hide: function () {
      var dimension;
      if (this.transitioning || !this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      this.reset(this.$element[dimension]());
      this.transition('removeClass', $.Event('hide'), 'hidden');
      this.$element[dimension](0);
    },
    reset: function (size) {
      var dimension = this.dimension();
      this.$element.removeClass('collapse')[dimension](size || 'auto')[0].offsetWidth;
      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse');
      return this;
    },
    transition: function (method, startEvent, completeEvent) {
      var that = this, complete = function () {
          if (startEvent.type == 'show')
            that.reset();
          that.transitioning = 0;
          that.$element.trigger(completeEvent);
        };
      this.$element.trigger(startEvent);
      if (startEvent.isDefaultPrevented())
        return;
      this.transitioning = 1;
      this.$element[method]('in');
      $.support.transition && this.$element.hasClass('collapse') ? this.$element.one($.support.transition.end, complete) : complete();
    },
    toggle: function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']();
    }
  };
  var old = $.fn.collapse;
  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('collapse'), options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('collapse', data = new Collapse(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.collapse.defaults = { toggle: true };
  $.fn.collapse.Constructor = Collapse;
  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old;
    return this;
  };
  $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
    var $this = $(this), href, target = $this.attr('data-target') || e.preventDefault() || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''), option = $(target).data('collapse') ? 'toggle' : $this.data();
    $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed');
    $(target).collapse(option);
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var toggle = '[data-toggle=dropdown]', Dropdown = function (element) {
      var $el = $(element).on('click.dropdown.data-api', this.toggle);
      $('html').on('click.dropdown.data-api', function () {
        $el.parent().removeClass('open');
      });
    };
  Dropdown.prototype = {
    constructor: Dropdown,
    toggle: function (e) {
      var $this = $(this), $parent, isActive;
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      clearMenus();
      if (!isActive) {
        if ('ontouchstart' in document.documentElement) {
          $('<div class="dropdown-backdrop"/>').insertBefore($(this)).on('click', clearMenus);
        }
        $parent.toggleClass('open');
      }
      $this.focus();
      return false;
    },
    keydown: function (e) {
      var $this, $items, $active, $parent, isActive, index;
      if (!/(38|40|27)/.test(e.keyCode))
        return;
      $this = $(this);
      e.preventDefault();
      e.stopPropagation();
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      if (!isActive || isActive && e.keyCode == 27) {
        if (e.which == 27)
          $parent.find(toggle).focus();
        return $this.click();
      }
      $items = $('[role=menu] li:not(.divider):visible a', $parent);
      if (!$items.length)
        return;
      index = $items.index($items.filter(':focus'));
      if (e.keyCode == 38 && index > 0)
        index--;
      if (e.keyCode == 40 && index < $items.length - 1)
        index++;
      if (!~index)
        index = 0;
      $items.eq(index).focus();
    }
  };
  function clearMenus() {
    $('.dropdown-backdrop').remove();
    $(toggle).each(function () {
      getParent($(this)).removeClass('open');
    });
  }
  function getParent($this) {
    var selector = $this.attr('data-target'), $parent;
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    $parent = selector && $(selector);
    if (!$parent || !$parent.length)
      $parent = $this.parent();
    return $parent;
  }
  var old = $.fn.dropdown;
  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('dropdown');
      if (!data)
        $this.data('dropdown', data = new Dropdown(this));
      if (typeof option == 'string')
        data[option].call($this);
    });
  };
  $.fn.dropdown.Constructor = Dropdown;
  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old;
    return this;
  };
  $(document).on('click.dropdown.data-api', clearMenus).on('click.dropdown.data-api', '.dropdown form', function (e) {
    e.stopPropagation();
  }).on('click.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.dropdown.data-api', toggle + ', [role=menu]', Dropdown.prototype.keydown);
}(window.jQuery);
!function ($) {
  'use strict';
  var Modal = function (element, options) {
    this.options = options;
    this.$element = $(element).delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this));
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote);
  };
  Modal.prototype = {
    constructor: Modal,
    toggle: function () {
      return this[!this.isShown ? 'show' : 'hide']();
    },
    show: function () {
      var that = this, e = $.Event('show');
      this.$element.trigger(e);
      if (this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = true;
      this.escape();
      this.backdrop(function () {
        var transition = $.support.transition && that.$element.hasClass('fade');
        if (!that.$element.parent().length) {
          that.$element.appendTo(document.body);
        }
        that.$element.show();
        if (transition) {
          that.$element[0].offsetWidth;
        }
        that.$element.addClass('in').attr('aria-hidden', false);
        that.enforceFocus();
        transition ? that.$element.one($.support.transition.end, function () {
          that.$element.focus().trigger('shown');
        }) : that.$element.focus().trigger('shown');
      });
    },
    hide: function (e) {
      e && e.preventDefault();
      var that = this;
      e = $.Event('hide');
      this.$element.trigger(e);
      if (!this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = false;
      this.escape();
      $(document).off('focusin.modal');
      this.$element.removeClass('in').attr('aria-hidden', true);
      $.support.transition && this.$element.hasClass('fade') ? this.hideWithTransition() : this.hideModal();
    },
    enforceFocus: function () {
      var that = this;
      $(document).on('focusin.modal', function (e) {
        if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
          that.$element.focus();
        }
      });
    },
    escape: function () {
      var that = this;
      if (this.isShown && this.options.keyboard) {
        this.$element.on('keyup.dismiss.modal', function (e) {
          e.which == 27 && that.hide();
        });
      } else if (!this.isShown) {
        this.$element.off('keyup.dismiss.modal');
      }
    },
    hideWithTransition: function () {
      var that = this, timeout = setTimeout(function () {
          that.$element.off($.support.transition.end);
          that.hideModal();
        }, 500);
      this.$element.one($.support.transition.end, function () {
        clearTimeout(timeout);
        that.hideModal();
      });
    },
    hideModal: function () {
      var that = this;
      this.$element.hide();
      this.backdrop(function () {
        that.removeBackdrop();
        that.$element.trigger('hidden');
      });
    },
    removeBackdrop: function () {
      this.$backdrop && this.$backdrop.remove();
      this.$backdrop = null;
    },
    backdrop: function (callback) {
      var that = this, animate = this.$element.hasClass('fade') ? 'fade' : '';
      if (this.isShown && this.options.backdrop) {
        var doAnimate = $.support.transition && animate;
        this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body);
        this.$backdrop.click(this.options.backdrop == 'static' ? $.proxy(this.$element[0].focus, this.$element[0]) : $.proxy(this.hide, this));
        if (doAnimate)
          this.$backdrop[0].offsetWidth;
        this.$backdrop.addClass('in');
        if (!callback)
          return;
        doAnimate ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (!this.isShown && this.$backdrop) {
        this.$backdrop.removeClass('in');
        $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (callback) {
        callback();
      }
    }
  };
  var old = $.fn.modal;
  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('modal'), options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('modal', data = new Modal(this, options));
      if (typeof option == 'string')
        data[option]();
      else if (options.show)
        data.show();
    });
  };
  $.fn.modal.defaults = {
    backdrop: true,
    keyboard: true,
    show: true
  };
  $.fn.modal.Constructor = Modal;
  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  };
  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this), href = $this.attr('href'), $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')), option = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());
    e.preventDefault();
    $target.modal(option).one('hide', function () {
      $this.focus();
    });
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Tab = function (element) {
    this.element = $(element);
  };
  Tab.prototype = {
    constructor: Tab,
    show: function () {
      var $this = this.element, $ul = $this.closest('ul:not(.dropdown-menu)'), selector = $this.attr('data-target'), previous, $target, e;
      if (!selector) {
        selector = $this.attr('href');
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
      }
      if ($this.parent('li').hasClass('active'))
        return;
      previous = $ul.find('.active:last a')[0];
      e = $.Event('show', { relatedTarget: previous });
      $this.trigger(e);
      if (e.isDefaultPrevented())
        return;
      $target = $(selector);
      this.activate($this.parent('li'), $ul);
      this.activate($target, $target.parent(), function () {
        $this.trigger({
          type: 'shown',
          relatedTarget: previous
        });
      });
    },
    activate: function (element, container, callback) {
      var $active = container.find('> .active'), transition = callback && $.support.transition && $active.hasClass('fade');
      function next() {
        $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active');
        element.addClass('active');
        if (transition) {
          element[0].offsetWidth;
          element.addClass('in');
        } else {
          element.removeClass('fade');
        }
        if (element.parent('.dropdown-menu')) {
          element.closest('li.dropdown').addClass('active');
        }
        callback && callback();
      }
      transition ? $active.one($.support.transition.end, next) : next();
      $active.removeClass('in');
    }
  };
  var old = $.fn.tab;
  $.fn.tab = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('tab');
      if (!data)
        $this.data('tab', data = new Tab(this));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.tab.Constructor = Tab;
  $.fn.tab.noConflict = function () {
    $.fn.tab = old;
    return this;
  };
  $(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
    e.preventDefault();
    $(this).tab('show');
  });
}(window.jQuery);
!function ($) {
  'use strict';
  $(function () {
    $.support.transition = function () {
      var transitionEnd = function () {
          var el = document.createElement('bootstrap'), transEndEventNames = {
              'WebkitTransition': 'webkitTransitionEnd',
              'MozTransition': 'transitionend',
              'OTransition': 'oTransitionEnd otransitionend',
              'transition': 'transitionend'
            }, name;
          for (name in transEndEventNames) {
            if (el.style[name] !== undefined) {
              return transEndEventNames[name];
            }
          }
        }();
      return transitionEnd && { end: transitionEnd };
    }();
  });
}(window.jQuery);
(function (window, document, undefined) {
  'use strict';
  var lowercase = function (string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var uppercase = function (string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function (s) {
    return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) | 32);
    }) : s;
  };
  var manualUppercase = function (s) {
    return isString(s) ? s.replace(/[a-z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) & ~32);
    }) : s;
  };
  if ('i' !== 'I'.toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]), jqLite, jQuery, slice = [].slice, push = [].push, toString = Object.prototype.toString, angular = window.angular || (window.angular = {}), angularModule, nodeName_, uid = [
      '0',
      '0',
      '0'
    ];
  function isArrayLike(obj) {
    if (!obj || typeof obj.length !== 'number')
      return false;
    if (typeof obj.hasOwnProperty != 'function' && typeof obj.constructor != 'function') {
      return true;
    } else {
      return obj instanceof JQLite || jQuery && obj instanceof jQuery || toString.call(obj) !== '[object Object]' || typeof obj.callee === 'function';
    }
  }
  function forEach(obj, iterator, context) {
    var key;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context);
      } else if (isArrayLike(obj)) {
        for (key = 0; key < obj.length; key++)
          iterator.call(context, obj[key], key);
      } else {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      }
    }
    return obj;
  }
  function sortedKeys(obj) {
    var keys = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        keys.push(key);
      }
    }
    return keys.sort();
  }
  function forEachSorted(obj, iterator, context) {
    var keys = sortedKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }
  function reverseParams(iteratorFn) {
    return function (value, key) {
      iteratorFn(key, value);
    };
  }
  function nextUid() {
    var index = uid.length;
    var digit;
    while (index) {
      index--;
      digit = uid[index].charCodeAt(0);
      if (digit == 57) {
        uid[index] = 'A';
        return uid.join('');
      }
      if (digit == 90) {
        uid[index] = '0';
      } else {
        uid[index] = String.fromCharCode(digit + 1);
        return uid.join('');
      }
    }
    uid.unshift('0');
    return uid.join('');
  }
  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }
  function extend(dst) {
    var h = dst.$$hashKey;
    forEach(arguments, function (obj) {
      if (obj !== dst) {
        forEach(obj, function (value, key) {
          dst[key] = value;
        });
      }
    });
    setHashKey(dst, h);
    return dst;
  }
  function int(str) {
    return parseInt(str, 10);
  }
  function inherit(parent, extra) {
    return extend(new (extend(function () {
    }, { prototype: parent }))(), extra);
  }
  function noop() {
  }
  noop.$inject = [];
  function identity($) {
    return $;
  }
  identity.$inject = [];
  function valueFn(value) {
    return function () {
      return value;
    };
  }
  function isUndefined(value) {
    return typeof value == 'undefined';
  }
  function isDefined(value) {
    return typeof value != 'undefined';
  }
  function isObject(value) {
    return value != null && typeof value == 'object';
  }
  function isString(value) {
    return typeof value == 'string';
  }
  function isNumber(value) {
    return typeof value == 'number';
  }
  function isDate(value) {
    return toString.apply(value) == '[object Date]';
  }
  function isArray(value) {
    return toString.apply(value) == '[object Array]';
  }
  function isFunction(value) {
    return typeof value == 'function';
  }
  function isWindow(obj) {
    return obj && obj.document && obj.location && obj.alert && obj.setInterval;
  }
  function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
  }
  function isFile(obj) {
    return toString.apply(obj) === '[object File]';
  }
  function isBoolean(value) {
    return typeof value == 'boolean';
  }
  function trim(value) {
    return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
  }
  function isElement(node) {
    return node && (node.nodeName || node.bind && node.find);
  }
  function makeMap(str) {
    var obj = {}, items = str.split(','), i;
    for (i = 0; i < items.length; i++)
      obj[items[i]] = true;
    return obj;
  }
  if (msie < 9) {
    nodeName_ = function (element) {
      element = element.nodeName ? element : element[0];
      return element.scopeName && element.scopeName != 'HTML' ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
    };
  } else {
    nodeName_ = function (element) {
      return element.nodeName ? element.nodeName : element[0].nodeName;
    };
  }
  function map(obj, iterator, context) {
    var results = [];
    forEach(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  }
  function size(obj, ownPropsOnly) {
    var size = 0, key;
    if (isArray(obj) || isString(obj)) {
      return obj.length;
    } else if (isObject(obj)) {
      for (key in obj)
        if (!ownPropsOnly || obj.hasOwnProperty(key))
          size++;
    }
    return size;
  }
  function includes(array, obj) {
    return indexOf(array, obj) != -1;
  }
  function indexOf(array, obj) {
    if (array.indexOf)
      return array.indexOf(obj);
    for (var i = 0; i < array.length; i++) {
      if (obj === array[i])
        return i;
    }
    return -1;
  }
  function arrayRemove(array, value) {
    var index = indexOf(array, value);
    if (index >= 0)
      array.splice(index, 1);
    return value;
  }
  function isLeafNode(node) {
    if (node) {
      switch (node.nodeName) {
      case 'OPTION':
      case 'PRE':
      case 'TITLE':
        return true;
      }
    }
    return false;
  }
  function copy(source, destination) {
    if (isWindow(source) || isScope(source))
      throw Error('Can\'t copy Window or Scope');
    if (!destination) {
      destination = source;
      if (source) {
        if (isArray(source)) {
          destination = copy(source, []);
        } else if (isDate(source)) {
          destination = new Date(source.getTime());
        } else if (isObject(source)) {
          destination = copy(source, {});
        }
      }
    } else {
      if (source === destination)
        throw Error('Can\'t copy equivalent objects or arrays');
      if (isArray(source)) {
        destination.length = 0;
        for (var i = 0; i < source.length; i++) {
          destination.push(copy(source[i]));
        }
      } else {
        var h = destination.$$hashKey;
        forEach(destination, function (value, key) {
          delete destination[key];
        });
        for (var key in source) {
          destination[key] = copy(source[key]);
        }
        setHashKey(destination, h);
      }
    }
    return destination;
  }
  function shallowCopy(src, dst) {
    dst = dst || {};
    for (var key in src) {
      if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {
        dst[key] = src[key];
      }
    }
    return dst;
  }
  function equals(o1, o2) {
    if (o1 === o2)
      return true;
    if (o1 === null || o2 === null)
      return false;
    if (o1 !== o1 && o2 !== o2)
      return true;
    var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
    if (t1 == t2) {
      if (t1 == 'object') {
        if (isArray(o1)) {
          if ((length = o1.length) == o2.length) {
            for (key = 0; key < length; key++) {
              if (!equals(o1[key], o2[key]))
                return false;
            }
            return true;
          }
        } else if (isDate(o1)) {
          return isDate(o2) && o1.getTime() == o2.getTime();
        } else {
          if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2))
            return false;
          keySet = {};
          for (key in o1) {
            if (key.charAt(0) === '$' || isFunction(o1[key]))
              continue;
            if (!equals(o1[key], o2[key]))
              return false;
            keySet[key] = true;
          }
          for (key in o2) {
            if (!keySet[key] && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key]))
              return false;
          }
          return true;
        }
      }
    }
    return false;
  }
  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }
  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }
  function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length ? function () {
        return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs);
      } : function () {
        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
      };
    } else {
      return fn;
    }
  }
  function toJsonReplacer(key, value) {
    var val = value;
    if (/^\$+/.test(key)) {
      val = undefined;
    } else if (isWindow(value)) {
      val = '$WINDOW';
    } else if (value && document === value) {
      val = '$DOCUMENT';
    } else if (isScope(value)) {
      val = '$SCOPE';
    }
    return val;
  }
  function toJson(obj, pretty) {
    return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
  }
  function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
  }
  function toBoolean(value) {
    if (value && value.length !== 0) {
      var v = lowercase('' + value);
      value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
    } else {
      value = false;
    }
    return value;
  }
  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.html('');
    } catch (e) {
    }
    var TEXT_NODE = 3;
    var elemHtml = jqLite('<div>').append(element).html();
    try {
      return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
        return '<' + lowercase(nodeName);
      });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }
  function parseKeyValue(keyValue) {
    var obj = {}, key_value, key;
    forEach((keyValue || '').split('&'), function (keyValue) {
      if (keyValue) {
        key_value = keyValue.split('=');
        key = decodeURIComponent(key_value[0]);
        obj[key] = isDefined(key_value[1]) ? decodeURIComponent(key_value[1]) : true;
      }
    });
    return obj;
  }
  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function (value, key) {
      parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
    });
    return parts.length ? parts.join('&') : '';
  }
  function encodeUriSegment(val) {
    return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
  }
  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
  }
  function angularInit(element, bootstrap) {
    var elements = [element], appElement, module, names = [
        'ng:app',
        'ng-app',
        'x-ng-app',
        'data-ng-app'
      ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
    function append(element) {
      element && elements.push(element);
    }
    forEach(names, function (name) {
      names[name] = true;
      append(document.getElementById(name));
      name = name.replace(':', '\\:');
      if (element.querySelectorAll) {
        forEach(element.querySelectorAll('.' + name), append);
        forEach(element.querySelectorAll('.' + name + '\\:'), append);
        forEach(element.querySelectorAll('[' + name + ']'), append);
      }
    });
    forEach(elements, function (element) {
      if (!appElement) {
        var className = ' ' + element.className + ' ';
        var match = NG_APP_CLASS_REGEXP.exec(className);
        if (match) {
          appElement = element;
          module = (match[2] || '').replace(/\s+/g, ',');
        } else {
          forEach(element.attributes, function (attr) {
            if (!appElement && names[attr.name]) {
              appElement = element;
              module = attr.value;
            }
          });
        }
      }
    });
    if (appElement) {
      bootstrap(appElement, module ? [module] : []);
    }
  }
  function bootstrap(element, modules) {
    var resumeBootstrapInternal = function () {
      element = jqLite(element);
      modules = modules || [];
      modules.unshift([
        '$provide',
        function ($provide) {
          $provide.value('$rootElement', element);
        }
      ]);
      modules.unshift('ng');
      var injector = createInjector(modules);
      injector.invoke([
        '$rootScope',
        '$rootElement',
        '$compile',
        '$injector',
        function (scope, element, compile, injector) {
          scope.$apply(function () {
            element.data('$injector', injector);
            compile(element)(scope);
          });
        }
      ]);
      return injector;
    };
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return resumeBootstrapInternal();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
    angular.resumeBootstrap = function (extraModules) {
      forEach(extraModules, function (module) {
        modules.push(module);
      });
      resumeBootstrapInternal();
    };
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;
  function snake_case(name, separator) {
    separator = separator || '_';
    return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }
  function bindJQuery() {
    jQuery = window.jQuery;
    if (jQuery) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
      });
      JQLitePatchJQueryRemove('remove', true);
      JQLitePatchJQueryRemove('empty');
      JQLitePatchJQueryRemove('html');
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
  }
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw new Error('Argument \'' + (name || '?') + '\' is ' + (reason || 'required'));
    }
    return arg;
  }
  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
    return arg;
  }
  function setupModuleLoader(window) {
    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    return ensure(ensure(window, 'angular', Object), 'module', function () {
      var modules = {};
      return function module(name, requires, configFn) {
        if (requires && modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function () {
          if (!requires) {
            throw Error('No module: ' + name);
          }
          var invokeQueue = [];
          var runBlocks = [];
          var config = invokeLater('$injector', 'invoke');
          var moduleInstance = {
              _invokeQueue: invokeQueue,
              _runBlocks: runBlocks,
              requires: requires,
              name: name,
              provider: invokeLater('$provide', 'provider'),
              factory: invokeLater('$provide', 'factory'),
              service: invokeLater('$provide', 'service'),
              value: invokeLater('$provide', 'value'),
              constant: invokeLater('$provide', 'constant', 'unshift'),
              filter: invokeLater('$filterProvider', 'register'),
              controller: invokeLater('$controllerProvider', 'register'),
              directive: invokeLater('$compileProvider', 'directive'),
              config: config,
              run: function (block) {
                runBlocks.push(block);
                return this;
              }
            };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;
          function invokeLater(provider, method, insertMethod) {
            return function () {
              invokeQueue[insertMethod || 'push']([
                provider,
                method,
                arguments
              ]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }
  var version = {
      full: '1.0.7',
      major: 1,
      minor: 0,
      dot: 7,
      codeName: 'monochromatic-rainbow'
    };
  function publishExternalAPI(angular) {
    extend(angular, {
      'bootstrap': bootstrap,
      'copy': copy,
      'extend': extend,
      'equals': equals,
      'element': jqLite,
      'forEach': forEach,
      'injector': createInjector,
      'noop': noop,
      'bind': bind,
      'toJson': toJson,
      'fromJson': fromJson,
      'identity': identity,
      'isUndefined': isUndefined,
      'isDefined': isDefined,
      'isString': isString,
      'isFunction': isFunction,
      'isObject': isObject,
      'isNumber': isNumber,
      'isElement': isElement,
      'isArray': isArray,
      'version': version,
      'isDate': isDate,
      'lowercase': lowercase,
      'uppercase': uppercase,
      'callbacks': { counter: 0 }
    });
    angularModule = setupModuleLoader(window);
    try {
      angularModule('ngLocale');
    } catch (e) {
      angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
    }
    angularModule('ng', ['ngLocale'], [
      '$provide',
      function ngModule($provide) {
        $provide.provider('$compile', $CompileProvider).directive({
          a: htmlAnchorDirective,
          input: inputDirective,
          textarea: inputDirective,
          form: formDirective,
          script: scriptDirective,
          select: selectDirective,
          style: styleDirective,
          option: optionDirective,
          ngBind: ngBindDirective,
          ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,
          ngBindTemplate: ngBindTemplateDirective,
          ngClass: ngClassDirective,
          ngClassEven: ngClassEvenDirective,
          ngClassOdd: ngClassOddDirective,
          ngCsp: ngCspDirective,
          ngCloak: ngCloakDirective,
          ngController: ngControllerDirective,
          ngForm: ngFormDirective,
          ngHide: ngHideDirective,
          ngInclude: ngIncludeDirective,
          ngInit: ngInitDirective,
          ngNonBindable: ngNonBindableDirective,
          ngPluralize: ngPluralizeDirective,
          ngRepeat: ngRepeatDirective,
          ngShow: ngShowDirective,
          ngSubmit: ngSubmitDirective,
          ngStyle: ngStyleDirective,
          ngSwitch: ngSwitchDirective,
          ngSwitchWhen: ngSwitchWhenDirective,
          ngSwitchDefault: ngSwitchDefaultDirective,
          ngOptions: ngOptionsDirective,
          ngView: ngViewDirective,
          ngTransclude: ngTranscludeDirective,
          ngModel: ngModelDirective,
          ngList: ngListDirective,
          ngChange: ngChangeDirective,
          required: requiredDirective,
          ngRequired: requiredDirective,
          ngValue: ngValueDirective
        }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
        $provide.provider({
          $anchorScroll: $AnchorScrollProvider,
          $browser: $BrowserProvider,
          $cacheFactory: $CacheFactoryProvider,
          $controller: $ControllerProvider,
          $document: $DocumentProvider,
          $exceptionHandler: $ExceptionHandlerProvider,
          $filter: $FilterProvider,
          $interpolate: $InterpolateProvider,
          $http: $HttpProvider,
          $httpBackend: $HttpBackendProvider,
          $location: $LocationProvider,
          $log: $LogProvider,
          $parse: $ParseProvider,
          $route: $RouteProvider,
          $routeParams: $RouteParamsProvider,
          $rootScope: $RootScopeProvider,
          $q: $QProvider,
          $sniffer: $SnifferProvider,
          $templateCache: $TemplateCacheProvider,
          $timeout: $TimeoutProvider,
          $window: $WindowProvider
        });
      }
    ]);
  }
  var jqCache = JQLite.cache = {}, jqName = JQLite.expando = 'ng-' + new Date().getTime(), jqId = 1, addEventListenerFn = window.document.addEventListener ? function (element, type, fn) {
      element.addEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.attachEvent('on' + type, fn);
    }, removeEventListenerFn = window.document.removeEventListener ? function (element, type, fn) {
      element.removeEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.detachEvent('on' + type, fn);
    };
  function jqNextId() {
    return ++jqId;
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  function camelCase(name) {
    return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).replace(MOZ_HACK_REGEXP, 'Moz$1');
  }
  function JQLitePatchJQueryRemove(name, dispatchThis) {
    var originalJqFn = jQuery.fn[name];
    originalJqFn = originalJqFn.$original || originalJqFn;
    removePatch.$original = originalJqFn;
    jQuery.fn[name] = removePatch;
    function removePatch() {
      var list = [this], fireEvent = dispatchThis, set, setIndex, setLength, element, childIndex, childLength, children, fns, events;
      while (list.length) {
        set = list.shift();
        for (setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
          element = jqLite(set[setIndex]);
          if (fireEvent) {
            element.triggerHandler('$destroy');
          } else {
            fireEvent = !fireEvent;
          }
          for (childIndex = 0, childLength = (children = element.children()).length; childIndex < childLength; childIndex++) {
            list.push(jQuery(children[childIndex]));
          }
        }
      }
      return originalJqFn.apply(this, arguments);
    }
  }
  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    if (!(this instanceof JQLite)) {
      if (isString(element) && element.charAt(0) != '<') {
        throw Error('selectors not implemented');
      }
      return new JQLite(element);
    }
    if (isString(element)) {
      var div = document.createElement('div');
      div.innerHTML = '<div>&#160;</div>' + element;
      div.removeChild(div.firstChild);
      JQLiteAddNodes(this, div.childNodes);
      this.remove();
    } else {
      JQLiteAddNodes(this, element);
    }
  }
  function JQLiteClone(element) {
    return element.cloneNode(true);
  }
  function JQLiteDealoc(element) {
    JQLiteRemoveData(element);
    for (var i = 0, children = element.childNodes || []; i < children.length; i++) {
      JQLiteDealoc(children[i]);
    }
  }
  function JQLiteUnbind(element, type, fn) {
    var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
    if (!handle)
      return;
    if (isUndefined(type)) {
      forEach(events, function (eventHandler, type) {
        removeEventListenerFn(element, type, eventHandler);
        delete events[type];
      });
    } else {
      if (isUndefined(fn)) {
        removeEventListenerFn(element, type, events[type]);
        delete events[type];
      } else {
        arrayRemove(events[type], fn);
      }
    }
  }
  function JQLiteRemoveData(element) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId];
    if (expandoStore) {
      if (expandoStore.handle) {
        expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');
        JQLiteUnbind(element);
      }
      delete jqCache[expandoId];
      element[jqName] = undefined;
    }
  }
  function JQLiteExpandoStore(element, key, value) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId || -1];
    if (isDefined(value)) {
      if (!expandoStore) {
        element[jqName] = expandoId = jqNextId();
        expandoStore = jqCache[expandoId] = {};
      }
      expandoStore[key] = value;
    } else {
      return expandoStore && expandoStore[key];
    }
  }
  function JQLiteData(element, key, value) {
    var data = JQLiteExpandoStore(element, 'data'), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
    if (!data && !isSimpleGetter) {
      JQLiteExpandoStore(element, 'data', data = {});
    }
    if (isSetter) {
      data[key] = value;
    } else {
      if (keyDefined) {
        if (isSimpleGetter) {
          return data && data[key];
        } else {
          extend(data, key);
        }
      } else {
        return data;
      }
    }
  }
  function JQLiteHasClass(element, selector) {
    return (' ' + element.className + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;
  }
  function JQLiteRemoveClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        element.className = trim((' ' + element.className + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' '));
      });
    }
  }
  function JQLiteAddClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        if (!JQLiteHasClass(element, cssClass)) {
          element.className = trim(element.className + ' ' + trim(cssClass));
        }
      });
    }
  }
  function JQLiteAddNodes(root, elements) {
    if (elements) {
      elements = !elements.nodeName && isDefined(elements.length) && !isWindow(elements) ? elements : [elements];
      for (var i = 0; i < elements.length; i++) {
        root.push(elements[i]);
      }
    }
  }
  function JQLiteController(element, name) {
    return JQLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
  }
  function JQLiteInheritedData(element, name, value) {
    element = jqLite(element);
    if (element[0].nodeType == 9) {
      element = element.find('html');
    }
    while (element.length) {
      if (value = element.data(name))
        return value;
      element = element.parent();
    }
  }
  var JQLitePrototype = JQLite.prototype = {
      ready: function (fn) {
        var fired = false;
        function trigger() {
          if (fired)
            return;
          fired = true;
          fn();
        }
        this.bind('DOMContentLoaded', trigger);
        JQLite(window).bind('load', trigger);
      },
      toString: function () {
        var value = [];
        forEach(this, function (e) {
          value.push('' + e);
        });
        return '[' + value.join(', ') + ']';
      },
      eq: function (index) {
        return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
      },
      length: 0,
      push: push,
      sort: [].sort,
      splice: [].splice
    };
  var BOOLEAN_ATTR = {};
  forEach('multiple,selected,checked,disabled,readOnly,required'.split(','), function (value) {
    BOOLEAN_ATTR[lowercase(value)] = value;
  });
  var BOOLEAN_ELEMENTS = {};
  forEach('input,select,option,textarea,button,form'.split(','), function (value) {
    BOOLEAN_ELEMENTS[uppercase(value)] = true;
  });
  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
  }
  forEach({
    data: JQLiteData,
    inheritedData: JQLiteInheritedData,
    scope: function (element) {
      return JQLiteInheritedData(element, '$scope');
    },
    controller: JQLiteController,
    injector: function (element) {
      return JQLiteInheritedData(element, '$injector');
    },
    removeAttr: function (element, name) {
      element.removeAttribute(name);
    },
    hasClass: JQLiteHasClass,
    css: function (element, name, value) {
      name = camelCase(name);
      if (isDefined(value)) {
        element.style[name] = value;
      } else {
        var val;
        if (msie <= 8) {
          val = element.currentStyle && element.currentStyle[name];
          if (val === '')
            val = 'auto';
        }
        val = val || element.style[name];
        if (msie <= 8) {
          val = val === '' ? undefined : val;
        }
        return val;
      }
    },
    attr: function (element, name, value) {
      var lowercasedName = lowercase(name);
      if (BOOLEAN_ATTR[lowercasedName]) {
        if (isDefined(value)) {
          if (!!value) {
            element[name] = true;
            element.setAttribute(name, lowercasedName);
          } else {
            element[name] = false;
            element.removeAttribute(lowercasedName);
          }
        } else {
          return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
        }
      } else if (isDefined(value)) {
        element.setAttribute(name, value);
      } else if (element.getAttribute) {
        var ret = element.getAttribute(name, 2);
        return ret === null ? undefined : ret;
      }
    },
    prop: function (element, name, value) {
      if (isDefined(value)) {
        element[name] = value;
      } else {
        return element[name];
      }
    },
    text: extend(msie < 9 ? function (element, value) {
      if (element.nodeType == 1) {
        if (isUndefined(value))
          return element.innerText;
        element.innerText = value;
      } else {
        if (isUndefined(value))
          return element.nodeValue;
        element.nodeValue = value;
      }
    } : function (element, value) {
      if (isUndefined(value)) {
        return element.textContent;
      }
      element.textContent = value;
    }, { $dv: '' }),
    val: function (element, value) {
      if (isUndefined(value)) {
        return element.value;
      }
      element.value = value;
    },
    html: function (element, value) {
      if (isUndefined(value)) {
        return element.innerHTML;
      }
      for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
        JQLiteDealoc(childNodes[i]);
      }
      element.innerHTML = value;
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var i, key;
      if ((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController) ? arg1 : arg2) === undefined) {
        if (isObject(arg1)) {
          for (i = 0; i < this.length; i++) {
            if (fn === JQLiteData) {
              fn(this[i], arg1);
            } else {
              for (key in arg1) {
                fn(this[i], key, arg1[key]);
              }
            }
          }
          return this;
        } else {
          if (this.length)
            return fn(this[0], arg1, arg2);
        }
      } else {
        for (i = 0; i < this.length; i++) {
          fn(this[i], arg1, arg2);
        }
        return this;
      }
      return fn.$dv;
    };
  });
  function createEventHandler(element, events) {
    var eventHandler = function (event, type) {
      if (!event.preventDefault) {
        event.preventDefault = function () {
          event.returnValue = false;
        };
      }
      if (!event.stopPropagation) {
        event.stopPropagation = function () {
          event.cancelBubble = true;
        };
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (isUndefined(event.defaultPrevented)) {
        var prevent = event.preventDefault;
        event.preventDefault = function () {
          event.defaultPrevented = true;
          prevent.call(event);
        };
        event.defaultPrevented = false;
      }
      event.isDefaultPrevented = function () {
        return event.defaultPrevented;
      };
      forEach(events[type || event.type], function (fn) {
        fn.call(element, event);
      });
      if (msie <= 8) {
        event.preventDefault = null;
        event.stopPropagation = null;
        event.isDefaultPrevented = null;
      } else {
        delete event.preventDefault;
        delete event.stopPropagation;
        delete event.isDefaultPrevented;
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }
  forEach({
    removeData: JQLiteRemoveData,
    dealoc: JQLiteDealoc,
    bind: function bindFn(element, type, fn) {
      var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
      if (!events)
        JQLiteExpandoStore(element, 'events', events = {});
      if (!handle)
        JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));
      forEach(type.split(' '), function (type) {
        var eventFns = events[type];
        if (!eventFns) {
          if (type == 'mouseenter' || type == 'mouseleave') {
            var contains = document.body.contains || document.body.compareDocumentPosition ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
              } : function (a, b) {
                if (b) {
                  while (b = b.parentNode) {
                    if (b === a) {
                      return true;
                    }
                  }
                }
                return false;
              };
            events[type] = [];
            var eventmap = {
                mouseleave: 'mouseout',
                mouseenter: 'mouseover'
              };
            bindFn(element, eventmap[type], function (event) {
              var ret, target = this, related = event.relatedTarget;
              if (!related || related !== target && !contains(target, related)) {
                handle(event, type);
              }
            });
          } else {
            addEventListenerFn(element, type, handle);
            events[type] = [];
          }
          eventFns = events[type];
        }
        eventFns.push(fn);
      });
    },
    unbind: JQLiteUnbind,
    replaceWith: function (element, replaceNode) {
      var index, parent = element.parentNode;
      JQLiteDealoc(element);
      forEach(new JQLite(replaceNode), function (node) {
        if (index) {
          parent.insertBefore(node, index.nextSibling);
        } else {
          parent.replaceChild(node, element);
        }
        index = node;
      });
    },
    children: function (element) {
      var children = [];
      forEach(element.childNodes, function (element) {
        if (element.nodeType === 1)
          children.push(element);
      });
      return children;
    },
    contents: function (element) {
      return element.childNodes || [];
    },
    append: function (element, node) {
      forEach(new JQLite(node), function (child) {
        if (element.nodeType === 1)
          element.appendChild(child);
      });
    },
    prepend: function (element, node) {
      if (element.nodeType === 1) {
        var index = element.firstChild;
        forEach(new JQLite(node), function (child) {
          if (index) {
            element.insertBefore(child, index);
          } else {
            element.appendChild(child);
            index = child;
          }
        });
      }
    },
    wrap: function (element, wrapNode) {
      wrapNode = jqLite(wrapNode)[0];
      var parent = element.parentNode;
      if (parent) {
        parent.replaceChild(wrapNode, element);
      }
      wrapNode.appendChild(element);
    },
    remove: function (element) {
      JQLiteDealoc(element);
      var parent = element.parentNode;
      if (parent)
        parent.removeChild(element);
    },
    after: function (element, newElement) {
      var index = element, parent = element.parentNode;
      forEach(new JQLite(newElement), function (node) {
        parent.insertBefore(node, index.nextSibling);
        index = node;
      });
    },
    addClass: JQLiteAddClass,
    removeClass: JQLiteRemoveClass,
    toggleClass: function (element, selector, condition) {
      if (isUndefined(condition)) {
        condition = !JQLiteHasClass(element, selector);
      }
      (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
    },
    parent: function (element) {
      var parent = element.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    next: function (element) {
      if (element.nextElementSibling) {
        return element.nextElementSibling;
      }
      var elm = element.nextSibling;
      while (elm != null && elm.nodeType !== 1) {
        elm = elm.nextSibling;
      }
      return elm;
    },
    find: function (element, selector) {
      return element.getElementsByTagName(selector);
    },
    clone: JQLiteClone,
    triggerHandler: function (element, eventName) {
      var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];
      forEach(eventFns, function (fn) {
        fn.call(element, null);
      });
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var value;
      for (var i = 0; i < this.length; i++) {
        if (value == undefined) {
          value = fn(this[i], arg1, arg2);
          if (value !== undefined) {
            value = jqLite(value);
          }
        } else {
          JQLiteAddNodes(value, fn(this[i], arg1, arg2));
        }
      }
      return value == undefined ? this : value;
    };
  });
  function hashKey(obj) {
    var objType = typeof obj, key;
    if (objType == 'object' && obj !== null) {
      if (typeof (key = obj.$$hashKey) == 'function') {
        key = obj.$$hashKey();
      } else if (key === undefined) {
        key = obj.$$hashKey = nextUid();
      }
    } else {
      key = obj;
    }
    return objType + ':' + key;
  }
  function HashMap(array) {
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function (key, value) {
      this[hashKey(key)] = value;
    },
    get: function (key) {
      return this[hashKey(key)];
    },
    remove: function (key) {
      var value = this[key = hashKey(key)];
      delete this[key];
      return value;
    }
  };
  function HashQueueMap() {
  }
  HashQueueMap.prototype = {
    push: function (key, value) {
      var array = this[key = hashKey(key)];
      if (!array) {
        this[key] = [value];
      } else {
        array.push(value);
      }
    },
    shift: function (key) {
      var array = this[key = hashKey(key)];
      if (array) {
        if (array.length == 1) {
          delete this[key];
          return array[0];
        } else {
          return array.shift();
        }
      }
    },
    peek: function (key) {
      var array = this[hashKey(key)];
      if (array) {
        return array[0];
      }
    }
  };
  var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
  function annotate(fn) {
    var $inject, fnText, argDecl, last;
    if (typeof fn == 'function') {
      if (!($inject = fn.$inject)) {
        $inject = [];
        fnText = fn.toString().replace(STRIP_COMMENTS, '');
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
          arg.replace(FN_ARG, function (all, underscore, name) {
            $inject.push(name);
          });
        });
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], 'fn');
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, 'fn', true);
    }
    return $inject;
  }
  function createInjector(modulesToLoad) {
    var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new HashMap(), providerCache = {
        $provide: {
          provider: supportObject(provider),
          factory: supportObject(factory),
          service: supportObject(service),
          value: supportObject(value),
          constant: supportObject(constant),
          decorator: decorator
        }
      }, providerInjector = createInternalInjector(providerCache, function () {
        throw Error('Unknown provider: ' + path.join(' <- '));
      }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (servicename) {
        var provider = providerInjector.get(servicename + providerSuffix);
        return instanceInjector.invoke(provider.$get, provider);
      });
    forEach(loadModules(modulesToLoad), function (fn) {
      instanceInjector.invoke(fn || noop);
    });
    return instanceInjector;
    function supportObject(delegate) {
      return function (key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }
    function provider(name, provider_) {
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw Error('Provider ' + name + ' must define $get factory method.');
      }
      return providerCache[name + providerSuffix] = provider_;
    }
    function factory(name, factoryFn) {
      return provider(name, { $get: factoryFn });
    }
    function service(name, constructor) {
      return factory(name, [
        '$injector',
        function ($injector) {
          return $injector.instantiate(constructor);
        }
      ]);
    }
    function value(name, value) {
      return factory(name, valueFn(value));
    }
    function constant(name, value) {
      providerCache[name] = value;
      instanceCache[name] = value;
    }
    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
      origProvider.$get = function () {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
      };
    }
    function loadModules(modulesToLoad) {
      var runBlocks = [];
      forEach(modulesToLoad, function (module) {
        if (loadedModules.get(module))
          return;
        loadedModules.put(module, true);
        if (isString(module)) {
          var moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
          try {
            for (var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
              var invokeArgs = invokeQueue[i], provider = invokeArgs[0] == '$injector' ? providerInjector : providerInjector.get(invokeArgs[0]);
              provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isFunction(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isArray(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + String(module[module.length - 1]);
            throw e;
          }
        } else {
          assertArgFn(module, 'module');
        }
      });
      return runBlocks;
    }
    function createInternalInjector(cache, factory) {
      function getService(serviceName) {
        if (typeof serviceName !== 'string') {
          throw Error('Service name expected');
        }
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw Error('Circular dependency: ' + path.join(' <- '));
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            return cache[serviceName] = factory(serviceName);
          } finally {
            path.shift();
          }
        }
      }
      function invoke(fn, self, locals) {
        var args = [], $inject = annotate(fn), length, i, key;
        for (i = 0, length = $inject.length; i < length; i++) {
          key = $inject[i];
          args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
        }
        if (!fn.$inject) {
          fn = fn[length];
        }
        switch (self ? -1 : args.length) {
        case 0:
          return fn();
        case 1:
          return fn(args[0]);
        case 2:
          return fn(args[0], args[1]);
        case 3:
          return fn(args[0], args[1], args[2]);
        case 4:
          return fn(args[0], args[1], args[2], args[3]);
        case 5:
          return fn(args[0], args[1], args[2], args[3], args[4]);
        case 6:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        case 8:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        case 9:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        case 10:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
        default:
          return fn.apply(self, args);
        }
      }
      function instantiate(Type, locals) {
        var Constructor = function () {
          }, instance, returnedValue;
        Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
        instance = new Constructor();
        returnedValue = invoke(Type, instance, locals);
        return isObject(returnedValue) ? returnedValue : instance;
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: annotate
      };
    }
  }
  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function () {
      autoScrollingEnabled = false;
    };
    this.$get = [
      '$window',
      '$location',
      '$rootScope',
      function ($window, $location, $rootScope) {
        var document = $window.document;
        function getFirstAnchor(list) {
          var result = null;
          forEach(list, function (element) {
            if (!result && lowercase(element.nodeName) === 'a')
              result = element;
          });
          return result;
        }
        function scroll() {
          var hash = $location.hash(), elm;
          if (!hash)
            $window.scrollTo(0, 0);
          else if (elm = document.getElementById(hash))
            elm.scrollIntoView();
          else if (elm = getFirstAnchor(document.getElementsByName(hash)))
            elm.scrollIntoView();
          else if (hash === 'top')
            $window.scrollTo(0, 0);
        }
        if (autoScrollingEnabled) {
          $rootScope.$watch(function autoScrollWatch() {
            return $location.hash();
          }, function autoScrollWatchAction() {
            $rootScope.$evalAsync(scroll);
          });
        }
        return scroll;
      }
    ];
  }
  function Browser(window, document, $log, $sniffer) {
    var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function () {
      outstandingRequestCount++;
    };
    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }
    self.notifyWhenNoOutstandingRequests = function (callback) {
      forEach(pollFns, function (pollFn) {
        pollFn();
      });
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var pollFns = [], pollTimeout;
    self.addPollFn = function (fn) {
      if (isUndefined(pollTimeout))
        startPoller(100, setTimeout);
      pollFns.push(fn);
      return fn;
    };
    function startPoller(interval, setTimeout) {
      (function check() {
        forEach(pollFns, function (pollFn) {
          pollFn();
        });
        pollTimeout = setTimeout(check, interval);
      }());
    }
    var lastBrowserUrl = location.href, baseElement = document.find('base');
    self.url = function (url, replace) {
      if (url) {
        if (lastBrowserUrl == url)
          return;
        lastBrowserUrl = url;
        if ($sniffer.history) {
          if (replace)
            history.replaceState(null, '', url);
          else {
            history.pushState(null, '', url);
            baseElement.attr('href', baseElement.attr('href'));
          }
        } else {
          if (replace)
            location.replace(url);
          else
            location.href = url;
        }
        return self;
      } else {
        return location.href.replace(/%27/g, '\'');
      }
    };
    var urlChangeListeners = [], urlChangeInit = false;
    function fireUrlChange() {
      if (lastBrowserUrl == self.url())
        return;
      lastBrowserUrl = self.url();
      forEach(urlChangeListeners, function (listener) {
        listener(self.url());
      });
    }
    self.onUrlChange = function (callback) {
      if (!urlChangeInit) {
        if ($sniffer.history)
          jqLite(window).bind('popstate', fireUrlChange);
        if ($sniffer.hashchange)
          jqLite(window).bind('hashchange', fireUrlChange);
        else
          self.addPollFn(fireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.baseHref = function () {
      var href = baseElement.attr('href');
      return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : '';
    };
    var lastCookies = {};
    var lastCookieString = '';
    var cookiePath = self.baseHref();
    self.cookies = function (name, value) {
      var cookieLength, cookieArray, cookie, i, index;
      if (name) {
        if (value === undefined) {
          rawDocument.cookie = escape(name) + '=;path=' + cookiePath + ';expires=Thu, 01 Jan 1970 00:00:00 GMT';
        } else {
          if (isString(value)) {
            cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;
            if (cookieLength > 4096) {
              $log.warn('Cookie \'' + name + '\' possibly not set or overflowed because it was too large (' + cookieLength + ' > 4096 bytes)!');
            }
          }
        }
      } else {
        if (rawDocument.cookie !== lastCookieString) {
          lastCookieString = rawDocument.cookie;
          cookieArray = lastCookieString.split('; ');
          lastCookies = {};
          for (i = 0; i < cookieArray.length; i++) {
            cookie = cookieArray[i];
            index = cookie.indexOf('=');
            if (index > 0) {
              var name = unescape(cookie.substring(0, index));
              if (lastCookies[name] === undefined) {
                lastCookies[name] = unescape(cookie.substring(index + 1));
              }
            }
          }
        }
        return lastCookies;
      }
    };
    self.defer = function (fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function () {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function (deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }
  function $BrowserProvider() {
    this.$get = [
      '$window',
      '$log',
      '$sniffer',
      '$document',
      function ($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      }
    ];
  }
  function $CacheFactoryProvider() {
    this.$get = function () {
      var caches = {};
      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw Error('cacheId ' + cacheId + ' taken');
        }
        var size = 0, stats = extend({}, options, { id: cacheId }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
        return caches[cacheId] = {
          put: function (key, value) {
            var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
            refresh(lruEntry);
            if (isUndefined(value))
              return;
            if (!(key in data))
              size++;
            data[key] = value;
            if (size > capacity) {
              this.remove(staleEnd.key);
            }
          },
          get: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            refresh(lruEntry);
            return data[key];
          },
          remove: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            if (lruEntry == freshEnd)
              freshEnd = lruEntry.p;
            if (lruEntry == staleEnd)
              staleEnd = lruEntry.n;
            link(lruEntry.n, lruEntry.p);
            delete lruHash[key];
            delete data[key];
            size--;
          },
          removeAll: function () {
            data = {};
            size = 0;
            lruHash = {};
            freshEnd = staleEnd = null;
          },
          destroy: function () {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function () {
            return extend({}, stats, { size: size });
          }
        };
        function refresh(entry) {
          if (entry != freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd == entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }
        function link(nextEntry, prevEntry) {
          if (nextEntry != prevEntry) {
            if (nextEntry)
              nextEntry.p = prevEntry;
            if (prevEntry)
              prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function () {
        var info = {};
        forEach(caches, function (cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function (cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }
  function $TemplateCacheProvider() {
    this.$get = [
      '$cacheFactory',
      function ($cacheFactory) {
        return $cacheFactory('templates');
      }
    ];
  }
  var NON_ASSIGNABLE_MODEL_EXPRESSION = 'Non-assignable model expression: ';
  $CompileProvider.$inject = ['$provide'];
  function $CompileProvider($provide) {
    var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/, MULTI_ROOT_TEMPLATE_ERROR = 'Template must have exactly one root element. was: ', urlSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/;
    this.directive = function registerDirective(name, directiveFactory) {
      if (isString(name)) {
        assertArg(directiveFactory, 'directive');
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, [
            '$injector',
            '$exceptionHandler',
            function ($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function (directiveFactory) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = { compile: valueFn(directive) };
                  } else if (!directive.compile && directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.name = directive.name || name;
                  directive.require = directive.require || directive.controller && directive.name;
                  directive.restrict = directive.restrict || 'A';
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            }
          ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.urlSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        urlSanitizationWhitelist = regexp;
        return this;
      }
      return urlSanitizationWhitelist;
    };
    this.$get = [
      '$injector',
      '$interpolate',
      '$exceptionHandler',
      '$http',
      '$templateCache',
      '$parse',
      '$controller',
      '$rootScope',
      '$document',
      function ($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document) {
        var Attributes = function (element, attr) {
          this.$$element = element;
          this.$attr = attr || {};
        };
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $set: function (key, value, writeAttr, attrName) {
            var booleanKey = getBooleanAttrName(this.$$element[0], key), $$observers = this.$$observers, normalizedVal;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, '-');
              }
            }
            if (nodeName_(this.$$element[0]) === 'A' && key === 'href') {
              urlSanitizationNode.setAttribute('href', value);
              normalizedVal = urlSanitizationNode.href;
              if (!normalizedVal.match(urlSanitizationWhitelist)) {
                this[key] = value = 'unsafe:' + normalizedVal;
              }
            }
            if (writeAttr !== false) {
              if (value === null || value === undefined) {
                this.$$element.removeAttr(attrName);
              } else {
                this.$$element.attr(attrName, value);
              }
            }
            $$observers && forEach($$observers[key], function (fn) {
              try {
                fn(value);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          },
          $observe: function (key, fn) {
            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
            listeners.push(fn);
            $rootScope.$evalAsync(function () {
              if (!listeners.$$inter) {
                fn(attrs[key]);
              }
            });
            return fn;
          }
        };
        var urlSanitizationNode = $document[0].createElement('a'), startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == '{{' || endSymbol == '}}' ? identity : function denormalizeTemplate(template) {
            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
          };
        return compile;
        function compile($compileNodes, transcludeFn, maxPriority) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          forEach($compileNodes, function (node, index) {
            if (node.nodeType == 3 && node.nodeValue.match(/\S+/)) {
              $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
            }
          });
          var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority);
          return function publicLinkFn(scope, cloneConnectFn) {
            assertArg(scope, 'scope');
            var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
            for (var i = 0, ii = $linkNode.length; i < ii; i++) {
              var node = $linkNode[i];
              if (node.nodeType == 1 || node.nodeType == 9) {
                $linkNode.eq(i).data('$scope', scope);
              }
            }
            safeAddClass($linkNode, 'ng-scope');
            if (cloneConnectFn)
              cloneConnectFn($linkNode, scope);
            if (compositeLinkFn)
              compositeLinkFn(scope, $linkNode, $linkNode);
            return $linkNode;
          };
        }
        function wrongMode(localName, mode) {
          throw Error('Unsupported \'' + mode + '\' for \'' + localName + '\'.');
        }
        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {
          }
        }
        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority) {
          var linkFns = [], nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;
          for (var i = 0; i < nodeList.length; i++) {
            attrs = new Attributes();
            directives = collectDirectives(nodeList[i], [], attrs, maxPriority);
            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement) : null;
            childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length ? null : compileNodes(nodeList[i].childNodes, nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);
            linkFns.push(nodeLinkFn);
            linkFns.push(childLinkFn);
            linkFnFound = linkFnFound || nodeLinkFn || childLinkFn;
          }
          return linkFnFound ? compositeLinkFn : null;
          function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
            var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;
            var stableNodeList = [];
            for (i = 0, ii = nodeList.length; i < ii; i++) {
              stableNodeList.push(nodeList[i]);
            }
            for (i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
              node = stableNodeList[n];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new(isObject(nodeLinkFn.scope));
                  jqLite(node).data('$scope', childScope);
                } else {
                  childScope = scope;
                }
                childTranscludeFn = nodeLinkFn.transclude;
                if (childTranscludeFn || !boundTranscludeFn && transcludeFn) {
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, function (transcludeFn) {
                    return function (cloneFn) {
                      var transcludeScope = scope.$new();
                      transcludeScope.$$transcluded = true;
                      return transcludeFn(transcludeScope, cloneFn).bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));
                    };
                  }(childTranscludeFn || transcludeFn));
                } else {
                  nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);
                }
              } else if (childLinkFn) {
                childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
              }
            }
          }
        }
        function collectDirectives(node, directives, attrs, maxPriority) {
          var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
          switch (nodeType) {
          case 1:
            addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);
            for (var attr, name, nName, value, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
              attr = nAttrs[j];
              if (attr.specified) {
                name = attr.name;
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                attrs[nName] = value = trim(msie && name == 'href' ? decodeURIComponent(node.getAttribute(name, 2)) : attr.value);
                if (getBooleanAttrName(node, nName)) {
                  attrs[nName] = true;
                }
                addAttrInterpolateDirective(node, directives, value, nName);
                addDirective(directives, nName, 'A', maxPriority);
              }
            }
            className = node.className;
            if (isString(className) && className !== '') {
              while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                nName = directiveNormalize(match[2]);
                if (addDirective(directives, nName, 'C', maxPriority)) {
                  attrs[nName] = trim(match[3]);
                }
                className = className.substr(match.index + match[0].length);
              }
            }
            break;
          case 3:
            addTextInterpolateDirective(directives, node.nodeValue);
            break;
          case 8:
            try {
              match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
              if (match) {
                nName = directiveNormalize(match[1]);
                if (addDirective(directives, nName, 'M', maxPriority)) {
                  attrs[nName] = trim(match[2]);
                }
              }
            } catch (e) {
            }
            break;
          }
          directives.sort(byPriority);
          return directives;
        }
        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection) {
          var terminalPriority = -Number.MAX_VALUE, preLinkFns = [], postLinkFns = [], newScopeDirective = null, newIsolateScopeDirective = null, templateDirective = null, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, transcludeDirective, childTranscludeFn = transcludeFn, controllerDirectives, linkFn, directiveValue;
          for (var i = 0, ii = directives.length; i < ii; i++) {
            directive = directives[i];
            $template = undefined;
            if (terminalPriority > directive.priority) {
              break;
            }
            if (directiveValue = directive.scope) {
              assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);
              if (isObject(directiveValue)) {
                safeAddClass($compileNode, 'ng-isolate-scope');
                newIsolateScopeDirective = directive;
              }
              safeAddClass($compileNode, 'ng-scope');
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (directiveValue = directive.controller) {
              controllerDirectives = controllerDirectives || {};
              assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
              controllerDirectives[directiveName] = directive;
            }
            if (directiveValue = directive.transclude) {
              assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);
              transcludeDirective = directive;
              terminalPriority = directive.priority;
              if (directiveValue == 'element') {
                $template = jqLite(compileNode);
                $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                compileNode = $compileNode[0];
                replaceWith(jqCollection, jqLite($template[0]), compileNode);
                childTranscludeFn = compile($template, transcludeFn, terminalPriority);
              } else {
                $template = jqLite(JQLiteClone(compileNode)).contents();
                $compileNode.html('');
                childTranscludeFn = compile($template, transcludeFn);
              }
            }
            if (directiveValue = directive.template) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                $template = jqLite('<div>' + trim(directiveValue) + '</div>').contents();
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== 1) {
                  throw new Error(MULTI_ROOT_TEMPLATE_ERROR + directiveValue);
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = { $attr: {} };
                directives = directives.concat(collectDirectives(compileNode, directives.splice(i + 1, directives.length - (i + 1)), newTemplateAttrs));
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), nodeLinkFn, $compileNode, templateAttrs, jqCollection, directive.replace, childTranscludeFn);
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                if (isFunction(linkFn)) {
                  addLinkFns(null, linkFn);
                } else if (linkFn) {
                  addLinkFns(linkFn.pre, linkFn.post);
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;
          nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;
          return nodeLinkFn;
          function addLinkFns(pre, post) {
            if (pre) {
              pre.require = directive.require;
              preLinkFns.push(pre);
            }
            if (post) {
              post.require = directive.require;
              postLinkFns.push(post);
            }
          }
          function getControllers(require, $element) {
            var value, retrievalMethod = 'data', optional = false;
            if (isString(require)) {
              while ((value = require.charAt(0)) == '^' || value == '?') {
                require = require.substr(1);
                if (value == '^') {
                  retrievalMethod = 'inheritedData';
                }
                optional = optional || value == '?';
              }
              value = $element[retrievalMethod]('$' + require + 'Controller');
              if (!value && !optional) {
                throw Error('No controller: ' + require);
              }
              return value;
            } else if (isArray(require)) {
              value = [];
              forEach(require, function (require) {
                value.push(getControllers(require, $element));
              });
            }
            return value;
          }
          function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
            var attrs, $element, i, ii, linkFn, controller;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
            } else {
              attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
            }
            $element = attrs.$$element;
            if (newIsolateScopeDirective) {
              var LOCAL_REGEXP = /^\s*([@=&])\s*(\w*)\s*$/;
              var parentScope = scope.$parent || scope;
              forEach(newIsolateScopeDirective.scope, function (definiton, scopeName) {
                var match = definiton.match(LOCAL_REGEXP) || [], attrName = match[2] || scopeName, mode = match[1], lastValue, parentGet, parentSet;
                scope.$$isolateBindings[scopeName] = mode + attrName;
                switch (mode) {
                case '@': {
                    attrs.$observe(attrName, function (value) {
                      scope[scopeName] = value;
                    });
                    attrs.$$observers[attrName].$$scope = parentScope;
                    break;
                  }
                case '=': {
                    parentGet = $parse(attrs[attrName]);
                    parentSet = parentGet.assign || function () {
                      lastValue = scope[scopeName] = parentGet(parentScope);
                      throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + attrs[attrName] + ' (directive: ' + newIsolateScopeDirective.name + ')');
                    };
                    lastValue = scope[scopeName] = parentGet(parentScope);
                    scope.$watch(function parentValueWatch() {
                      var parentValue = parentGet(parentScope);
                      if (parentValue !== scope[scopeName]) {
                        if (parentValue !== lastValue) {
                          lastValue = scope[scopeName] = parentValue;
                        } else {
                          parentSet(parentScope, parentValue = lastValue = scope[scopeName]);
                        }
                      }
                      return parentValue;
                    });
                    break;
                  }
                case '&': {
                    parentGet = $parse(attrs[attrName]);
                    scope[scopeName] = function (locals) {
                      return parentGet(parentScope, locals);
                    };
                    break;
                  }
                default: {
                    throw Error('Invalid isolate scope definition for directive ' + newIsolateScopeDirective.name + ': ' + definiton);
                  }
                }
              });
            }
            if (controllerDirectives) {
              forEach(controllerDirectives, function (directive) {
                var locals = {
                    $scope: scope,
                    $element: $element,
                    $attrs: attrs,
                    $transclude: boundTranscludeFn
                  };
                controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                $element.data('$' + directive.name + 'Controller', $controller(controller, locals));
              });
            }
            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
              try {
                linkFn = preLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
            childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);
            for (i = 0, ii = postLinkFns.length; i < ii; i++) {
              try {
                linkFn = postLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
          }
        }
        function addDirective(tDirectives, name, location, maxPriority) {
          var match = false;
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
              try {
                directive = directives[i];
                if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                  tDirectives.push(directive);
                  match = true;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          return match;
        }
        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
          forEach(dst, function (value, key) {
            if (key.charAt(0) != '$') {
              if (src[key]) {
                value += (key === 'style' ? ';' : ' ') + src[key];
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function (value, key) {
            if (key == 'class') {
              safeAddClass($element, value);
              dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
            } else if (key == 'style') {
              $element.attr('style', $element.attr('style') + ';' + value);
            } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
              dst[key] = value;
              dstAttr[key] = srcAttr[key];
            }
          });
        }
        function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs, $rootElement, replace, childTranscludeFn) {
          var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
              controller: null,
              templateUrl: null,
              transclude: null,
              scope: null
            });
          $compileNode.html('');
          $http.get(origAsyncDirective.templateUrl, { cache: $templateCache }).success(function (content) {
            var compileNode, tempTemplateAttrs, $template;
            content = denormalizeTemplate(content);
            if (replace) {
              $template = jqLite('<div>' + trim(content) + '</div>').contents();
              compileNode = $template[0];
              if ($template.length != 1 || compileNode.nodeType !== 1) {
                throw new Error(MULTI_ROOT_TEMPLATE_ERROR + content);
              }
              tempTemplateAttrs = { $attr: {} };
              replaceWith($rootElement, $compileNode, compileNode);
              collectDirectives(compileNode, directives, tempTemplateAttrs);
              mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
            } else {
              compileNode = beforeTemplateCompileNode;
              $compileNode.html(content);
            }
            directives.unshift(derivedSyncDirective);
            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn);
            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
            while (linkQueue.length) {
              var controller = linkQueue.pop(), linkRootElement = linkQueue.pop(), beforeTemplateLinkNode = linkQueue.pop(), scope = linkQueue.pop(), linkNode = compileNode;
              if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                linkNode = JQLiteClone(compileNode);
                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
              }
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller);
              }, scope, linkNode, $rootElement, controller);
            }
            linkQueue = null;
          }).error(function (response, code, headers, config) {
            throw Error('Failed to load template: ' + config.url);
          });
          return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {
            if (linkQueue) {
              linkQueue.push(scope);
              linkQueue.push(node);
              linkQueue.push(rootElement);
              linkQueue.push(controller);
            } else {
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);
              }, scope, node, rootElement, controller);
            }
          };
        }
        function byPriority(a, b) {
          return b.priority - a.priority;
        }
        function assertNoDuplicate(what, previousDirective, directive, element) {
          if (previousDirective) {
            throw Error('Multiple directives [' + previousDirective.name + ', ' + directive.name + '] asking for ' + what + ' on: ' + startingTag(element));
          }
        }
        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: valueFn(function textInterpolateLinkFn(scope, node) {
                var parent = node.parent(), bindings = parent.data('$binding') || [];
                bindings.push(interpolateFn);
                safeAddClass(parent.data('$binding', bindings), 'ng-binding');
                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                  node[0].nodeValue = value;
                });
              })
            });
          }
        }
        function addAttrInterpolateDirective(node, directives, value, name) {
          var interpolateFn = $interpolate(value, true);
          if (!interpolateFn)
            return;
          directives.push({
            priority: 100,
            compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {
              var $$observers = attr.$$observers || (attr.$$observers = {});
              if (name === 'class') {
                interpolateFn = $interpolate(attr[name], true);
              }
              attr[name] = undefined;
              ($$observers[name] || ($$observers[name] = [])).$$inter = true;
              (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(value) {
                attr.$set(name, value);
              });
            })
          });
        }
        function replaceWith($rootElement, $element, newNode) {
          var oldNode = $element[0], parent = oldNode.parentNode, i, ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i < ii; i++) {
              if ($rootElement[i] == oldNode) {
                $rootElement[i] = newNode;
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, oldNode);
          }
          newNode[jqLite.expando] = oldNode[jqLite.expando];
          $element[0] = newNode;
        }
      }
    ];
  }
  var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
  function directiveNormalize(name) {
    return camelCase(name.replace(PREFIX_REGEXP, ''));
  }
  function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
  }
  function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
  }
  function $ControllerProvider() {
    var controllers = {};
    this.register = function (name, constructor) {
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.$get = [
      '$injector',
      '$window',
      function ($injector, $window) {
        return function (constructor, locals) {
          if (isString(constructor)) {
            var name = constructor;
            constructor = controllers.hasOwnProperty(name) ? controllers[name] : getter(locals.$scope, name, true) || getter($window, name, true);
            assertArgFn(constructor, name, true);
          }
          return $injector.instantiate(constructor, locals);
        };
      }
    ];
  }
  function $DocumentProvider() {
    this.$get = [
      '$window',
      function (window) {
        return jqLite(window.document);
      }
    ];
  }
  function $ExceptionHandlerProvider() {
    this.$get = [
      '$log',
      function ($log) {
        return function (exception, cause) {
          $log.error.apply($log, arguments);
        };
      }
    ];
  }
  function $InterpolateProvider() {
    var startSymbol = '{{';
    var endSymbol = '}}';
    this.startSymbol = function (value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function (value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = [
      '$parse',
      function ($parse) {
        var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
        function $interpolate(text, mustHaveExpression) {
          var startIndex, endIndex, index = 0, parts = [], length = text.length, hasInterpolation = false, fn, exp, concat = [];
          while (index < length) {
            if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
              index != startIndex && parts.push(text.substring(index, startIndex));
              parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
              fn.exp = exp;
              index = endIndex + endSymbolLength;
              hasInterpolation = true;
            } else {
              index != length && parts.push(text.substring(index));
              index = length;
            }
          }
          if (!(length = parts.length)) {
            parts.push('');
            length = 1;
          }
          if (!mustHaveExpression || hasInterpolation) {
            concat.length = length;
            fn = function (context) {
              for (var i = 0, ii = length, part; i < ii; i++) {
                if (typeof (part = parts[i]) == 'function') {
                  part = part(context);
                  if (part == null || part == undefined) {
                    part = '';
                  } else if (typeof part != 'string') {
                    part = toJson(part);
                  }
                }
                concat[i] = part;
              }
              return concat.join('');
            };
            fn.exp = text;
            fn.parts = parts;
            return fn;
          }
        }
        $interpolate.startSymbol = function () {
          return startSymbol;
        };
        $interpolate.endSymbol = function () {
          return endSymbol;
        };
        return $interpolate;
      }
    ];
  }
  var URL_MATCH = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/, PATH_MATCH = /^([^\?#]*)?(\?([^#]*))?(#(.*))?$/, HASH_MATCH = PATH_MATCH, DEFAULT_PORTS = {
      'http': 80,
      'https': 443,
      'ftp': 21
    };
  function encodePath(path) {
    var segments = path.split('/'), i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join('/');
  }
  function stripHash(url) {
    return url.split('#')[0];
  }
  function matchUrl(url, obj) {
    var match = URL_MATCH.exec(url);
    match = {
      protocol: match[1],
      host: match[3],
      port: int(match[5]) || DEFAULT_PORTS[match[1]] || null,
      path: match[6] || '/',
      search: match[8],
      hash: match[10]
    };
    if (obj) {
      obj.$$protocol = match.protocol;
      obj.$$host = match.host;
      obj.$$port = match.port;
    }
    return match;
  }
  function composeProtocolHostPort(protocol, host, port) {
    return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);
  }
  function pathPrefixFromBase(basePath) {
    return basePath.substr(0, basePath.lastIndexOf('/'));
  }
  function convertToHtml5Url(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) != basePath || isUndefined(match.hash) || match.hash.indexOf(hashPrefix) !== 0) {
      return url;
    } else {
      return composeProtocolHostPort(match.protocol, match.host, match.port) + pathPrefixFromBase(basePath) + match.hash.substr(hashPrefix.length);
    }
  }
  function convertToHashbangUrl(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) == basePath && !isUndefined(match.hash) && match.hash.indexOf(hashPrefix) === 0) {
      return url;
    } else {
      var search = match.search && '?' + match.search || '', hash = match.hash && '#' + match.hash || '', pathPrefix = pathPrefixFromBase(basePath), path = match.path.substr(pathPrefix.length);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing path prefix "' + pathPrefix + '" !');
      }
      return composeProtocolHostPort(match.protocol, match.host, match.port) + basePath + '#' + hashPrefix + path + search + hash;
    }
  }
  function LocationUrl(url, pathPrefix, appBaseUrl) {
    pathPrefix = pathPrefix || '';
    this.$$parse = function (newAbsoluteUrl) {
      var match = matchUrl(newAbsoluteUrl, this);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + newAbsoluteUrl + '", missing path prefix "' + pathPrefix + '" !');
      }
      this.$$path = decodeURIComponent(match.path.substr(pathPrefix.length));
      this.$$search = parseKeyValue(match.search);
      this.$$hash = match.hash && decodeURIComponent(match.hash) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + pathPrefix + this.$$url;
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  function LocationHashbangUrl(url, hashPrefix, appBaseUrl) {
    var basePath;
    this.$$parse = function (url) {
      var match = matchUrl(url, this);
      if (match.hash && match.hash.indexOf(hashPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing hash prefix "' + hashPrefix + '" !');
      }
      basePath = match.path + (match.search ? '?' + match.search : '');
      match = HASH_MATCH.exec((match.hash || '').substr(hashPrefix.length));
      if (match[1]) {
        this.$$path = (match[1].charAt(0) == '/' ? '' : '/') + decodeURIComponent(match[1]);
      } else {
        this.$$path = '';
      }
      this.$$search = parseKeyValue(match[3]);
      this.$$hash = match[5] && decodeURIComponent(match[5]) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + basePath + (this.$$url ? '#' + hashPrefix + this.$$url : '');
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  LocationUrl.prototype = {
    $$replace: false,
    absUrl: locationGetter('$$absUrl'),
    url: function (url, replace) {
      if (isUndefined(url))
        return this.$$url;
      var match = PATH_MATCH.exec(url);
      if (match[1])
        this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1])
        this.search(match[3] || '');
      this.hash(match[5] || '', replace);
      return this;
    },
    protocol: locationGetter('$$protocol'),
    host: locationGetter('$$host'),
    port: locationGetter('$$port'),
    path: locationGetterSetter('$$path', function (path) {
      return path.charAt(0) == '/' ? path : '/' + path;
    }),
    search: function (search, paramValue) {
      if (isUndefined(search))
        return this.$$search;
      if (isDefined(paramValue)) {
        if (paramValue === null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
      } else {
        this.$$search = isString(search) ? parseKeyValue(search) : search;
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter('$$hash', identity),
    replace: function () {
      this.$$replace = true;
      return this;
    }
  };
  LocationHashbangUrl.prototype = inherit(LocationUrl.prototype);
  function LocationHashbangInHtml5Url(url, hashPrefix, appBaseUrl, baseExtra) {
    LocationHashbangUrl.apply(this, arguments);
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return appBaseUrl + baseExtra + '#' + hashPrefix + absoluteLinkUrl.substr(appBaseUrl.length);
      }
    };
  }
  LocationHashbangInHtml5Url.prototype = inherit(LocationHashbangUrl.prototype);
  function locationGetter(property) {
    return function () {
      return this[property];
    };
  }
  function locationGetterSetter(property, preprocess) {
    return function (value) {
      if (isUndefined(value))
        return this[property];
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }
  function $LocationProvider() {
    var hashPrefix = '', html5Mode = false;
    this.hashPrefix = function (prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function (mode) {
      if (isDefined(mode)) {
        html5Mode = mode;
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = [
      '$rootScope',
      '$browser',
      '$sniffer',
      '$rootElement',
      function ($rootScope, $browser, $sniffer, $rootElement) {
        var $location, basePath, pathPrefix, initUrl = $browser.url(), initUrlParts = matchUrl(initUrl), appBaseUrl;
        if (html5Mode) {
          basePath = $browser.baseHref() || '/';
          pathPrefix = pathPrefixFromBase(basePath);
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + pathPrefix + '/';
          if ($sniffer.history) {
            $location = new LocationUrl(convertToHtml5Url(initUrl, basePath, hashPrefix), pathPrefix, appBaseUrl);
          } else {
            $location = new LocationHashbangInHtml5Url(convertToHashbangUrl(initUrl, basePath, hashPrefix), hashPrefix, appBaseUrl, basePath.substr(pathPrefix.length + 1));
          }
        } else {
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + (initUrlParts.path || '') + (initUrlParts.search ? '?' + initUrlParts.search : '') + '#' + hashPrefix + '/';
          $location = new LocationHashbangUrl(initUrl, hashPrefix, appBaseUrl);
        }
        $rootElement.bind('click', function (event) {
          if (event.ctrlKey || event.metaKey || event.which == 2)
            return;
          var elm = jqLite(event.target);
          while (lowercase(elm[0].nodeName) !== 'a') {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
              return;
          }
          var absHref = elm.prop('href'), rewrittenUrl = $location.$$rewriteAppUrl(absHref);
          if (absHref && !elm.attr('target') && rewrittenUrl) {
            $location.$$parse(rewrittenUrl);
            $rootScope.$apply();
            event.preventDefault();
            window.angular['ff-684208-preventDefault'] = true;
          }
        });
        if ($location.absUrl() != initUrl) {
          $browser.url($location.absUrl(), true);
        }
        $browser.onUrlChange(function (newUrl) {
          if ($location.absUrl() != newUrl) {
            if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {
              $browser.url($location.absUrl());
              return;
            }
            $rootScope.$evalAsync(function () {
              var oldUrl = $location.absUrl();
              $location.$$parse(newUrl);
              afterLocationChange(oldUrl);
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          }
        });
        var changeCounter = 0;
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = $browser.url();
          var currentReplace = $location.$$replace;
          if (!changeCounter || oldUrl != $location.absUrl()) {
            changeCounter++;
            $rootScope.$evalAsync(function () {
              if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).defaultPrevented) {
                $location.$$parse(oldUrl);
              } else {
                $browser.url($location.absUrl(), currentReplace);
                afterLocationChange(oldUrl);
              }
            });
          }
          $location.$$replace = false;
          return changeCounter;
        });
        return $location;
        function afterLocationChange(oldUrl) {
          $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
        }
      }
    ];
  }
  function $LogProvider() {
    this.$get = [
      '$window',
      function ($window) {
        return {
          log: consoleLog('log'),
          warn: consoleLog('warn'),
          info: consoleLog('info'),
          error: consoleLog('error')
        };
        function formatError(arg) {
          if (arg instanceof Error) {
            if (arg.stack) {
              arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
            } else if (arg.sourceURL) {
              arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
            }
          }
          return arg;
        }
        function consoleLog(type) {
          var console = $window.console || {}, logFn = console[type] || console.log || noop;
          if (logFn.apply) {
            return function () {
              var args = [];
              forEach(arguments, function (arg) {
                args.push(formatError(arg));
              });
              return logFn.apply(console, args);
            };
          }
          return function (arg1, arg2) {
            logFn(arg1, arg2);
          };
        }
      }
    ];
  }
  var OPERATORS = {
      'null': function () {
        return null;
      },
      'true': function () {
        return true;
      },
      'false': function () {
        return false;
      },
      undefined: noop,
      '+': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        if (isDefined(a)) {
          if (isDefined(b)) {
            return a + b;
          }
          return a;
        }
        return isDefined(b) ? b : undefined;
      },
      '-': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
      },
      '*': function (self, locals, a, b) {
        return a(self, locals) * b(self, locals);
      },
      '/': function (self, locals, a, b) {
        return a(self, locals) / b(self, locals);
      },
      '%': function (self, locals, a, b) {
        return a(self, locals) % b(self, locals);
      },
      '^': function (self, locals, a, b) {
        return a(self, locals) ^ b(self, locals);
      },
      '=': noop,
      '==': function (self, locals, a, b) {
        return a(self, locals) == b(self, locals);
      },
      '!=': function (self, locals, a, b) {
        return a(self, locals) != b(self, locals);
      },
      '<': function (self, locals, a, b) {
        return a(self, locals) < b(self, locals);
      },
      '>': function (self, locals, a, b) {
        return a(self, locals) > b(self, locals);
      },
      '<=': function (self, locals, a, b) {
        return a(self, locals) <= b(self, locals);
      },
      '>=': function (self, locals, a, b) {
        return a(self, locals) >= b(self, locals);
      },
      '&&': function (self, locals, a, b) {
        return a(self, locals) && b(self, locals);
      },
      '||': function (self, locals, a, b) {
        return a(self, locals) || b(self, locals);
      },
      '&': function (self, locals, a, b) {
        return a(self, locals) & b(self, locals);
      },
      '|': function (self, locals, a, b) {
        return b(self, locals)(self, locals, a(self, locals));
      },
      '!': function (self, locals, a) {
        return !a(self, locals);
      }
    };
  var ESCAPE = {
      'n': '\n',
      'f': '\f',
      'r': '\r',
      't': '\t',
      'v': '\x0B',
      '\'': '\'',
      '"': '"'
    };
  function lex(text, csp) {
    var tokens = [], token, index = 0, json = [], ch, lastCh = ':';
    while (index < text.length) {
      ch = text.charAt(index);
      if (is('"\'')) {
        readString(ch);
      } else if (isNumber(ch) || is('.') && isNumber(peek())) {
        readNumber();
      } else if (isIdent(ch)) {
        readIdent();
        if (was('{,') && json[0] == '{' && (token = tokens[tokens.length - 1])) {
          token.json = token.text.indexOf('.') == -1;
        }
      } else if (is('(){}[].,;:')) {
        tokens.push({
          index: index,
          text: ch,
          json: was(':[,') && is('{[') || is('}]:,')
        });
        if (is('{['))
          json.unshift(ch);
        if (is('}]'))
          json.shift();
        index++;
      } else if (isWhitespace(ch)) {
        index++;
        continue;
      } else {
        var ch2 = ch + peek(), fn = OPERATORS[ch], fn2 = OPERATORS[ch2];
        if (fn2) {
          tokens.push({
            index: index,
            text: ch2,
            fn: fn2
          });
          index += 2;
        } else if (fn) {
          tokens.push({
            index: index,
            text: ch,
            fn: fn,
            json: was('[,:') && is('+-')
          });
          index += 1;
        } else {
          throwError('Unexpected next character ', index, index + 1);
        }
      }
      lastCh = ch;
    }
    return tokens;
    function is(chars) {
      return chars.indexOf(ch) != -1;
    }
    function was(chars) {
      return chars.indexOf(lastCh) != -1;
    }
    function peek() {
      return index + 1 < text.length ? text.charAt(index + 1) : false;
    }
    function isNumber(ch) {
      return '0' <= ch && ch <= '9';
    }
    function isWhitespace(ch) {
      return ch == ' ' || ch == '\r' || ch == '\t' || ch == '\n' || ch == '\x0B' || ch == '\xa0';
    }
    function isIdent(ch) {
      return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' == ch || ch == '$';
    }
    function isExpOperator(ch) {
      return ch == '-' || ch == '+' || isNumber(ch);
    }
    function throwError(error, start, end) {
      end = end || index;
      throw Error('Lexer Error: ' + error + ' at column' + (isDefined(start) ? 's ' + start + '-' + index + ' [' + text.substring(start, end) + ']' : ' ' + end) + ' in expression [' + text + '].');
    }
    function readNumber() {
      var number = '';
      var start = index;
      while (index < text.length) {
        var ch = lowercase(text.charAt(index));
        if (ch == '.' || isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = peek();
          if (ch == 'e' && isExpOperator(peekCh)) {
            number += ch;
          } else if (isExpOperator(ch) && peekCh && isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
            number += ch;
          } else if (isExpOperator(ch) && (!peekCh || !isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
            throwError('Invalid exponent');
          } else {
            break;
          }
        }
        index++;
      }
      number = 1 * number;
      tokens.push({
        index: start,
        text: number,
        json: true,
        fn: function () {
          return number;
        }
      });
    }
    function readIdent() {
      var ident = '', start = index, lastDot, peekIndex, methodName, ch;
      while (index < text.length) {
        ch = text.charAt(index);
        if (ch == '.' || isIdent(ch) || isNumber(ch)) {
          if (ch == '.')
            lastDot = index;
          ident += ch;
        } else {
          break;
        }
        index++;
      }
      if (lastDot) {
        peekIndex = index;
        while (peekIndex < text.length) {
          ch = text.charAt(peekIndex);
          if (ch == '(') {
            methodName = ident.substr(lastDot - start + 1);
            ident = ident.substr(0, lastDot - start);
            index = peekIndex;
            break;
          }
          if (isWhitespace(ch)) {
            peekIndex++;
          } else {
            break;
          }
        }
      }
      var token = {
          index: start,
          text: ident
        };
      if (OPERATORS.hasOwnProperty(ident)) {
        token.fn = token.json = OPERATORS[ident];
      } else {
        var getter = getterFn(ident, csp);
        token.fn = extend(function (self, locals) {
          return getter(self, locals);
        }, {
          assign: function (self, value) {
            return setter(self, ident, value);
          }
        });
      }
      tokens.push(token);
      if (methodName) {
        tokens.push({
          index: lastDot,
          text: '.',
          json: false
        });
        tokens.push({
          index: lastDot + 1,
          text: methodName,
          json: false
        });
      }
    }
    function readString(quote) {
      var start = index;
      index++;
      var string = '';
      var rawString = quote;
      var escape = false;
      while (index < text.length) {
        var ch = text.charAt(index);
        rawString += ch;
        if (escape) {
          if (ch == 'u') {
            var hex = text.substring(index + 1, index + 5);
            if (!hex.match(/[\da-f]{4}/i))
              throwError('Invalid unicode escape [\\u' + hex + ']');
            index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            if (rep) {
              string += rep;
            } else {
              string += ch;
            }
          }
          escape = false;
        } else if (ch == '\\') {
          escape = true;
        } else if (ch == quote) {
          index++;
          tokens.push({
            index: start,
            text: rawString,
            string: string,
            json: true,
            fn: function () {
              return string;
            }
          });
          return;
        } else {
          string += ch;
        }
        index++;
      }
      throwError('Unterminated quote', start);
    }
  }
  function parser(text, json, $filter, csp) {
    var ZERO = valueFn(0), value, tokens = lex(text, csp), assignment = _assignment, functionCall = _functionCall, fieldAccess = _fieldAccess, objectIndex = _objectIndex, filterChain = _filterChain;
    if (json) {
      assignment = logicalOR;
      functionCall = fieldAccess = objectIndex = filterChain = function () {
        throwError('is not valid json', {
          text: text,
          index: 0
        });
      };
      value = primary();
    } else {
      value = statements();
    }
    if (tokens.length !== 0) {
      throwError('is an unexpected token', tokens[0]);
    }
    return value;
    function throwError(msg, token) {
      throw Error('Syntax Error: Token \'' + token.text + '\' ' + msg + ' at column ' + (token.index + 1) + ' of the expression [' + text + '] starting at [' + text.substring(token.index) + '].');
    }
    function peekToken() {
      if (tokens.length === 0)
        throw Error('Unexpected end of expression: ' + text);
      return tokens[0];
    }
    function peek(e1, e2, e3, e4) {
      if (tokens.length > 0) {
        var token = tokens[0];
        var t = token.text;
        if (t == e1 || t == e2 || t == e3 || t == e4 || !e1 && !e2 && !e3 && !e4) {
          return token;
        }
      }
      return false;
    }
    function expect(e1, e2, e3, e4) {
      var token = peek(e1, e2, e3, e4);
      if (token) {
        if (json && !token.json) {
          throwError('is not valid json', token);
        }
        tokens.shift();
        return token;
      }
      return false;
    }
    function consume(e1) {
      if (!expect(e1)) {
        throwError('is unexpected, expecting [' + e1 + ']', peek());
      }
    }
    function unaryFn(fn, right) {
      return function (self, locals) {
        return fn(self, locals, right);
      };
    }
    function binaryFn(left, fn, right) {
      return function (self, locals) {
        return fn(self, locals, left, right);
      };
    }
    function statements() {
      var statements = [];
      while (true) {
        if (tokens.length > 0 && !peek('}', ')', ';', ']'))
          statements.push(filterChain());
        if (!expect(';')) {
          return statements.length == 1 ? statements[0] : function (self, locals) {
            var value;
            for (var i = 0; i < statements.length; i++) {
              var statement = statements[i];
              if (statement)
                value = statement(self, locals);
            }
            return value;
          };
        }
      }
    }
    function _filterChain() {
      var left = expression();
      var token;
      while (true) {
        if (token = expect('|')) {
          left = binaryFn(left, token.fn, filter());
        } else {
          return left;
        }
      }
    }
    function filter() {
      var token = expect();
      var fn = $filter(token.text);
      var argsFn = [];
      while (true) {
        if (token = expect(':')) {
          argsFn.push(expression());
        } else {
          var fnInvoke = function (self, locals, input) {
            var args = [input];
            for (var i = 0; i < argsFn.length; i++) {
              args.push(argsFn[i](self, locals));
            }
            return fn.apply(self, args);
          };
          return function () {
            return fnInvoke;
          };
        }
      }
    }
    function expression() {
      return assignment();
    }
    function _assignment() {
      var left = logicalOR();
      var right;
      var token;
      if (token = expect('=')) {
        if (!left.assign) {
          throwError('implies assignment but [' + text.substring(0, token.index) + '] can not be assigned to', token);
        }
        right = logicalOR();
        return function (scope, locals) {
          return left.assign(scope, right(scope, locals), locals);
        };
      } else {
        return left;
      }
    }
    function logicalOR() {
      var left = logicalAND();
      var token;
      while (true) {
        if (token = expect('||')) {
          left = binaryFn(left, token.fn, logicalAND());
        } else {
          return left;
        }
      }
    }
    function logicalAND() {
      var left = equality();
      var token;
      if (token = expect('&&')) {
        left = binaryFn(left, token.fn, logicalAND());
      }
      return left;
    }
    function equality() {
      var left = relational();
      var token;
      if (token = expect('==', '!=')) {
        left = binaryFn(left, token.fn, equality());
      }
      return left;
    }
    function relational() {
      var left = additive();
      var token;
      if (token = expect('<', '>', '<=', '>=')) {
        left = binaryFn(left, token.fn, relational());
      }
      return left;
    }
    function additive() {
      var left = multiplicative();
      var token;
      while (token = expect('+', '-')) {
        left = binaryFn(left, token.fn, multiplicative());
      }
      return left;
    }
    function multiplicative() {
      var left = unary();
      var token;
      while (token = expect('*', '/', '%')) {
        left = binaryFn(left, token.fn, unary());
      }
      return left;
    }
    function unary() {
      var token;
      if (expect('+')) {
        return primary();
      } else if (token = expect('-')) {
        return binaryFn(ZERO, token.fn, unary());
      } else if (token = expect('!')) {
        return unaryFn(token.fn, unary());
      } else {
        return primary();
      }
    }
    function primary() {
      var primary;
      if (expect('(')) {
        primary = filterChain();
        consume(')');
      } else if (expect('[')) {
        primary = arrayDeclaration();
      } else if (expect('{')) {
        primary = object();
      } else {
        var token = expect();
        primary = token.fn;
        if (!primary) {
          throwError('not a primary expression', token);
        }
      }
      var next, context;
      while (next = expect('(', '[', '.')) {
        if (next.text === '(') {
          primary = functionCall(primary, context);
          context = null;
        } else if (next.text === '[') {
          context = primary;
          primary = objectIndex(primary);
        } else if (next.text === '.') {
          context = primary;
          primary = fieldAccess(primary);
        } else {
          throwError('IMPOSSIBLE');
        }
      }
      return primary;
    }
    function _fieldAccess(object) {
      var field = expect().text;
      var getter = getterFn(field, csp);
      return extend(function (scope, locals, self) {
        return getter(self || object(scope, locals), locals);
      }, {
        assign: function (scope, value, locals) {
          return setter(object(scope, locals), field, value);
        }
      });
    }
    function _objectIndex(obj) {
      var indexFn = expression();
      consume(']');
      return extend(function (self, locals) {
        var o = obj(self, locals), i = indexFn(self, locals), v, p;
        if (!o)
          return undefined;
        v = o[i];
        if (v && v.then) {
          p = v;
          if (!('$$v' in v)) {
            p.$$v = undefined;
            p.then(function (val) {
              p.$$v = val;
            });
          }
          v = v.$$v;
        }
        return v;
      }, {
        assign: function (self, value, locals) {
          return obj(self, locals)[indexFn(self, locals)] = value;
        }
      });
    }
    function _functionCall(fn, contextGetter) {
      var argsFn = [];
      if (peekToken().text != ')') {
        do {
          argsFn.push(expression());
        } while (expect(','));
      }
      consume(')');
      return function (scope, locals) {
        var args = [], context = contextGetter ? contextGetter(scope, locals) : scope;
        for (var i = 0; i < argsFn.length; i++) {
          args.push(argsFn[i](scope, locals));
        }
        var fnPtr = fn(scope, locals, context) || noop;
        return fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
      };
    }
    function arrayDeclaration() {
      var elementFns = [];
      if (peekToken().text != ']') {
        do {
          elementFns.push(expression());
        } while (expect(','));
      }
      consume(']');
      return function (self, locals) {
        var array = [];
        for (var i = 0; i < elementFns.length; i++) {
          array.push(elementFns[i](self, locals));
        }
        return array;
      };
    }
    function object() {
      var keyValues = [];
      if (peekToken().text != '}') {
        do {
          var token = expect(), key = token.string || token.text;
          consume(':');
          var value = expression();
          keyValues.push({
            key: key,
            value: value
          });
        } while (expect(','));
      }
      consume('}');
      return function (self, locals) {
        var object = {};
        for (var i = 0; i < keyValues.length; i++) {
          var keyValue = keyValues[i];
          object[keyValue.key] = keyValue.value(self, locals);
        }
        return object;
      };
    }
  }
  function setter(obj, path, setValue) {
    var element = path.split('.');
    for (var i = 0; element.length > 1; i++) {
      var key = element.shift();
      var propertyObj = obj[key];
      if (!propertyObj) {
        propertyObj = {};
        obj[key] = propertyObj;
      }
      obj = propertyObj;
    }
    obj[element.shift()] = setValue;
    return setValue;
  }
  function getter(obj, path, bindFnToScope) {
    if (!path)
      return obj;
    var keys = path.split('.');
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope && isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }
  var getterFnCache = {};
  function cspSafeGetterFn(key0, key1, key2, key3, key4) {
    return function (scope, locals) {
      var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope, promise;
      if (pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key0];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key1 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key1];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key2 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key2];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key3 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key3];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key4 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key4];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      return pathVal;
    };
  }
  function getterFn(path, csp) {
    if (getterFnCache.hasOwnProperty(path)) {
      return getterFnCache[path];
    }
    var pathKeys = path.split('.'), pathKeysLength = pathKeys.length, fn;
    if (csp) {
      fn = pathKeysLength < 6 ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4]) : function (scope, locals) {
        var i = 0, val;
        do {
          val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++])(scope, locals);
          locals = undefined;
          scope = val;
        } while (i < pathKeysLength);
        return val;
      };
    } else {
      var code = 'var l, fn, p;\n';
      forEach(pathKeys, function (key, index) {
        code += 'if(s === null || s === undefined) return s;\n' + 'l=s;\n' + 's=' + (index ? 's' : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' + 'if (s && s.then) {\n' + ' if (!("$$v" in s)) {\n' + ' p=s;\n' + ' p.$$v = undefined;\n' + ' p.then(function(v) {p.$$v=v;});\n' + '}\n' + ' s=s.$$v\n' + '}\n';
      });
      code += 'return s;';
      fn = Function('s', 'k', code);
      fn.toString = function () {
        return code;
      };
    }
    return getterFnCache[path] = fn;
  }
  function $ParseProvider() {
    var cache = {};
    this.$get = [
      '$filter',
      '$sniffer',
      function ($filter, $sniffer) {
        return function (exp) {
          switch (typeof exp) {
          case 'string':
            return cache.hasOwnProperty(exp) ? cache[exp] : cache[exp] = parser(exp, false, $filter, $sniffer.csp);
          case 'function':
            return exp;
          default:
            return noop;
          }
        };
      }
    ];
  }
  function $QProvider() {
    this.$get = [
      '$rootScope',
      '$exceptionHandler',
      function ($rootScope, $exceptionHandler) {
        return qFactory(function (callback) {
          $rootScope.$evalAsync(callback);
        }, $exceptionHandler);
      }
    ];
  }
  function qFactory(nextTick, exceptionHandler) {
    var defer = function () {
      var pending = [], value, deferred;
      deferred = {
        resolve: function (val) {
          if (pending) {
            var callbacks = pending;
            pending = undefined;
            value = ref(val);
            if (callbacks.length) {
              nextTick(function () {
                var callback;
                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                  callback = callbacks[i];
                  value.then(callback[0], callback[1]);
                }
              });
            }
          }
        },
        reject: function (reason) {
          deferred.resolve(reject(reason));
        },
        promise: {
          then: function (callback, errback) {
            var result = defer();
            var wrappedCallback = function (value) {
              try {
                result.resolve((callback || defaultCallback)(value));
              } catch (e) {
                exceptionHandler(e);
                result.reject(e);
              }
            };
            var wrappedErrback = function (reason) {
              try {
                result.resolve((errback || defaultErrback)(reason));
              } catch (e) {
                exceptionHandler(e);
                result.reject(e);
              }
            };
            if (pending) {
              pending.push([
                wrappedCallback,
                wrappedErrback
              ]);
            } else {
              value.then(wrappedCallback, wrappedErrback);
            }
            return result.promise;
          }
        }
      };
      return deferred;
    };
    var ref = function (value) {
      if (value && value.then)
        return value;
      return {
        then: function (callback) {
          var result = defer();
          nextTick(function () {
            result.resolve(callback(value));
          });
          return result.promise;
        }
      };
    };
    var reject = function (reason) {
      return {
        then: function (callback, errback) {
          var result = defer();
          nextTick(function () {
            result.resolve((errback || defaultErrback)(reason));
          });
          return result.promise;
        }
      };
    };
    var when = function (value, callback, errback) {
      var result = defer(), done;
      var wrappedCallback = function (value) {
        try {
          return (callback || defaultCallback)(value);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      var wrappedErrback = function (reason) {
        try {
          return (errback || defaultErrback)(reason);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      nextTick(function () {
        ref(value).then(function (value) {
          if (done)
            return;
          done = true;
          result.resolve(ref(value).then(wrappedCallback, wrappedErrback));
        }, function (reason) {
          if (done)
            return;
          done = true;
          result.resolve(wrappedErrback(reason));
        });
      });
      return result.promise;
    };
    function defaultCallback(value) {
      return value;
    }
    function defaultErrback(reason) {
      return reject(reason);
    }
    function all(promises) {
      var deferred = defer(), counter = promises.length, results = [];
      if (counter) {
        forEach(promises, function (promise, index) {
          ref(promise).then(function (value) {
            if (index in results)
              return;
            results[index] = value;
            if (!--counter)
              deferred.resolve(results);
          }, function (reason) {
            if (index in results)
              return;
            deferred.reject(reason);
          });
        });
      } else {
        deferred.resolve(results);
      }
      return deferred.promise;
    }
    return {
      defer: defer,
      reject: reject,
      when: when,
      all: all
    };
  }
  function $RouteProvider() {
    var routes = {};
    this.when = function (path, route) {
      routes[path] = extend({ reloadOnSearch: true }, route);
      if (path) {
        var redirectPath = path[path.length - 1] == '/' ? path.substr(0, path.length - 1) : path + '/';
        routes[redirectPath] = { redirectTo: path };
      }
      return this;
    };
    this.otherwise = function (params) {
      this.when(null, params);
      return this;
    };
    this.$get = [
      '$rootScope',
      '$location',
      '$routeParams',
      '$q',
      '$injector',
      '$http',
      '$templateCache',
      function ($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache) {
        var forceReload = false, $route = {
            routes: routes,
            reload: function () {
              forceReload = true;
              $rootScope.$evalAsync(updateRoute);
            }
          };
        $rootScope.$on('$locationChangeSuccess', updateRoute);
        return $route;
        function switchRouteMatcher(on, when) {
          when = '^' + when.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '$';
          var regex = '', params = [], dst = {};
          var re = /:(\w+)/g, paramMatch, lastMatchedIndex = 0;
          while ((paramMatch = re.exec(when)) !== null) {
            regex += when.slice(lastMatchedIndex, paramMatch.index);
            regex += '([^\\/]*)';
            params.push(paramMatch[1]);
            lastMatchedIndex = re.lastIndex;
          }
          regex += when.substr(lastMatchedIndex);
          var match = on.match(new RegExp(regex));
          if (match) {
            forEach(params, function (name, index) {
              dst[name] = match[index + 1];
            });
          }
          return match ? dst : null;
        }
        function updateRoute() {
          var next = parseRoute(), last = $route.current;
          if (next && last && next.$$route === last.$$route && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {
            last.params = next.params;
            copy(last.params, $routeParams);
            $rootScope.$broadcast('$routeUpdate', last);
          } else if (next || last) {
            forceReload = false;
            $rootScope.$broadcast('$routeChangeStart', next, last);
            $route.current = next;
            if (next) {
              if (next.redirectTo) {
                if (isString(next.redirectTo)) {
                  $location.path(interpolate(next.redirectTo, next.params)).search(next.params).replace();
                } else {
                  $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search())).replace();
                }
              }
            }
            $q.when(next).then(function () {
              if (next) {
                var keys = [], values = [], template;
                forEach(next.resolve || {}, function (value, key) {
                  keys.push(key);
                  values.push(isString(value) ? $injector.get(value) : $injector.invoke(value));
                });
                if (isDefined(template = next.template)) {
                } else if (isDefined(template = next.templateUrl)) {
                  template = $http.get(template, { cache: $templateCache }).then(function (response) {
                    return response.data;
                  });
                }
                if (isDefined(template)) {
                  keys.push('$template');
                  values.push(template);
                }
                return $q.all(values).then(function (values) {
                  var locals = {};
                  forEach(values, function (value, index) {
                    locals[keys[index]] = value;
                  });
                  return locals;
                });
              }
            }).then(function (locals) {
              if (next == $route.current) {
                if (next) {
                  next.locals = locals;
                  copy(next.params, $routeParams);
                }
                $rootScope.$broadcast('$routeChangeSuccess', next, last);
              }
            }, function (error) {
              if (next == $route.current) {
                $rootScope.$broadcast('$routeChangeError', next, last, error);
              }
            });
          }
        }
        function parseRoute() {
          var params, match;
          forEach(routes, function (route, path) {
            if (!match && (params = switchRouteMatcher($location.path(), path))) {
              match = inherit(route, {
                params: extend({}, $location.search(), params),
                pathParams: params
              });
              match.$$route = route;
            }
          });
          return match || routes[null] && inherit(routes[null], {
            params: {},
            pathParams: {}
          });
        }
        function interpolate(string, params) {
          var result = [];
          forEach((string || '').split(':'), function (segment, i) {
            if (i == 0) {
              result.push(segment);
            } else {
              var segmentMatch = segment.match(/(\w+)(.*)/);
              var key = segmentMatch[1];
              result.push(params[key]);
              result.push(segmentMatch[2] || '');
              delete params[key];
            }
          });
          return result.join('');
        }
      }
    ];
  }
  function $RouteParamsProvider() {
    this.$get = valueFn({});
  }
  function $RootScopeProvider() {
    var TTL = 10;
    this.digestTtl = function (value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };
    this.$get = [
      '$injector',
      '$exceptionHandler',
      '$parse',
      function ($injector, $exceptionHandler, $parse) {
        function Scope() {
          this.$id = nextUid();
          this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          this['this'] = this.$root = this;
          this.$$destroyed = false;
          this.$$asyncQueue = [];
          this.$$listeners = {};
          this.$$isolateBindings = {};
        }
        Scope.prototype = {
          $new: function (isolate) {
            var Child, child;
            if (isFunction(isolate)) {
              throw Error('API-CHANGE: Use $controller to instantiate controllers.');
            }
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              Child = function () {
              };
              Child.prototype = this;
              child = new Child();
              child.$id = nextUid();
            }
            child['this'] = child;
            child.$$listeners = {};
            child.$parent = this;
            child.$$asyncQueue = [];
            child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
            child.$$prevSibling = this.$$childTail;
            if (this.$$childHead) {
              this.$$childTail.$$nextSibling = child;
              this.$$childTail = child;
            } else {
              this.$$childHead = this.$$childTail = child;
            }
            return child;
          },
          $watch: function (watchExp, listener, objectEquality) {
            var scope = this, get = compileToFn(watchExp, 'watch'), array = scope.$$watchers, watcher = {
                fn: listener,
                last: initWatchVal,
                get: get,
                exp: watchExp,
                eq: !!objectEquality
              };
            if (!isFunction(listener)) {
              var listenFn = compileToFn(listener || noop, 'listener');
              watcher.fn = function (newVal, oldVal, scope) {
                listenFn(scope);
              };
            }
            if (!array) {
              array = scope.$$watchers = [];
            }
            array.unshift(watcher);
            return function () {
              arrayRemove(array, watcher);
            };
          },
          $digest: function () {
            var watch, value, last, watchers, asyncQueue, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg;
            beginPhase('$digest');
            do {
              dirty = false;
              current = target;
              do {
                asyncQueue = current.$$asyncQueue;
                while (asyncQueue.length) {
                  try {
                    current.$eval(asyncQueue.shift());
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (watchers = current.$$watchers) {
                  length = watchers.length;
                  while (length--) {
                    try {
                      watch = watchers[length];
                      if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value == 'number' && typeof last == 'number' && isNaN(value) && isNaN(last))) {
                        dirty = true;
                        watch.last = watch.eq ? copy(value) : value;
                        watch.fn(value, last === initWatchVal ? value : last, current);
                        if (ttl < 5) {
                          logIdx = 4 - ttl;
                          if (!watchLog[logIdx])
                            watchLog[logIdx] = [];
                          logMsg = isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp;
                          logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                          watchLog[logIdx].push(logMsg);
                        }
                      }
                    } catch (e) {
                      $exceptionHandler(e);
                    }
                  }
                }
                if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              } while (current = next);
              if (dirty && !ttl--) {
                clearPhase();
                throw Error(TTL + ' $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: ' + toJson(watchLog));
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
          },
          $destroy: function () {
            if ($rootScope == this || this.$$destroyed)
              return;
            var parent = this.$parent;
            this.$broadcast('$destroy');
            this.$$destroyed = true;
            if (parent.$$childHead == this)
              parent.$$childHead = this.$$nextSibling;
            if (parent.$$childTail == this)
              parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling)
              this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling)
              this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          },
          $eval: function (expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function (expr) {
            this.$$asyncQueue.push(expr);
          },
          $apply: function (expr) {
            try {
              beginPhase('$apply');
              return this.$eval(expr);
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              clearPhase();
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $on: function (name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            return function () {
              namedListeners[indexOf(namedListeners, listener)] = null;
            };
          },
          $emit: function (name, args) {
            var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                name: name,
                targetScope: scope,
                stopPropagation: function () {
                  stopPropagation = true;
                },
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), i, length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i < length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                  if (stopPropagation)
                    return event;
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              scope = scope.$parent;
            } while (scope);
            return event;
          },
          $broadcast: function (name, args) {
            var target = this, current = target, next = target, event = {
                name: name,
                targetScope: target,
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), listeners, i, length;
            do {
              current = next;
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i < length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            } while (current = next);
            return event;
          }
        };
        var $rootScope = new Scope();
        return $rootScope;
        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw Error($rootScope.$$phase + ' already in progress');
          }
          $rootScope.$$phase = phase;
        }
        function clearPhase() {
          $rootScope.$$phase = null;
        }
        function compileToFn(exp, name) {
          var fn = $parse(exp);
          assertArgFn(fn, name);
          return fn;
        }
        function initWatchVal() {
        }
      }
    ];
  }
  function $SnifferProvider() {
    this.$get = [
      '$window',
      function ($window) {
        var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase($window.navigator.userAgent)) || [])[1]);
        return {
          history: !!($window.history && $window.history.pushState && !(android < 4)),
          hashchange: 'onhashchange' in $window && (!$window.document.documentMode || $window.document.documentMode > 7),
          hasEvent: function (event) {
            if (event == 'input' && msie == 9)
              return false;
            if (isUndefined(eventSupport[event])) {
              var divElm = $window.document.createElement('div');
              eventSupport[event] = 'on' + event in divElm;
            }
            return eventSupport[event];
          },
          csp: false
        };
      }
    ];
  }
  function $WindowProvider() {
    this.$get = valueFn(window);
  }
  function parseHeaders(headers) {
    var parsed = {}, key, val, i;
    if (!headers)
      return parsed;
    forEach(headers.split('\n'), function (line) {
      i = line.indexOf(':');
      key = lowercase(trim(line.substr(0, i)));
      val = trim(line.substr(i + 1));
      if (key) {
        if (parsed[key]) {
          parsed[key] += ', ' + val;
        } else {
          parsed[key] = val;
        }
      }
    });
    return parsed;
  }
  function headersGetter(headers) {
    var headersObj = isObject(headers) ? headers : undefined;
    return function (name) {
      if (!headersObj)
        headersObj = parseHeaders(headers);
      if (name) {
        return headersObj[lowercase(name)] || null;
      }
      return headersObj;
    };
  }
  function transformData(data, headers, fns) {
    if (isFunction(fns))
      return fns(data, headers);
    forEach(fns, function (fn) {
      data = fn(data, headers);
    });
    return data;
  }
  function isSuccess(status) {
    return 200 <= status && status < 300;
  }
  function $HttpProvider() {
    var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/;
    var $config = this.defaults = {
        transformResponse: [function (data) {
            if (isString(data)) {
              data = data.replace(PROTECTION_PREFIX, '');
              if (JSON_START.test(data) && JSON_END.test(data))
                data = fromJson(data, true);
            }
            return data;
          }],
        transformRequest: [function (d) {
            return isObject(d) && !isFile(d) ? toJson(d) : d;
          }],
        headers: {
          common: {
            'Accept': 'application/json, text/plain, */*',
            'X-Requested-With': 'XMLHttpRequest'
          },
          post: { 'Content-Type': 'application/json;charset=utf-8' },
          put: { 'Content-Type': 'application/json;charset=utf-8' }
        }
      };
    var providerResponseInterceptors = this.responseInterceptors = [];
    this.$get = [
      '$httpBackend',
      '$browser',
      '$cacheFactory',
      '$rootScope',
      '$q',
      '$injector',
      function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
        var defaultCache = $cacheFactory('$http'), responseInterceptors = [];
        forEach(providerResponseInterceptors, function (interceptor) {
          responseInterceptors.push(isString(interceptor) ? $injector.get(interceptor) : $injector.invoke(interceptor));
        });
        function $http(config) {
          config.method = uppercase(config.method);
          var reqTransformFn = config.transformRequest || $config.transformRequest, respTransformFn = config.transformResponse || $config.transformResponse, defHeaders = $config.headers, reqHeaders = extend({ 'X-XSRF-TOKEN': $browser.cookies()['XSRF-TOKEN'] }, defHeaders.common, defHeaders[lowercase(config.method)], config.headers), reqData = transformData(config.data, headersGetter(reqHeaders), reqTransformFn), promise;
          if (isUndefined(config.data)) {
            delete reqHeaders['Content-Type'];
          }
          promise = sendReq(config, reqData, reqHeaders);
          promise = promise.then(transformResponse, transformResponse);
          forEach(responseInterceptors, function (interceptor) {
            promise = interceptor(promise);
          });
          promise.success = function (fn) {
            promise.then(function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          promise.error = function (fn) {
            promise.then(null, function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          return promise;
          function transformResponse(response) {
            var resp = extend({}, response, { data: transformData(response.data, response.headers, respTransformFn) });
            return isSuccess(response.status) ? resp : $q.reject(resp);
          }
        }
        $http.pendingRequests = [];
        createShortMethods('get', 'delete', 'head', 'jsonp');
        createShortMethodsWithData('post', 'put');
        $http.defaults = $config;
        return $http;
        function createShortMethods(names) {
          forEach(arguments, function (name) {
            $http[name] = function (url, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url
              }));
            };
          });
        }
        function createShortMethodsWithData(name) {
          forEach(arguments, function (name) {
            $http[name] = function (url, data, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url,
                data: data
              }));
            };
          });
        }
        function sendReq(config, reqData, reqHeaders) {
          var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, url = buildUrl(config.url, config.params);
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if (config.cache && config.method == 'GET') {
            cache = isObject(config.cache) ? config.cache : defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (cachedResp) {
              if (cachedResp.then) {
                cachedResp.then(removePendingReq, removePendingReq);
                return cachedResp;
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
                } else {
                  resolvePromise(cachedResp, 200, {});
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (!cachedResp) {
            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials);
          }
          return promise;
          function done(status, response, headersString) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [
                  status,
                  response,
                  parseHeaders(headersString)
                ]);
              } else {
                cache.remove(url);
              }
            }
            resolvePromise(response, status, headersString);
            $rootScope.$apply();
          }
          function resolvePromise(response, status, headers) {
            status = Math.max(status, 0);
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config
            });
          }
          function removePendingReq() {
            var idx = indexOf($http.pendingRequests, config);
            if (idx !== -1)
              $http.pendingRequests.splice(idx, 1);
          }
        }
        function buildUrl(url, params) {
          if (!params)
            return url;
          var parts = [];
          forEachSorted(params, function (value, key) {
            if (value == null || value == undefined)
              return;
            if (isObject(value)) {
              value = toJson(value);
            }
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
          });
          return url + (url.indexOf('?') == -1 ? '?' : '&') + parts.join('&');
        }
      }
    ];
  }
  var XHR = window.XMLHttpRequest || function () {
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.6.0');
      } catch (e1) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.3.0');
      } catch (e2) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP');
      } catch (e3) {
      }
      throw new Error('This browser does not support XMLHttpRequest.');
    };
  function $HttpBackendProvider() {
    this.$get = [
      '$browser',
      '$window',
      '$document',
      function ($browser, $window, $document) {
        return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks, $document[0], $window.location.protocol.replace(':', ''));
      }
    ];
  }
  function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {
    return function (method, url, post, callback, headers, timeout, withCredentials) {
      $browser.$$incOutstandingRequestCount();
      url = url || $browser.url();
      if (lowercase(method) == 'jsonp') {
        var callbackId = '_' + (callbacks.counter++).toString(36);
        callbacks[callbackId] = function (data) {
          callbacks[callbackId].data = data;
        };
        jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), function () {
          if (callbacks[callbackId].data) {
            completeRequest(callback, 200, callbacks[callbackId].data);
          } else {
            completeRequest(callback, -2);
          }
          delete callbacks[callbackId];
        });
      } else {
        var xhr = new XHR();
        xhr.open(method, url, true);
        forEach(headers, function (value, key) {
          if (value)
            xhr.setRequestHeader(key, value);
        });
        var status;
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4) {
            var responseHeaders = xhr.getAllResponseHeaders();
            var value, simpleHeaders = [
                'Cache-Control',
                'Content-Language',
                'Content-Type',
                'Expires',
                'Last-Modified',
                'Pragma'
              ];
            if (!responseHeaders) {
              responseHeaders = '';
              forEach(simpleHeaders, function (header) {
                var value = xhr.getResponseHeader(header);
                if (value) {
                  responseHeaders += header + ': ' + value + '\n';
                }
              });
            }
            completeRequest(callback, status || xhr.status, xhr.responseText, responseHeaders);
          }
        };
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        xhr.send(post || '');
        if (timeout > 0) {
          $browserDefer(function () {
            status = -1;
            xhr.abort();
          }, timeout);
        }
      }
      function completeRequest(callback, status, response, headersString) {
        var protocol = (url.match(URL_MATCH) || [
            '',
            locationProtocol
          ])[1];
        status = protocol == 'file' ? response ? 200 : 404 : status;
        status = status == 1223 ? 204 : status;
        callback(status, response, headersString);
        $browser.$$completeOutstandingRequest(noop);
      }
    };
    function jsonpReq(url, done) {
      var script = rawDocument.createElement('script'), doneWrapper = function () {
          rawDocument.body.removeChild(script);
          if (done)
            done();
        };
      script.type = 'text/javascript';
      script.src = url;
      if (msie) {
        script.onreadystatechange = function () {
          if (/loaded|complete/.test(script.readyState))
            doneWrapper();
        };
      } else {
        script.onload = script.onerror = doneWrapper;
      }
      rawDocument.body.appendChild(script);
    }
  }
  function $LocaleProvider() {
    this.$get = function () {
      return {
        id: 'en-us',
        NUMBER_FORMATS: {
          DECIMAL_SEP: '.',
          GROUP_SEP: ',',
          PATTERNS: [
            {
              minInt: 1,
              minFrac: 0,
              maxFrac: 3,
              posPre: '',
              posSuf: '',
              negPre: '-',
              negSuf: '',
              gSize: 3,
              lgSize: 3
            },
            {
              minInt: 1,
              minFrac: 2,
              maxFrac: 2,
              posPre: '\xa4',
              posSuf: '',
              negPre: '(\xa4',
              negSuf: ')',
              gSize: 3,
              lgSize: 3
            }
          ],
          CURRENCY_SYM: '$'
        },
        DATETIME_FORMATS: {
          MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
          SHORTMONTH: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
          DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
          SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
          AMPMS: [
            'AM',
            'PM'
          ],
          medium: 'MMM d, y h:mm:ss a',
          short: 'M/d/yy h:mm a',
          fullDate: 'EEEE, MMMM d, y',
          longDate: 'MMMM d, y',
          mediumDate: 'MMM d, y',
          shortDate: 'M/d/yy',
          mediumTime: 'h:mm:ss a',
          shortTime: 'h:mm a'
        },
        pluralCat: function (num) {
          if (num === 1) {
            return 'one';
          }
          return 'other';
        }
      };
    };
  }
  function $TimeoutProvider() {
    this.$get = [
      '$rootScope',
      '$browser',
      '$q',
      '$exceptionHandler',
      function ($rootScope, $browser, $q, $exceptionHandler) {
        var deferreds = {};
        function timeout(fn, delay, invokeApply) {
          var deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply, timeoutId, cleanup;
          timeoutId = $browser.defer(function () {
            try {
              deferred.resolve(fn());
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            }
            if (!skipApply)
              $rootScope.$apply();
          }, delay);
          cleanup = function () {
            delete deferreds[promise.$$timeoutId];
          };
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          promise.then(cleanup, cleanup);
          return promise;
        }
        timeout.cancel = function (promise) {
          if (promise && promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].reject('canceled');
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      }
    ];
  }
  $FilterProvider.$inject = ['$provide'];
  function $FilterProvider($provide) {
    var suffix = 'Filter';
    function register(name, factory) {
      return $provide.factory(name + suffix, factory);
    }
    this.register = register;
    this.$get = [
      '$injector',
      function ($injector) {
        return function (name) {
          return $injector.get(name + suffix);
        };
      }
    ];
    register('currency', currencyFilter);
    register('date', dateFilter);
    register('filter', filterFilter);
    register('json', jsonFilter);
    register('limitTo', limitToFilter);
    register('lowercase', lowercaseFilter);
    register('number', numberFilter);
    register('orderBy', orderByFilter);
    register('uppercase', uppercaseFilter);
  }
  function filterFilter() {
    return function (array, expression) {
      if (!isArray(array))
        return array;
      var predicates = [];
      predicates.check = function (value) {
        for (var j = 0; j < predicates.length; j++) {
          if (!predicates[j](value)) {
            return false;
          }
        }
        return true;
      };
      var search = function (obj, text) {
        if (text.charAt(0) === '!') {
          return !search(obj, text.substr(1));
        }
        switch (typeof obj) {
        case 'boolean':
        case 'number':
        case 'string':
          return ('' + obj).toLowerCase().indexOf(text) > -1;
        case 'object':
          for (var objKey in obj) {
            if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
              return true;
            }
          }
          return false;
        case 'array':
          for (var i = 0; i < obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;
        default:
          return false;
        }
      };
      switch (typeof expression) {
      case 'boolean':
      case 'number':
      case 'string':
        expression = { $: expression };
      case 'object':
        for (var key in expression) {
          if (key == '$') {
            (function () {
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(value, text);
              });
            }());
          } else {
            (function () {
              var path = key;
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(getter(value, path), text);
              });
            }());
          }
        }
        break;
      case 'function':
        predicates.push(expression);
        break;
      default:
        return array;
      }
      var filtered = [];
      for (var j = 0; j < array.length; j++) {
        var value = array[j];
        if (predicates.check(value)) {
          filtered.push(value);
        }
      }
      return filtered;
    };
  }
  currencyFilter.$inject = ['$locale'];
  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (amount, currencySymbol) {
      if (isUndefined(currencySymbol))
        currencySymbol = formats.CURRENCY_SYM;
      return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = ['$locale'];
  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (number, fractionSize) {
      return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
    };
  }
  var DECIMAL_SEP = '.';
  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (isNaN(number) || !isFinite(number))
      return '';
    var isNegative = number < 0;
    number = Math.abs(number);
    var numStr = number + '', formatedText = '', parts = [];
    var hasExponent = false;
    if (numStr.indexOf('e') !== -1) {
      var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
      if (match && match[2] == '-' && match[3] > fractionSize + 1) {
        numStr = '0';
      } else {
        formatedText = numStr;
        hasExponent = true;
      }
    }
    if (!hasExponent) {
      var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
      if (isUndefined(fractionSize)) {
        fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
      }
      var pow = Math.pow(10, fractionSize);
      number = Math.round(number * pow) / pow;
      var fraction = ('' + number).split(DECIMAL_SEP);
      var whole = fraction[0];
      fraction = fraction[1] || '';
      var pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
      if (whole.length >= lgroup + group) {
        pos = whole.length - lgroup;
        for (var i = 0; i < pos; i++) {
          if ((pos - i) % group === 0 && i !== 0) {
            formatedText += groupSep;
          }
          formatedText += whole.charAt(i);
        }
      }
      for (i = pos; i < whole.length; i++) {
        if ((whole.length - i) % lgroup === 0 && i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
      while (fraction.length < fractionSize) {
        fraction += '0';
      }
      if (fractionSize && fractionSize !== '0')
        formatedText += decimalSep + fraction.substr(0, fractionSize);
    }
    parts.push(isNegative ? pattern.negPre : pattern.posPre);
    parts.push(formatedText);
    parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
    return parts.join('');
  }
  function padNumber(num, digits, trim) {
    var neg = '';
    if (num < 0) {
      neg = '-';
      num = -num;
    }
    num = '' + num;
    while (num.length < digits)
      num = '0' + num;
    if (trim)
      num = num.substr(num.length - digits);
    return neg + num;
  }
  function dateGetter(name, size, offset, trim) {
    offset = offset || 0;
    return function (date) {
      var value = date['get' + name]();
      if (offset > 0 || value > -offset)
        value += offset;
      if (value === 0 && offset == -12)
        value = 12;
      return padNumber(value, size, trim);
    };
  }
  function dateStrGetter(name, shortForm) {
    return function (date, formats) {
      var value = date['get' + name]();
      var get = uppercase(shortForm ? 'SHORT' + name : name);
      return formats[get][value];
    };
  }
  function timeZoneGetter(date) {
    var zone = -1 * date.getTimezoneOffset();
    var paddedZone = zone >= 0 ? '+' : '';
    paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }
  function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }
  var DATE_FORMATS = {
      yyyy: dateGetter('FullYear', 4),
      yy: dateGetter('FullYear', 2, 0, true),
      y: dateGetter('FullYear', 1),
      MMMM: dateStrGetter('Month'),
      MMM: dateStrGetter('Month', true),
      MM: dateGetter('Month', 2, 1),
      M: dateGetter('Month', 1, 1),
      dd: dateGetter('Date', 2),
      d: dateGetter('Date', 1),
      HH: dateGetter('Hours', 2),
      H: dateGetter('Hours', 1),
      hh: dateGetter('Hours', 2, -12),
      h: dateGetter('Hours', 1, -12),
      mm: dateGetter('Minutes', 2),
      m: dateGetter('Minutes', 1),
      ss: dateGetter('Seconds', 2),
      s: dateGetter('Seconds', 1),
      EEEE: dateStrGetter('Day'),
      EEE: dateStrGetter('Day', true),
      a: ampmGetter,
      Z: timeZoneGetter
    };
  var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\d+$/;
  dateFilter.$inject = ['$locale'];
  function dateFilter($locale) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    function jsonStringToDate(string) {
      var match;
      if (match = string.match(R_ISO8601_STR)) {
        var date = new Date(0), tzHour = 0, tzMin = 0;
        if (match[9]) {
          tzHour = int(match[9] + match[10]);
          tzMin = int(match[9] + match[11]);
        }
        date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));
        date.setUTCHours(int(match[4] || 0) - tzHour, int(match[5] || 0) - tzMin, int(match[6] || 0), int(match[7] || 0));
        return date;
      }
      return string;
    }
    return function (date, format) {
      var text = '', parts = [], fn, match;
      format = format || 'mediumDate';
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        if (NUMBER_STRING.test(date)) {
          date = int(date);
        } else {
          date = jsonStringToDate(date);
        }
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date)) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      forEach(parts, function (value) {
        fn = DATE_FORMATS[value];
        text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
      });
      return text;
    };
  }
  function jsonFilter() {
    return function (object) {
      return toJson(object, true);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);
  function limitToFilter() {
    return function (array, limit) {
      if (!(array instanceof Array))
        return array;
      limit = int(limit);
      var out = [], i, n;
      if (!array || !(array instanceof Array))
        return out;
      if (limit > array.length)
        limit = array.length;
      else if (limit < -array.length)
        limit = -array.length;
      if (limit > 0) {
        i = 0;
        n = limit;
      } else {
        i = array.length + limit;
        n = array.length;
      }
      for (; i < n; i++) {
        out.push(array[i]);
      }
      return out;
    };
  }
  orderByFilter.$inject = ['$parse'];
  function orderByFilter($parse) {
    return function (array, sortPredicate, reverseOrder) {
      if (!isArray(array))
        return array;
      if (!sortPredicate)
        return array;
      sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate];
      sortPredicate = map(sortPredicate, function (predicate) {
        var descending = false, get = predicate || identity;
        if (isString(predicate)) {
          if (predicate.charAt(0) == '+' || predicate.charAt(0) == '-') {
            descending = predicate.charAt(0) == '-';
            predicate = predicate.substring(1);
          }
          get = $parse(predicate);
        }
        return reverseComparator(function (a, b) {
          return compare(get(a), get(b));
        }, descending);
      });
      var arrayCopy = [];
      for (var i = 0; i < array.length; i++) {
        arrayCopy.push(array[i]);
      }
      return arrayCopy.sort(reverseComparator(comparator, reverseOrder));
      function comparator(o1, o2) {
        for (var i = 0; i < sortPredicate.length; i++) {
          var comp = sortPredicate[i](o1, o2);
          if (comp !== 0)
            return comp;
        }
        return 0;
      }
      function reverseComparator(comp, descending) {
        return toBoolean(descending) ? function (a, b) {
          return comp(b, a);
        } : comp;
      }
      function compare(v1, v2) {
        var t1 = typeof v1;
        var t2 = typeof v2;
        if (t1 == t2) {
          if (t1 == 'string')
            v1 = v1.toLowerCase();
          if (t1 == 'string')
            v2 = v2.toLowerCase();
          if (v1 === v2)
            return 0;
          return v1 < v2 ? -1 : 1;
        } else {
          return t1 < t2 ? -1 : 1;
        }
      }
    };
  }
  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = { link: directive };
    }
    directive.restrict = directive.restrict || 'AC';
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
      restrict: 'E',
      compile: function (element, attr) {
        if (msie <= 8) {
          if (!attr.href && !attr.name) {
            attr.$set('href', '');
          }
          element.append(document.createComment('IE fix'));
        }
        return function (scope, element) {
          element.bind('click', function (event) {
            if (!element.attr('href')) {
              event.preventDefault();
            }
          });
        };
      }
    });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function (propName, attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 100,
        compile: function () {
          return function (scope, element, attr) {
            scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
              attr.$set(attrName, !!value);
            });
          };
        }
      };
    };
  });
  forEach([
    'src',
    'href'
  ], function (attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 99,
        link: function (scope, element, attr) {
          attr.$observe(normalized, function (value) {
            if (!value)
              return;
            attr.$set(attrName, value);
            if (msie)
              element.prop(attrName, attr[attrName]);
          });
        }
      };
    };
  });
  var nullFormCtrl = {
      $addControl: noop,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop
    };
  FormController.$inject = [
    '$element',
    '$attrs',
    '$scope'
  ];
  function FormController(element, attrs) {
    var form = this, parentForm = element.parent().controller('form') || nullFormCtrl, invalidCount = 0, errors = form.$error = {};
    form.$name = attrs.name;
    form.$dirty = false;
    form.$pristine = true;
    form.$valid = true;
    form.$invalid = false;
    parentForm.$addControl(form);
    element.addClass(PRISTINE_CLASS);
    toggleValidCss(true);
    function toggleValidCss(isValid, validationErrorKey) {
      validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
      element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
    }
    form.$addControl = function (control) {
      if (control.$name && !form.hasOwnProperty(control.$name)) {
        form[control.$name] = control;
      }
    };
    form.$removeControl = function (control) {
      if (control.$name && form[control.$name] === control) {
        delete form[control.$name];
      }
      forEach(errors, function (queue, validationToken) {
        form.$setValidity(validationToken, true, control);
      });
    };
    form.$setValidity = function (validationToken, isValid, control) {
      var queue = errors[validationToken];
      if (isValid) {
        if (queue) {
          arrayRemove(queue, control);
          if (!queue.length) {
            invalidCount--;
            if (!invalidCount) {
              toggleValidCss(isValid);
              form.$valid = true;
              form.$invalid = false;
            }
            errors[validationToken] = false;
            toggleValidCss(true, validationToken);
            parentForm.$setValidity(validationToken, true, form);
          }
        }
      } else {
        if (!invalidCount) {
          toggleValidCss(isValid);
        }
        if (queue) {
          if (includes(queue, control))
            return;
        } else {
          errors[validationToken] = queue = [];
          invalidCount++;
          toggleValidCss(false, validationToken);
          parentForm.$setValidity(validationToken, false, form);
        }
        queue.push(control);
        form.$valid = false;
        form.$invalid = true;
      }
    };
    form.$setDirty = function () {
      element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      form.$dirty = true;
      form.$pristine = false;
      parentForm.$setDirty();
    };
  }
  var formDirectiveFactory = function (isNgForm) {
    return [
      '$timeout',
      function ($timeout) {
        var formDirective = {
            name: 'form',
            restrict: 'E',
            controller: FormController,
            compile: function () {
              return {
                pre: function (scope, formElement, attr, controller) {
                  if (!attr.action) {
                    var preventDefaultListener = function (event) {
                      event.preventDefault ? event.preventDefault() : event.returnValue = false;
                    };
                    addEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                    formElement.bind('$destroy', function () {
                      $timeout(function () {
                        removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = formElement.parent().controller('form'), alias = attr.name || attr.ngForm;
                  if (alias) {
                    scope[alias] = controller;
                  }
                  if (parentFormCtrl) {
                    formElement.bind('$destroy', function () {
                      parentFormCtrl.$removeControl(controller);
                      if (alias) {
                        scope[alias] = undefined;
                      }
                      extend(controller, nullFormCtrl);
                    });
                  }
                }
              };
            }
          };
        return isNgForm ? extend(copy(formDirective), { restrict: 'EAC' }) : formDirective;
      }
    ];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
  var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;
  var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
  var inputType = {
      'text': textInputType,
      'number': numberInputType,
      'url': urlInputType,
      'email': emailInputType,
      'radio': radioInputType,
      'checkbox': checkboxInputType,
      'hidden': noop,
      'button': noop,
      'submit': noop,
      'reset': noop
    };
  function isEmpty(value) {
    return isUndefined(value) || value === '' || value === null || value !== value;
  }
  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var listener = function () {
      var value = trim(element.val());
      if (ctrl.$viewValue !== value) {
        scope.$apply(function () {
          ctrl.$setViewValue(value);
        });
      }
    };
    if ($sniffer.hasEvent('input')) {
      element.bind('input', listener);
    } else {
      var timeout;
      var deferListener = function () {
        if (!timeout) {
          timeout = $browser.defer(function () {
            listener();
            timeout = null;
          });
        }
      };
      element.bind('keydown', function (event) {
        var key = event.keyCode;
        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
          return;
        deferListener();
      });
      element.bind('change', listener);
      if ($sniffer.hasEvent('paste')) {
        element.bind('paste cut', deferListener);
      }
    }
    ctrl.$render = function () {
      element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
    };
    var pattern = attr.ngPattern, patternValidator;
    var validate = function (regexp, value) {
      if (isEmpty(value) || regexp.test(value)) {
        ctrl.$setValidity('pattern', true);
        return value;
      } else {
        ctrl.$setValidity('pattern', false);
        return undefined;
      }
    };
    if (pattern) {
      if (pattern.match(/^\/(.*)\/$/)) {
        pattern = new RegExp(pattern.substr(1, pattern.length - 2));
        patternValidator = function (value) {
          return validate(pattern, value);
        };
      } else {
        patternValidator = function (value) {
          var patternObj = scope.$eval(pattern);
          if (!patternObj || !patternObj.test) {
            throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);
          }
          return validate(patternObj, value);
        };
      }
      ctrl.$formatters.push(patternValidator);
      ctrl.$parsers.push(patternValidator);
    }
    if (attr.ngMinlength) {
      var minlength = int(attr.ngMinlength);
      var minLengthValidator = function (value) {
        if (!isEmpty(value) && value.length < minlength) {
          ctrl.$setValidity('minlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('minlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(minLengthValidator);
      ctrl.$formatters.push(minLengthValidator);
    }
    if (attr.ngMaxlength) {
      var maxlength = int(attr.ngMaxlength);
      var maxLengthValidator = function (value) {
        if (!isEmpty(value) && value.length > maxlength) {
          ctrl.$setValidity('maxlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('maxlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxLengthValidator);
      ctrl.$formatters.push(maxLengthValidator);
    }
  }
  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    ctrl.$parsers.push(function (value) {
      var empty = isEmpty(value);
      if (empty || NUMBER_REGEXP.test(value)) {
        ctrl.$setValidity('number', true);
        return value === '' ? null : empty ? value : parseFloat(value);
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
    ctrl.$formatters.push(function (value) {
      return isEmpty(value) ? '' : '' + value;
    });
    if (attr.min) {
      var min = parseFloat(attr.min);
      var minValidator = function (value) {
        if (!isEmpty(value) && value < min) {
          ctrl.$setValidity('min', false);
          return undefined;
        } else {
          ctrl.$setValidity('min', true);
          return value;
        }
      };
      ctrl.$parsers.push(minValidator);
      ctrl.$formatters.push(minValidator);
    }
    if (attr.max) {
      var max = parseFloat(attr.max);
      var maxValidator = function (value) {
        if (!isEmpty(value) && value > max) {
          ctrl.$setValidity('max', false);
          return undefined;
        } else {
          ctrl.$setValidity('max', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxValidator);
      ctrl.$formatters.push(maxValidator);
    }
    ctrl.$formatters.push(function (value) {
      if (isEmpty(value) || isNumber(value)) {
        ctrl.$setValidity('number', true);
        return value;
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
  }
  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var urlValidator = function (value) {
      if (isEmpty(value) || URL_REGEXP.test(value)) {
        ctrl.$setValidity('url', true);
        return value;
      } else {
        ctrl.$setValidity('url', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(urlValidator);
    ctrl.$parsers.push(urlValidator);
  }
  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var emailValidator = function (value) {
      if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
        ctrl.$setValidity('email', true);
        return value;
      } else {
        ctrl.$setValidity('email', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(emailValidator);
    ctrl.$parsers.push(emailValidator);
  }
  function radioInputType(scope, element, attr, ctrl) {
    if (isUndefined(attr.name)) {
      element.attr('name', nextUid());
    }
    element.bind('click', function () {
      if (element[0].checked) {
        scope.$apply(function () {
          ctrl.$setViewValue(attr.value);
        });
      }
    });
    ctrl.$render = function () {
      var value = attr.value;
      element[0].checked = value == ctrl.$viewValue;
    };
    attr.$observe('value', ctrl.$render);
  }
  function checkboxInputType(scope, element, attr, ctrl) {
    var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
    if (!isString(trueValue))
      trueValue = true;
    if (!isString(falseValue))
      falseValue = false;
    element.bind('click', function () {
      scope.$apply(function () {
        ctrl.$setViewValue(element[0].checked);
      });
    });
    ctrl.$render = function () {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$formatters.push(function (value) {
      return value === trueValue;
    });
    ctrl.$parsers.push(function (value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = [
      '$browser',
      '$sniffer',
      function ($browser, $sniffer) {
        return {
          restrict: 'E',
          require: '?ngModel',
          link: function (scope, element, attr, ctrl) {
            if (ctrl) {
              (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
            }
          }
        };
      }
    ];
  var VALID_CLASS = 'ng-valid', INVALID_CLASS = 'ng-invalid', PRISTINE_CLASS = 'ng-pristine', DIRTY_CLASS = 'ng-dirty';
  var NgModelController = [
      '$scope',
      '$exceptionHandler',
      '$attrs',
      '$element',
      '$parse',
      function ($scope, $exceptionHandler, $attr, $element, $parse) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$name = $attr.name;
        var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
        if (!ngModelSet) {
          throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + $attr.ngModel + ' (' + startingTag($element) + ')');
        }
        this.$render = noop;
        var parentForm = $element.inheritedData('$formController') || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
        $element.addClass(PRISTINE_CLASS);
        toggleValidCss(true);
        function toggleValidCss(isValid, validationErrorKey) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          $element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        this.$setValidity = function (validationErrorKey, isValid) {
          if ($error[validationErrorKey] === !isValid)
            return;
          if (isValid) {
            if ($error[validationErrorKey])
              invalidCount--;
            if (!invalidCount) {
              toggleValidCss(true);
              this.$valid = true;
              this.$invalid = false;
            }
          } else {
            toggleValidCss(false);
            this.$invalid = true;
            this.$valid = false;
            invalidCount++;
          }
          $error[validationErrorKey] = !isValid;
          toggleValidCss(isValid, validationErrorKey);
          parentForm.$setValidity(validationErrorKey, isValid, this);
        };
        this.$setViewValue = function (value) {
          this.$viewValue = value;
          if (this.$pristine) {
            this.$dirty = true;
            this.$pristine = false;
            $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
            parentForm.$setDirty();
          }
          forEach(this.$parsers, function (fn) {
            value = fn(value);
          });
          if (this.$modelValue !== value) {
            this.$modelValue = value;
            ngModelSet($scope, value);
            forEach(this.$viewChangeListeners, function (listener) {
              try {
                listener();
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          }
        };
        var ctrl = this;
        $scope.$watch(function ngModelWatch() {
          var value = ngModelGet($scope);
          if (ctrl.$modelValue !== value) {
            var formatters = ctrl.$formatters, idx = formatters.length;
            ctrl.$modelValue = value;
            while (idx--) {
              value = formatters[idx](value);
            }
            if (ctrl.$viewValue !== value) {
              ctrl.$viewValue = value;
              ctrl.$render();
            }
          }
        });
      }
    ];
  var ngModelDirective = function () {
    return {
      require: [
        'ngModel',
        '^?form'
      ],
      controller: NgModelController,
      link: function (scope, element, attr, ctrls) {
        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
        formCtrl.$addControl(modelCtrl);
        element.bind('$destroy', function () {
          formCtrl.$removeControl(modelCtrl);
        });
      }
    };
  };
  var ngChangeDirective = valueFn({
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        ctrl.$viewChangeListeners.push(function () {
          scope.$eval(attr.ngChange);
        });
      }
    });
  var requiredDirective = function () {
    return {
      require: '?ngModel',
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl)
          return;
        attr.required = true;
        var validator = function (value) {
          if (attr.required && (isEmpty(value) || value === false)) {
            ctrl.$setValidity('required', false);
            return;
          } else {
            ctrl.$setValidity('required', true);
            return value;
          }
        };
        ctrl.$formatters.push(validator);
        ctrl.$parsers.unshift(validator);
        attr.$observe('required', function () {
          validator(ctrl.$viewValue);
        });
      }
    };
  };
  var ngListDirective = function () {
    return {
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ',';
        var parse = function (viewValue) {
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function (value) {
              if (value)
                list.push(trim(value));
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function (value) {
          if (isArray(value)) {
            return value.join(', ');
          }
          return undefined;
        });
      }
    };
  };
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function () {
    return {
      priority: 100,
      compile: function (tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function (scope, elm, attr) {
            attr.$set('value', scope.$eval(attr.ngValue));
          };
        } else {
          return function (scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              attr.$set('value', value, false);
            });
          };
        }
      }
    };
  };
  var ngBindDirective = ngDirective(function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.ngBind);
      scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
        element.text(value == undefined ? '' : value);
      });
    });
  var ngBindTemplateDirective = [
      '$interpolate',
      function ($interpolate) {
        return function (scope, element, attr) {
          var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
          element.addClass('ng-binding').data('$binding', interpolateFn);
          attr.$observe('ngBindTemplate', function (value) {
            element.text(value);
          });
        };
      }
    ];
  var ngBindHtmlUnsafeDirective = [function () {
        return function (scope, element, attr) {
          element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);
          scope.$watch(attr.ngBindHtmlUnsafe, function ngBindHtmlUnsafeWatchAction(value) {
            element.html(value || '');
          });
        };
      }];
  function classDirective(name, selector) {
    name = 'ngClass' + name;
    return ngDirective(function (scope, element, attr) {
      var oldVal = undefined;
      scope.$watch(attr[name], ngClassWatchAction, true);
      attr.$observe('class', function (value) {
        var ngClass = scope.$eval(attr[name]);
        ngClassWatchAction(ngClass, ngClass);
      });
      if (name !== 'ngClass') {
        scope.$watch('$index', function ($index, old$index) {
          var mod = $index & 1;
          if (mod !== old$index & 1) {
            if (mod === selector) {
              addClass(scope.$eval(attr[name]));
            } else {
              removeClass(scope.$eval(attr[name]));
            }
          }
        });
      }
      function ngClassWatchAction(newVal) {
        if (selector === true || scope.$index % 2 === selector) {
          if (oldVal && !equals(newVal, oldVal)) {
            removeClass(oldVal);
          }
          addClass(newVal);
        }
        oldVal = copy(newVal);
      }
      function removeClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        element.removeClass(isArray(classVal) ? classVal.join(' ') : classVal);
      }
      function addClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        if (classVal) {
          element.addClass(isArray(classVal) ? classVal.join(' ') : classVal);
        }
      }
    });
  }
  var ngClassDirective = classDirective('', true);
  var ngClassOddDirective = classDirective('Odd', 0);
  var ngClassEvenDirective = classDirective('Even', 1);
  var ngCloakDirective = ngDirective({
      compile: function (element, attr) {
        attr.$set('ngCloak', undefined);
        element.removeClass('ng-cloak');
      }
    });
  var ngControllerDirective = [function () {
        return {
          scope: true,
          controller: '@'
        };
      }];
  var ngCspDirective = [
      '$sniffer',
      function ($sniffer) {
        return {
          priority: 1000,
          compile: function () {
            $sniffer.csp = true;
          }
        };
      }
    ];
  var ngEventDirectives = {};
  forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave'.split(' '), function (name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = [
      '$parse',
      function ($parse) {
        return function (scope, element, attr) {
          var fn = $parse(attr[directiveName]);
          element.bind(lowercase(name), function (event) {
            scope.$apply(function () {
              fn(scope, { $event: event });
            });
          });
        };
      }
    ];
  });
  var ngSubmitDirective = ngDirective(function (scope, element, attrs) {
      element.bind('submit', function () {
        scope.$apply(attrs.ngSubmit);
      });
    });
  var ngIncludeDirective = [
      '$http',
      '$templateCache',
      '$anchorScroll',
      '$compile',
      function ($http, $templateCache, $anchorScroll, $compile) {
        return {
          restrict: 'ECA',
          terminal: true,
          compile: function (element, attr) {
            var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
            return function (scope, element) {
              var changeCounter = 0, childScope;
              var clearContent = function () {
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                element.html('');
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var thisChangeId = ++changeCounter;
                if (src) {
                  $http.get(src, { cache: $templateCache }).success(function (response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    if (childScope)
                      childScope.$destroy();
                    childScope = scope.$new();
                    element.html(response);
                    $compile(element.contents())(childScope);
                    if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                      $anchorScroll();
                    }
                    childScope.$emit('$includeContentLoaded');
                    scope.$eval(onloadExp);
                  }).error(function () {
                    if (thisChangeId === changeCounter)
                      clearContent();
                  });
                } else
                  clearContent();
              });
            };
          }
        };
      }
    ];
  var ngInitDirective = ngDirective({
      compile: function () {
        return {
          pre: function (scope, element, attrs) {
            scope.$eval(attrs.ngInit);
          }
        };
      }
    });
  var ngNonBindableDirective = ngDirective({
      terminal: true,
      priority: 1000
    });
  var ngPluralizeDirective = [
      '$locale',
      '$interpolate',
      function ($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
          restrict: 'EA',
          link: function (scope, element, attr) {
            var numberExp = attr.count, whenExp = element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp), whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol();
            forEach(whens, function (expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' + offset + endSymbol));
            });
            scope.$watch(function ngPluralizeWatch() {
              var value = parseFloat(scope.$eval(numberExp));
              if (!isNaN(value)) {
                if (!(value in whens))
                  value = $locale.pluralCat(value - offset);
                return whensExpFns[value](scope, element, true);
              } else {
                return '';
              }
            }, function ngPluralizeWatchAction(newVal) {
              element.text(newVal);
            });
          }
        };
      }
    ];
  var ngRepeatDirective = ngDirective({
      transclude: 'element',
      priority: 1000,
      terminal: true,
      compile: function (element, attr, linker) {
        return function (scope, iterStartElement, attr) {
          var expression = attr.ngRepeat;
          var match = expression.match(/^\s*(.+)\s+in\s+(.*)\s*$/), lhs, rhs, valueIdent, keyIdent;
          if (!match) {
            throw Error('Expected ngRepeat in form of \'_item_ in _collection_\' but got \'' + expression + '\'.');
          }
          lhs = match[1];
          rhs = match[2];
          match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
          if (!match) {
            throw Error('\'item\' in \'item in collection\' should be identifier or (key, value) but got \'' + lhs + '\'.');
          }
          valueIdent = match[3] || match[1];
          keyIdent = match[2];
          var lastOrder = new HashQueueMap();
          scope.$watch(function ngRepeatWatch(scope) {
            var index, length, collection = scope.$eval(rhs), cursor = iterStartElement, nextOrder = new HashQueueMap(), arrayBound, childScope, key, value, array, last;
            if (!isArray(collection)) {
              array = [];
              for (key in collection) {
                if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                  array.push(key);
                }
              }
              array.sort();
            } else {
              array = collection || [];
            }
            arrayBound = array.length - 1;
            for (index = 0, length = array.length; index < length; index++) {
              key = collection === array ? index : array[index];
              value = collection[key];
              last = lastOrder.shift(value);
              if (last) {
                childScope = last.scope;
                nextOrder.push(value, last);
                if (index === last.index) {
                  cursor = last.element;
                } else {
                  last.index = index;
                  cursor.after(last.element);
                  cursor = last.element;
                }
              } else {
                childScope = scope.$new();
              }
              childScope[valueIdent] = value;
              if (keyIdent)
                childScope[keyIdent] = key;
              childScope.$index = index;
              childScope.$first = index === 0;
              childScope.$last = index === arrayBound;
              childScope.$middle = !(childScope.$first || childScope.$last);
              if (!last) {
                linker(childScope, function (clone) {
                  cursor.after(clone);
                  last = {
                    scope: childScope,
                    element: cursor = clone,
                    index: index
                  };
                  nextOrder.push(value, last);
                });
              }
            }
            for (key in lastOrder) {
              if (lastOrder.hasOwnProperty(key)) {
                array = lastOrder[key];
                while (array.length) {
                  value = array.pop();
                  value.element.remove();
                  value.scope.$destroy();
                }
              }
            }
            lastOrder = nextOrder;
          });
        };
      }
    });
  var ngShowDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
        element.css('display', toBoolean(value) ? '' : 'none');
      });
    });
  var ngHideDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
        element.css('display', toBoolean(value) ? 'none' : '');
      });
    });
  var ngStyleDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
        if (oldStyles && newStyles !== oldStyles) {
          forEach(oldStyles, function (val, style) {
            element.css(style, '');
          });
        }
        if (newStyles)
          element.css(newStyles);
      }, true);
    });
  var NG_SWITCH = 'ng-switch';
  var ngSwitchDirective = valueFn({
      restrict: 'EA',
      require: 'ngSwitch',
      controller: [
        '$scope',
        function ngSwitchController() {
          this.cases = {};
        }
      ],
      link: function (scope, element, attr, ctrl) {
        var watchExpr = attr.ngSwitch || attr.on, selectedTransclude, selectedElement, selectedScope;
        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
          if (selectedElement) {
            selectedScope.$destroy();
            selectedElement.remove();
            selectedElement = selectedScope = null;
          }
          if (selectedTransclude = ctrl.cases['!' + value] || ctrl.cases['?']) {
            scope.$eval(attr.change);
            selectedScope = scope.$new();
            selectedTransclude(selectedScope, function (caseElement) {
              selectedElement = caseElement;
              element.append(caseElement);
            });
          }
        });
      }
    });
  var ngSwitchWhenDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = transclude;
        };
      }
    });
  var ngSwitchDefaultDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['?'] = transclude;
        };
      }
    });
  var ngTranscludeDirective = ngDirective({
      controller: [
        '$transclude',
        '$element',
        function ($transclude, $element) {
          $transclude(function (clone) {
            $element.append(clone);
          });
        }
      ]
    });
  var ngViewDirective = [
      '$http',
      '$templateCache',
      '$route',
      '$anchorScroll',
      '$compile',
      '$controller',
      function ($http, $templateCache, $route, $anchorScroll, $compile, $controller) {
        return {
          restrict: 'ECA',
          terminal: true,
          link: function (scope, element, attr) {
            var lastScope, onloadExp = attr.onload || '';
            scope.$on('$routeChangeSuccess', update);
            update();
            function destroyLastScope() {
              if (lastScope) {
                lastScope.$destroy();
                lastScope = null;
              }
            }
            function clearContent() {
              element.html('');
              destroyLastScope();
            }
            function update() {
              var locals = $route.current && $route.current.locals, template = locals && locals.$template;
              if (template) {
                element.html(template);
                destroyLastScope();
                var link = $compile(element.contents()), current = $route.current, controller;
                lastScope = current.scope = scope.$new();
                if (current.controller) {
                  locals.$scope = lastScope;
                  controller = $controller(current.controller, locals);
                  element.children().data('$ngControllerController', controller);
                }
                link(lastScope);
                lastScope.$emit('$viewContentLoaded');
                lastScope.$eval(onloadExp);
                $anchorScroll();
              } else {
                clearContent();
              }
            }
          }
        };
      }
    ];
  var scriptDirective = [
      '$templateCache',
      function ($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function (element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id, text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }
    ];
  var ngOptionsDirective = valueFn({ terminal: true });
  var selectDirective = [
      '$compile',
      '$parse',
      function ($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/, nullModelCtrl = { $setViewValue: noop };
        return {
          restrict: 'E',
          require: [
            'select',
            '?ngModel'
          ],
          controller: [
            '$element',
            '$scope',
            '$attrs',
            function ($element, $scope, $attrs) {
              var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
              self.databound = $attrs.ngModel;
              self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
                ngModelCtrl = ngModelCtrl_;
                nullOption = nullOption_;
                unknownOption = unknownOption_;
              };
              self.addOption = function (value) {
                optionsMap[value] = true;
                if (ngModelCtrl.$viewValue == value) {
                  $element.val(value);
                  if (unknownOption.parent())
                    unknownOption.remove();
                }
              };
              self.removeOption = function (value) {
                if (this.hasOption(value)) {
                  delete optionsMap[value];
                  if (ngModelCtrl.$viewValue == value) {
                    this.renderUnknownOption(value);
                  }
                }
              };
              self.renderUnknownOption = function (val) {
                var unknownVal = '? ' + hashKey(val) + ' ?';
                unknownOption.val(unknownVal);
                $element.prepend(unknownOption);
                $element.val(unknownVal);
                unknownOption.prop('selected', true);
              };
              self.hasOption = function (value) {
                return optionsMap.hasOwnProperty(value);
              };
              $scope.$on('$destroy', function () {
                self.renderUnknownOption = noop;
              });
            }
          ],
          link: function (scope, element, attr, ctrls) {
            if (!ctrls[1])
              return;
            var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, optionTemplate = jqLite(document.createElement('option')), optGroupTemplate = jqLite(document.createElement('optgroup')), unknownOption = optionTemplate.clone();
            for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
              if (children[i].value == '') {
                emptyOption = nullOption = children.eq(i);
                break;
              }
            }
            selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
            if (multiple && (attr.required || attr.ngRequired)) {
              var requiredValidator = function (value) {
                ngModelCtrl.$setValidity('required', !attr.required || value && value.length);
                return value;
              };
              ngModelCtrl.$parsers.push(requiredValidator);
              ngModelCtrl.$formatters.unshift(requiredValidator);
              attr.$observe('required', function () {
                requiredValidator(ngModelCtrl.$viewValue);
              });
            }
            if (optionsExp)
              Options(scope, element, ngModelCtrl);
            else if (multiple)
              Multiple(scope, element, ngModelCtrl);
            else
              Single(scope, element, ngModelCtrl, selectCtrl);
            function Single(scope, selectElement, ngModelCtrl, selectCtrl) {
              ngModelCtrl.$render = function () {
                var viewValue = ngModelCtrl.$viewValue;
                if (selectCtrl.hasOption(viewValue)) {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  selectElement.val(viewValue);
                  if (viewValue === '')
                    emptyOption.prop('selected', true);
                } else {
                  if (isUndefined(viewValue) && emptyOption) {
                    selectElement.val('');
                  } else {
                    selectCtrl.renderUnknownOption(viewValue);
                  }
                }
              };
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  ngModelCtrl.$setViewValue(selectElement.val());
                });
              });
            }
            function Multiple(scope, selectElement, ctrl) {
              var lastView;
              ctrl.$render = function () {
                var items = new HashMap(ctrl.$viewValue);
                forEach(selectElement.find('option'), function (option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              scope.$watch(function selectMultipleWatch() {
                if (!equals(lastView, ctrl.$viewValue)) {
                  lastView = copy(ctrl.$viewValue);
                  ctrl.$render();
                }
              });
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var array = [];
                  forEach(selectElement.find('option'), function (option) {
                    if (option.selected) {
                      array.push(option.value);
                    }
                  });
                  ctrl.$setViewValue(array);
                });
              });
            }
            function Options(scope, selectElement, ctrl) {
              var match;
              if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                throw Error('Expected ngOptions in form of \'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'' + optionsExp + '\'.');
              }
              var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ''), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), optionGroupsCache = [[{
                      element: selectElement,
                      label: ''
                    }]];
              if (nullOption) {
                $compile(nullOption)(scope);
                nullOption.removeClass('ng-scope');
                nullOption.remove();
              }
              selectElement.html('');
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var optionGroup, collection = valuesFn(scope) || [], locals = {}, key, value, optionElement, index, groupIndex, length, groupLength;
                  if (multiple) {
                    value = [];
                    for (groupIndex = 0, groupLength = optionGroupsCache.length; groupIndex < groupLength; groupIndex++) {
                      optionGroup = optionGroupsCache[groupIndex];
                      for (index = 1, length = optionGroup.length; index < length; index++) {
                        if ((optionElement = optionGroup[index].element)[0].selected) {
                          key = optionElement.val();
                          if (keyName)
                            locals[keyName] = key;
                          locals[valueName] = collection[key];
                          value.push(valueFn(scope, locals));
                        }
                      }
                    }
                  } else {
                    key = selectElement.val();
                    if (key == '?') {
                      value = undefined;
                    } else if (key == '') {
                      value = null;
                    } else {
                      locals[valueName] = collection[key];
                      if (keyName)
                        locals[keyName] = key;
                      value = valueFn(scope, locals);
                    }
                  }
                  ctrl.$setViewValue(value);
                });
              });
              ctrl.$render = render;
              scope.$watch(render);
              function render() {
                var optionGroups = { '': [] }, optionGroupNames = [''], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, groupLength, length, groupIndex, index, locals = {}, selected, selectedSet = false, lastElement, element, label;
                if (multiple) {
                  selectedSet = new HashMap(modelValue);
                }
                for (index = 0; length = keys.length, index < length; index++) {
                  locals[valueName] = values[keyName ? locals[keyName] = keys[index] : index];
                  optionGroupName = groupByFn(scope, locals) || '';
                  if (!(optionGroup = optionGroups[optionGroupName])) {
                    optionGroup = optionGroups[optionGroupName] = [];
                    optionGroupNames.push(optionGroupName);
                  }
                  if (multiple) {
                    selected = selectedSet.remove(valueFn(scope, locals)) != undefined;
                  } else {
                    selected = modelValue === valueFn(scope, locals);
                    selectedSet = selectedSet || selected;
                  }
                  label = displayFn(scope, locals);
                  label = label === undefined ? '' : label;
                  optionGroup.push({
                    id: keyName ? keys[index] : index,
                    label: label,
                    selected: selected
                  });
                }
                if (!multiple) {
                  if (nullOption || modelValue === null) {
                    optionGroups[''].unshift({
                      id: '',
                      label: '',
                      selected: !selectedSet
                    });
                  } else if (!selectedSet) {
                    optionGroups[''].unshift({
                      id: '?',
                      label: '',
                      selected: true
                    });
                  }
                }
                for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                  optionGroupName = optionGroupNames[groupIndex];
                  optionGroup = optionGroups[optionGroupName];
                  if (optionGroupsCache.length <= groupIndex) {
                    existingParent = {
                      element: optGroupTemplate.clone().attr('label', optionGroupName),
                      label: optionGroup.label
                    };
                    existingOptions = [existingParent];
                    optionGroupsCache.push(existingOptions);
                    selectElement.append(existingParent.element);
                  } else {
                    existingOptions = optionGroupsCache[groupIndex];
                    existingParent = existingOptions[0];
                    if (existingParent.label != optionGroupName) {
                      existingParent.element.attr('label', existingParent.label = optionGroupName);
                    }
                  }
                  lastElement = null;
                  for (index = 0, length = optionGroup.length; index < length; index++) {
                    option = optionGroup[index];
                    if (existingOption = existingOptions[index + 1]) {
                      lastElement = existingOption.element;
                      if (existingOption.label !== option.label) {
                        lastElement.text(existingOption.label = option.label);
                      }
                      if (existingOption.id !== option.id) {
                        lastElement.val(existingOption.id = option.id);
                      }
                      if (lastElement[0].selected !== option.selected) {
                        lastElement.prop('selected', existingOption.selected = option.selected);
                      }
                    } else {
                      if (option.id === '' && nullOption) {
                        element = nullOption;
                      } else {
                        (element = optionTemplate.clone()).val(option.id).attr('selected', option.selected).text(option.label);
                      }
                      existingOptions.push(existingOption = {
                        element: element,
                        label: option.label,
                        id: option.id,
                        selected: option.selected
                      });
                      if (lastElement) {
                        lastElement.after(element);
                      } else {
                        existingParent.element.append(element);
                      }
                      lastElement = element;
                    }
                  }
                  index++;
                  while (existingOptions.length > index) {
                    existingOptions.pop().element.remove();
                  }
                }
                while (optionGroupsCache.length > groupIndex) {
                  optionGroupsCache.pop()[0].element.remove();
                }
              }
            }
          }
        };
      }
    ];
  var optionDirective = [
      '$interpolate',
      function ($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
          };
        return {
          restrict: 'E',
          priority: 100,
          compile: function (element, attr) {
            if (isUndefined(attr.value)) {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function (scope, element, attr) {
              var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl && selectCtrl.databound) {
                element.prop('selected', false);
              } else {
                selectCtrl = nullSelectCtrl;
              }
              if (interpolateFn) {
                scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                  attr.$set('value', newVal);
                  if (newVal !== oldVal)
                    selectCtrl.removeOption(oldVal);
                  selectCtrl.addOption(newVal);
                });
              } else {
                selectCtrl.addOption(attr.value);
              }
              element.bind('$destroy', function () {
                selectCtrl.removeOption(attr.value);
              });
            };
          }
        };
      }
    ];
  var styleDirective = valueFn({
      restrict: 'E',
      terminal: true
    });
  bindJQuery();
  publishExternalAPI(angular);
  jqLite(document).ready(function () {
    angularInit(document, bootstrap);
  });
}(window, document));
angular.element(document).find('head').append('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none;}ng\\:form{display:block;}</style>');
(function () {
  var root = this;
  var previousUnderscore = root._;
  var breaker = {};
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
  var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
  var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
  var _ = function (obj) {
    if (obj instanceof _)
      return obj;
    if (!(this instanceof _))
      return new _(obj);
    this._wrapped = obj;
  };
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }
  _.VERSION = '1.5.1';
  var each = _.each = _.forEach = function (obj, iterator, context) {
      if (obj == null)
        return;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, l = obj.length; i < l; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker)
            return;
        }
      } else {
        for (var key in obj) {
          if (_.has(obj, key)) {
            if (iterator.call(context, obj[key], key, obj) === breaker)
              return;
          }
        }
      }
    };
  _.map = _.collect = function (obj, iterator, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeMap && obj.map === nativeMap)
      return obj.map(iterator, context);
    each(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };
  var reduceError = 'Reduce of empty array with no initial value';
  _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function (value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function (value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.find = _.detect = function (obj, iterator, context) {
    var result;
    any(obj, function (value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };
  _.filter = _.select = function (obj, iterator, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeFilter && obj.filter === nativeFilter)
      return obj.filter(iterator, context);
    each(obj, function (value, index, list) {
      if (iterator.call(context, value, index, list))
        results.push(value);
    });
    return results;
  };
  _.reject = function (obj, iterator, context) {
    return _.filter(obj, function (value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };
  _.every = _.all = function (obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null)
      return result;
    if (nativeEvery && obj.every === nativeEvery)
      return obj.every(iterator, context);
    each(obj, function (value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list)))
        return breaker;
    });
    return !!result;
  };
  var any = _.some = _.any = function (obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = false;
      if (obj == null)
        return result;
      if (nativeSome && obj.some === nativeSome)
        return obj.some(iterator, context);
      each(obj, function (value, index, list) {
        if (result || (result = iterator.call(context, value, index, list)))
          return breaker;
      });
      return !!result;
    };
  _.contains = _.include = function (obj, target) {
    if (obj == null)
      return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf)
      return obj.indexOf(target) != -1;
    return any(obj, function (value) {
      return value === target;
    });
  };
  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function (value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };
  _.pluck = function (obj, key) {
    return _.map(obj, function (value) {
      return value[key];
    });
  };
  _.where = function (obj, attrs, first) {
    if (_.isEmpty(attrs))
      return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function (value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key])
          return false;
      }
      return true;
    });
  };
  _.findWhere = function (obj, attrs) {
    return _.where(obj, attrs, true);
  };
  _.max = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj))
      return -Infinity;
    var result = {
        computed: -Infinity,
        value: -Infinity
      };
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {
        value: value,
        computed: computed
      });
    });
    return result.value;
  };
  _.min = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj))
      return Infinity;
    var result = {
        computed: Infinity,
        value: Infinity
      };
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {
        value: value,
        computed: computed
      });
    });
    return result.value;
  };
  _.shuffle = function (obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function (value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };
  var lookupIterator = function (value) {
    return _.isFunction(value) ? value : function (obj) {
      return obj[value];
    };
  };
  _.sortBy = function (obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0)
          return 1;
        if (a < b || b === void 0)
          return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };
  var group = function (obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value == null ? _.identity : value);
    each(obj, function (value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };
  _.groupBy = function (obj, value, context) {
    return group(obj, value, context, function (result, key, value) {
      (_.has(result, key) ? result[key] : result[key] = []).push(value);
    });
  };
  _.countBy = function (obj, value, context) {
    return group(obj, value, context, function (result, key) {
      if (!_.has(result, key))
        result[key] = 0;
      result[key]++;
    });
  };
  _.sortedIndex = function (array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };
  _.toArray = function (obj) {
    if (!obj)
      return [];
    if (_.isArray(obj))
      return slice.call(obj);
    if (obj.length === +obj.length)
      return _.map(obj, _.identity);
    return _.values(obj);
  };
  _.size = function (obj) {
    if (obj == null)
      return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null)
      return void 0;
    return n != null && !guard ? slice.call(array, 0, n) : array[0];
  };
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
  };
  _.last = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n != null && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };
  _.compact = function (array) {
    return _.filter(array, _.identity);
  };
  var flatten = function (input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function (value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, []);
  };
  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  };
  _.uniq = _.unique = function (array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function (value, index) {
      if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };
  _.union = function () {
    return _.uniq(_.flatten(arguments, true));
  };
  _.intersection = function (array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function (item) {
      return _.every(rest, function (other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };
  _.difference = function (array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  };
  _.zip = function () {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };
  _.object = function (list, values) {
    if (list == null)
      return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };
  _.indexOf = function (array, item, isSorted) {
    if (array == null)
      return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, l + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf)
      return array.indexOf(item, isSorted);
    for (; i < l; i++)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.lastIndexOf = function (array, item, from) {
    if (array == null)
      return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = hasIndex ? from : array.length;
    while (i--)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.range = function (start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;
    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);
    while (idx < len) {
      range[idx++] = start;
      start += step;
    }
    return range;
  };
  var ctor = function () {
  };
  _.bind = function (func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind)
      return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func))
      throw new TypeError();
    args = slice.call(arguments, 2);
    return bound = function () {
      if (!(this instanceof bound))
        return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor();
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result)
        return result;
      return self;
    };
  };
  _.partial = function (func) {
    var args = slice.call(arguments, 1);
    return function () {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };
  _.bindAll = function (obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0)
      throw new Error('bindAll must be passed function names');
    each(funcs, function (f) {
      obj[f] = _.bind(obj[f], obj);
    });
    return obj;
  };
  _.memoize = function (func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function () {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
    };
  };
  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  };
  _.defer = function (func) {
    return _.delay.apply(_, [
      func,
      1
    ].concat(slice.call(arguments, 1)));
  };
  _.throttle = function (func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function () {
      previous = options.leading === false ? 0 : new Date();
      timeout = null;
      result = func.apply(context, args);
    };
    return function () {
      var now = new Date();
      if (!previous && options.leading === false)
        previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };
  _.debounce = function (func, wait, immediate) {
    var result;
    var timeout = null;
    return function () {
      var context = this, args = arguments;
      var later = function () {
        timeout = null;
        if (!immediate)
          result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow)
        result = func.apply(context, args);
      return result;
    };
  };
  _.once = function (func) {
    var ran = false, memo;
    return function () {
      if (ran)
        return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };
  _.wrap = function (func, wrapper) {
    return function () {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };
  _.compose = function () {
    var funcs = arguments;
    return function () {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };
  _.keys = nativeKeys || function (obj) {
    if (obj !== Object(obj))
      throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj)
      if (_.has(obj, key))
        keys.push(key);
    return keys;
  };
  _.values = function (obj) {
    var values = [];
    for (var key in obj)
      if (_.has(obj, key))
        values.push(obj[key]);
    return values;
  };
  _.pairs = function (obj) {
    var pairs = [];
    for (var key in obj)
      if (_.has(obj, key))
        pairs.push([
          key,
          obj[key]
        ]);
    return pairs;
  };
  _.invert = function (obj) {
    var result = {};
    for (var key in obj)
      if (_.has(obj, key))
        result[obj[key]] = key;
    return result;
  };
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key]))
        names.push(key);
    }
    return names.sort();
  };
  _.extend = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.pick = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function (key) {
      if (key in obj)
        copy[key] = obj[key];
    });
    return copy;
  };
  _.omit = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key))
        copy[key] = obj[key];
    }
    return copy;
  };
  _.defaults = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0)
            obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.clone = function (obj) {
    if (!_.isObject(obj))
      return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };
  var eq = function (a, b, aStack, bStack) {
    if (a === b)
      return a !== 0 || 1 / a == 1 / b;
    if (a == null || b == null)
      return a === b;
    if (a instanceof _)
      a = a._wrapped;
    if (b instanceof _)
      b = b._wrapped;
    var className = toString.call(a);
    if (className != toString.call(b))
      return false;
    switch (className) {
    case '[object String]':
      return a == String(b);
    case '[object Number]':
      return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
    case '[object Date]':
    case '[object Boolean]':
      return +a == +b;
    case '[object RegExp]':
      return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object')
      return false;
    var length = aStack.length;
    while (length--) {
      if (aStack[length] == a)
        return bStack[length] == b;
    }
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {
      return false;
    }
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    if (className == '[object Array]') {
      size = a.length;
      result = size == b.length;
      if (result) {
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack)))
            break;
        }
      }
    } else {
      for (var key in a) {
        if (_.has(a, key)) {
          size++;
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)))
            break;
        }
      }
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !size--)
            break;
        }
        result = !size;
      }
    }
    aStack.pop();
    bStack.pop();
    return result;
  };
  _.isEqual = function (a, b) {
    return eq(a, b, [], []);
  };
  _.isEmpty = function (obj) {
    if (obj == null)
      return true;
    if (_.isArray(obj) || _.isString(obj))
      return obj.length === 0;
    for (var key in obj)
      if (_.has(obj, key))
        return false;
    return true;
  };
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) == '[object Array]';
  };
  _.isObject = function (obj) {
    return obj === Object(obj);
  };
  each([
    'Arguments',
    'Function',
    'String',
    'Number',
    'Date',
    'RegExp'
  ], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }
  if (typeof /./ !== 'function') {
    _.isFunction = function (obj) {
      return typeof obj === 'function';
    };
  }
  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };
  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj != +obj;
  };
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };
  _.isNull = function (obj) {
    return obj === null;
  };
  _.isUndefined = function (obj) {
    return obj === void 0;
  };
  _.has = function (obj, key) {
    return hasOwnProperty.call(obj, key);
  };
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };
  _.identity = function (value) {
    return value;
  };
  _.times = function (n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++)
      accum[i] = iterator.call(context, i);
    return accum;
  };
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };
  var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#x27;',
        '/': '&#x2F;'
      }
    };
  entityMap.unescape = _.invert(entityMap.escape);
  var entityRegexes = {
      escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };
  _.each([
    'escape',
    'unescape'
  ], function (method) {
    _[method] = function (string) {
      if (string == null)
        return '';
      return ('' + string).replace(entityRegexes[method], function (match) {
        return entityMap[method][match];
      });
    };
  });
  _.result = function (object, property) {
    if (object == null)
      return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };
  _.mixin = function (obj) {
    each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };
  var noMatch = /(.)^/;
  var escapes = {
      '\'': '\'',
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\t': 't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  _.template = function (text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);
    var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');
    var index = 0;
    var source = '__p+=\'';
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, function (match) {
        return '\\' + escapes[match];
      });
      if (escape) {
        source += '\'+\n((__t=(' + escape + '))==null?\'\':_.escape(__t))+\n\'';
      }
      if (interpolate) {
        source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';
      }
      if (evaluate) {
        source += '\';\n' + evaluate + '\n__p+=\'';
      }
      index = offset + match.length;
      return match;
    });
    source += '\';\n';
    if (!settings.variable)
      source = 'with(obj||{}){\n' + source + '}\n';
    source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n';
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }
    if (data)
      return render(data, _);
    var template = function (data) {
      return render.call(this, data, _);
    };
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
    return template;
  };
  _.chain = function (obj) {
    return _(obj).chain();
  };
  var result = function (obj) {
    return this._chain ? _(obj).chain() : obj;
  };
  _.mixin(_);
  each([
    'pop',
    'push',
    'reverse',
    'shift',
    'sort',
    'splice',
    'unshift'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0)
        delete obj[0];
      return result.call(this, obj);
    };
  });
  each([
    'concat',
    'join',
    'slice'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });
  _.extend(_.prototype, {
    chain: function () {
      this._chain = true;
      return this;
    },
    value: function () {
      return this._wrapped;
    }
  });
}.call(this));
(function (root, undef) {
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, hasOwnProp = ObjProto.hasOwnProperty, nativeForEach = ArrayProto.forEach, breaker = {};
  var _ = {
      forEach: function (obj, iterator, context) {
        var i, l, key;
        if (obj === null) {
          return;
        }
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (i = 0, l = obj.length; i < l; i++) {
            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
              return;
            }
          }
        } else {
          for (key in obj) {
            if (hasOwnProp.call(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) {
                return;
              }
            }
          }
        }
      },
      extend: function (obj) {
        this.forEach(slice.call(arguments, 1), function (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        });
        return obj;
      }
    };
  var Jed = function (options) {
    this.defaults = {
      'locale_data': {
        'messages': {
          '': {
            'domain': 'messages',
            'lang': 'en',
            'plural_forms': 'nplurals=2; plural=(n != 1);'
          }
        }
      },
      'domain': 'messages'
    };
    this.options = _.extend({}, this.defaults, options);
    this.textdomain(this.options.domain);
    if (options.domain && !this.options.locale_data[this.options.domain]) {
      throw new Error('Text domain set to non-existent domain: `' + options.domain + '`');
    }
  };
  Jed.context_delimiter = String.fromCharCode(4);
  function getPluralFormFunc(plural_form_string) {
    return Jed.PF.compile(plural_form_string || 'nplurals=2; plural=(n != 1);');
  }
  function Chain(key, i18n) {
    this._key = key;
    this._i18n = i18n;
  }
  _.extend(Chain.prototype, {
    onDomain: function (domain) {
      this._domain = domain;
      return this;
    },
    withContext: function (context) {
      this._context = context;
      return this;
    },
    ifPlural: function (num, pkey) {
      this._val = num;
      this._pkey = pkey;
      return this;
    },
    fetch: function (sArr) {
      if ({}.toString.call(sArr) != '[object Array]') {
        sArr = [].slice.call(arguments);
      }
      return (sArr && sArr.length ? Jed.sprintf : function (x) {
        return x;
      })(this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val), sArr);
    }
  });
  _.extend(Jed.prototype, {
    translate: function (key) {
      return new Chain(key, this);
    },
    textdomain: function (domain) {
      if (!domain) {
        return this._textdomain;
      }
      this._textdomain = domain;
    },
    gettext: function (key) {
      return this.dcnpgettext.call(this, undef, undef, key);
    },
    dgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    dcgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    ngettext: function (skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, undef, skey, pkey, val);
    },
    dngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    dcngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    pgettext: function (context, key) {
      return this.dcnpgettext.call(this, undef, context, key);
    },
    dpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    dcpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    npgettext: function (context, skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, context, skey, pkey, val);
    },
    dnpgettext: function (domain, context, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, context, skey, pkey, val);
    },
    dcnpgettext: function (domain, context, singular_key, plural_key, val) {
      plural_key = plural_key || singular_key;
      domain = domain || this._textdomain;
      val = typeof val == 'undefined' ? 1 : val;
      var fallback;
      if (!this.options) {
        fallback = new Jed();
        return fallback.dcnpgettext.call(fallback, undefined, undefined, singular_key, plural_key, val);
      }
      if (!this.options.locale_data) {
        throw new Error('No locale data provided.');
      }
      if (!this.options.locale_data[domain]) {
        throw new Error('Domain `' + domain + '` was not found.');
      }
      if (!this.options.locale_data[domain]['']) {
        throw new Error('No locale meta information provided.');
      }
      if (!singular_key) {
        throw new Error('No translation key found.');
      }
      if (typeof val != 'number') {
        val = parseInt(val, 10);
        if (isNaN(val)) {
          throw new Error('The number that was passed in is not a number.');
        }
      }
      var key = context ? context + Jed.context_delimiter + singular_key : singular_key, locale_data = this.options.locale_data, dict = locale_data[domain], pluralForms = dict[''].plural_forms || (locale_data.messages || this.defaults.locale_data.messages)[''].plural_forms, val_idx = getPluralFormFunc(pluralForms)(val) + 1, val_list, res;
      if (!dict) {
        throw new Error('No domain named `' + domain + '` could be found.');
      }
      val_list = dict[key];
      if (!val_list || val_idx >= val_list.length) {
        if (this.options.missing_key_callback) {
          this.options.missing_key_callback(key);
        }
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      res = val_list[val_idx];
      if (!res) {
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      return res;
    }
  });
  var sprintf = function () {
      function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
      }
      function str_repeat(input, multiplier) {
        for (var output = []; multiplier > 0; output[--multiplier] = input) {
        }
        return output.join('');
      }
      var str_format = function () {
        if (!str_format.cache.hasOwnProperty(arguments[0])) {
          str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
        }
        return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
      };
      str_format.format = function (parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
        for (i = 0; i < tree_length; i++) {
          node_type = get_type(parse_tree[i]);
          if (node_type === 'string') {
            output.push(parse_tree[i]);
          } else if (node_type === 'array') {
            match = parse_tree[i];
            if (match[2]) {
              arg = argv[cursor];
              for (k = 0; k < match[2].length; k++) {
                if (!arg.hasOwnProperty(match[2][k])) {
                  throw sprintf('[sprintf] property "%s" does not exist', match[2][k]);
                }
                arg = arg[match[2][k]];
              }
            } else if (match[1]) {
              arg = argv[match[1]];
            } else {
              arg = argv[cursor++];
            }
            if (/[^s]/.test(match[8]) && get_type(arg) != 'number') {
              throw sprintf('[sprintf] expecting number but found %s', get_type(arg));
            }
            if (typeof arg == 'undefined' || arg === null) {
              arg = '';
            }
            switch (match[8]) {
            case 'b':
              arg = arg.toString(2);
              break;
            case 'c':
              arg = String.fromCharCode(arg);
              break;
            case 'd':
              arg = parseInt(arg, 10);
              break;
            case 'e':
              arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
              break;
            case 'f':
              arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
              break;
            case 'o':
              arg = arg.toString(8);
              break;
            case 's':
              arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
              break;
            case 'u':
              arg = Math.abs(arg);
              break;
            case 'x':
              arg = arg.toString(16);
              break;
            case 'X':
              arg = arg.toString(16).toUpperCase();
              break;
            }
            arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg;
            pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
            pad_length = match[6] - String(arg).length;
            pad = match[6] ? str_repeat(pad_character, pad_length) : '';
            output.push(match[5] ? arg + pad : pad + arg);
          }
        }
        return output.join('');
      };
      str_format.cache = {};
      str_format.parse = function (fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
            parse_tree.push('%');
          } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                  if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw '[sprintf] huh?';
                  }
                }
              } else {
                throw '[sprintf] huh?';
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw '[sprintf] mixing positional and named placeholders is not (yet) supported';
            }
            parse_tree.push(match);
          } else {
            throw '[sprintf] huh?';
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return parse_tree;
      };
      return str_format;
    }();
  var vsprintf = function (fmt, argv) {
    argv.unshift(fmt);
    return sprintf.apply(null, argv);
  };
  Jed.parse_plural = function (plural_forms, n) {
    plural_forms = plural_forms.replace(/n/g, n);
    return Jed.parse_expression(plural_forms);
  };
  Jed.sprintf = function (fmt, args) {
    if ({}.toString.call(args) == '[object Array]') {
      return vsprintf(fmt, [].slice.call(args));
    }
    return sprintf.apply(this, [].slice.call(arguments));
  };
  Jed.prototype.sprintf = function () {
    return Jed.sprintf.apply(this, arguments);
  };
  Jed.PF = {};
  Jed.PF.parse = function (p) {
    var plural_str = Jed.PF.extractPluralExpr(p);
    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);
  };
  Jed.PF.compile = function (p) {
    function imply(val) {
      return val === true ? 1 : val ? val : 0;
    }
    var ast = Jed.PF.parse(p);
    return function (n) {
      return imply(Jed.PF.interpreter(ast)(n));
    };
  };
  Jed.PF.interpreter = function (ast) {
    return function (n) {
      var res;
      switch (ast.type) {
      case 'GROUP':
        return Jed.PF.interpreter(ast.expr)(n);
      case 'TERNARY':
        if (Jed.PF.interpreter(ast.expr)(n)) {
          return Jed.PF.interpreter(ast.truthy)(n);
        }
        return Jed.PF.interpreter(ast.falsey)(n);
      case 'OR':
        return Jed.PF.interpreter(ast.left)(n) || Jed.PF.interpreter(ast.right)(n);
      case 'AND':
        return Jed.PF.interpreter(ast.left)(n) && Jed.PF.interpreter(ast.right)(n);
      case 'LT':
        return Jed.PF.interpreter(ast.left)(n) < Jed.PF.interpreter(ast.right)(n);
      case 'GT':
        return Jed.PF.interpreter(ast.left)(n) > Jed.PF.interpreter(ast.right)(n);
      case 'LTE':
        return Jed.PF.interpreter(ast.left)(n) <= Jed.PF.interpreter(ast.right)(n);
      case 'GTE':
        return Jed.PF.interpreter(ast.left)(n) >= Jed.PF.interpreter(ast.right)(n);
      case 'EQ':
        return Jed.PF.interpreter(ast.left)(n) == Jed.PF.interpreter(ast.right)(n);
      case 'NEQ':
        return Jed.PF.interpreter(ast.left)(n) != Jed.PF.interpreter(ast.right)(n);
      case 'MOD':
        return Jed.PF.interpreter(ast.left)(n) % Jed.PF.interpreter(ast.right)(n);
      case 'VAR':
        return n;
      case 'NUM':
        return ast.val;
      default:
        throw new Error('Invalid Token found.');
      }
    };
  };
  Jed.PF.extractPluralExpr = function (p) {
    p = p.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    if (!/;\s*$/.test(p)) {
      p = p.concat(';');
    }
    var nplurals_re = /nplurals\=(\d+);/, plural_re = /plural\=(.*);/, nplurals_matches = p.match(nplurals_re), res = {}, plural_matches;
    if (nplurals_matches.length > 1) {
      res.nplurals = nplurals_matches[1];
    } else {
      throw new Error('nplurals not found in plural_forms string: ' + p);
    }
    p = p.replace(nplurals_re, '');
    plural_matches = p.match(plural_re);
    if (!(plural_matches && plural_matches.length > 1)) {
      throw new Error('`plural` expression not found: ' + p);
    }
    return plural_matches[1];
  };
  Jed.PF.parser = function () {
    var parser = {
        trace: function trace() {
        },
        yy: {},
        symbols_: {
          'error': 2,
          'expressions': 3,
          'e': 4,
          'EOF': 5,
          '?': 6,
          ':': 7,
          '||': 8,
          '&&': 9,
          '<': 10,
          '<=': 11,
          '>': 12,
          '>=': 13,
          '!=': 14,
          '==': 15,
          '%': 16,
          '(': 17,
          ')': 18,
          'n': 19,
          'NUMBER': 20,
          '$accept': 0,
          '$end': 1
        },
        terminals_: {
          2: 'error',
          5: 'EOF',
          6: '?',
          7: ':',
          8: '||',
          9: '&&',
          10: '<',
          11: '<=',
          12: '>',
          13: '>=',
          14: '!=',
          15: '==',
          16: '%',
          17: '(',
          18: ')',
          19: 'n',
          20: 'NUMBER'
        },
        productions_: [
          0,
          [
            3,
            2
          ],
          [
            4,
            5
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            1
          ],
          [
            4,
            1
          ]
        ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
          case 1:
            return {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 2:
            this.$ = {
              type: 'TERNARY',
              expr: $$[$0 - 4],
              truthy: $$[$0 - 2],
              falsey: $$[$0]
            };
            break;
          case 3:
            this.$ = {
              type: 'OR',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 4:
            this.$ = {
              type: 'AND',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 5:
            this.$ = {
              type: 'LT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 6:
            this.$ = {
              type: 'LTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 7:
            this.$ = {
              type: 'GT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 8:
            this.$ = {
              type: 'GTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 9:
            this.$ = {
              type: 'NEQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 10:
            this.$ = {
              type: 'EQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 11:
            this.$ = {
              type: 'MOD',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 12:
            this.$ = {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 13:
            this.$ = { type: 'VAR' };
            break;
          case 14:
            this.$ = {
              type: 'NUM',
              val: Number(yytext)
            };
            break;
          }
        },
        table: [
          {
            3: 1,
            4: 2,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          { 1: [3] },
          {
            5: [
              1,
              6
            ],
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            4: 17,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              13
            ],
            6: [
              2,
              13
            ],
            7: [
              2,
              13
            ],
            8: [
              2,
              13
            ],
            9: [
              2,
              13
            ],
            10: [
              2,
              13
            ],
            11: [
              2,
              13
            ],
            12: [
              2,
              13
            ],
            13: [
              2,
              13
            ],
            14: [
              2,
              13
            ],
            15: [
              2,
              13
            ],
            16: [
              2,
              13
            ],
            18: [
              2,
              13
            ]
          },
          {
            5: [
              2,
              14
            ],
            6: [
              2,
              14
            ],
            7: [
              2,
              14
            ],
            8: [
              2,
              14
            ],
            9: [
              2,
              14
            ],
            10: [
              2,
              14
            ],
            11: [
              2,
              14
            ],
            12: [
              2,
              14
            ],
            13: [
              2,
              14
            ],
            14: [
              2,
              14
            ],
            15: [
              2,
              14
            ],
            16: [
              2,
              14
            ],
            18: [
              2,
              14
            ]
          },
          {
            1: [
              2,
              1
            ]
          },
          {
            4: 18,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 19,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 20,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 21,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 22,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 23,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 24,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 25,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 26,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 27,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              1,
              28
            ]
          },
          {
            6: [
              1,
              7
            ],
            7: [
              1,
              29
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            5: [
              2,
              3
            ],
            6: [
              2,
              3
            ],
            7: [
              2,
              3
            ],
            8: [
              2,
              3
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              3
            ]
          },
          {
            5: [
              2,
              4
            ],
            6: [
              2,
              4
            ],
            7: [
              2,
              4
            ],
            8: [
              2,
              4
            ],
            9: [
              2,
              4
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              4
            ]
          },
          {
            5: [
              2,
              5
            ],
            6: [
              2,
              5
            ],
            7: [
              2,
              5
            ],
            8: [
              2,
              5
            ],
            9: [
              2,
              5
            ],
            10: [
              2,
              5
            ],
            11: [
              2,
              5
            ],
            12: [
              2,
              5
            ],
            13: [
              2,
              5
            ],
            14: [
              2,
              5
            ],
            15: [
              2,
              5
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              5
            ]
          },
          {
            5: [
              2,
              6
            ],
            6: [
              2,
              6
            ],
            7: [
              2,
              6
            ],
            8: [
              2,
              6
            ],
            9: [
              2,
              6
            ],
            10: [
              2,
              6
            ],
            11: [
              2,
              6
            ],
            12: [
              2,
              6
            ],
            13: [
              2,
              6
            ],
            14: [
              2,
              6
            ],
            15: [
              2,
              6
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              6
            ]
          },
          {
            5: [
              2,
              7
            ],
            6: [
              2,
              7
            ],
            7: [
              2,
              7
            ],
            8: [
              2,
              7
            ],
            9: [
              2,
              7
            ],
            10: [
              2,
              7
            ],
            11: [
              2,
              7
            ],
            12: [
              2,
              7
            ],
            13: [
              2,
              7
            ],
            14: [
              2,
              7
            ],
            15: [
              2,
              7
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              7
            ]
          },
          {
            5: [
              2,
              8
            ],
            6: [
              2,
              8
            ],
            7: [
              2,
              8
            ],
            8: [
              2,
              8
            ],
            9: [
              2,
              8
            ],
            10: [
              2,
              8
            ],
            11: [
              2,
              8
            ],
            12: [
              2,
              8
            ],
            13: [
              2,
              8
            ],
            14: [
              2,
              8
            ],
            15: [
              2,
              8
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              8
            ]
          },
          {
            5: [
              2,
              9
            ],
            6: [
              2,
              9
            ],
            7: [
              2,
              9
            ],
            8: [
              2,
              9
            ],
            9: [
              2,
              9
            ],
            10: [
              2,
              9
            ],
            11: [
              2,
              9
            ],
            12: [
              2,
              9
            ],
            13: [
              2,
              9
            ],
            14: [
              2,
              9
            ],
            15: [
              2,
              9
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              9
            ]
          },
          {
            5: [
              2,
              10
            ],
            6: [
              2,
              10
            ],
            7: [
              2,
              10
            ],
            8: [
              2,
              10
            ],
            9: [
              2,
              10
            ],
            10: [
              2,
              10
            ],
            11: [
              2,
              10
            ],
            12: [
              2,
              10
            ],
            13: [
              2,
              10
            ],
            14: [
              2,
              10
            ],
            15: [
              2,
              10
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              10
            ]
          },
          {
            5: [
              2,
              11
            ],
            6: [
              2,
              11
            ],
            7: [
              2,
              11
            ],
            8: [
              2,
              11
            ],
            9: [
              2,
              11
            ],
            10: [
              2,
              11
            ],
            11: [
              2,
              11
            ],
            12: [
              2,
              11
            ],
            13: [
              2,
              11
            ],
            14: [
              2,
              11
            ],
            15: [
              2,
              11
            ],
            16: [
              2,
              11
            ],
            18: [
              2,
              11
            ]
          },
          {
            5: [
              2,
              12
            ],
            6: [
              2,
              12
            ],
            7: [
              2,
              12
            ],
            8: [
              2,
              12
            ],
            9: [
              2,
              12
            ],
            10: [
              2,
              12
            ],
            11: [
              2,
              12
            ],
            12: [
              2,
              12
            ],
            13: [
              2,
              12
            ],
            14: [
              2,
              12
            ],
            15: [
              2,
              12
            ],
            16: [
              2,
              12
            ],
            18: [
              2,
              12
            ]
          },
          {
            4: 30,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              2
            ],
            6: [
              1,
              7
            ],
            7: [
              2,
              2
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              2
            ]
          }
        ],
        defaultActions: {
          6: [
            2,
            1
          ]
        },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse(input) {
          var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          if (typeof this.lexer.yylloc == 'undefined')
            this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          if (typeof this.yy.parseError === 'function')
            this.parseError = this.yy.parseError;
          function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
          }
          function lex() {
            var token;
            token = self.lexer.lex() || 1;
            if (typeof token !== 'number') {
              token = self.symbols_[token] || token;
            }
            return token;
          }
          var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol == null)
                symbol = lex();
              action = table[state] && table[state][symbol];
            }
            _handle_error:
              if (typeof action === 'undefined' || !action.length || !action[0]) {
                if (!recovering) {
                  expected = [];
                  for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                      expected.push('\'' + this.terminals_[p] + '\'');
                    }
                  var errStr = '';
                  if (this.lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + this.terminals_[symbol] + '\'';
                  } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == 1 ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                  }
                  this.parseError(errStr, {
                    text: this.lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: this.lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                  });
                }
                if (recovering == 3) {
                  if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  symbol = lex();
                }
                while (1) {
                  if (TERROR.toString() in table[state]) {
                    break;
                  }
                  if (state == 0) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  popStack(1);
                  state = stack[stack.length - 1];
                }
                preErrorSymbol = symbol;
                symbol = TERROR;
                state = stack[stack.length - 1];
                action = table[state] && table[state][TERROR];
                recovering = 3;
              }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }
            switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                  recovering--;
              } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== 'undefined') {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
            }
          }
          return true;
        }
      };
    var lexer = function () {
        var lexer = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parseError) {
                this.yy.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            setInput: function (input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = '';
              this.conditionStack = ['INITIAL'];
              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
              };
              return this;
            },
            input: function () {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/\n/);
              if (lines)
                this.yylineno++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function (ch) {
              this._input = ch + this._input;
              return this;
            },
            more: function () {
              this._more = true;
              return this;
            },
            pastInput: function () {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, '');
            },
            upcomingInput: function () {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, '');
            },
            showPosition: function () {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join('-');
              return pre + this.upcomingInput() + '\n' + c + '^';
            },
            next: function () {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match, col, lines;
              if (!this._more) {
                this.yytext = '';
                this.match = '';
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                match = this._input.match(this.rules[rules[i]]);
                if (match) {
                  lines = match[0].match(/\n.*/g);
                  if (lines)
                    this.yylineno += lines.length;
                  this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
                  };
                  this.yytext += match[0];
                  this.match += match[0];
                  this.matches = match;
                  this.yyleng = this.yytext.length;
                  this._more = false;
                  this._input = this._input.slice(match[0].length);
                  this.matched += match[0];
                  token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]);
                  if (token)
                    return token;
                  else
                    return;
                }
              }
              if (this._input === '') {
                return this.EOF;
              } else {
                this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                  text: '',
                  token: null,
                  line: this.yylineno
                });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== 'undefined') {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function () {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            return 20;
            break;
          case 2:
            return 19;
            break;
          case 3:
            return 8;
            break;
          case 4:
            return 9;
            break;
          case 5:
            return 6;
            break;
          case 6:
            return 7;
            break;
          case 7:
            return 11;
            break;
          case 8:
            return 13;
            break;
          case 9:
            return 10;
            break;
          case 10:
            return 12;
            break;
          case 11:
            return 14;
            break;
          case 12:
            return 15;
            break;
          case 13:
            return 16;
            break;
          case 14:
            return 17;
            break;
          case 15:
            return 18;
            break;
          case 16:
            return 5;
            break;
          case 17:
            return 'INVALID';
            break;
          }
        };
        lexer.rules = [
          /^\s+/,
          /^[0-9]+(\.[0-9]+)?\b/,
          /^n\b/,
          /^\|\|/,
          /^&&/,
          /^\?/,
          /^:/,
          /^<=/,
          /^>=/,
          /^</,
          /^>/,
          /^!=/,
          /^==/,
          /^%/,
          /^\(/,
          /^\)/,
          /^$/,
          /^./
        ];
        lexer.conditions = {
          'INITIAL': {
            'rules': [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            'inclusive': true
          }
        };
        return lexer;
      }();
    parser.lexer = lexer;
    return parser;
  }();
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Jed;
    }
    exports.Jed = Jed;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jed', function () {
        return Jed;
      });
    }
    root['Jed'] = Jed;
  }
}(this));
window.CodeMirror = function () {
  'use strict';
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var opera = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);
  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /windows/i.test(navigator.platform);
  var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (opera_version)
    opera_version = Number(opera_version[1]);
  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
  var captureMiddleClick = gecko || ie && !ie_lt9;
  var sawReadOnlySpans = false, sawCollapsedSpans = false;
  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror))
      return new CodeMirror(place, options);
    this.options = options = options || {};
    for (var opt in defaults)
      if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
        options[opt] = defaults[opt];
    setGuttersForLineNumbers(options);
    var docStart = typeof options.value == 'string' ? 0 : options.value.first;
    var display = this.display = makeDisplay(place, docStart);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    if (options.autofocus && !mobile)
      focusInput(this);
    this.state = {
      keyMaps: [],
      overlays: [],
      modeGen: 0,
      overwrite: false,
      focused: false,
      suppressEdits: false,
      pasteIncoming: false,
      draggingText: false,
      highlight: new Delayed()
    };
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += ' CodeMirror-wrap';
    var doc = options.value;
    if (typeof doc == 'string')
      doc = new Doc(options.value, options.mode);
    operation(this, attachDoc)(this, doc);
    if (ie)
      setTimeout(bind(resetInput, this, true), 20);
    registerEventHandlers(this);
    var hasFocus;
    try {
      hasFocus = document.activeElement == display.input;
    } catch (e) {
    }
    if (hasFocus || options.autofocus && !mobile)
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);
    operation(this, function () {
      for (var opt in optionHandlers)
        if (optionHandlers.propertyIsEnumerable(opt))
          optionHandlers[opt](this, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i)
        initHooks[i](this);
    })();
  }
  function makeDisplay(place, docStart) {
    var d = {};
    var input = d.input = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;');
    if (webkit)
      input.style.width = '1000px';
    else
      input.setAttribute('wrap', 'off');
    if (ios)
      input.style.border = '1px solid black';
    input.setAttribute('autocorrect', 'off');
    input.setAttribute('autocapitalize', 'off');
    d.inputDiv = elt('div', [input], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
    d.scrollbarH = elt('div', [elt('div', null, null, 'height: 1px')], 'CodeMirror-hscrollbar');
    d.scrollbarV = elt('div', [elt('div', null, null, 'width: 1px')], 'CodeMirror-vscrollbar');
    d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
    d.lineDiv = elt('div');
    d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
    d.cursor = elt('div', '\xa0', 'CodeMirror-cursor');
    d.otherCursor = elt('div', '\xa0', 'CodeMirror-cursor CodeMirror-secondarycursor');
    d.measure = elt('div', null, 'CodeMirror-measure');
    d.lineSpace = elt('div', [
      d.measure,
      d.selectionDiv,
      d.lineDiv,
      d.cursor,
      d.otherCursor
    ], null, 'position: relative; outline: none');
    d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
    d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
    d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerCutOff + 'px; width: 1px;');
    d.gutters = elt('div', null, 'CodeMirror-gutters');
    d.lineGutter = null;
    var scrollerInner = elt('div', [
        d.sizer,
        d.heightForcer,
        d.gutters
      ], null, 'position: relative; min-height: 100%');
    d.scroller = elt('div', [scrollerInner], 'CodeMirror-scroll');
    d.scroller.setAttribute('tabIndex', '-1');
    d.wrapper = elt('div', [
      d.inputDiv,
      d.scrollbarH,
      d.scrollbarV,
      d.scrollbarFiller,
      d.scroller
    ], 'CodeMirror');
    if (ie_lt8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    if (place.appendChild)
      place.appendChild(d.wrapper);
    else
      place(d.wrapper);
    if (ios)
      input.style.width = '0px';
    if (!webkit)
      d.scroller.draggable = true;
    if (khtml) {
      d.inputDiv.style.height = '1px';
      d.inputDiv.style.position = 'absolute';
    } else if (ie_lt8)
      d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = '18px';
    d.viewOffset = d.lastSizeC = 0;
    d.showingFrom = d.showingTo = docStart;
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    d.prevInput = '';
    d.alignWidgets = false;
    d.pollingFast = false;
    d.poll = new Delayed();
    d.cachedCharWidth = d.cachedTextHeight = null;
    d.measureLineCache = [];
    d.measureLineCachePos = 0;
    d.inaccurateSelection = false;
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
    return d;
  }
  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    cm.doc.iter(function (line) {
      if (line.stateAfter)
        line.stateAfter = null;
      if (line.styles)
        line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp)
      regChange(cm);
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      cm.display.wrapper.className += ' CodeMirror-wrap';
      cm.display.sizer.style.minWidth = '';
    } else {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-wrap', '');
      computeMaxLength(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      updateScrollbars(cm.display, cm.doc.height);
    }, 100);
  }
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      else if (wrapping)
        return (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return th;
    };
  }
  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height)
        updateLineHeight(line, estHeight);
    });
  }
  function keyMapChanged(cm) {
    var style = keyMap[cm.options.keyMap].style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, '') + (style ? ' cm-keymap-' + style : '');
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
    clearCaches(cm);
  }
  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
  }
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
      if (gutterClass == 'CodeMirror-linenumbers') {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
      }
    }
    gutters.style.display = i ? '' : 'none';
  }
  function lineLength(doc, line) {
    if (line.height == 0)
      return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find();
      cur = getLine(doc, found.from.line);
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find();
      len -= cur.text.length - found.from.ch;
      cur = getLine(doc, found.to.line);
      len += cur.text.length - found.to.ch;
    }
    return len;
  }
  function computeMaxLength(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(doc, d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(doc, line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }
  function setGuttersForLineNumbers(options) {
    var found = false;
    for (var i = 0; i < options.gutters.length; ++i) {
      if (options.gutters[i] == 'CodeMirror-linenumbers') {
        if (options.lineNumbers)
          found = true;
        else
          options.gutters.splice(i--, 1);
      }
    }
    if (!found && options.lineNumbers)
      options.gutters.push('CodeMirror-linenumbers');
  }
  function updateScrollbars(d, docHeight) {
    var totalHeight = docHeight + paddingVert(d);
    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + 'px';
    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
    var needsH = d.scroller.scrollWidth > d.scroller.clientWidth;
    var needsV = scrollHeight > d.scroller.clientHeight;
    if (needsV) {
      d.scrollbarV.style.display = 'block';
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + 'px';
    } else
      d.scrollbarV.style.display = '';
    if (needsH) {
      d.scrollbarH.style.display = 'block';
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + 'px';
    } else
      d.scrollbarH.style.display = '';
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = 'block';
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + 'px';
    } else
      d.scrollbarFiller.style.display = '';
    if (mac_geLion && scrollbarWidth(d.measure) === 0)
      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? '18px' : '12px';
  }
  function visibleLines(display, doc, viewPort) {
    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
    if (typeof viewPort == 'number')
      top = viewPort;
    else if (viewPort) {
      top = viewPort.top;
      height = viewPort.bottom - viewPort.top;
    }
    top = Math.floor(top - paddingTop(display));
    var bottom = Math.ceil(top + height);
    return {
      from: lineAtHeight(doc, top),
      to: lineAtHeight(doc, bottom)
    };
  }
  function alignHorizontally(cm) {
    var display = cm.display;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
      return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, l = comp + 'px';
    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling)
      if (n.alignable) {
        for (var i = 0, a = n.alignable; i < a.length; ++i)
          a[i].style.left = l;
      }
    if (cm.options.fixedGutter)
      display.gutters.style.left = comp + gutterW + 'px';
  }
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers)
      return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = '';
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + 'px';
      return true;
    }
    return false;
  }
  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  function compensateForHScroll(display) {
    return getRect(display.scroller).left - getRect(display.sizer).left;
  }
  function updateDisplay(cm, changes, viewPort) {
    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (;;) {
      if (updateDisplayInner(cm, changes, visible)) {
        updated = true;
        signalLater(cm, 'update', cm);
        if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
          signalLater(cm, 'viewportChange', cm, cm.display.showingFrom, cm.display.showingTo);
      } else
        break;
      updateSelection(cm);
      updateScrollbars(cm.display, cm.doc.height);
      if (viewPort)
        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == 'number' ? viewPort : viewPort.top);
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
        break;
      changes = [];
    }
    return updated;
  }
  function updateDisplayInner(cm, changes, visible) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.clientWidth) {
      display.showingFrom = display.showingTo = doc.first;
      display.viewOffset = 0;
      return;
    }
    if (changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo)
      return;
    if (maybeUpdateLineNumberWidth(cm))
      changes = [{
          from: doc.first,
          to: doc.first + doc.size
        }];
    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + 'px';
    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : '0';
    var positionsChangedFrom = Infinity;
    if (cm.options.lineNumbers)
      for (var i = 0; i < changes.length; ++i)
        if (changes[i].diff) {
          positionsChangedFrom = changes[i].from;
          break;
        }
    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.showingFrom < from && from - display.showingFrom < 20)
      from = Math.max(doc.first, display.showingFrom);
    if (display.showingTo > to && display.showingTo - to < 20)
      to = Math.min(end, display.showingTo);
    if (sawCollapsedSpans) {
      from = lineNo(visualLine(doc, getLine(doc, from)));
      while (to < end && lineIsHidden(doc, getLine(doc, to)))
        ++to;
    }
    var intact = [{
          from: Math.max(display.showingFrom, doc.first),
          to: Math.min(display.showingTo, end)
        }];
    if (intact[0].from >= intact[0].to)
      intact = [];
    else
      intact = computeIntact(intact, changes);
    if (sawCollapsedSpans)
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i], merged;
        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
          var newTo = merged.find().from.line;
          if (newTo > range.from)
            range.to = newTo;
          else {
            intact.splice(i--, 1);
            break;
          }
        }
      }
    var intactLines = 0;
    for (var i = 0; i < intact.length; ++i) {
      var range = intact[i];
      if (range.from < from)
        range.from = from;
      if (range.to > to)
        range.to = to;
      if (range.from >= range.to)
        intact.splice(i--, 1);
      else
        intactLines += range.to - range.from;
    }
    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
      updateViewOffset(cm);
      return;
    }
    intact.sort(function (a, b) {
      return a.from - b.from;
    });
    try {
      var focused = document.activeElement;
    } catch (e) {
    }
    if (intactLines < (to - from) * 0.7)
      display.lineDiv.style.display = 'none';
    patchDisplay(cm, from, to, intact, positionsChangedFrom);
    display.lineDiv.style.display = '';
    if (focused && document.activeElement != focused && focused.offsetHeight)
      focused.focus();
    var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
    if (different)
      display.lastSizeC = display.wrapper.clientHeight;
    display.showingFrom = from;
    display.showingTo = to;
    startWorker(cm, 100);
    var prevBottom = display.lineDiv.offsetTop;
    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling)
      if (node.lineObj) {
        if (ie_lt8) {
          var bot = node.offsetTop + node.offsetHeight;
          height = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = getRect(node);
          height = box.bottom - box.top;
        }
        var diff = node.lineObj.height - height;
        if (height < 2)
          height = textHeight(display);
        if (diff > 0.001 || diff < -0.001) {
          updateLineHeight(node.lineObj, height);
          var widgets = node.lineObj.widgets;
          if (widgets)
            for (var i = 0; i < widgets.length; ++i)
              widgets[i].height = widgets[i].node.offsetHeight;
        }
      }
    updateViewOffset(cm);
    return true;
  }
  function updateViewOffset(cm) {
    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
    cm.display.mover.style.top = off + 'px';
  }
  function computeIntact(intact, changes) {
    for (var i = 0, l = changes.length || 0; i < l; ++i) {
      var change = changes[i], intact2 = [], diff = change.diff || 0;
      for (var j = 0, l2 = intact.length; j < l2; ++j) {
        var range = intact[j];
        if (change.to <= range.from && change.diff) {
          intact2.push({
            from: range.from + diff,
            to: range.to + diff
          });
        } else if (change.to <= range.from || change.from >= range.to) {
          intact2.push(range);
        } else {
          if (change.from > range.from)
            intact2.push({
              from: range.from,
              to: change.from
            });
          if (change.to < range.to)
            intact2.push({
              from: change.to + diff,
              to: range.to + diff
            });
        }
      }
      intact = intact2;
    }
    return intact;
  }
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }
  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
    var dims = getDimensions(cm);
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
      removeChildren(display.lineDiv);
    var container = display.lineDiv, cur = container.firstChild;
    function rm(node) {
      var next = node.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = 'none';
        node.lineObj = null;
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }
    var nextIntact = intact.shift(), lineN = from;
    cm.doc.iter(from, to, function (line) {
      if (nextIntact && nextIntact.to == lineN)
        nextIntact = intact.shift();
      if (lineIsHidden(cm.doc, line)) {
        if (line.height != 0)
          updateLineHeight(line, 0);
        if (line.widgets && cur.previousSibling)
          for (var i = 0; i < line.widgets.length; ++i)
            if (line.widgets[i].showIfHidden) {
              var prev = cur.previousSibling;
              if (/pre/i.test(prev.nodeName)) {
                var wrap = elt('div', null, null, 'position: relative');
                prev.parentNode.replaceChild(wrap, prev);
                wrap.appendChild(prev);
                prev = wrap;
              }
              var wnode = prev.appendChild(elt('div', [line.widgets[i].node], 'CodeMirror-linewidget'));
              positionLineWidget(line.widgets[i], wnode, prev, dims);
            }
      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
        while (cur.lineObj != line)
          cur = rm(cur);
        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
        cur = cur.nextSibling;
      } else {
        if (line.widgets)
          for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
            if (search.lineObj == line && /div/i.test(search.nodeName)) {
              reuse = search;
              break;
            }
        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
        if (lineNode != reuse) {
          container.insertBefore(lineNode, cur);
        } else {
          while (cur != reuse)
            cur = rm(cur);
          cur = cur.nextSibling;
        }
        lineNode.lineObj = line;
      }
      ++lineN;
    });
    while (cur)
      cur = rm(cur);
  }
  function buildLineElement(cm, line, lineNo, dims, reuse) {
    var lineElement = lineContent(cm, line);
    var markers = line.gutterMarkers, display = cm.display, wrap;
    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)
      return lineElement;
    if (reuse) {
      reuse.alignable = null;
      var isOk = true, widgetsSeen = 0;
      for (var n = reuse.firstChild, next; n; n = next) {
        next = n.nextSibling;
        if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
          reuse.removeChild(n);
        } else {
          for (var i = 0, first = true; i < line.widgets.length; ++i) {
            var widget = line.widgets[i], isFirst = false;
            if (!widget.above) {
              isFirst = first;
              first = false;
            }
            if (widget.node == n.firstChild) {
              positionLineWidget(widget, n, reuse, dims);
              ++widgetsSeen;
              if (isFirst)
                reuse.insertBefore(lineElement, n);
              break;
            }
          }
          if (i == line.widgets.length) {
            isOk = false;
            break;
          }
        }
      }
      if (isOk && widgetsSeen == line.widgets.length) {
        wrap = reuse;
        reuse.className = line.wrapClass || '';
      }
    }
    if (!wrap) {
      wrap = elt('div', null, line.wrapClass, 'position: relative');
      wrap.appendChild(lineElement);
    }
    if (line.bgClass)
      wrap.insertBefore(elt('div', null, line.bgClass + ' CodeMirror-linebackground'), wrap.firstChild);
    if (cm.options.lineNumbers || markers) {
      var gutterWrap = wrap.insertBefore(elt('div', null, null, 'position: absolute; left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px'), wrap.firstChild);
      if (cm.options.fixedGutter)
        (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
      if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
        wrap.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineNo), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + display.lineNumInnerWidth + 'px'));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
        }
    }
    if (ie_lt8)
      wrap.style.zIndex = 2;
    if (line.widgets && wrap != reuse)
      for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
        var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
        positionLineWidget(widget, node, wrap, dims);
        if (widget.above)
          wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
        else
          wrap.appendChild(node);
        signalLater(widget, 'redraw');
      }
    return wrap;
  }
  function positionLineWidget(widget, node, wrap, dims) {
    if (widget.noHScroll) {
      (wrap.alignable || (wrap.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + 'px';
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + 'px';
      }
      node.style.width = width + 'px';
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = 'relative';
      if (!widget.noHScroll)
        node.style.marginLeft = -dims.gutterTotalWidth + 'px';
    }
  }
  function updateSelection(cm) {
    var display = cm.display;
    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
    if (collapsed || cm.options.showCursorWhenSelecting)
      updateSelectionCursor(cm);
    else
      display.cursor.style.display = display.otherCursor.style.display = 'none';
    if (!collapsed)
      updateSelectionRange(cm);
    else
      display.selectionDiv.style.display = 'none';
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, cm.doc.sel.head, 'div');
      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + 'px';
      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + 'px';
    }
  }
  function updateSelectionCursor(cm) {
    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, 'div');
    display.cursor.style.left = pos.left + 'px';
    display.cursor.style.top = pos.top + 'px';
    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
    display.cursor.style.display = '';
    if (pos.other) {
      display.otherCursor.style.display = '';
      display.otherCursor.style.left = pos.other.left + 'px';
      display.otherCursor.style.top = pos.other.top + 'px';
      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
    } else {
      display.otherCursor.style.display = 'none';
    }
  }
  function updateSelectionRange(cm) {
    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
    var fragment = document.createDocumentFragment();
    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);
    function add(left, top, width, bottom) {
      if (top < 0)
        top = 0;
      fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? clientWidth - left : width) + 'px; height: ' + (bottom - top) + 'px'));
    }
    function drawForLine(line, fromArg, toArg, retTop) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length, rVal = retTop ? Infinity : -Infinity;
      function coords(ch) {
        return charCoords(cm, Pos(line, ch), 'div', lineObj);
      }
      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
        var leftPos = coords(from), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1);
          if (dir == 'rtl') {
            var tmp = leftPos;
            leftPos = rightPos;
            rightPos = tmp;
          }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (rightPos.top - leftPos.top > 3) {
          add(left, leftPos.top, null, leftPos.bottom);
          left = pl;
          if (leftPos.bottom < rightPos.top)
            add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen)
          right = clientWidth;
        if (fromArg == null && from == 0)
          left = pl;
        rVal = retTop ? Math.min(rightPos.top, rVal) : Math.max(rightPos.bottom, rVal);
        if (left < pl + 1)
          left = pl;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return rVal;
    }
    if (sel.from.line == sel.to.line) {
      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
    } else {
      var fromObj = getLine(doc, sel.from.line);
      var cur = fromObj, merged, path = [
          sel.from.line,
          sel.from.ch
        ], singleLine;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found = merged.find();
        path.push(found.from.ch, found.to.line, found.to.ch);
        if (found.to.line == sel.to.line) {
          path.push(sel.to.ch);
          singleLine = true;
          break;
        }
        cur = getLine(doc, found.to.line);
      }
      if (singleLine) {
        for (var i = 0; i < path.length; i += 3)
          drawForLine(path[i], path[i + 1], path[i + 2]);
      } else {
        var middleTop, middleBot, toObj = getLine(doc, sel.to.line);
        if (sel.from.ch)
          middleTop = drawForLine(sel.from.line, sel.from.ch, null, false);
        else
          middleTop = heightAtLine(cm, fromObj) - display.viewOffset;
        if (!sel.to.ch)
          middleBot = heightAtLine(cm, toObj) - display.viewOffset;
        else
          middleBot = drawForLine(sel.to.line, collapsedSpanAtStart(toObj) ? null : 0, sel.to.ch, true);
        if (middleTop < middleBot)
          add(pl, middleTop, null, middleBot);
      }
    }
    removeChildrenAndAdd(display.selectionDiv, fragment);
    display.selectionDiv.style.display = '';
  }
  function restartBlink(cm) {
    if (!cm.state.focused)
      return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = '';
    display.blinker = setInterval(function () {
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? '' : 'hidden';
    }, cm.options.cursorBlinkRate);
  }
  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }
  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first)
      doc.frontier = doc.first;
    if (doc.frontier >= cm.display.showingTo)
      return;
    var end = +new Date() + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changed = [], prevChange;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {
      if (doc.frontier >= cm.display.showingFrom) {
        var oldStyles = line.styles;
        line.styles = highlightLine(cm, line, state);
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i)
          ischange = oldStyles[i] != line.styles[i];
        if (ischange) {
          if (prevChange && prevChange.end == doc.frontier)
            prevChange.end++;
          else
            changed.push(prevChange = {
              start: doc.frontier,
              end: doc.frontier + 1
            });
        }
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changed.length)
      operation(cm, function () {
        for (var i = 0; i < changed.length; ++i)
          regChange(this, changed[i].start, changed[i].end);
      })();
  }
  function findStartLine(cm, n) {
    var minindent, minline, doc = cm.doc;
    for (var search = n, lim = n - 100; search > lim; --search) {
      if (search <= doc.first)
        return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter)
        return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function getStateBefore(cm, n) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState)
      return true;
    var pos = findStartLine(cm, n), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
    if (!state)
      state = startState(doc.mode);
    else
      state = copyState(doc.mode, state);
    doc.iter(pos, n, function (line) {
      processLine(cm, line, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    return state;
  }
  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingLeft(display) {
    var e = removeChildrenAndAdd(display.measure, elt('pre', null, null, 'text-align: left')).appendChild(elt('span', 'x'));
    return e.offsetLeft;
  }
  function measureChar(cm, line, ch, data) {
    var dir = -1;
    data = data || measureLine(cm, line);
    for (var pos = ch;; pos += dir) {
      var r = data[pos];
      if (r)
        break;
      if (dir < 0 && pos == 0)
        dir = 1;
    }
    return {
      left: pos < ch ? r.right : r.left,
      right: pos > ch ? r.left : r.right,
      top: r.top,
      bottom: r.bottom
    };
  }
  function findCachedMeasurement(cm, line) {
    var cache = cm.display.measureLineCache;
    for (var i = 0; i < cache.length; ++i) {
      var memo = cache[i];
      if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + '|' + line.bgClass + '|' + line.wrapClass)
        return memo.measure;
    }
  }
  function measureLine(cm, line) {
    var measure = findCachedMeasurement(cm, line);
    if (!measure) {
      measure = measureLineInner(cm, line);
      var cache = cm.display.measureLineCache;
      var memo = {
          text: line.text,
          width: cm.display.scroller.clientWidth,
          markedSpans: line.markedSpans,
          measure: measure,
          classes: line.textClass + '|' + line.bgClass + '|' + line.wrapClass
        };
      if (cache.length == 16)
        cache[++cm.display.measureLineCachePos % 16] = memo;
      else
        cache.push(memo);
    }
    return measure;
  }
  function measureLineInner(cm, line) {
    var display = cm.display, measure = emptyArray(line.text.length);
    var pre = lineContent(cm, line, measure);
    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
      var fragment = document.createDocumentFragment();
      var chunk = 10, n = pre.childNodes.length;
      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
        var wrap = elt('div', null, null, 'display: inline-block');
        for (var j = 0; j < chunk && n; ++j) {
          wrap.appendChild(pre.firstChild);
          --n;
        }
        fragment.appendChild(wrap);
      }
      pre.appendChild(fragment);
    }
    removeChildrenAndAdd(display.measure, pre);
    var outer = getRect(display.lineDiv);
    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
    if (ie_lt9 && display.measure.first != pre)
      removeChildrenAndAdd(display.measure, pre);
    for (var i = 0, cur; i < measure.length; ++i)
      if (cur = measure[i]) {
        var size = getRect(cur);
        var top = Math.max(0, size.top - outer.top), bot = Math.min(size.bottom - outer.top, maxBot);
        for (var j = 0; j < vranges.length; j += 2) {
          var rtop = vranges[j], rbot = vranges[j + 1];
          if (rtop > bot || rbot < top)
            continue;
          if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {
            vranges[j] = Math.min(top, rtop);
            vranges[j + 1] = Math.max(bot, rbot);
            break;
          }
        }
        if (j == vranges.length)
          vranges.push(top, bot);
        var right = size.right;
        if (cur.measureRight)
          right = getRect(cur.measureRight).left;
        data[i] = {
          left: size.left - outer.left,
          right: right - outer.left,
          top: j
        };
      }
    for (var i = 0, cur; i < data.length; ++i)
      if (cur = data[i]) {
        var vr = cur.top;
        cur.top = vranges[vr];
        cur.bottom = vranges[vr + 1];
      }
    return data;
  }
  function measureLineWidth(cm, line) {
    var hasBadSpan = false;
    if (line.markedSpans)
      for (var i = 0; i < line.markedSpans; ++i) {
        var sp = line.markedSpans[i];
        if (sp.collapsed && (sp.to == null || sp.to == line.text.length))
          hasBadSpan = true;
      }
    var cached = !hasBadSpan && findCachedMeasurement(cm, line);
    if (cached)
      return measureChar(cm, line, line.text.length, cached).right;
    var pre = lineContent(cm, line);
    var end = pre.appendChild(zeroWidthElement(cm.display.measure));
    removeChildrenAndAdd(cm.display.measure, pre);
    return getRect(end).right - getRect(cm.display.lineDiv).left;
  }
  function clearCaches(cm) {
    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
    if (!cm.options.lineWrapping)
      cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets)
      for (var i = 0; i < lineObj.widgets.length; ++i)
        if (lineObj.widgets[i].above) {
          var size = widgetHeight(lineObj.widgets[i]);
          rect.top += size;
          rect.bottom += size;
        }
    if (context == 'line')
      return rect;
    if (!context)
      context = 'local';
    var yOff = heightAtLine(cm, lineObj);
    if (context != 'local')
      yOff -= cm.display.viewOffset;
    if (context == 'page') {
      var lOff = getRect(cm.display.lineSpace);
      yOff += lOff.top + (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      var xOff = lOff.left + (window.pageXOffset || (document.documentElement || document.body).scrollLeft);
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }
  function fromCoordSystem(cm, coords, context) {
    if (context == 'div')
      return coords;
    var left = coords.left, top = coords.top;
    if (context == 'page') {
      left -= window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      top -= window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    var lineSpaceBox = getRect(cm.display.lineSpace);
    left -= lineSpaceBox.left;
    top -= lineSpaceBox.top;
    if (context == 'local' || !context) {
      var editorBox = getRect(cm.display.wrapper);
      left += editorBox.left;
      top += editorBox.top;
    }
    return {
      left: left,
      top: top
    };
  }
  function charCoords(cm, pos, context, lineObj) {
    if (!lineObj)
      lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch), context);
  }
  function cursorCoords(cm, pos, context, lineObj, measurement) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!measurement)
      measurement = measureLine(cm, lineObj);
    function get(ch, right) {
      var m = measureChar(cm, lineObj, ch, measurement);
      if (right)
        m.left = m.right;
      else
        m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order)
      return get(ch);
    var main, other, linedir = order[0].level;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i], rtl = part.level % 2, nb, here;
      if (part.from < ch && part.to > ch)
        return get(ch, rtl);
      var left = rtl ? part.to : part.from, right = rtl ? part.from : part.to;
      if (left == ch) {
        if (i && part.level < (nb = order[i - 1]).level)
          here = get(nb.level % 2 ? nb.from : nb.to - 1, true);
        else
          here = get(rtl && part.from != part.to ? ch - 1 : ch);
        if (rtl == linedir)
          main = here;
        else
          other = here;
      } else if (right == ch) {
        var nb = i < order.length - 1 && order[i + 1];
        if (!rtl && nb && nb.from == nb.to)
          continue;
        if (nb && part.level < nb.level)
          here = get(nb.level % 2 ? nb.to - 1 : nb.from);
        else
          here = get(rtl ? ch : ch - 1, true);
        if (rtl == linedir)
          main = here;
        else
          other = here;
      }
    }
    if (linedir && !ch)
      other = get(order[0].to - 1);
    if (!main)
      return other;
    if (other)
      main.other = other;
    return main;
  }
  function PosMaybeOutside(line, ch, outside) {
    var pos = new Pos(line, ch);
    if (outside)
      pos.outside = true;
    return pos;
  }
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0)
      return PosMaybeOutside(doc.first, 0, true);
    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineNo > last)
      return PosMaybeOutside(doc.first + doc.size - 1, getLine(doc, last).text.length, true);
    if (x < 0)
      x = 0;
    for (;;) {
      var lineObj = getLine(doc, lineNo);
      var found = coordsCharInner(cm, lineObj, lineNo, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find();
      if (merged && found.ch >= mergedPos.from.ch)
        lineNo = mergedPos.to.line;
      else
        return found;
    }
  }
  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(cm, lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var measurement = measureLine(cm, lineObj);
    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, measurement);
      wrongLine = true;
      if (innerOff > sp.bottom)
        return sp.left - adjust;
      else if (innerOff < sp.top)
        return sp.left + adjust;
      else
        wrongLine = false;
      return sp.left;
    }
    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
    if (x > toX)
      return PosMaybeOutside(lineNo, to, toOutside);
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var after = x - fromX < toX - x, ch = after ? from : to;
        while (isExtendingChar.test(lineObj.text.charAt(ch)))
          ++ch;
        var pos = PosMaybeOutside(lineNo, ch, after ? fromOutside : toOutside);
        pos.after = after;
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i)
          middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {
        to = middle;
        toX = middleX;
        if (toOutside = wrongLine)
          toX += 1000;
        dist = step;
      } else {
        from = middle;
        fromX = middleX;
        fromOutside = wrongLine;
        dist -= step;
      }
    }
  }
  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null)
      return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt('pre');
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode('x'));
        measureText.appendChild(elt('br'));
      }
      measureText.appendChild(document.createTextNode('x'));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3)
      display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }
  function charWidth(display) {
    if (display.cachedCharWidth != null)
      return display.cachedCharWidth;
    var anchor = elt('span', 'x');
    var pre = elt('pre', [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var width = anchor.offsetWidth;
    if (width > 2)
      display.cachedCharWidth = width;
    return width || 10;
  }
  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      changes: [],
      updateInput: null,
      userSelChange: null,
      textChanged: null,
      selectionChanged: false,
      cursorActivity: false,
      updateMaxLine: false,
      updateScrollPos: false,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++)
      delayedCallbacks = [];
  }
  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;
    if (op.updateMaxLine)
      computeMaxLength(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
      var width = measureLineWidth(cm, display.maxLine);
      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + 'px';
      display.maxLineChanged = false;
      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
    }
    var newScrollPos, updated;
    if (op.updateScrollPos) {
      newScrollPos = op.updateScrollPos;
    } else if (op.selectionChanged && display.scroller.clientHeight) {
      var coords = cursorCoords(cm, doc.sel.head);
      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
    }
    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null) {
      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);
      if (cm.display.scroller.offsetHeight)
        cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    if (!updated && op.selectionChanged)
      updateSelection(cm);
    if (op.updateScrollPos) {
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
      alignHorizontally(cm);
      if (op.scrollToPos)
        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
    } else if (newScrollPos) {
      scrollCursorIntoView(cm);
    }
    if (op.selectionChanged)
      restartBlink(cm);
    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.userSelChange);
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden)
      for (var i = 0; i < hidden.length; ++i)
        if (!hidden[i].lines.length)
          signal(hidden[i], 'hide');
    if (unhidden)
      for (var i = 0; i < unhidden.length; ++i)
        if (unhidden[i].lines.length)
          signal(unhidden[i], 'unhide');
    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    if (op.textChanged)
      signal(cm, 'change', cm, op.textChanged);
    if (op.cursorActivity)
      signal(cm, 'cursorActivity', cm);
    if (delayed)
      for (var i = 0; i < delayed.length; ++i)
        delayed[i]();
  }
  function operation(cm1, f) {
    return function () {
      var cm = cm1 || this, withOp = !cm.curOp;
      if (withOp)
        startOperation(cm);
      try {
        var result = f.apply(cm, arguments);
      } finally {
        if (withOp)
          endOperation(cm);
      }
      return result;
    };
  }
  function docOperation(f) {
    return function () {
      var withOp = this.cm && !this.cm.curOp, result;
      if (withOp)
        startOperation(this.cm);
      try {
        result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  function runInOp(cm, f) {
    var withOp = !cm.curOp, result;
    if (withOp)
      startOperation(cm);
    try {
      result = f();
    } finally {
      if (withOp)
        endOperation(cm);
    }
    return result;
  }
  function regChange(cm, from, to, lendiff) {
    if (from == null)
      from = cm.doc.first;
    if (to == null)
      to = cm.doc.first + cm.doc.size;
    cm.curOp.changes.push({
      from: from,
      to: to,
      diff: lendiff
    });
  }
  function slowPoll(cm) {
    if (cm.display.pollingFast)
      return;
    cm.display.poll.set(cm.options.pollInterval, function () {
      readInput(cm);
      if (cm.state.focused)
        slowPoll(cm);
    });
  }
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {
        missed = true;
        cm.display.poll.set(60, p);
      } else {
        cm.display.pollingFast = false;
        slowPoll(cm);
      }
    }
    cm.display.poll.set(20, p);
  }
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm))
      return false;
    var text = input.value;
    if (text == prevInput && posEq(sel.from, sel.to))
      return false;
    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
      resetInput(cm, true);
      return false;
    }
    var withOp = !cm.curOp;
    if (withOp)
      startOperation(cm);
    sel.shift = false;
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
      ++same;
    var from = sel.from, to = sel.to;
    if (same < prevInput.length)
      from = Pos(from.line, from.ch - (prevInput.length - same));
    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));
    var updateInput = cm.curOp.updateInput;
    makeChange(cm.doc, {
      from: from,
      to: to,
      text: splitLines(text.slice(same)),
      origin: cm.state.pasteIncoming ? 'paste' : '+input'
    }, 'end');
    cm.curOp.updateInput = updateInput;
    if (text.length > 1000 || text.indexOf('\n') > -1)
      input.value = cm.display.prevInput = '';
    else
      cm.display.prevInput = text;
    if (withOp)
      endOperation(cm);
    cm.state.pasteIncoming = false;
    return true;
  }
  function resetInput(cm, user) {
    var minimal, selected, doc = cm.doc;
    if (!posEq(doc.sel.from, doc.sel.to)) {
      cm.display.prevInput = '';
      minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? '-' : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused)
        selectInput(cm.display.input);
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = content;
    } else if (user) {
      cm.display.prevInput = cm.display.input.value = '';
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }
  function focusInput(cm) {
    if (cm.options.readOnly != 'nocursor' && (!mobile || document.activeElement != cm.display.input))
      cm.display.input.focus();
  }
  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, 'mousedown', operation(cm, onMouseDown));
    if (ie)
      on(d.scroller, 'dblclick', operation(cm, function (e) {
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
          return;
        e_preventDefault(e);
        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
        extendSelection(cm.doc, word.from, word.to);
      }));
    else
      on(d.scroller, 'dblclick', e_preventDefault);
    on(d.lineSpace, 'selectstart', function (e) {
      if (!eventInWidget(d, e))
        e_preventDefault(e);
    });
    if (!captureMiddleClick)
      on(d.scroller, 'contextmenu', function (e) {
        onContextMenu(cm, e);
      });
    on(d.scroller, 'scroll', function () {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, 'scroll', cm);
      }
    });
    on(d.scrollbarV, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });
    on(d.scroller, 'mousewheel', function (e) {
      onScrollWheel(cm, e);
    });
    on(d.scroller, 'DOMMouseScroll', function (e) {
      onScrollWheel(cm, e);
    });
    function reFocus() {
      if (cm.state.focused)
        setTimeout(bind(focusInput, cm), 0);
    }
    on(d.scrollbarH, 'mousedown', reFocus);
    on(d.scrollbarV, 'mousedown', reFocus);
    on(d.wrapper, 'scroll', function () {
      d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    function onResize() {
      d.cachedCharWidth = d.cachedTextHeight = null;
      clearCaches(cm);
      runInOp(cm, bind(regChange, cm));
    }
    on(window, 'resize', onResize);
    function unregister() {
      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {
      }
      if (p)
        setTimeout(unregister, 5000);
      else
        off(window, 'resize', onResize);
    }
    setTimeout(unregister, 5000);
    on(d.input, 'keyup', operation(cm, function (e) {
      if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
        return;
      if (e.keyCode == 16)
        cm.doc.sel.shift = false;
    }));
    on(d.input, 'input', bind(fastPoll, cm));
    on(d.input, 'keydown', operation(cm, onKeyDown));
    on(d.input, 'keypress', operation(cm, onKeyPress));
    on(d.input, 'focus', bind(onFocus, cm));
    on(d.input, 'blur', bind(onBlur, cm));
    function drag_(e) {
      if (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
        return;
      e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, 'dragstart', function (e) {
        onDragStart(cm, e);
      });
      on(d.scroller, 'dragenter', drag_);
      on(d.scroller, 'dragover', drag_);
      on(d.scroller, 'drop', operation(cm, onDrop));
    }
    on(d.scroller, 'paste', function (e) {
      if (eventInWidget(d, e))
        return;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, 'paste', function () {
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });
    function prepareCopy() {
      if (d.inaccurateSelection) {
        d.prevInput = '';
        d.inaccurateSelection = false;
        d.input.value = cm.getSelection();
        selectInput(d.input);
      }
    }
    on(d.input, 'cut', prepareCopy);
    on(d.input, 'copy', prepareCopy);
    if (khtml)
      on(d.sizer, 'mouseup', function () {
        if (document.activeElement == d.input)
          d.input.blur();
        focusInput(cm);
      });
  }
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n)
        return true;
      if (/\bCodeMirror-(?:line)?widget\b/.test(n.className) || n.parentNode == display.sizer && n != display.mover)
        return true;
    }
  }
  function posFromMouse(cm, e, liberal) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller)
        return null;
    }
    var x, y, space = getRect(display.lineSpace);
    try {
      x = e.clientX;
      y = e.clientY;
    } catch (e) {
      return null;
    }
    return coordsChar(cm, x - space.left, y - space.top);
  }
  var lastClick, lastDoubleClick;
  function onMouseDown(e) {
    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
    sel.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function () {
          display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e))
      return;
    var start = posFromMouse(cm, e);
    switch (e_button(e)) {
    case 3:
      if (captureMiddleClick)
        onContextMenu.call(cm, cm, e);
      return;
    case 2:
      if (start)
        extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      return;
    }
    if (!start) {
      if (e_target(e) == display.scroller)
        e_preventDefault(e);
      return;
    }
    if (!cm.state.focused)
      onFocus(cm);
    var now = +new Date(), type = 'single';
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
      type = 'triple';
      e_preventDefault(e);
      setTimeout(bind(focusInput, cm), 20);
      selectLine(cm, start.line);
    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
      type = 'double';
      lastDoubleClick = {
        time: now,
        pos: start
      };
      e_preventDefault(e);
      var word = findWordAt(getLine(doc, start.line).text, start);
      extendSelection(cm.doc, word.from, word.to);
    } else {
      lastClick = {
        time: now,
        pos: start
      };
    }
    var last = start;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == 'single') {
      var dragEnd = operation(cm, function (e2) {
          if (webkit)
            display.scroller.draggable = false;
          cm.state.draggingText = false;
          off(document, 'mouseup', dragEnd);
          off(display.scroller, 'drop', dragEnd);
          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
            e_preventDefault(e2);
            extendSelection(cm.doc, start);
            focusInput(cm);
          }
        });
      if (webkit)
        display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      if (display.scroller.dragDrop)
        display.scroller.dragDrop();
      on(document, 'mouseup', dragEnd);
      on(display.scroller, 'drop', dragEnd);
      return;
    }
    e_preventDefault(e);
    if (type == 'single')
      extendSelection(cm.doc, clipPos(doc, start));
    var startstart = sel.from, startend = sel.to, lastPos = start;
    function doSelect(cur) {
      if (posEq(lastPos, cur))
        return;
      lastPos = cur;
      if (type == 'single') {
        extendSelection(cm.doc, clipPos(doc, start), cur);
        return;
      }
      startstart = clipPos(doc, startstart);
      startend = clipPos(doc, startend);
      if (type == 'double') {
        var word = findWordAt(getLine(doc, cur.line).text, cur);
        if (posLess(cur, startstart))
          extendSelection(cm.doc, word.from, startend);
        else
          extendSelection(cm.doc, startstart, word.to);
      } else if (type == 'triple') {
        if (posLess(cur, startstart))
          extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
        else
          extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
      }
    }
    var editorSize = getRect(display.wrapper);
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true);
      if (!cur)
        return;
      if (!posEq(cur, last)) {
        if (!cm.state.focused)
          onFocus(cm);
        last = cur;
        doSelect(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function () {
            if (counter == curCount)
              extend(e);
          }), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside)
          setTimeout(operation(cm, function () {
            if (counter != curCount)
              return;
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
      }
    }
    function done(e) {
      counter = Infinity;
      var cur = posFromMouse(cm, e);
      if (cur)
        doSelect(cur);
      e_preventDefault(e);
      focusInput(cm);
      off(document, 'mousemove', move);
      off(document, 'mouseup', up);
    }
    var move = operation(cm, function (e) {
        if (!ie && !e_button(e))
          done(e);
        else
          extend(e);
      });
    var up = operation(cm, done);
    on(document, 'mousemove', move);
    on(document, 'mouseup', up);
  }
  function onDrop(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
      return;
    e_preventDefault(e);
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm))
      return;
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        var reader = new FileReader();
        reader.onload = function () {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            makeChange(cm.doc, {
              from: pos,
              to: pos,
              text: splitLines(text.join('\n')),
              origin: 'paste'
            }, 'around');
          }
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i)
        loadFile(files[i], i);
    } else {
      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
        cm.state.draggingText(e);
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData('Text');
        if (text) {
          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
          setSelection(cm.doc, pos, pos);
          if (cm.state.draggingText)
            replaceRange(cm.doc, '', curFrom, curTo, 'paste');
          cm.replaceSelection(text, null, 'paste');
          focusInput(cm);
          onFocus(cm);
        }
      } catch (e) {
      }
    }
  }
  function clickInGutter(cm, e) {
    var display = cm.display;
    try {
      var mX = e.clientX, mY = e.clientY;
    } catch (e) {
      return false;
    }
    if (mX >= Math.floor(getRect(display.gutters).right))
      return false;
    e_preventDefault(e);
    if (!hasHandler(cm, 'gutterClick'))
      return true;
    var lineBox = getRect(display.lineDiv);
    if (mY > lineBox.bottom)
      return true;
    mY -= lineBox.top - display.viewOffset;
    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && getRect(g).right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalLater(cm, 'gutterClick', cm, line, gutter, e);
        break;
      }
    }
    return true;
  }
  function onDragStart(cm, e) {
    if (ie && !cm.state.draggingText) {
      e_stop(e);
      return;
    }
    if (eventInWidget(cm.display, e))
      return;
    var txt = cm.getSelection();
    e.dataTransfer.setData('Text', txt);
    if (e.dataTransfer.setDragImage) {
      var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
      if (opera) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        img._top = img.offsetTop;
      }
      if (safari) {
        if (cm.display.dragImg) {
          img = cm.display.dragImg;
        } else {
          cm.display.dragImg = img;
          img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
          cm.display.wrapper.appendChild(img);
        }
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (opera)
        img.parentNode.removeChild(img);
    }
  }
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2)
      return;
    cm.doc.scrollTop = val;
    if (!gecko)
      updateDisplay(cm, [], val);
    if (cm.display.scroller.scrollTop != val)
      cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val)
      cm.display.scrollbarV.scrollTop = val;
    if (gecko)
      updateDisplay(cm, []);
  }
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
      return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val)
      cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val)
      cm.display.scrollbarH.scrollLeft = val;
  }
  var wheelSamples = 0, wheelPixelsPerUnit = null;
  if (ie)
    wheelPixelsPerUnit = -0.53;
  else if (gecko)
    wheelPixelsPerUnit = 15;
  else if (chrome)
    wheelPixelsPerUnit = -0.7;
  else if (safari)
    wheelPixelsPerUnit = -1 / 3;
  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
      dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
      dy = e.detail;
    else if (dy == null)
      dy = e.wheelDelta;
    var display = cm.display, scroll = display.scroller;
    if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
      return;
    if (dy && mac && webkit) {
      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
        if (cur.lineObj) {
          cm.display.currentWheelTarget = cur;
          break;
        }
      }
    }
    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null;
      return;
    }
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0)
        top = Math.max(0, top + pixels - 50);
      else
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, [], {
        top: top,
        bottom: bot
      });
    }
    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null)
            return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample)
            return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == 'string') {
      bound = commands[bound];
      if (!bound)
        return false;
    }
    if (cm.display.pollingFast && readInput(cm))
      cm.display.pollingFast = false;
    var doc = cm.doc, prevShift = doc.sel.shift, done = false;
    try {
      if (isReadOnly(cm))
        cm.state.suppressEdits = true;
      if (dropShift)
        doc.sel.shift = false;
      done = bound(cm) != Pass;
    } finally {
      doc.sel.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys)
      maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }
  var maybeTransition;
  function handleKeyBinding(cm, e) {
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e))
      maybeTransition = setTimeout(function () {
        if (getKeyMap(cm.options.keyMap) == startMap)
          cm.options.keyMap = next.call ? next.call(null, cm) : next;
      }, 50);
    var name = keyName(e, true), handled = false;
    if (!name)
      return false;
    var keymaps = allKeyMaps(cm);
    if (e.shiftKey) {
      handled = lookupKey('Shift-' + name, keymaps, function (b) {
        return doHandleBinding(cm, b, true);
      }) || lookupKey(name, keymaps, function (b) {
        if (typeof b == 'string' && /^go[A-Z]/.test(b))
          return doHandleBinding(cm, b);
      });
    } else {
      handled = lookupKey(name, keymaps, function (b) {
        return doHandleBinding(cm, b);
      });
    }
    if (handled == 'stop')
      handled = false;
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      if (ie_lt9) {
        e.oldKeyCode = e.keyCode;
        e.keyCode = 0;
      }
    }
    return handled;
  }
  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey('\'' + ch + '\'', allKeyMaps(cm), function (b) {
        return doHandleBinding(cm, b, true);
      });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
    }
    return handled;
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (!cm.state.focused)
      onFocus(cm);
    if (ie && e.keyCode == 27) {
      e.returnValue = false;
    }
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var code = e.keyCode;
    cm.doc.sel.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (opera) {
      lastStoppedKey = handled ? code : null;
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection('');
    }
  }
  function onKeyPress(e) {
    var cm = this;
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (opera && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e))
      return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1)
      setTimeout(operation(cm, function () {
        indentLine(cm, cm.doc.sel.to.line, 'smart');
      }), 75);
    if (handleCharBinding(cm, e, ch))
      return;
    if (ie && !ie_lt9)
      cm.display.inputHasSelection = null;
    fastPoll(cm);
  }
  function onFocus(cm) {
    if (cm.options.readOnly == 'nocursor')
      return;
    if (!cm.state.focused) {
      signal(cm, 'focus', cm);
      cm.state.focused = true;
      if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
        cm.display.wrapper.className += ' CodeMirror-focused';
      resetInput(cm, true);
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, 'blur', cm);
      cm.state.focused = false;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-focused', '');
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused)
        cm.doc.sel.shift = false;
    }, 150);
  }
  var detectingSelectAll;
  function onContextMenu(cm, e) {
    var display = cm.display, sel = cm.doc.sel;
    if (eventInWidget(display, e))
      return;
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || opera)
      return;
    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
      operation(cm, setSelection)(cm.doc, pos, pos);
    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = 'absolute';
    display.input.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: white; outline: none;' + 'border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);';
    focusInput(cm);
    resetInput(cm, true);
    if (posEq(sel.from, sel.to))
      display.input.value = display.prevInput = ' ';
    function rehide() {
      display.inputDiv.style.position = 'relative';
      display.input.style.cssText = oldCSS;
      if (ie_lt9)
        display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);
      if (display.input.selectionStart != null && (!ie || ie_lt9)) {
        clearTimeout(detectingSelectAll);
        var extval = display.input.value = ' ' + (posEq(sel.from, sel.to) ? '' : display.input.value), i = 0;
        display.prevInput = ' ';
        display.input.selectionStart = 1;
        display.input.selectionEnd = extval.length;
        var poll = function () {
          if (display.prevInput == ' ' && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10)
            detectingSelectAll = setTimeout(poll, 500);
          else
            resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (captureMiddleClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, 'mouseup', mouseup);
        setTimeout(rehide, 20);
      };
      on(window, 'mouseup', mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }
  function changeEnd(change) {
    if (!change.text)
      return change.to;
    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  }
  function clipPostChange(doc, change, pos) {
    if (!posLess(change.from, pos))
      return clipPos(doc, pos);
    var diff = change.text.length - 1 - (change.to.line - change.from.line);
    if (pos.line > change.to.line + diff) {
      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
      if (preLine > lastLine)
        return Pos(lastLine, getLine(doc, lastLine).text.length);
      return clipToLen(pos, getLine(doc, preLine).text.length);
    }
    if (pos.line == change.to.line + diff)
      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
    var inside = pos.line - change.from.line;
    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
  }
  function computeSelAfterChange(doc, change, hint) {
    if (hint && typeof hint == 'object')
      return {
        anchor: clipPostChange(doc, change, hint.anchor),
        head: clipPostChange(doc, change, hint.head)
      };
    if (hint == 'start')
      return {
        anchor: change.from,
        head: change.from
      };
    var end = changeEnd(change);
    if (hint == 'around')
      return {
        anchor: change.from,
        head: end
      };
    if (hint == 'end')
      return {
        anchor: end,
        head: end
      };
    var adjustPos = function (pos) {
      if (posLess(pos, change.from))
        return pos;
      if (!posLess(change.to, pos))
        return end;
      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line)
        ch += end.ch - change.to.ch;
      return Pos(line, ch);
    };
    return {
      anchor: adjustPos(doc.sel.anchor),
      head: adjustPos(doc.sel.head)
    };
  }
  function filterChange(doc, change) {
    var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        update: function (from, to, text, origin) {
          if (from)
            this.from = clipPos(doc, from);
          if (to)
            this.to = clipPos(doc, to);
          if (text)
            this.text = text;
          if (origin !== undefined)
            this.origin = origin;
        },
        cancel: function () {
          this.canceled = true;
        }
      };
    signal(doc, 'beforeChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeChange', doc.cm, obj);
    if (obj.canceled)
      return null;
    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  }
  function makeChange(doc, change, selUpdate, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp)
        return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
      if (doc.cm.state.suppressEdits)
        return;
    }
    if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
      change = filterChange(doc, change);
      if (!change)
        return;
    }
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 1; --i)
        makeChangeNoReadonly(doc, {
          from: split[i].from,
          to: split[i].to,
          text: ['']
        });
      if (split.length)
        makeChangeNoReadonly(doc, {
          from: split[0].from,
          to: split[0].to,
          text: change.text
        }, selUpdate);
    } else {
      makeChangeNoReadonly(doc, change, selUpdate);
    }
  }
  function makeChangeNoReadonly(doc, change, selUpdate) {
    var selAfter = computeSelAfterChange(doc, change, selUpdate);
    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }
  function makeChangeFromHistory(doc, type) {
    if (doc.cm && doc.cm.state.suppressEdits)
      return;
    var hist = doc.history;
    var event = (type == 'undo' ? hist.done : hist.undone).pop();
    if (!event)
      return;
    hist.dirtyCounter += type == 'undo' ? -1 : 1;
    var anti = {
        changes: [],
        anchorBefore: event.anchorAfter,
        headBefore: event.headAfter,
        anchorAfter: event.anchorBefore,
        headAfter: event.headBefore
      };
    (type == 'undo' ? hist.undone : hist.done).push(anti);
    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      anti.changes.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change, null) : {
          anchor: event.anchorBefore,
          head: event.headBefore
        };
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      var rebased = [];
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }
  function shiftDoc(doc, distance) {
    function shiftPos(pos) {
      return Pos(pos.line + distance, pos.ch);
    }
    doc.first += distance;
    if (doc.cm)
      regChange(doc.cm, doc.first, doc.first, distance);
    doc.sel.head = shiftPos(doc.sel.head);
    doc.sel.anchor = shiftPos(doc.sel.anchor);
    doc.sel.from = shiftPos(doc.sel.from);
    doc.sel.to = shiftPos(doc.sel.to);
  }
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine())
      return;
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc, change.from, change.to);
    if (!selAfter)
      selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm)
      makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
    else
      updateDoc(doc, change, spans, selAfter);
  }
  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
      cm.curOp.cursorActivity = true;
    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(doc, line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength)
        cm.curOp.updateMaxLine = true;
    }
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    regChange(cm, from.line, to.line + 1, lendiff);
    if (hasHandler(cm, 'change')) {
      var changeObj = {
          from: from,
          to: to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
      if (cm.curOp.textChanged) {
        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {
        }
        cur.next = changeObj;
      } else
        cm.curOp.textChanged = changeObj;
    }
  }
  function replaceRange(doc, code, from, to, origin) {
    if (!to)
      to = from;
    if (posLess(to, from)) {
      var tmp = to;
      to = from;
      from = tmp;
    }
    if (typeof code == 'string')
      code = splitLines(code);
    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    }, null);
  }
  function Pos(line, ch) {
    if (!(this instanceof Pos))
      return new Pos(line, ch);
    this.line = line;
    this.ch = ch;
  }
  CodeMirror.Pos = Pos;
  function posEq(a, b) {
    return a.line == b.line && a.ch == b.ch;
  }
  function posLess(a, b) {
    return a.line < b.line || a.line == b.line && a.ch < b.ch;
  }
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function clipPos(doc, pos) {
    if (pos.line < doc.first)
      return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last)
      return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen)
      return Pos(pos.line, linelen);
    else if (ch < 0)
      return Pos(pos.line, 0);
    else
      return pos;
  }
  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }
  function extendSelection(doc, pos, other, bias) {
    if (doc.sel.shift || doc.sel.extend) {
      var anchor = doc.sel.anchor;
      if (other) {
        var posBefore = posLess(pos, anchor);
        if (posBefore != posLess(other, anchor)) {
          anchor = pos;
          pos = other;
        } else if (posBefore != posLess(pos, other)) {
          pos = other;
        }
      }
      setSelection(doc, anchor, pos, bias);
    } else {
      setSelection(doc, pos, other || pos, bias);
    }
    if (doc.cm)
      doc.cm.curOp.userSelChange = true;
  }
  function filterSelectionChange(doc, anchor, head) {
    var obj = {
        anchor: anchor,
        head: head
      };
    signal(doc, 'beforeSelectionChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
    obj.anchor = clipPos(doc, obj.anchor);
    obj.head = clipPos(doc, obj.head);
    return obj;
  }
  function setSelection(doc, anchor, head, bias, checkAtomic) {
    if (!checkAtomic && hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange')) {
      var filtered = filterSelectionChange(doc, anchor, head);
      head = filtered.head;
      anchor = filtered.anchor;
    }
    var sel = doc.sel;
    sel.goalColumn = null;
    if (checkAtomic || !posEq(anchor, sel.anchor))
      anchor = skipAtomic(doc, anchor, bias, checkAtomic != 'push');
    if (checkAtomic || !posEq(head, sel.head))
      head = skipAtomic(doc, head, bias, checkAtomic != 'push');
    if (posEq(sel.anchor, anchor) && posEq(sel.head, head))
      return;
    sel.anchor = anchor;
    sel.head = head;
    var inv = posLess(head, anchor);
    sel.from = inv ? head : anchor;
    sel.to = inv ? anchor : head;
    if (doc.cm)
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;
    signalLater(doc, 'cursorActivity', doc);
  }
  function reCheckSelection(cm) {
    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, 'push');
  }
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search:
      for (;;) {
        var line = getLine(doc, curPos.line);
        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i], m = sp.marker;
            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
              if (mayClear) {
                signal(m, 'beforeCursorEnter');
                if (m.explicitlyCleared) {
                  if (!line.markedSpans)
                    break;
                  else {
                    --i;
                    continue;
                  }
                }
              }
              if (!m.atomic)
                continue;
              var newPos = m.find()[dir < 0 ? 'from' : 'to'];
              if (posEq(newPos, curPos)) {
                newPos.ch += dir;
                if (newPos.ch < 0) {
                  if (newPos.line > doc.first)
                    newPos = clipPos(doc, Pos(newPos.line - 1));
                  else
                    newPos = null;
                } else if (newPos.ch > line.text.length) {
                  if (newPos.line < doc.first + doc.size - 1)
                    newPos = Pos(newPos.line + 1, 0);
                  else
                    newPos = null;
                }
                if (!newPos) {
                  if (flipped) {
                    if (!mayClear)
                      return skipAtomic(doc, pos, bias, true);
                    doc.cantEdit = true;
                    return Pos(doc.first, 0);
                  }
                  flipped = true;
                  newPos = pos;
                  dir = -dir;
                }
              }
              curPos = newPos;
              continue search;
            }
          }
        }
        return curPos;
      }
  }
  function scrollCursorIntoView(cm) {
    var coords = scrollPosIntoView(cm, cm.doc.sel.head);
    if (!cm.state.focused)
      return;
    var display = cm.display, box = getRect(display.sizer), doScroll = null, pTop = paddingTop(cm.display);
    if (coords.top + pTop + box.top < 0)
      doScroll = true;
    else if (coords.bottom + pTop + box.top > (window.innerHeight || document.documentElement.clientHeight))
      doScroll = false;
    if (doScroll != null && !phantom) {
      var hidden = display.cursor.style.display == 'none';
      if (hidden) {
        display.cursor.style.display = '';
        display.cursor.style.left = coords.left + 'px';
        display.cursor.style.top = coords.top - display.viewOffset + 'px';
      }
      display.cursor.scrollIntoView(doScroll);
      if (hidden)
        display.cursor.style.display = 'none';
    }
  }
  function scrollPosIntoView(cm, pos, margin) {
    if (margin == null)
      margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1)
          changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
          changed = true;
      }
      if (!changed)
        return coords;
    }
  }
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null)
      setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null)
      setScrollLeft(cm, scrollPos.scrollLeft);
  }
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, pt = paddingTop(display);
    y1 += pt;
    y2 += pt;
    if (y1 < 0)
      y1 = 0;
    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < pt + 10, atBottom = y2 + pt > docBottom - 10;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop)
        result.scrollTop = newTop;
    }
    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
    x1 += display.gutters.offsetWidth;
    x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft)
        x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }
  function updateScrollPos(cm, left, top) {
    cm.curOp.updateScrollPos = {
      scrollLeft: left == null ? cm.doc.scrollLeft : left,
      scrollTop: top == null ? cm.doc.scrollTop : top
    };
  }
  function addToScrollPos(cm, left, top) {
    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {
        scrollLeft: cm.doc.scrollLeft,
        scrollTop: cm.doc.scrollTop
      });
    var scroll = cm.display.scroller;
    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
  }
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc;
    if (!how)
      how = 'add';
    if (how == 'smart') {
      if (!cm.doc.mode.indent)
        how = 'prev';
      else
        var state = getStateBefore(cm, n);
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (how == 'smart') {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive)
          return;
        how = 'prev';
      }
    }
    if (how == 'prev') {
      if (n > doc.first)
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      else
        indentation = 0;
    } else if (how == 'add') {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == 'subtract') {
      indentation = curSpace - cm.options.indentUnit;
    }
    indentation = Math.max(0, indentation);
    var indentString = '', pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += '\t';
      }
    if (pos < indentation)
      indentString += spaceStr(indentation - pos);
    if (indentString != curSpaceString)
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
    line.stateAfter = null;
  }
  function changeLine(cm, handle, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == 'number')
      line = getLine(doc, clipLine(doc, handle));
    else
      no = lineNo(handle);
    if (no == null)
      return null;
    if (op(line, no))
      regChange(cm, no, no + 1);
    else
      return null;
    return line;
  }
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size)
        return possible = false;
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually)
            ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else
            ch = dir < 0 ? lineObj.text.length : 0;
        } else
          return possible = false;
      } else
        ch = next;
      return true;
    }
    if (unit == 'char')
      moveOnce();
    else if (unit == 'column')
      moveOnce(true);
    else if (unit == 'word' || unit == 'group') {
      var sawType = null, group = unit == 'group';
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first))
          break;
        var cur = lineObj.text.charAt(ch) || '\n';
        var type = isWordChar(cur) ? 'w' : !group ? null : /\s/.test(cur) ? null : 'p';
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
          }
          break;
        }
        if (type)
          sawType = type;
        if (dir > 0 && !moveOnce(!first))
          break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), dir, true);
    if (!possible)
      result.hitSide = true;
    return result;
  }
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == 'page') {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
    } else if (unit == 'line') {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside)
        break;
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }
  function findWordAt(line, pos) {
    var start = pos.ch, end = pos.ch;
    if (line) {
      if (pos.after === false || end == line.length)
        --start;
      else
        ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ? function (ch) {
          return /\s/.test(ch);
        } : function (ch) {
          return !/\s/.test(ch) && !isWordChar(ch);
        };
      while (start > 0 && check(line.charAt(start - 1)))
        --start;
      while (end < line.length && check(line.charAt(end)))
        ++end;
    }
    return {
      from: Pos(pos.line, start),
      to: Pos(pos.line, end)
    };
  }
  function selectLine(cm, line) {
    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
  }
  CodeMirror.prototype = {
    focus: function () {
      window.focus();
      focusInput(this);
      onFocus(this);
      fastPoll(this);
    },
    setOption: function (option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != 'mode')
        return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },
    getOption: function (option) {
      return this.options[option];
    },
    getDoc: function () {
      return this.doc;
    },
    addKeyMap: function (map, bottom) {
      this.state.keyMaps[bottom ? 'push' : 'unshift'](map);
    },
    removeKeyMap: function (map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if ((typeof map == 'string' ? maps[i].name : maps[i]) == map) {
          maps.splice(i, 1);
          return true;
        }
    },
    addOverlay: operation(null, function (spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState)
        throw new Error('Overlays may not be stateful.');
      this.state.overlays.push({
        mode: mode,
        modeSpec: spec,
        opaque: options && options.opaque
      });
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: operation(null, function (spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        if (overlays[i].modeSpec == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),
    indentLine: operation(null, function (n, dir, aggressive) {
      if (typeof dir != 'string') {
        if (dir == null)
          dir = this.options.smartIndent ? 'smart' : 'prev';
        else
          dir = dir ? 'add' : 'subtract';
      }
      if (isLine(this.doc, n))
        indentLine(this, n, dir, aggressive);
    }),
    indentSelection: operation(null, function (how) {
      var sel = this.doc.sel;
      if (posEq(sel.from, sel.to))
        return indentLine(this, sel.from.line, how);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i)
        indentLine(this, i, how);
    }),
    getTokenAt: function (pos) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {
        start: stream.start,
        end: stream.pos,
        string: stream.current(),
        className: style || null,
        type: style || null,
        state: state
      };
    },
    getStateAfter: function (line) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
      return getStateBefore(this, line + 1);
    },
    cursorCoords: function (start, mode) {
      var pos, sel = this.doc.sel;
      if (start == null)
        pos = sel.head;
      else if (typeof start == 'object')
        pos = clipPos(this.doc, start);
      else
        pos = start ? sel.from : sel.to;
      return cursorCoords(this, pos, mode || 'page');
    },
    charCoords: function (pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || 'page');
    },
    coordsChar: function (coords, mode) {
      coords = fromCoordSystem(this, coords, mode || 'page');
      return coordsChar(this, coords.left, coords.top);
    },
    defaultTextHeight: function () {
      return textHeight(this.display);
    },
    defaultCharWidth: function () {
      return charWidth(this.display);
    },
    setGutterMarker: operation(null, function (line, gutterID, value) {
      return changeLine(this, line, function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers))
          line.gutterMarkers = null;
        return true;
      });
    }),
    clearGutter: operation(null, function (gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regChange(cm, i, i + 1);
          if (isEmpty(line.gutterMarkers))
            line.gutterMarkers = null;
        }
        ++i;
      });
    }),
    addLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        if (!line[prop])
          line[prop] = cls;
        else if (new RegExp('\\b' + cls + '\\b').test(line[prop]))
          return false;
        else
          line[prop] += ' ' + cls;
        return true;
      });
    }),
    removeLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        var cur = line[prop];
        if (!cur)
          return false;
        else if (cls == null)
          line[prop] = null;
        else {
          var upd = cur.replace(new RegExp('^' + cls + '\\b\\s*|\\s*\\b' + cls + '\\b'), '');
          if (upd == cur)
            return false;
          line[prop] = upd || null;
        }
        return true;
      });
    }),
    addLineWidget: operation(null, function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function (widget) {
      widget.clear();
    },
    lineInfo: function (line) {
      if (typeof line == 'number') {
        if (!isLine(this.doc, line))
          return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line)
          return null;
      } else {
        var n = lineNo(line);
        if (n == null)
          return null;
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    getViewport: function () {
      return {
        from: this.display.showingFrom,
        to: this.display.showingTo
      };
    },
    addWidget: function (pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = 'absolute';
      display.sizer.appendChild(node);
      if (vert == 'over') {
        top = pos.top;
      } else if (vert == 'above' || vert == 'near') {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + paddingTop(display) + 'px';
      node.style.left = node.style.right = '';
      if (horiz == 'right') {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = '0px';
      } else {
        if (horiz == 'left')
          left = 0;
        else if (horiz == 'middle')
          left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + 'px';
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },
    triggerOnKeyDown: operation(null, onKeyDown),
    execCommand: function (cmd) {
      return commands[cmd](this);
    },
    findPosH: function (from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveH: operation(null, function (dir, unit) {
      var sel = this.doc.sel, pos;
      if (sel.shift || sel.extend || posEq(sel.from, sel.to))
        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
      else
        pos = dir < 0 ? sel.from : sel.to;
      extendSelection(this.doc, pos, pos, dir);
    }),
    deleteH: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      if (!posEq(sel.from, sel.to))
        replaceRange(this.doc, '', sel.from, sel.to, '+delete');
      else
        replaceRange(this.doc, '', sel.from, findPosH(this.doc, sel.head, dir, unit, false), '+delete');
      this.curOp.userSelChange = true;
    }),
    findPosV: function (from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, 'div');
        if (x == null)
          x = coords.left;
        else
          coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveV: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      var pos = cursorCoords(this, sel.head, 'div');
      if (sel.goalColumn != null)
        pos.left = sel.goalColumn;
      var target = findPosV(this, pos, dir, unit);
      if (unit == 'page')
        addToScrollPos(this, 0, charCoords(this, target, 'div').top - pos.top);
      extendSelection(this.doc, target, target, dir);
      sel.goalColumn = pos.left;
    }),
    toggleOverwrite: function () {
      if (this.state.overwrite = !this.state.overwrite)
        this.display.cursor.className += ' CodeMirror-overwrite';
      else
        this.display.cursor.className = this.display.cursor.className.replace(' CodeMirror-overwrite', '');
    },
    hasFocus: function () {
      return this.state.focused;
    },
    scrollTo: operation(null, function (x, y) {
      updateScrollPos(this, x, y);
    }),
    getScrollInfo: function () {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {
        left: scroller.scrollLeft,
        top: scroller.scrollTop,
        height: scroller.scrollHeight - co,
        width: scroller.scrollWidth - co,
        clientHeight: scroller.clientHeight - co,
        clientWidth: scroller.clientWidth - co
      };
    },
    scrollIntoView: operation(null, function (pos, margin) {
      if (typeof pos == 'number')
        pos = Pos(pos, 0);
      if (!margin)
        margin = 0;
      var coords = pos;
      if (!pos || pos.line != null) {
        this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
        this.curOp.scrollToPosMargin = margin;
        coords = cursorCoords(this, this.curOp.scrollToPos);
      }
      var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
    }),
    setSize: function (width, height) {
      function interpret(val) {
        return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
      }
      if (width != null)
        this.display.wrapper.style.width = interpret(width);
      if (height != null)
        this.display.wrapper.style.height = interpret(height);
      this.refresh();
    },
    on: function (type, f) {
      on(this, type, f);
    },
    off: function (type, f) {
      off(this, type, f);
    },
    operation: function (f) {
      return runInOp(this, f);
    },
    refresh: operation(null, function () {
      clearCaches(this);
      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
      regChange(this);
    }),
    swapDoc: operation(null, function (doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this, true);
      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
      return old;
    }),
    getInputField: function () {
      return this.display.input;
    },
    getWrapperElement: function () {
      return this.display.wrapper;
    },
    getScrollerElement: function () {
      return this.display.scroller;
    },
    getGutterElement: function () {
      return this.display.gutters;
    }
  };
  var optionHandlers = CodeMirror.optionHandlers = {};
  var defaults = CodeMirror.defaults = {};
  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle)
      optionHandlers[name] = notOnInit ? function (cm, val, old) {
        if (old != Init)
          handle(cm, val, old);
      } : handle;
  }
  var Init = CodeMirror.Init = {
      toString: function () {
        return 'CodeMirror.Init';
      }
    };
  option('value', '', function (cm, val) {
    cm.setValue(val);
  }, true);
  option('mode', null, function (cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);
  option('indentUnit', 2, loadMode, true);
  option('indentWithTabs', false);
  option('smartIndent', true);
  option('tabSize', 4, function (cm) {
    loadMode(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option('electricChars', true);
  option('rtlMoveVisually', !windows);
  option('theme', 'default', function (cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option('keyMap', 'default', keyMapChanged);
  option('extraKeys', null);
  option('onKeyEvent', null);
  option('onDragEvent', null);
  option('lineWrapping', false, wrappingChanged, true);
  option('gutters', [], function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('fixedGutter', true, function (cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
    cm.refresh();
  }, true);
  option('lineNumbers', false, function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('firstLineNumber', 1, guttersChanged, true);
  option('lineNumberFormatter', function (integer) {
    return integer;
  }, guttersChanged, true);
  option('showCursorWhenSelecting', false, updateSelection, true);
  option('readOnly', false, function (cm, val) {
    if (val == 'nocursor') {
      onBlur(cm);
      cm.display.input.blur();
    } else if (!val)
      resetInput(cm, true);
  });
  option('dragDrop', true);
  option('cursorBlinkRate', 530);
  option('cursorHeight', 1);
  option('workTime', 100);
  option('workDelay', 100);
  option('flattenSpans', true);
  option('pollInterval', 100);
  option('undoDepth', 40, function (cm, val) {
    cm.doc.history.undoDepth = val;
  });
  option('historyEventDelay', 500);
  option('viewportMargin', 10, function (cm) {
    cm.refresh();
  }, true);
  option('maxHighlightLength', 10000, function (cm) {
    loadMode(cm);
    cm.refresh();
  }, true);
  option('moveInputWithCursor', true, function (cm, val) {
    if (!val)
      cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });
  option('tabindex', null, function (cm, val) {
    cm.display.input.tabIndex = val || '';
  });
  option('autofocus', null);
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
  CodeMirror.defineMode = function (name, mode) {
    if (!CodeMirror.defaults.mode && name != 'null')
      CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i)
        mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };
  CodeMirror.defineMIME = function (mime, spec) {
    mimeModes[mime] = spec;
  };
  CodeMirror.resolveMode = function (spec) {
    if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec))
      spec = mimeModes[spec];
    else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec))
      return CodeMirror.resolveMode('application/xml');
    if (typeof spec == 'string')
      return { name: spec };
    else
      return spec || { name: 'null' };
  };
  CodeMirror.getMode = function (options, spec) {
    spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory)
      return CodeMirror.getMode(options, 'text/plain');
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop))
          continue;
        if (modeObj.hasOwnProperty(prop))
          modeObj['_' + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    return modeObj;
  };
  CodeMirror.defineMode('null', function () {
    return {
      token: function (stream) {
        stream.skipToEnd();
      }
    };
  });
  CodeMirror.defineMIME('text/plain', 'null');
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function (mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  };
  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;
  var initHooks = [];
  CodeMirror.defineInitHook = function (f) {
    initHooks.push(f);
  };
  function copyState(mode, state) {
    if (state === true)
      return state;
    if (mode.copyState)
      return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array)
        val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;
  CodeMirror.innerMode = function (mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      state = info.state;
      mode = info.mode;
    }
    return info || {
      mode: mode,
      state: state
    };
  };
  var commands = CodeMirror.commands = {
      selectAll: function (cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));
      },
      killLine: function (cm) {
        var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
        if (!sel && cm.getLine(from.line).length == from.ch)
          cm.replaceRange('', from, Pos(from.line + 1, 0), '+delete');
        else
          cm.replaceRange('', from, sel ? to : Pos(from.line), '+delete');
      },
      deleteLine: function (cm) {
        var l = cm.getCursor().line;
        cm.replaceRange('', Pos(l, 0), Pos(l), '+delete');
      },
      undo: function (cm) {
        cm.undo();
      },
      redo: function (cm) {
        cm.redo();
      },
      goDocStart: function (cm) {
        cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function (cm) {
        cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function (cm) {
        cm.extendSelection(lineStart(cm, cm.getCursor().line));
      },
      goLineStartSmart: function (cm) {
        var cur = cm.getCursor(), start = lineStart(cm, cur.line);
        var line = cm.getLineHandle(start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
          cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
        } else
          cm.extendSelection(start);
      },
      goLineEnd: function (cm) {
        cm.extendSelection(lineEnd(cm, cm.getCursor().line));
      },
      goLineRight: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, 'div'));
      },
      goLineLeft: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: 0,
          top: top
        }, 'div'));
      },
      goLineUp: function (cm) {
        cm.moveV(-1, 'line');
      },
      goLineDown: function (cm) {
        cm.moveV(1, 'line');
      },
      goPageUp: function (cm) {
        cm.moveV(-1, 'page');
      },
      goPageDown: function (cm) {
        cm.moveV(1, 'page');
      },
      goCharLeft: function (cm) {
        cm.moveH(-1, 'char');
      },
      goCharRight: function (cm) {
        cm.moveH(1, 'char');
      },
      goColumnLeft: function (cm) {
        cm.moveH(-1, 'column');
      },
      goColumnRight: function (cm) {
        cm.moveH(1, 'column');
      },
      goWordLeft: function (cm) {
        cm.moveH(-1, 'word');
      },
      goGroupRight: function (cm) {
        cm.moveH(1, 'group');
      },
      goGroupLeft: function (cm) {
        cm.moveH(-1, 'group');
      },
      goWordRight: function (cm) {
        cm.moveH(1, 'word');
      },
      delCharBefore: function (cm) {
        cm.deleteH(-1, 'char');
      },
      delCharAfter: function (cm) {
        cm.deleteH(1, 'char');
      },
      delWordBefore: function (cm) {
        cm.deleteH(-1, 'word');
      },
      delWordAfter: function (cm) {
        cm.deleteH(1, 'word');
      },
      delGroupBefore: function (cm) {
        cm.deleteH(-1, 'group');
      },
      delGroupAfter: function (cm) {
        cm.deleteH(1, 'group');
      },
      indentAuto: function (cm) {
        cm.indentSelection('smart');
      },
      indentMore: function (cm) {
        cm.indentSelection('add');
      },
      indentLess: function (cm) {
        cm.indentSelection('subtract');
      },
      insertTab: function (cm) {
        cm.replaceSelection('\t', 'end', '+input');
      },
      defaultTab: function (cm) {
        if (cm.somethingSelected())
          cm.indentSelection('add');
        else
          cm.replaceSelection('\t', 'end', '+input');
      },
      transposeChars: function (cm) {
        var cur = cm.getCursor(), line = cm.getLine(cur.line);
        if (cur.ch > 0 && cur.ch < line.length - 1)
          cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
      },
      newlineAndIndent: function (cm) {
        operation(cm, function () {
          cm.replaceSelection('\n', 'end', '+input');
          cm.indentLine(cm.getCursor().line, null, true);
        })();
      },
      toggleOverwrite: function (cm) {
        cm.toggleOverwrite();
      }
    };
  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    'Left': 'goCharLeft',
    'Right': 'goCharRight',
    'Up': 'goLineUp',
    'Down': 'goLineDown',
    'End': 'goLineEnd',
    'Home': 'goLineStartSmart',
    'PageUp': 'goPageUp',
    'PageDown': 'goPageDown',
    'Delete': 'delCharAfter',
    'Backspace': 'delCharBefore',
    'Tab': 'defaultTab',
    'Shift-Tab': 'indentAuto',
    'Enter': 'newlineAndIndent',
    'Insert': 'toggleOverwrite'
  };
  keyMap.pcDefault = {
    'Ctrl-A': 'selectAll',
    'Ctrl-D': 'deleteLine',
    'Ctrl-Z': 'undo',
    'Shift-Ctrl-Z': 'redo',
    'Ctrl-Y': 'redo',
    'Ctrl-Home': 'goDocStart',
    'Alt-Up': 'goDocStart',
    'Ctrl-End': 'goDocEnd',
    'Ctrl-Down': 'goDocEnd',
    'Ctrl-Left': 'goGroupLeft',
    'Ctrl-Right': 'goGroupRight',
    'Alt-Left': 'goLineStart',
    'Alt-Right': 'goLineEnd',
    'Ctrl-Backspace': 'delGroupBefore',
    'Ctrl-Delete': 'delGroupAfter',
    'Ctrl-S': 'save',
    'Ctrl-F': 'find',
    'Ctrl-G': 'findNext',
    'Shift-Ctrl-G': 'findPrev',
    'Shift-Ctrl-F': 'replace',
    'Shift-Ctrl-R': 'replaceAll',
    'Ctrl-[': 'indentLess',
    'Ctrl-]': 'indentMore',
    fallthrough: 'basic'
  };
  keyMap.macDefault = {
    'Cmd-A': 'selectAll',
    'Cmd-D': 'deleteLine',
    'Cmd-Z': 'undo',
    'Shift-Cmd-Z': 'redo',
    'Cmd-Y': 'redo',
    'Cmd-Up': 'goDocStart',
    'Cmd-End': 'goDocEnd',
    'Cmd-Down': 'goDocEnd',
    'Alt-Left': 'goGroupLeft',
    'Alt-Right': 'goGroupRight',
    'Cmd-Left': 'goLineStart',
    'Cmd-Right': 'goLineEnd',
    'Alt-Backspace': 'delGroupBefore',
    'Ctrl-Alt-Backspace': 'delGroupAfter',
    'Alt-Delete': 'delGroupAfter',
    'Cmd-S': 'save',
    'Cmd-F': 'find',
    'Cmd-G': 'findNext',
    'Shift-Cmd-G': 'findPrev',
    'Cmd-Alt-F': 'replace',
    'Shift-Cmd-Alt-F': 'replaceAll',
    'Cmd-[': 'indentLess',
    'Cmd-]': 'indentMore',
    fallthrough: [
      'basic',
      'emacsy'
    ]
  };
  keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    'Ctrl-F': 'goCharRight',
    'Ctrl-B': 'goCharLeft',
    'Ctrl-P': 'goLineUp',
    'Ctrl-N': 'goLineDown',
    'Alt-F': 'goWordRight',
    'Alt-B': 'goWordLeft',
    'Ctrl-A': 'goLineStart',
    'Ctrl-E': 'goLineEnd',
    'Ctrl-V': 'goPageDown',
    'Shift-Ctrl-V': 'goPageUp',
    'Ctrl-D': 'delCharAfter',
    'Ctrl-H': 'delCharBefore',
    'Alt-D': 'delWordAfter',
    'Alt-Backspace': 'delWordBefore',
    'Ctrl-K': 'killLine',
    'Ctrl-T': 'transposeChars'
  };
  function getKeyMap(val) {
    if (typeof val == 'string')
      return keyMap[val];
    else
      return val;
  }
  function lookupKey(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false)
        return 'stop';
      if (found != null && handle(found))
        return true;
      if (map.nofallthrough)
        return 'stop';
      var fallthrough = map.fallthrough;
      if (fallthrough == null)
        return false;
      if (Object.prototype.toString.call(fallthrough) != '[object Array]')
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        var done = lookup(fallthrough[i]);
        if (done)
          return done;
      }
      return false;
    }
    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done)
        return done;
    }
  }
  function isModifierKey(event) {
    var name = keyNames[event.keyCode];
    return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
  }
  function keyName(event, noShift) {
    if (opera && event.keyCode == 34 && event['char'])
      return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey)
      return false;
    if (event.altKey)
      name = 'Alt-' + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey)
      name = 'Ctrl-' + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey)
      name = 'Cmd-' + name;
    if (!noShift && event.shiftKey)
      name = 'Shift-' + name;
    return name;
  }
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.keyName = keyName;
  CodeMirror.fromTextArea = function (textarea, options) {
    if (!options)
      options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    if (options.autofocus == null) {
      var hasFocus = document.body;
      try {
        hasFocus = document.activeElement;
      } catch (e) {
      }
      options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    if (textarea.form) {
      on(textarea.form, 'submit', save);
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
        } catch (e) {
        }
      }
    }
    textarea.style.display = 'none';
    var cm = CodeMirror(function (node) {
        textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
    cm.save = save;
    cm.getTextArea = function () {
      return textarea;
    };
    cm.toTextArea = function () {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = '';
      if (textarea.form) {
        off(textarea.form, 'submit', save);
        if (typeof textarea.form.submit == 'function')
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
  }
  StringStream.prototype = {
    eol: function () {
      return this.pos >= this.string.length;
    },
    sol: function () {
      return this.pos == 0;
    },
    peek: function () {
      return this.string.charAt(this.pos) || undefined;
    },
    next: function () {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function (match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == 'string')
        var ok = ch == match;
      else
        var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {
        ++this.pos;
        return ch;
      }
    },
    eatWhile: function (match) {
      var start = this.pos;
      while (this.eat(match)) {
      }
      return this.pos > start;
    },
    eatSpace: function () {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
        ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function () {
      this.pos = this.string.length;
    },
    skipTo: function (ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    },
    backUp: function (n) {
      this.pos -= n;
    },
    column: function () {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue;
    },
    indentation: function () {
      return countColumn(this.string, null, this.tabSize);
    },
    match: function (pattern, consume, caseInsensitive) {
      if (typeof pattern == 'string') {
        var cased = function (str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false)
            this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0)
          return null;
        if (match && consume !== false)
          this.pos += match[0].length;
        return match;
      }
    },
    current: function () {
      return this.string.slice(this.start, this.pos);
    }
  };
  CodeMirror.StringStream = StringStream;
  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  }
  CodeMirror.TextMarker = TextMarker;
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp)
      startOperation(cm);
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.to != null)
        max = lineNo(line);
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from != null)
        min = lineNo(line);
      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping)
      for (var i = 0; i < this.lines.length; ++i) {
        var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    if (min != null && cm)
      regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.collapsed && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm)
        reCheckSelection(cm);
    }
    if (withOp)
      endOperation(cm);
    signalLater(this, 'clear');
  };
  TextMarker.prototype.find = function () {
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null || span.to != null) {
        var found = lineNo(line);
        if (span.from != null)
          from = Pos(found, span.from);
        if (span.to != null)
          to = Pos(found, span.to);
      }
    }
    if (this.type == 'bookmark')
      return from;
    return from && {
      from: from,
      to: to
    };
  };
  TextMarker.prototype.getOptions = function (copyWidget) {
    var repl = this.replacedWith;
    return {
      className: this.className,
      inclusiveLeft: this.inclusiveLeft,
      inclusiveRight: this.inclusiveRight,
      atomic: this.atomic,
      collapsed: this.collapsed,
      replacedWith: copyWidget ? repl && repl.cloneNode(true) : repl,
      readOnly: this.readOnly,
      startStyle: this.startStyle,
      endStyle: this.endStyle
    };
  };
  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  function markText(doc, from, to, options, type) {
    if (options && options.shared)
      return markTextShared(doc, from, to, options, type);
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, markText)(doc, from, to, options, type);
    var marker = new TextMarker(doc, type);
    if (type == 'range' && !posLess(from, to))
      return marker;
    if (options)
      copyObj(options, marker);
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.replacedWith = elt('span', [marker.replacedWith], 'CodeMirror-widget');
    }
    if (marker.collapsed)
      sawCollapsedSpans = true;
    if (marker.addToHistory)
      addToHistory(doc, {
        from: from,
        to: to,
        origin: 'markText'
      }, {
        head: doc.sel.head,
        anchor: doc.sel.anchor
      }, NaN);
    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
        updateMaxLine = true;
      var span = {
          from: null,
          to: null,
          marker: marker
        };
      size += line.text.length;
      if (curLine == from.line) {
        span.from = from.ch;
        size -= from.ch;
      }
      if (curLine == to.line) {
        span.to = to.ch;
        size -= line.text.length - to.ch;
      }
      if (marker.collapsed) {
        if (curLine == to.line)
          collapsedAtEnd = collapsedSpanAt(line, to.ch);
        if (curLine == from.line)
          collapsedAtStart = collapsedSpanAt(line, from.ch);
        else
          updateLineHeight(line, 0);
      }
      addMarkedSpan(line, span);
      ++curLine;
    });
    if (marker.collapsed)
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line))
          updateLineHeight(line, 0);
      });
    if (marker.clearOnEnter)
      on(marker, 'beforeCursorEnter', function () {
        marker.clear();
      });
    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      if (collapsedAtStart != collapsedAtEnd)
        throw new Error('Inserting collapsed marker overlapping an existing one');
      marker.size = size;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine)
        cm.curOp.updateMaxLine = true;
      if (marker.className || marker.startStyle || marker.endStyle || marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      if (marker.atomic)
        reCheckSelection(cm);
    }
    return marker;
  }
  function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0, me = this; i < markers.length; ++i) {
      markers[i].parent = this;
      on(markers[i], 'clear', function () {
        me.clear();
      });
    }
  }
  CodeMirror.SharedTextMarker = SharedTextMarker;
  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, 'clear');
  };
  SharedTextMarker.prototype.find = function () {
    return this.primary.find();
  };
  SharedTextMarker.prototype.getOptions = function (copyWidget) {
    var inner = this.primary.getOptions(copyWidget);
    inner.shared = true;
    return inner;
  };
  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.replacedWith;
    linkedDocs(doc, function (doc) {
      if (widget)
        options.replacedWith = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent)
          return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  function getMarkedSpanFor(spans, marker) {
    if (spans)
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker)
          return span;
      }
  }
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span)
        (r || (r = [])).push(spans[i]);
    return r;
  }
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }
  function markedSpansBefore(old, startCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || marker.type == 'bookmark' && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push({
            from: span.from,
            to: endsAfter ? null : span.to,
            marker: marker
          });
        }
      }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || marker.type == 'bookmark' && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push({
            from: startsBefore ? null : span.from - endCh,
            to: span.to == null ? null : span.to - endCh,
            marker: marker
          });
        }
      }
    return nw;
  }
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast)
      return null;
    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found)
            span.to = startCh;
          else if (sameLine)
            span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null)
          span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine)
              (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine)
            (first || (first = [])).push(span);
        }
      }
    }
    var newMarkers = [first];
    if (!sameLine) {
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push({
              from: null,
              to: null,
              marker: first[i].marker
            });
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old)
      return stretched;
    if (!stretched)
      return old;
    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans:
          for (var j = 0; j < stretchCur.length; ++j) {
            var span = stretchCur[j];
            for (var k = 0; k < oldCur.length; ++k)
              if (oldCur[k].marker == span.marker)
                continue spans;
            oldCur.push(span);
          }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans)
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
            (markers || (markers = [])).push(mark);
        }
    });
    if (!markers)
      return null;
    var parts = [{
          from: from,
          to: to
        }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find();
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (posLess(p.to, m.from) || posLess(m.to, p.from))
          continue;
        var newParts = [
            j,
            1
          ];
        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
          newParts.push({
            from: p.from,
            to: m.from
          });
        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
          newParts.push({
            from: m.to,
            to: p.to
          });
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }
  function collapsedSpanAt(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width))
          found = sp.marker;
      }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAt(line, -1);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAt(line, line.text.length + 1);
  }
  function visualLine(doc, line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(doc, merged.find().from.line);
    return line;
  }
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if (sp.from == null)
          return true;
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
          return true;
      }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find().to, endLine = getLine(doc, end.line);
      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }
  var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
      for (var opt in options)
        if (options.hasOwnProperty(opt))
          this[opt] = options[opt];
      this.cm = cm;
      this.node = node;
    };
  function widgetOperation(f) {
    return function () {
      var withOp = !this.cm.curOp;
      if (withOp)
        startOperation(this.cm);
      try {
        var result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  LineWidget.prototype.clear = widgetOperation(function () {
    var ws = this.line.widgets, no = lineNo(this.line);
    if (no == null || !ws)
      return;
    for (var i = 0; i < ws.length; ++i)
      if (ws[i] == this)
        ws.splice(i--, 1);
    if (!ws.length)
      this.line.widgets = null;
    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
    regChange(this.cm, no, no + 1);
  });
  LineWidget.prototype.changed = widgetOperation(function () {
    var oldH = this.height;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff)
      return;
    updateLineHeight(this.line, this.line.height + diff);
    var no = lineNo(this.line);
    regChange(this.cm, no, no + 1);
  });
  function widgetHeight(widget) {
    if (widget.height != null)
      return widget.height;
    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
      removeChildrenAndAdd(widget.cm.display.measure, elt('div', [widget.node], null, 'position: relative'));
    return widget.height = widget.node.offsetHeight;
  }
  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll)
      cm.display.alignWidgets = true;
    changeLine(cm, handle, function (line) {
      (line.widgets || (line.widgets = [])).push(widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
        var aboveVisible = heightAtLine(cm, line) < cm.display.scroller.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible)
          addToScrollPos(cm, 0, widget.height);
      }
      return true;
    });
    return widget;
  }
  function makeLine(text, markedSpans, estimateHeight) {
    var line = { text: text };
    attachMarkedSpans(line, markedSpans);
    line.height = estimateHeight ? estimateHeight(line) : 1;
    return line;
  }
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter)
      line.stateAfter = null;
    if (line.styles)
      line.styles = null;
    if (line.order != null)
      line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height)
      updateLineHeight(line, estHeight);
  }
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }
  function runMode(cm, text, mode, state, f) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null)
      flattenSpans = cm.options.flattenSpans;
    var curText = '', curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        stream.pos = Math.min(text.length, stream.start + 50000);
        style = null;
      } else {
        style = mode.token(stream, state);
      }
      var substr = stream.current();
      stream.start = stream.pos;
      if (!flattenSpans || curStyle != style) {
        if (curText)
          f(curText, curStyle);
        curText = substr;
        curStyle = style;
      } else
        curText = curText + substr;
    }
    if (curText)
      f(curText, curStyle);
  }
  function highlightLine(cm, line, state) {
    var st = [cm.state.modeGen];
    runMode(cm, line.text, cm.doc.mode, state, function (txt, style) {
      st.push(txt, style);
    });
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1;
      runMode(cm, line.text, overlay.mode, true, function (txt, style) {
        var start = i, len = txt.length;
        while (len) {
          var cur = st[i], len_ = cur.length;
          if (len_ <= len) {
            len -= len_;
          } else {
            st.splice(i, 1, cur.slice(0, len), st[i + 1], cur.slice(len));
            len = 0;
          }
          i += 2;
        }
        if (!style)
          return;
        if (overlay.opaque) {
          st.splice(start, i - start, txt, style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = cur ? cur + ' ' + style : style;
          }
        }
      });
    }
    return st;
  }
  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen)
      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
    return line.styles;
  }
  function processLine(cm, line, state) {
    var mode = cm.doc.mode;
    var stream = new StringStream(line.text, cm.options.tabSize);
    if (line.text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      mode.token(stream, state);
      stream.start = stream.pos;
    }
  }
  var styleToClassCache = {};
  function styleToClass(style) {
    if (!style)
      return null;
    return styleToClassCache[style] || (styleToClassCache[style] = 'cm-' + style.replace(/ +/g, ' cm-'));
  }
  function lineContent(cm, realLine, measure) {
    var merged, line = realLine, lineBefore, sawBefore, simple = true;
    while (merged = collapsedSpanAtStart(line)) {
      simple = false;
      line = getLine(cm.doc, merged.find().from.line);
      if (!lineBefore)
        lineBefore = line;
    }
    var builder = {
        pre: elt('pre'),
        col: 0,
        pos: 0,
        display: !measure,
        measure: null,
        addedOne: false,
        cm: cm
      };
    if (line.textClass)
      builder.pre.className = line.textClass;
    do {
      builder.measure = line == realLine && measure;
      builder.pos = 0;
      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
      if ((ie || webkit) && cm.getOption('lineWrapping'))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      if (measure && sawBefore && line != realLine && !builder.addedOne) {
        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
        builder.addedOne = true;
      }
      var next = insertLineContent(line, builder, getLineStyles(cm, line));
      sawBefore = line == lineBefore;
      if (next) {
        line = getLine(cm.doc, next.to.line);
        simple = false;
      }
    } while (next);
    if (measure && !builder.addedOne)
      measure[0] = builder.pre.appendChild(simple ? elt('span', '\xa0') : zeroWidthElement(cm.display.measure));
    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
      builder.pre.appendChild(document.createTextNode('\xa0'));
    var order;
    if (measure && ie && (order = getOrder(line))) {
      var l = order.length - 1;
      if (order[l].from == order[l].to)
        --l;
      var last = order[l], prev = order[l - 1];
      if (last.from + 1 == last.to && prev && last.level < prev.level) {
        var span = measure[builder.pos - 1];
        if (span)
          span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);
      }
    }
    signal(cm, 'renderLine', cm, realLine, builder.pre);
    return builder.pre;
  }
  var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
  function buildToken(builder, text, style, startStyle, endStyle) {
    if (!text)
      return;
    if (!tokenSpecialChars.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        tokenSpecialChars.lastIndex = pos;
        var m = tokenSpecialChars.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
          builder.col += skipped;
        }
        if (!m)
          break;
        pos += skipped + 1;
        if (m[0] == '\t') {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
          builder.col += tabWidth;
        } else {
          var token = elt('span', '\u2022', 'cm-invalidchar');
          token.title = '\\u' + m[0].charCodeAt(0).toString(16);
          content.appendChild(token);
          builder.col += 1;
        }
      }
    }
    if (style || startStyle || endStyle || builder.measure) {
      var fullStyle = style || '';
      if (startStyle)
        fullStyle += startStyle;
      if (endStyle)
        fullStyle += endStyle;
      return builder.pre.appendChild(elt('span', [content], fullStyle));
    }
    builder.pre.appendChild(content);
  }
  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
    var wrapping = builder.cm.options.lineWrapping;
    for (var i = 0; i < text.length; ++i) {
      var ch = text.charAt(i), start = i == 0;
      if (ch >= '\ud800' && ch < '\udbff' && i < text.length - 1) {
        ch = text.slice(i, i + 2);
        ++i;
      } else if (i && wrapping && spanAffectsWrapping.test(text.slice(i - 1, i + 1))) {
        builder.pre.appendChild(elt('wbr'));
      }
      var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
      if (ie && wrapping && ch == ' ' && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
        span.style.whiteSpace = 'normal';
      builder.pos += ch.length;
    }
    if (text.length)
      builder.addedOne = true;
  }
  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = ' ';
      for (var i = 0; i < old.length - 2; ++i)
        out += i % 2 ? ' ' : '\xa0';
      out += ' ';
      return out;
    }
    return function (builder, text, style, startStyle, endStyle) {
      return inner(builder, text.replace(/ {3,}/, split), style, startStyle, endStyle);
    };
  }
  function buildCollapsedSpan(builder, size, widget) {
    if (widget) {
      if (!builder.display)
        widget = widget.cloneNode(true);
      builder.pre.appendChild(widget);
      if (builder.measure && size) {
        builder.measure[builder.pos] = widget;
        builder.addedOne = true;
      }
    }
    builder.pos += size;
  }
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans;
    if (!spans) {
      for (var i = 1; i < styles.length; i += 2)
        builder.addToken(builder, styles[i], styleToClass(styles[i + 1]));
      return;
    }
    var allText = line.text, len = allText.length;
    var pos = 0, i = 1, text = '', style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed;
    for (;;) {
      if (nextChange == pos) {
        spanStyle = spanEndStyle = spanStartStyle = '';
        collapsed = null;
        nextChange = Infinity;
        var foundBookmark = null;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = '';
            }
            if (m.className)
              spanStyle += ' ' + m.className;
            if (m.startStyle && sp.from == pos)
              spanStartStyle += ' ' + m.startStyle;
            if (m.endStyle && sp.to == nextChange)
              spanEndStyle += ' ' + m.endStyle;
            if (m.collapsed && (!collapsed || collapsed.marker.width < m.width))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == 'bookmark' && sp.from == pos && m.replacedWith)
            foundBookmark = m.replacedWith;
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.from != null && collapsed.marker.replacedWith);
          if (collapsed.to == null)
            return collapsed.marker.find();
        }
        if (foundBookmark && !collapsed)
          buildCollapsedSpan(builder, 0, foundBookmark);
      }
      if (pos >= len)
        break;
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '');
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = '';
        }
        text = styles[i++];
        style = styleToClass(styles[i++]);
      }
    }
  }
  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, 'change', line, change);
    }
    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
    if (from.ch == 0 && to.ch == 0 && lastText == '') {
      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines)
        doc.remove(from.line, nlines);
      if (added.length)
        doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
          added.push(makeLine(text[i], spansFor(i), estimateHeight));
        added.push(makeLine(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      if (nlines > 1)
        doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }
    signalLater(doc, 'change', doc, change);
    setSelection(doc, selAfter.anchor, selAfter.head, null, true);
  }
  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function () {
      return this.lines.length;
    },
    removeInner: function (at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, 'delete');
      }
      this.lines.splice(at, n);
    },
    collapse: function (lines) {
      lines.splice.apply(lines, [
        lines.length,
        0
      ].concat(this.lines));
    },
    insertInner: function (at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0, e = lines.length; i < e; ++i)
        lines[i].parent = this;
    },
    iterN: function (at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at]))
          return true;
    }
  };
  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function () {
      return this.size;
    },
    removeInner: function (at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) {
            this.children.splice(i--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function (lines) {
      for (var i = 0, e = this.children.length; i < e; ++i)
        this.children[i].collapse(lines);
    },
    insertInner: function (at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function () {
      if (this.children.length <= 10)
        return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [
            copy,
            sibling
          ];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function (at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op))
            return true;
          if ((n -= used) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
    }
  };
  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
      if (!(this instanceof Doc))
        return new Doc(text, mode, firstLine);
      if (firstLine == null)
        firstLine = 0;
      BranchChunk.call(this, [new LeafChunk([makeLine('', null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.history = makeHistory();
      this.frontier = firstLine;
      var start = Pos(firstLine, 0);
      this.sel = {
        from: start,
        to: start,
        head: start,
        anchor: start,
        shift: false,
        extend: false,
        goalColumn: null
      };
      this.id = ++nextDocId;
      this.modeOption = mode;
      if (typeof text == 'string')
        text = splitLines(text);
      updateDoc(this, {
        from: start,
        to: start,
        text: text
      }, null, {
        head: start,
        anchor: start
      });
    };
  Doc.prototype = createObj(BranchChunk.prototype, {
    iter: function (from, to, op) {
      if (op)
        this.iterN(from - this.first, to - from, op);
      else
        this.iterN(this.first, this.first + this.size, from);
    },
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i)
        height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) {
      this.removeInner(at - this.first, n);
    },
    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    setValue: function (code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: splitLines(code),
        origin: 'setValue'
      }, {
        head: top,
        anchor: top
      }, true);
    },
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    getLine: function (line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    setLine: function (line, text) {
      if (isLine(this, line))
        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
    },
    removeLine: function (line) {
      if (line)
        replaceRange(this, '', clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
      else
        replaceRange(this, '', Pos(0, 0), clipPos(this, Pos(1, 0)));
    },
    getLineHandle: function (line) {
      if (isLine(this, line))
        return getLine(this, line);
    },
    getLineNumber: function (line) {
      return lineNo(line);
    },
    lineCount: function () {
      return this.size;
    },
    firstLine: function () {
      return this.first;
    },
    lastLine: function () {
      return this.first + this.size - 1;
    },
    clipPos: function (pos) {
      return clipPos(this, pos);
    },
    getCursor: function (start) {
      var sel = this.sel, pos;
      if (start == null || start == 'head')
        pos = sel.head;
      else if (start == 'anchor')
        pos = sel.anchor;
      else if (start == 'end' || start === false)
        pos = sel.to;
      else
        pos = sel.from;
      return copyPos(pos);
    },
    somethingSelected: function () {
      return !posEq(this.sel.head, this.sel.anchor);
    },
    setCursor: docOperation(function (line, ch, extend) {
      var pos = clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line);
      if (extend)
        extendSelection(this, pos);
      else
        setSelection(this, pos, pos);
    }),
    setSelection: docOperation(function (anchor, head) {
      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));
    }),
    extendSelection: docOperation(function (from, to) {
      extendSelection(this, clipPos(this, from), to && clipPos(this, to));
    }),
    getSelection: function (lineSep) {
      return this.getRange(this.sel.from, this.sel.to, lineSep);
    },
    replaceSelection: function (code, collapse, origin) {
      makeChange(this, {
        from: this.sel.from,
        to: this.sel.to,
        text: splitLines(code),
        origin: origin
      }, collapse || 'around');
    },
    undo: docOperation(function () {
      makeChangeFromHistory(this, 'undo');
    }),
    redo: docOperation(function () {
      makeChangeFromHistory(this, 'redo');
    }),
    setExtending: function (val) {
      this.sel.extend = val;
    },
    historySize: function () {
      var hist = this.history;
      return {
        undo: hist.done.length,
        redo: hist.undone.length
      };
    },
    clearHistory: function () {
      this.history = makeHistory();
    },
    markClean: function () {
      this.history.dirtyCounter = 0;
      this.history.lastOp = this.history.lastOrigin = null;
    },
    isClean: function () {
      return this.history.dirtyCounter == 0;
    },
    getHistory: function () {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function (histData) {
      var hist = this.history = makeHistory();
      hist.done = histData.done.slice(0);
      hist.undone = histData.undone.slice(0);
    },
    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
    },
    setBookmark: function (pos, options) {
      var realOpts = {
          replacedWith: options && (options.nodeType == null ? options.widget : options),
          insertLeft: options && options.insertLeft
        };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, 'bookmark');
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans)
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
            markers.push(span.marker.parent || span.marker);
        }
      return markers;
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps)
          for (var i = 0; i < sps.length; ++i)
            if (sps[i].from != null)
              markers.push(sps[i].marker);
      });
      return markers;
    },
    posFromIndex: function (off) {
      var ch, lineNo = this.first;
      this.iter(function (line) {
        var sz = line.text.length + 1;
        if (sz > off) {
          ch = off;
          return true;
        }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0)
        return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },
    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = {
        from: this.sel.from,
        to: this.sel.to,
        head: this.sel.head,
        anchor: this.sel.anchor,
        shift: this.sel.shift,
        extend: false,
        goalColumn: this.sel.goalColumn
      };
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },
    linkedDoc: function (options) {
      if (!options)
        options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from)
        from = options.from;
      if (options.to != null && options.to < to)
        to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist)
        copy.history = this.history;
      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
          doc: this,
          isParent: true,
          sharedHist: options.sharedHist
        }];
      return copy;
    },
    unlinkDoc: function (other) {
      if (other instanceof CodeMirror)
        other = other.doc;
      if (this.linked)
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this.linked[i];
          if (link.doc != other)
            continue;
          this.linked.splice(i, 1);
          other.unlinkDoc(this);
          break;
        }
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          splitIds.push(doc.id);
        }, true);
        other.history = makeHistory();
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) {
      linkedDocs(this, f);
    },
    getMode: function () {
      return this.mode;
    },
    getEditor: function () {
      return this.cm;
    }
  });
  Doc.prototype.eachLine = Doc.prototype.iter;
  var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
  for (var prop in Doc.prototype)
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
      CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked)
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip)
            continue;
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared)
            continue;
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
    }
    propagate(doc, null, true);
  }
  function attachDoc(cm, doc) {
    if (doc.cm)
      throw new Error('This document is already in use.');
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping)
      computeMaxLength(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }
  function getLine(chunk, n) {
    n -= chunk.first;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line)
        text = text.slice(0, end.ch);
      if (n == start.line)
        text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    });
    return out;
  }
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    for (var n = line; n; n = n.parent)
      n.height += diff;
  }
  function lineNo(line) {
    if (line.parent == null)
      return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur)
          break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer:
      do {
        for (var i = 0, e = chunk.children.length; i < e; ++i) {
          var child = chunk.children[i], ch = child.height;
          if (h < ch) {
            chunk = child;
            continue outer;
          }
          h -= ch;
          n += child.chunkSize();
        }
        return n;
      } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh)
        break;
      h -= lh;
    }
    return n + i;
  }
  function heightAtLine(cm, lineObj) {
    lineObj = visualLine(cm.doc, lineObj);
    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj)
        break;
      else
        h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk)
          break;
        else
          h += cur.height;
      }
    }
    return h;
  }
  function getOrder(line) {
    var order = line.order;
    if (order == null)
      order = line.order = bidiOrdering(line.text);
    return order;
  }
  function makeHistory() {
    return {
      done: [],
      undone: [],
      undoDepth: Infinity,
      lastTime: 0,
      lastOp: null,
      lastOrigin: null,
      dirtyCounter: 0
    };
  }
  function attachLocalSpans(doc, change, from, to) {
    var existing = change['spans_' + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }
  function historyChangeFromChange(doc, change) {
    var histChange = {
        from: change.from,
        to: changeEnd(change),
        text: getBetween(doc, change.from, change.to)
      };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }
  function addToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(), cur = lst(hist.done);
    if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*'))) {
      var last = lst(cur.changes);
      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
        last.to = changeEnd(change);
      } else {
        cur.changes.push(historyChangeFromChange(doc, change));
      }
      cur.anchorAfter = selAfter.anchor;
      cur.headAfter = selAfter.head;
    } else {
      cur = {
        changes: [historyChangeFromChange(doc, change)],
        anchorBefore: doc.sel.anchor,
        headBefore: doc.sel.head,
        anchorAfter: selAfter.anchor,
        headAfter: selAfter.head
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth)
        hist.done.shift();
      if (hist.dirtyCounter < 0)
        hist.dirtyCounter = NaN;
      else
        hist.dirtyCounter++;
    }
    hist.lastTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = change.origin;
  }
  function removeClearedSpans(spans) {
    if (!spans)
      return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out)
          out = spans.slice(0, i);
      } else if (out)
        out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }
  function getOldSpans(doc, change) {
    var found = change['spans_' + doc.id];
    if (!found)
      return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }
  function copyHistoryArray(events, newGroup) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i], changes = event.changes, newChanges = [];
      copy.push({
        changes: newChanges,
        anchorBefore: event.anchorBefore,
        headBefore: event.headBefore,
        anchorAfter: event.anchorAfter,
        headAfter: event.headAfter
      });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });
        if (newGroup)
          for (var prop in change)
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
      }
    }
    return copy;
  }
  function rebaseHistSel(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (!sub.copied) {
          cur.from = copyPos(cur.from);
          cur.to = copyPos(cur.to);
        }
        if (to < cur.from.line) {
          cur.from.line += diff;
          cur.to.line += diff;
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!sub.copied) {
        sub.anchorBefore = copyPos(sub.anchorBefore);
        sub.headBefore = copyPos(sub.headBefore);
        sub.anchorAfter = copyPos(sub.anchorAfter);
        sub.readAfter = copyPos(sub.headAfter);
        sub.copied = true;
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      } else {
        rebaseHistSel(sub.anchorBefore);
        rebaseHistSel(sub.headBefore);
        rebaseHistSel(sub.anchorAfter);
        rebaseHistSel(sub.headAfter);
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }
  function stopMethod() {
    e_stop(this);
  }
  function addStop(event) {
    if (!event.stop)
      event.stop = stopMethod;
    return event;
  }
  function e_preventDefault(e) {
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation)
      e.stopPropagation();
    else
      e.cancelBubble = true;
  }
  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1)
        b = 1;
      else if (e.button & 2)
        b = 3;
      else if (e.button & 4)
        b = 2;
    }
    if (mac && e.ctrlKey && b == 1)
      b = 3;
    return b;
  }
  function on(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent('on' + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  }
  function off(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent('on' + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr)
        return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) {
          arr.splice(i, 1);
          break;
        }
    }
  }
  function signal(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i)
      arr[i].apply(null, args);
  }
  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {
      return function () {
        f.apply(null, args);
      };
    }
    ;
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }
  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i)
      delayed[i]();
  }
  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }
  CodeMirror.on = on;
  CodeMirror.off = off;
  CodeMirror.signal = signal;
  var scrollerCutOff = 30;
  var Pass = CodeMirror.Pass = {
      toString: function () {
        return 'CodeMirror.Pass';
      }
    };
  function Delayed() {
    this.id = null;
  }
  Delayed.prototype = {
    set: function (ms, f) {
      clearTimeout(this.id);
      this.id = setTimeout(f, ms);
    }
  };
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1)
        end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
      if (string.charAt(i) == '\t')
        n += tabSize - n % tabSize;
      else
        ++n;
    }
    return n;
  }
  CodeMirror.countColumn = countColumn;
  var spaceStrs = [''];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + ' ');
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  function selectInput(node) {
    if (ios) {
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else
      node.select();
  }
  function indexOf(collection, elt) {
    if (collection.indexOf)
      return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt)
        return i;
    return -1;
  }
  function createObj(base, props) {
    function Obj() {
    }
    Obj.prototype = base;
    var inst = new Obj();
    if (props)
      copyObj(props, inst);
    return inst;
  }
  function copyObj(obj, target) {
    if (!target)
      target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop))
        target[prop] = obj[prop];
    return target;
  }
  function emptyArray(size) {
    for (var a = [], i = 0; i < size; ++i)
      a.push(undefined);
    return a;
  }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }
  var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc]/;
  function isWordChar(ch) {
    return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }
  function isEmpty(obj) {
    for (var n in obj)
      if (obj.hasOwnProperty(n) && obj[n])
        return false;
    return true;
  }
  var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className)
      e.className = className;
    if (style)
      e.style.cssText = style;
    if (typeof content == 'string')
      setTextContent(e, content);
    else if (content)
      for (var i = 0; i < content.length; ++i)
        e.appendChild(content[i]);
    return e;
  }
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function setTextContent(e, str) {
    if (ie_lt9) {
      e.innerHTML = '';
      e.appendChild(document.createTextNode(str));
    } else
      e.textContent = str;
  }
  function getRect(node) {
    return node.getBoundingClientRect();
  }
  CodeMirror.replaceGetRect = function (f) {
    getRect = f;
  };
  var dragAndDrop = function () {
      if (ie_lt9)
        return false;
      var div = elt('div');
      return 'draggable' in div || 'dragDrop' in div;
    }();
  var spanAffectsWrapping = /^$/;
  if (gecko)
    spanAffectsWrapping = /$'/;
  else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
    spanAffectsWrapping = /\-[^ \-?]|\?[^ !'\"\),.\-\/:;\?\]\}]/;
  else if (webkit)
    spanAffectsWrapping = /[~!#%&*)=+}\]|\"\.>,:;][({[<]|-[^\-?\.]|\?[\w~`@#$%\^&*(_=+{[|><]/;
  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null)
      return knownScrollbarWidth;
    var test = elt('div', null, null, 'width: 50px; height: 50px; overflow-x: scroll');
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt('span', '\u200b');
      removeChildrenAndAdd(measure, elt('span', [
        test,
        document.createTextNode('x')
      ]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
    }
    if (zwspSupported)
      return elt('span', '\u200b');
    else
      return elt('span', '\xa0', null, 'display: inline-block; width: 1px; margin-right: -1px');
  }
  var splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
      var pos = 0, result = [], l = string.length;
      while (pos <= l) {
        var nl = string.indexOf('\n', pos);
        if (nl == -1)
          nl = string.length;
        var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
        var rt = line.indexOf('\r');
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function (string) {
      return string.split(/\r\n?|\n/);
    };
  CodeMirror.splitLines = splitLines;
  var hasSelection = window.getSelection ? function (te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function (te) {
      try {
        var range = te.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range || range.parentElement() != te)
        return false;
      return range.compareEndPoints('StartToEnd', range) != 0;
    };
  var hasCopyEvent = function () {
      var e = elt('div');
      if ('oncopy' in e)
        return true;
      e.setAttribute('oncopy', 'return;');
      return typeof e.oncopy == 'function';
    }();
  var keyNames = {
      3: 'Enter',
      8: 'Backspace',
      9: 'Tab',
      13: 'Enter',
      16: 'Shift',
      17: 'Ctrl',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Esc',
      32: 'Space',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      44: 'PrintScrn',
      45: 'Insert',
      46: 'Delete',
      59: ';',
      91: 'Mod',
      92: 'Mod',
      93: 'Mod',
      109: '-',
      107: '=',
      127: 'Delete',
      186: ';',
      187: '=',
      188: ',',
      189: '-',
      190: '.',
      191: '/',
      192: '`',
      219: '[',
      220: '\\',
      221: ']',
      222: '\'',
      63276: 'PageUp',
      63277: 'PageDown',
      63275: 'End',
      63273: 'Home',
      63234: 'Left',
      63232: 'Up',
      63235: 'Right',
      63233: 'Down',
      63302: 'Insert',
      63272: 'Delete'
    };
  CodeMirror.keyNames = keyNames;
  (function () {
    for (var i = 0; i < 10; i++)
      keyNames[i + 48] = String(i);
    for (var i = 65; i <= 90; i++)
      keyNames[i] = String.fromCharCode(i);
    for (var i = 1; i <= 12; i++)
      keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
  }());
  function iterateBidiSections(order, from, to, f) {
    if (!order)
      return f(from, to, 'ltr');
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from)
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
    }
  }
  function bidiLeft(part) {
    return part.level % 2 ? part.to : part.from;
  }
  function bidiRight(part) {
    return part.level % 2 ? part.from : part.to;
  }
  function lineLeft(line) {
    var order = getOrder(line);
    return order ? bidiLeft(order[0]) : 0;
  }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order)
      return line.text.length;
    return bidiRight(lst(order));
  }
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(cm.doc, line);
    if (visual != line)
      lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line;
    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
      lineN = merged.find().to.line;
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN, ch);
  }
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi)
      return moveLogically(line, start, dir, byUnit);
    var moveOneUnit = byUnit ? function (pos, dir) {
        do
          pos += dir;
        while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
        return pos;
      } : function (pos, dir) {
        return pos + dir;
      };
    var linedir = bidi[0].level;
    for (var i = 0; i < bidi.length; ++i) {
      var part = bidi[i], sticky = part.level % 2 == linedir;
      if (part.from < start && part.to > start || sticky && (part.from == start || part.to == start))
        break;
    }
    var target = moveOneUnit(start, part.level % 2 ? -dir : dir);
    while (target != null) {
      if (part.level % 2 == linedir) {
        if (target < part.from || target > part.to) {
          part = bidi[i += dir];
          target = part && (dir > 0 == part.level % 2 ? moveOneUnit(part.to, -1) : moveOneUnit(part.from, 1));
        } else
          break;
      } else {
        if (target == bidiLeft(part)) {
          part = bidi[--i];
          target = part && bidiRight(part);
        } else if (target == bidiRight(part)) {
          part = bidi[++i];
          target = part && bidiLeft(part);
        } else
          break;
      }
    }
    return target < 0 || target > line.text.length ? null : target;
  }
  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit)
      while (target > 0 && isExtendingChar.test(line.text.charAt(target)))
        target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }
  var bidiOrdering = function () {
      var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL';
      var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr';
      function charType(code) {
        if (code <= 255)
          return lowTypes.charAt(code);
        else if (1424 <= code && code <= 1524)
          return 'R';
        else if (1536 <= code && code <= 1791)
          return arabicTypes.charAt(code - 1536);
        else if (1792 <= code && code <= 2220)
          return 'r';
        else
          return 'L';
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      var outerType = 'L';
      return function (str) {
        if (!bidiRE.test(str))
          return false;
        var len = str.length, types = [];
        for (var i = 0, type; i < len; ++i)
          types.push(type = charType(str.charCodeAt(i)));
        for (var i = 0, prev = outerType; i < len; ++i) {
          var type = types[i];
          if (type == 'm')
            types[i] = prev;
          else
            prev = type;
        }
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (type == '1' && cur == 'r')
            types[i] = 'n';
          else if (isStrong.test(type)) {
            cur = type;
            if (type == 'r')
              types[i] = 'R';
          }
        }
        for (var i = 1, prev = types[0]; i < len - 1; ++i) {
          var type = types[i];
          if (type == '+' && prev == '1' && types[i + 1] == '1')
            types[i] = '1';
          else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
            types[i] = prev;
          prev = type;
        }
        for (var i = 0; i < len; ++i) {
          var type = types[i];
          if (type == ',')
            types[i] = 'N';
          else if (type == '%') {
            for (var end = i + 1; end < len && types[end] == '%'; ++end) {
            }
            var replace = i && types[i - 1] == '!' || end < len - 1 && types[end] == '1' ? '1' : 'N';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (cur == 'L' && type == '1')
            types[i] = 'L';
          else if (isStrong.test(type))
            cur = type;
        }
        for (var i = 0; i < len; ++i) {
          if (isNeutral.test(types[i])) {
            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
            }
            var before = (i ? types[i - 1] : outerType) == 'L';
            var after = (end < len - 1 ? types[end] : outerType) == 'L';
            var replace = before || after ? 'L' : 'R';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        var order = [], m;
        for (var i = 0; i < len;) {
          if (countsAsLeft.test(types[i])) {
            var start = i;
            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
            }
            order.push({
              from: start,
              to: i,
              level: 0
            });
          } else {
            var pos = i, at = order.length;
            for (++i; i < len && types[i] != 'L'; ++i) {
            }
            for (var j = pos; j < i;) {
              if (countsAsNum.test(types[j])) {
                if (pos < j)
                  order.splice(at, 0, {
                    from: pos,
                    to: j,
                    level: 1
                  });
                var nstart = j;
                for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                }
                order.splice(at, 0, {
                  from: nstart,
                  to: j,
                  level: 2
                });
                pos = j;
              } else
                ++j;
            }
            if (pos < i)
              order.splice(at, 0, {
                from: pos,
                to: i,
                level: 1
              });
          }
        }
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift({
            from: 0,
            to: m[0].length,
            level: 0
          });
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push({
            from: len - m[0].length,
            to: len,
            level: 0
          });
        }
        if (order[0].level != lst(order).level)
          order.push({
            from: len,
            to: len,
            level: order[0].level
          });
        return order;
      };
    }();
  CodeMirror.version = '3.11 +';
  return CodeMirror;
}();
CodeMirror.defineMode('python', function (conf, parserConf) {
  var ERRORCLASS = 'error';
  function wordRegexp(words) {
    return new RegExp('^((' + words.join(')|(') + '))\\b');
  }
  var singleOperators = parserConf.singleOperators || new RegExp('^[\\+\\-\\*/%&|\\^~<>!]');
  var singleDelimiters = parserConf.singleDelimiters || new RegExp('^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]');
  var doubleOperators = parserConf.doubleOperators || new RegExp('^((==)|(!=)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\*\\*))');
  var doubleDelimiters = parserConf.doubleDelimiters || new RegExp('^((\\+=)|(\\-=)|(\\*=)|(%=)|(/=)|(&=)|(\\|=)|(\\^=))');
  var tripleDelimiters = parserConf.tripleDelimiters || new RegExp('^((//=)|(>>=)|(<<=)|(\\*\\*=))');
  var identifiers = parserConf.identifiers || new RegExp('^[_A-Za-z][_A-Za-z0-9]*');
  var wordOperators = wordRegexp([
      'and',
      'or',
      'not',
      'is',
      'in'
    ]);
  var commonkeywords = [
      'as',
      'assert',
      'break',
      'class',
      'continue',
      'def',
      'del',
      'elif',
      'else',
      'except',
      'finally',
      'for',
      'from',
      'global',
      'if',
      'import',
      'lambda',
      'pass',
      'raise',
      'return',
      'try',
      'while',
      'with',
      'yield'
    ];
  var commonBuiltins = [
      'abs',
      'all',
      'any',
      'bin',
      'bool',
      'bytearray',
      'callable',
      'chr',
      'classmethod',
      'compile',
      'complex',
      'delattr',
      'dict',
      'dir',
      'divmod',
      'enumerate',
      'eval',
      'filter',
      'float',
      'format',
      'frozenset',
      'getattr',
      'globals',
      'hasattr',
      'hash',
      'help',
      'hex',
      'id',
      'input',
      'int',
      'isinstance',
      'issubclass',
      'iter',
      'len',
      'list',
      'locals',
      'map',
      'max',
      'memoryview',
      'min',
      'next',
      'object',
      'oct',
      'open',
      'ord',
      'pow',
      'property',
      'range',
      'repr',
      'reversed',
      'round',
      'set',
      'setattr',
      'slice',
      'sorted',
      'staticmethod',
      'str',
      'sum',
      'super',
      'tuple',
      'type',
      'vars',
      'zip',
      '__import__',
      'NotImplemented',
      'Ellipsis',
      '__debug__'
    ];
  var py2 = {
      'builtins': [
        'apply',
        'basestring',
        'buffer',
        'cmp',
        'coerce',
        'execfile',
        'file',
        'intern',
        'long',
        'raw_input',
        'reduce',
        'reload',
        'unichr',
        'unicode',
        'xrange',
        'False',
        'True',
        'None'
      ],
      'keywords': [
        'exec',
        'print'
      ]
    };
  var py3 = {
      'builtins': [
        'ascii',
        'bytes',
        'exec',
        'print'
      ],
      'keywords': [
        'nonlocal',
        'False',
        'True',
        'None'
      ]
    };
  if (!!parserConf.version && parseInt(parserConf.version, 10) === 3) {
    commonkeywords = commonkeywords.concat(py3.keywords);
    commonBuiltins = commonBuiltins.concat(py3.builtins);
    var stringPrefixes = new RegExp('^(([rb]|(br))?(\'{3}|"{3}|[\'"]))', 'i');
  } else {
    commonkeywords = commonkeywords.concat(py2.keywords);
    commonBuiltins = commonBuiltins.concat(py2.builtins);
    var stringPrefixes = new RegExp('^(([rub]|(ur)|(br))?(\'{3}|"{3}|[\'"]))', 'i');
  }
  var keywords = wordRegexp(commonkeywords);
  var builtins = wordRegexp(commonBuiltins);
  var indentInfo = null;
  function tokenBase(stream, state) {
    if (stream.sol()) {
      var scopeOffset = state.scopes[0].offset;
      if (stream.eatSpace()) {
        var lineOffset = stream.indentation();
        if (lineOffset > scopeOffset) {
          indentInfo = 'indent';
        } else if (lineOffset < scopeOffset) {
          indentInfo = 'dedent';
        }
        return null;
      } else {
        if (scopeOffset > 0) {
          dedent(stream, state);
        }
      }
    }
    if (stream.eatSpace()) {
      return null;
    }
    var ch = stream.peek();
    if (ch === '#') {
      stream.skipToEnd();
      return 'comment';
    }
    if (stream.match(/^[0-9\.]/, false)) {
      var floatLiteral = false;
      if (stream.match(/^\d*\.\d+(e[\+\-]?\d+)?/i)) {
        floatLiteral = true;
      }
      if (stream.match(/^\d+\.\d*/)) {
        floatLiteral = true;
      }
      if (stream.match(/^\.\d+/)) {
        floatLiteral = true;
      }
      if (floatLiteral) {
        stream.eat(/J/i);
        return 'number';
      }
      var intLiteral = false;
      if (stream.match(/^0x[0-9a-f]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^0b[01]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^0o[0-7]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^[1-9]\d*(e[\+\-]?\d+)?/)) {
        stream.eat(/J/i);
        intLiteral = true;
      }
      if (stream.match(/^0(?![\dx])/i)) {
        intLiteral = true;
      }
      if (intLiteral) {
        stream.eat(/L/i);
        return 'number';
      }
    }
    if (stream.match(stringPrefixes)) {
      state.tokenize = tokenStringFactory(stream.current());
      return state.tokenize(stream, state);
    }
    if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {
      return null;
    }
    if (stream.match(doubleOperators) || stream.match(singleOperators) || stream.match(wordOperators)) {
      return 'operator';
    }
    if (stream.match(singleDelimiters)) {
      return null;
    }
    if (stream.match(keywords)) {
      return 'keyword';
    }
    if (stream.match(builtins)) {
      return 'builtin';
    }
    if (stream.match(identifiers)) {
      return 'variable';
    }
    stream.next();
    return ERRORCLASS;
  }
  function tokenStringFactory(delimiter) {
    while ('rub'.indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {
      delimiter = delimiter.substr(1);
    }
    var singleline = delimiter.length == 1;
    var OUTCLASS = 'string';
    function tokenString(stream, state) {
      while (!stream.eol()) {
        stream.eatWhile(/[^'"\\]/);
        if (stream.eat('\\')) {
          stream.next();
          if (singleline && stream.eol()) {
            return OUTCLASS;
          }
        } else if (stream.match(delimiter)) {
          state.tokenize = tokenBase;
          return OUTCLASS;
        } else {
          stream.eat(/['"]/);
        }
      }
      if (singleline) {
        if (parserConf.singleLineStringErrors) {
          return ERRORCLASS;
        } else {
          state.tokenize = tokenBase;
        }
      }
      return OUTCLASS;
    }
    tokenString.isString = true;
    return tokenString;
  }
  function indent(stream, state, type) {
    type = type || 'py';
    var indentUnit = 0;
    if (type === 'py') {
      if (state.scopes[0].type !== 'py') {
        state.scopes[0].offset = stream.indentation();
        return;
      }
      for (var i = 0; i < state.scopes.length; ++i) {
        if (state.scopes[i].type === 'py') {
          indentUnit = state.scopes[i].offset + conf.indentUnit;
          break;
        }
      }
    } else {
      indentUnit = stream.column() + stream.current().length;
    }
    state.scopes.unshift({
      offset: indentUnit,
      type: type
    });
  }
  function dedent(stream, state, type) {
    type = type || 'py';
    if (state.scopes.length == 1)
      return;
    if (state.scopes[0].type === 'py') {
      var _indent = stream.indentation();
      var _indent_index = -1;
      for (var i = 0; i < state.scopes.length; ++i) {
        if (_indent === state.scopes[i].offset) {
          _indent_index = i;
          break;
        }
      }
      if (_indent_index === -1) {
        return true;
      }
      while (state.scopes[0].offset !== _indent) {
        state.scopes.shift();
      }
      return false;
    } else {
      if (type === 'py') {
        state.scopes[0].offset = stream.indentation();
        return false;
      } else {
        if (state.scopes[0].type != type) {
          return true;
        }
        state.scopes.shift();
        return false;
      }
    }
  }
  function tokenLexer(stream, state) {
    indentInfo = null;
    var style = state.tokenize(stream, state);
    var current = stream.current();
    if (current === '.') {
      style = stream.match(identifiers, false) ? null : ERRORCLASS;
      if (style === null && state.lastToken === 'meta') {
        style = 'meta';
      }
      return style;
    }
    if (current === '@') {
      return stream.match(identifiers, false) ? 'meta' : ERRORCLASS;
    }
    if ((style === 'variable' || style === 'builtin') && state.lastToken === 'meta') {
      style = 'meta';
    }
    if (current === 'pass' || current === 'return') {
      state.dedent += 1;
    }
    if (current === 'lambda')
      state.lambda = true;
    if (current === ':' && !state.lambda && state.scopes[0].type == 'py' || indentInfo === 'indent') {
      indent(stream, state);
    }
    var delimiter_index = '[({'.indexOf(current);
    if (delimiter_index !== -1) {
      indent(stream, state, '])}'.slice(delimiter_index, delimiter_index + 1));
    }
    if (indentInfo === 'dedent') {
      if (dedent(stream, state)) {
        return ERRORCLASS;
      }
    }
    delimiter_index = '])}'.indexOf(current);
    if (delimiter_index !== -1) {
      if (dedent(stream, state, current)) {
        return ERRORCLASS;
      }
    }
    if (state.dedent > 0 && stream.eol() && state.scopes[0].type == 'py') {
      if (state.scopes.length > 1)
        state.scopes.shift();
      state.dedent -= 1;
    }
    return style;
  }
  var external = {
      startState: function (basecolumn) {
        return {
          tokenize: tokenBase,
          scopes: [{
              offset: basecolumn || 0,
              type: 'py'
            }],
          lastToken: null,
          lambda: false,
          dedent: 0
        };
      },
      token: function (stream, state) {
        var style = tokenLexer(stream, state);
        state.lastToken = style;
        if (stream.eol() && stream.lambda) {
          state.lambda = false;
        }
        return style;
      },
      indent: function (state) {
        if (state.tokenize != tokenBase) {
          return state.tokenize.isString ? CodeMirror.Pass : 0;
        }
        return state.scopes[0].offset;
      }
    };
  return external;
});
CodeMirror.defineMIME('text/x-python', 'python');
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'UID cannot be instantiated';
  };
  c._nextID = 0;
  c.get = function () {
    return c._nextID++;
  };
  createjs.UID = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.initialize = function (a) {
    a.addEventListener = b.addEventListener;
    a.removeEventListener = b.removeEventListener;
    a.removeAllEventListeners = b.removeAllEventListeners;
    a.hasEventListener = b.hasEventListener;
    a.dispatchEvent = b.dispatchEvent;
  };
  b._listeners = null;
  b.initialize = function () {
  };
  b.addEventListener = function (a, m) {
    var b = this._listeners;
    b ? this.removeEventListener(a, m) : b = this._listeners = {};
    var d = b[a];
    d || (d = b[a] = []);
    d.push(m);
    return m;
  };
  b.removeEventListener = function (a, m) {
    var b = this._listeners;
    if (b) {
      var d = b[a];
      if (d)
        for (var e = 0, c = d.length; e < c; e++)
          if (d[e] == m) {
            1 == c ? delete b[a] : d.splice(e, 1);
            break;
          }
    }
  };
  b.removeAllEventListeners = function (a) {
    a ? this._listeners && delete this._listeners[a] : this._listeners = null;
  };
  b.dispatchEvent = function (a, m) {
    var b = !1, d = this._listeners;
    if (a && d) {
      'string' == typeof a && (a = { type: a });
      d = d[a.type];
      if (!d)
        return b;
      a.target = m || this;
      for (var d = d.slice(), e = 0, c = d.length; e < c; e++)
        var h = d[e], b = h.handleEvent ? b || h.handleEvent(a) : b || h(a);
    }
    return !!b;
  };
  b.hasEventListener = function (a) {
    var m = this._listeners;
    return !(!m || !m[a]);
  };
  b.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Ticker cannot be instantiated.';
  };
  c.useRAF = !1;
  c.addEventListener = null;
  c.removeEventListener = null;
  c.removeAllEventListeners = null;
  c.dispatchEvent = null;
  c.hasEventListener = null;
  c._listeners = null;
  createjs.EventDispatcher.initialize(c);
  c._listeners = null;
  c._pauseable = null;
  c._paused = !1;
  c._inited = !1;
  c._startTime = 0;
  c._pausedTime = 0;
  c._ticks = 0;
  c._pausedTicks = 0;
  c._interval = 50;
  c._lastTime = 0;
  c._times = null;
  c._tickTimes = null;
  c._rafActive = !1;
  c._timeoutID = null;
  c.addListener = function (a, m) {
    null != a && (c.removeListener(a), c._pauseable[c._listeners.length] = null == m ? !0 : m, c._listeners.push(a));
  };
  c.init = function () {
    c._inited = !0;
    c._times = [];
    c._tickTimes = [];
    c._pauseable = [];
    c._listeners = [];
    c._times.push(c._lastTime = c._startTime = c._getTime());
    c.setInterval(c._interval);
  };
  c.removeListener = function (a) {
    var m = c._listeners;
    m && (a = m.indexOf(a), -1 != a && (m.splice(a, 1), c._pauseable.splice(a, 1)));
  };
  c.removeAllListeners = function () {
    c._listeners = [];
    c._pauseable = [];
  };
  c.setInterval = function (a) {
    c._interval = a;
    c._inited && c._setupTick();
  };
  c.getInterval = function () {
    return c._interval;
  };
  c.setFPS = function (a) {
    c.setInterval(1000 / a);
  };
  c.getFPS = function () {
    return 1000 / c._interval;
  };
  c.getMeasuredFPS = function (a) {
    if (2 > c._times.length)
      return -1;
    null == a && (a = c.getFPS() | 0);
    a = Math.min(c._times.length - 1, a);
    return 1000 / ((c._times[0] - c._times[a]) / a);
  };
  c.setPaused = function (a) {
    c._paused = a;
  };
  c.getPaused = function () {
    return c._paused;
  };
  c.getTime = function (a) {
    return c._getTime() - c._startTime - (a ? c._pausedTime : 0);
  };
  c.getTicks = function (a) {
    return c._ticks - (a ? c._pausedTicks : 0);
  };
  c._handleAF = function () {
    c._rafActive = !1;
    c._setupTick();
    c._getTime() - c._lastTime >= 0.97 * (c._interval - 1) && c._tick();
  };
  c._handleTimeout = function () {
    c.timeoutID = null;
    c._setupTick();
    c._tick();
  };
  c._setupTick = function () {
    if (!(c._rafActive || null != c.timeoutID)) {
      if (c.useRAF) {
        var a = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
        if (a) {
          a(c._handleAF);
          c._rafActive = !0;
          return;
        }
      }
      c.timeoutID = setTimeout(c._handleTimeout, c._interval);
    }
  };
  c._tick = function () {
    var a = c._getTime();
    c._ticks++;
    var m = a - c._lastTime, b = c._paused;
    b && (c._pausedTicks++, c._pausedTime += m);
    c._lastTime = a;
    for (var d = c._pauseable, e = c._listeners.slice(), f = e ? e.length : 0, h = 0; h < f; h++) {
      var k = e[h];
      null == k || b && d[h] || (k.tick ? k.tick(m, b) : k instanceof Function && k(m, b));
    }
    c.dispatchEvent({
      type: 'tick',
      paused: b,
      delta: m,
      time: a,
      runTime: a - c._pausedTime
    });
    for (c._tickTimes.unshift(c._getTime() - a); 100 < c._tickTimes.length;)
      c._tickTimes.pop();
    for (c._times.unshift(a); 100 < c._times.length;)
      c._times.pop();
  };
  var b = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
  c._getTime = function () {
    return b && b.call(performance) || new Date().getTime();
  };
  c.init();
  createjs.Ticker = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, e, c, h, k, j) {
      this.initialize(a, m, b, d, e, c, h, k, j);
    }, b = c.prototype;
  b.stageX = 0;
  b.stageY = 0;
  b.rawX = 0;
  b.rawY = 0;
  b.type = null;
  b.nativeEvent = null;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.target = null;
  b.pointerID = 0;
  b.primary = !1;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b.initialize = function (a, m, b, d, e, c, h, k, j) {
    this.type = a;
    this.stageX = m;
    this.stageY = b;
    this.target = d;
    this.nativeEvent = e;
    this.pointerID = c;
    this.primary = h;
    this.rawX = null == k ? m : k;
    this.rawY = null == j ? b : j;
  };
  b.clone = function () {
    return new c(this.type, this.stageX, this.stageY, this.target, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
  };
  b.toString = function () {
    return '[MouseEvent (type=' + this.type + ' stageX=' + this.stageX + ' stageY=' + this.stageY + ')]';
  };
  createjs.MouseEvent = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, c, f) {
      this.initialize(a, m, b, d, c, f);
    }, b = c.prototype;
  c.identity = null;
  c.DEG_TO_RAD = Math.PI / 180;
  b.a = 1;
  b.b = 0;
  b.c = 0;
  b.d = 1;
  b.tx = 0;
  b.ty = 0;
  b.alpha = 1;
  b.shadow = null;
  b.compositeOperation = null;
  b.initialize = function (a, m, b, d, c, f) {
    null != a && (this.a = a);
    this.b = m || 0;
    this.c = b || 0;
    null != d && (this.d = d);
    this.tx = c || 0;
    this.ty = f || 0;
    return this;
  };
  b.prepend = function (a, b, g, d, c, f) {
    var h = this.tx;
    if (1 != a || 0 != b || 0 != g || 1 != d) {
      var k = this.a, j = this.c;
      this.a = k * a + this.b * g;
      this.b = k * b + this.b * d;
      this.c = j * a + this.d * g;
      this.d = j * b + this.d * d;
    }
    this.tx = h * a + this.ty * g + c;
    this.ty = h * b + this.ty * d + f;
    return this;
  };
  b.append = function (a, b, g, d, c, f) {
    var h = this.a, k = this.b, j = this.c, l = this.d;
    this.a = a * h + b * j;
    this.b = a * k + b * l;
    this.c = g * h + d * j;
    this.d = g * k + d * l;
    this.tx = c * h + f * j + this.tx;
    this.ty = c * k + f * l + this.ty;
    return this;
  };
  b.prependMatrix = function (a) {
    this.prepend(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.prependProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.appendMatrix = function (a) {
    this.append(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.appendProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.prependTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    if (k || j)
      this.tx -= k, this.ty -= j;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.prepend(e * g, l * g, -l * d, e * d, 0, 0), this.prepend(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b)) : this.prepend(e * g, l * g, -l * d, e * d, a, b);
    return this;
  };
  b.appendTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.append(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b), this.append(e * g, l * g, -l * d, e * d, 0, 0)) : this.append(e * g, l * g, -l * d, e * d, a, b);
    if (k || j)
      this.tx -= k * this.a + j * this.c, this.ty -= k * this.b + j * this.d;
    return this;
  };
  b.rotate = function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    var g = this.a, d = this.c, c = this.tx;
    this.a = g * b - this.b * a;
    this.b = g * a + this.b * b;
    this.c = d * b - this.d * a;
    this.d = d * a + this.d * b;
    this.tx = c * b - this.ty * a;
    this.ty = c * a + this.ty * b;
    return this;
  };
  b.skew = function (a, b) {
    a *= c.DEG_TO_RAD;
    b *= c.DEG_TO_RAD;
    this.append(Math.cos(b), Math.sin(b), -Math.sin(a), Math.cos(a), 0, 0);
    return this;
  };
  b.scale = function (a, b) {
    this.a *= a;
    this.d *= b;
    this.c *= a;
    this.b *= b;
    this.tx *= a;
    this.ty *= b;
    return this;
  };
  b.translate = function (a, b) {
    this.tx += a;
    this.ty += b;
    return this;
  };
  b.identity = function () {
    this.alpha = this.a = this.d = 1;
    this.b = this.c = this.tx = this.ty = 0;
    this.shadow = this.compositeOperation = null;
    return this;
  };
  b.invert = function () {
    var a = this.a, b = this.b, g = this.c, d = this.d, c = this.tx, f = a * d - b * g;
    this.a = d / f;
    this.b = -b / f;
    this.c = -g / f;
    this.d = a / f;
    this.tx = (g * this.ty - d * c) / f;
    this.ty = -(a * this.ty - b * c) / f;
    return this;
  };
  b.isIdentity = function () {
    return 0 == this.tx && 0 == this.ty && 1 == this.a && 0 == this.b && 0 == this.c && 1 == this.d;
  };
  b.decompose = function (a) {
    null == a && (a = {});
    a.x = this.tx;
    a.y = this.ty;
    a.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
    a.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
    var b = Math.atan2(-this.c, this.d), g = Math.atan2(this.b, this.a);
    b == g ? (a.rotation = g / c.DEG_TO_RAD, 0 > this.a && 0 <= this.d && (a.rotation += 0 >= a.rotation ? 180 : -180), a.skewX = a.skewY = 0) : (a.skewX = b / c.DEG_TO_RAD, a.skewY = g / c.DEG_TO_RAD);
    return a;
  };
  b.reinitialize = function (a, b, g, d, c, f, h, k, j) {
    this.initialize(a, b, g, d, c, f);
    this.alpha = h || 1;
    this.shadow = k;
    this.compositeOperation = j;
    return this;
  };
  b.appendProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = b || this.shadow;
    this.compositeOperation = g || this.compositeOperation;
    return this;
  };
  b.prependProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = this.shadow || b;
    this.compositeOperation = this.compositeOperation || g;
    return this;
  };
  b.clone = function () {
    var a = new c(this.a, this.b, this.c, this.d, this.tx, this.ty);
    a.shadow = this.shadow;
    a.alpha = this.alpha;
    a.compositeOperation = this.compositeOperation;
    return a;
  };
  b.toString = function () {
    return '[Matrix2D (a=' + this.a + ' b=' + this.b + ' c=' + this.c + ' d=' + this.d + ' tx=' + this.tx + ' ty=' + this.ty + ')]';
  };
  c.identity = new c(1, 0, 0, 1, 0, 0);
  createjs.Matrix2D = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b) {
      this.initialize(a, b);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.initialize = function (a, b) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
  };
  b.clone = function () {
    return new c(this.x, this.y);
  };
  b.toString = function () {
    return '[Point (x=' + this.x + ' y=' + this.y + ')]';
  };
  createjs.Point = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.width = 0;
  b.height = 0;
  b.initialize = function (a, b, g, d) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
    this.width = null == g ? 0 : g;
    this.height = null == d ? 0 : d;
  };
  b.clone = function () {
    return new c(this.x, this.y, this.width, this.height);
  };
  b.toString = function () {
    return '[Rectangle (x=' + this.x + ' y=' + this.y + ' width=' + this.width + ' height=' + this.height + ')]';
  };
  createjs.Rectangle = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d, c, f, h) {
      this.initialize(a, b, g, d, c, f, h);
    }, b = c.prototype;
  b.target = null;
  b.overLabel = null;
  b.outLabel = null;
  b.downLabel = null;
  b.play = !1;
  b._isPressed = !1;
  b._isOver = !1;
  b.initialize = function (a, b, g, d, c, f, h) {
    a.addEventListener && (this.target = a, a.cursor = 'pointer', this.overLabel = null == g ? 'over' : g, this.outLabel = null == b ? 'out' : b, this.downLabel = null == d ? 'down' : d, this.play = c, this.setEnabled(!0), this.handleEvent({}), f && (h && (f.actionsEnabled = !1, f.gotoAndStop && f.gotoAndStop(h)), a.hitArea = f));
  };
  b.setEnabled = function (a) {
    var b = this.target;
    a ? (b.addEventListener('mouseover', this), b.addEventListener('mouseout', this), b.addEventListener('mousedown', this)) : (b.removeEventListener('mouseover', this), b.removeEventListener('mouseout', this), b.removeEventListener('mousedown', this));
  };
  b.toString = function () {
    return '[ButtonHelper]';
  };
  b.handleEvent = function (a) {
    var b = this.target, g = a.type;
    'mousedown' == g ? (a.addEventListener('mouseup', this), this._isPressed = !0, a = this.downLabel) : 'mouseup' == g ? (this._isPressed = !1, a = this._isOver ? this.overLabel : this.outLabel) : 'mouseover' == g ? (this._isOver = !0, a = this._isPressed ? this.downLabel : this.overLabel) : (this._isOver = !1, a = this._isPressed ? this.overLabel : this.outLabel);
    this.play ? b.gotoAndPlay && b.gotoAndPlay(a) : b.gotoAndStop && b.gotoAndStop(a);
  };
  createjs.ButtonHelper = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  c.identity = null;
  b.color = null;
  b.offsetX = 0;
  b.offsetY = 0;
  b.blur = 0;
  b.initialize = function (a, b, g, d) {
    this.color = a;
    this.offsetX = b;
    this.offsetY = g;
    this.blur = d;
  };
  b.toString = function () {
    return '[Shadow]';
  };
  b.clone = function () {
    return new c(this.color, this.offsetX, this.offsetY, this.blur);
  };
  c.identity = new c('transparent', 0, 0, 0);
  createjs.Shadow = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype;
  b.complete = !0;
  b.onComplete = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._animations = null;
  b._frames = null;
  b._images = null;
  b._data = null;
  b._loadCount = 0;
  b._frameHeight = 0;
  b._frameWidth = 0;
  b._numFrames = 0;
  b._regX = 0;
  b._regY = 0;
  b.initialize = function (a) {
    var b, g, d;
    if (null != a) {
      if (a.images && 0 < (g = a.images.length)) {
        d = this._images = [];
        for (b = 0; b < g; b++) {
          var c = a.images[b];
          if ('string' == typeof c) {
            var f = c, c = new Image();
            c.src = f;
          }
          d.push(c);
          !c.getContext && !c.complete && (this._loadCount++, this.complete = !1, function (a) {
            c.onload = function () {
              a._handleImageLoad();
            };
          }(this));
        }
      }
      if (null != a.frames)
        if (a.frames instanceof Array) {
          this._frames = [];
          d = a.frames;
          b = 0;
          for (g = d.length; b < g; b++)
            f = d[b], this._frames.push({
              image: this._images[f[4] ? f[4] : 0],
              rect: new createjs.Rectangle(f[0], f[1], f[2], f[3]),
              regX: f[5] || 0,
              regY: f[6] || 0
            });
        } else
          g = a.frames, this._frameWidth = g.width, this._frameHeight = g.height, this._regX = g.regX || 0, this._regY = g.regY || 0, this._numFrames = g.count, 0 == this._loadCount && this._calculateFrames();
      if (null != (g = a.animations)) {
        this._animations = [];
        this._data = {};
        for (var h in g) {
          a = { name: h };
          f = g[h];
          if ('number' == typeof f)
            d = a.frames = [f];
          else if (f instanceof Array)
            if (1 == f.length)
              a.frames = [f[0]];
            else {
              a.frequency = f[3];
              a.next = f[2];
              d = a.frames = [];
              for (b = f[0]; b <= f[1]; b++)
                d.push(b);
            }
          else
            a.frequency = f.frequency, a.next = f.next, b = f.frames, d = a.frames = 'number' == typeof b ? [b] : b.slice(0);
          a.next = 2 > d.length || !1 == a.next ? null : null == a.next || !0 == a.next ? h : a.next;
          a.frequency || (a.frequency = 1);
          this._animations.push(h);
          this._data[h] = a;
        }
      }
    }
  };
  b.getNumFrames = function (a) {
    if (null == a)
      return this._frames ? this._frames.length : this._numFrames;
    a = this._data[a];
    return null == a ? 0 : a.frames.length;
  };
  b.getAnimations = function () {
    return this._animations.slice(0);
  };
  b.getAnimation = function (a) {
    return this._data[a];
  };
  b.getFrame = function (a) {
    var b;
    return this.complete && this._frames && (b = this._frames[a]) ? b : null;
  };
  b.getFrameBounds = function (a) {
    return (a = this.getFrame(a)) ? new createjs.Rectangle(-a.regX, -a.regY, a.rect.width, a.rect.height) : null;
  };
  b.toString = function () {
    return '[SpriteSheet]';
  };
  b.clone = function () {
    var a = new c();
    a.complete = this.complete;
    a._animations = this._animations;
    a._frames = this._frames;
    a._images = this._images;
    a._data = this._data;
    a._frameHeight = this._frameHeight;
    a._frameWidth = this._frameWidth;
    a._numFrames = this._numFrames;
    a._loadCount = this._loadCount;
    return a;
  };
  b._handleImageLoad = function () {
    0 == --this._loadCount && (this._calculateFrames(), this.complete = !0, this.onComplete && this.onComplete(), this.dispatchEvent('complete'));
  };
  b._calculateFrames = function () {
    if (!(this._frames || 0 == this._frameWidth)) {
      this._frames = [];
      for (var a = 0, b = this._frameWidth, g = this._frameHeight, d = 0, c = this._images; d < c.length; d++) {
        for (var f = c[d], h = (f.width + 1) / b | 0, k = (f.height + 1) / g | 0, k = 0 < this._numFrames ? Math.min(this._numFrames - a, h * k) : h * k, j = 0; j < k; j++)
          this._frames.push({
            image: f,
            rect: new createjs.Rectangle(j % h * b, (j / h | 0) * g, b, g),
            regX: this._regX,
            regY: this._regY
          });
        a += k;
      }
      this._numFrames = a;
    }
  };
  createjs.SpriteSheet = c;
}());
this.createjs = this.createjs || {};
(function () {
  function c(a, b, d) {
    this.f = a;
    this.params = b;
    this.path = null == d ? !0 : d;
  }
  c.prototype.exec = function (a) {
    this.f.apply(a, this.params);
  };
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.getRGB = function (a, b, d, c) {
    null != a && null == d && (c = b, d = a & 255, b = a >> 8 & 255, a = a >> 16 & 255);
    return null == c ? 'rgb(' + a + ',' + b + ',' + d + ')' : 'rgba(' + a + ',' + b + ',' + d + ',' + c + ')';
  };
  b.getHSL = function (a, b, d, c) {
    return null == c ? 'hsl(' + a % 360 + ',' + b + '%,' + d + '%)' : 'hsla(' + a % 360 + ',' + b + '%,' + d + '%,' + c + ')';
  };
  b.BASE_64 = {
    A: 0,
    B: 1,
    C: 2,
    D: 3,
    E: 4,
    F: 5,
    G: 6,
    H: 7,
    I: 8,
    J: 9,
    K: 10,
    L: 11,
    M: 12,
    N: 13,
    O: 14,
    P: 15,
    Q: 16,
    R: 17,
    S: 18,
    T: 19,
    U: 20,
    V: 21,
    W: 22,
    X: 23,
    Y: 24,
    Z: 25,
    a: 26,
    b: 27,
    c: 28,
    d: 29,
    e: 30,
    f: 31,
    g: 32,
    h: 33,
    i: 34,
    j: 35,
    k: 36,
    l: 37,
    m: 38,
    n: 39,
    o: 40,
    p: 41,
    q: 42,
    r: 43,
    s: 44,
    t: 45,
    u: 46,
    v: 47,
    w: 48,
    x: 49,
    y: 50,
    z: 51,
    '0': 52,
    1: 53,
    2: 54,
    3: 55,
    4: 56,
    5: 57,
    6: 58,
    7: 59,
    8: 60,
    9: 61,
    '+': 62,
    '/': 63
  };
  b.STROKE_CAPS_MAP = [
    'butt',
    'round',
    'square'
  ];
  b.STROKE_JOINTS_MAP = [
    'miter',
    'round',
    'bevel'
  ];
  b._ctx = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.beginCmd = new c(b._ctx.beginPath, [], !1);
  b.fillCmd = new c(b._ctx.fill, [], !1);
  b.strokeCmd = new c(b._ctx.stroke, [], !1);
  a._strokeInstructions = null;
  a._strokeStyleInstructions = null;
  a._ignoreScaleStroke = !1;
  a._fillInstructions = null;
  a._instructions = null;
  a._oldInstructions = null;
  a._activeInstructions = null;
  a._active = !1;
  a._dirty = !1;
  a.initialize = function () {
    this.clear();
    this._ctx = b._ctx;
  };
  a.isEmpty = function () {
    return !(this._instructions.length || this._oldInstructions.length || this._activeInstructions.length);
  };
  a.draw = function (a) {
    this._dirty && this._updateInstructions();
    for (var b = this._instructions, d = 0, c = b.length; d < c; d++)
      b[d].exec(a);
  };
  a.drawAsPath = function (a) {
    this._dirty && this._updateInstructions();
    for (var b, d = this._instructions, c = 0, f = d.length; c < f; c++)
      ((b = d[c]).path || 0 == c) && b.exec(a);
  };
  a.moveTo = function (a, b) {
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      b
    ]));
    return this;
  };
  a.lineTo = function (a, b) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.lineTo, [
      a,
      b
    ]));
    return this;
  };
  a.arcTo = function (a, b, d, e, f) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.arcTo, [
      a,
      b,
      d,
      e,
      f
    ]));
    return this;
  };
  a.arc = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == h && (h = !1);
    this._activeInstructions.push(new c(this._ctx.arc, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.quadraticCurveTo = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.quadraticCurveTo, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.bezierCurveTo = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.bezierCurveTo, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.rect = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.rect, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.closePath = function () {
    this._active && (this._dirty = !0, this._activeInstructions.push(new c(this._ctx.closePath, [])));
    return this;
  };
  a.clear = function () {
    this._instructions = [];
    this._oldInstructions = [];
    this._activeInstructions = [];
    this._strokeStyleInstructions = this._strokeInstructions = this._fillInstructions = null;
    this._active = this._dirty = !1;
    return this;
  };
  a.beginFill = function (a) {
    this._active && this._newPath();
    this._fillInstructions = a ? [
      new c(this._setProp, [
        'fillStyle',
        a
      ], !1),
      b.fillCmd
    ] : null;
    return this;
  };
  a.beginLinearGradientFill = function (a, g, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginRadialGradientFill = function (a, g, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginBitmapFill = function (a, g, d) {
    this._active && this._newPath();
    a = this._ctx.createPattern(a, g || '');
    a = new c(this._setProp, [
      'fillStyle',
      a
    ], !1);
    this._fillInstructions = d ? [
      a,
      new c(this._ctx.save, [], !1),
      new c(this._ctx.transform, [
        d.a,
        d.b,
        d.c,
        d.d,
        d.tx,
        d.ty
      ], !1),
      b.fillCmd,
      new c(this._ctx.restore, [], !1)
    ] : [
      a,
      b.fillCmd
    ];
    return this;
  };
  a.endFill = function () {
    return this.beginFill();
  };
  a.setStrokeStyle = function (a, g, d, e, f) {
    this._active && this._newPath();
    this._strokeStyleInstructions = [
      new c(this._setProp, [
        'lineWidth',
        null == a ? '1' : a
      ], !1),
      new c(this._setProp, [
        'lineCap',
        null == g ? 'butt' : isNaN(g) ? g : b.STROKE_CAPS_MAP[g]
      ], !1),
      new c(this._setProp, [
        'lineJoin',
        null == d ? 'miter' : isNaN(d) ? d : b.STROKE_JOINTS_MAP[d]
      ], !1),
      new c(this._setProp, [
        'miterLimit',
        null == e ? '10' : e
      ], !1)
    ];
    this._ignoreScaleStroke = f;
    return this;
  };
  a.beginStroke = function (a) {
    this._active && this._newPath();
    this._strokeInstructions = a ? [new c(this._setProp, [
        'strokeStyle',
        a
      ], !1)] : null;
    return this;
  };
  a.beginLinearGradientStroke = function (a, b, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginRadialGradientStroke = function (a, b, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginBitmapStroke = function (a, b) {
    this._active && this._newPath();
    var d = this._ctx.createPattern(a, b || '');
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.endStroke = function () {
    this.beginStroke();
    return this;
  };
  a.curveTo = a.quadraticCurveTo;
  a.drawRect = a.rect;
  a.drawRoundRect = function (a, b, d, c, f) {
    this.drawRoundRectComplex(a, b, d, c, f, f, f, f);
    return this;
  };
  a.drawRoundRectComplex = function (a, b, d, e, f, h, k, j) {
    var l = (d < e ? d : e) / 2, n = 0, q = 0, p = 0, s = 0;
    0 > f && (f *= n = -1);
    f > l && (f = l);
    0 > h && (h *= q = -1);
    h > l && (h = l);
    0 > k && (k *= p = -1);
    k > l && (k = l);
    0 > j && (j *= s = -1);
    j > l && (j = l);
    this._dirty = this._active = !0;
    var l = this._ctx.arcTo, r = this._ctx.lineTo;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + d - h,
      b
    ]), new c(l, [
      a + d + h * q,
      b - h * q,
      a + d,
      b + h,
      h
    ]), new c(r, [
      a + d,
      b + e - k
    ]), new c(l, [
      a + d + k * p,
      b + e + k * p,
      a + d - k,
      b + e,
      k
    ]), new c(r, [
      a + j,
      b + e
    ]), new c(l, [
      a - j * s,
      b + e + j * s,
      a,
      b + e - j,
      j
    ]), new c(r, [
      a,
      b + f
    ]), new c(l, [
      a - f * n,
      b - f * n,
      a + f,
      b,
      f
    ]), new c(this._ctx.closePath));
    return this;
  };
  a.drawCircle = function (a, b, d) {
    this.arc(a, b, d, 0, 2 * Math.PI);
    return this;
  };
  a.drawEllipse = function (a, b, d, e) {
    this._dirty = this._active = !0;
    var f = 0.5522848 * (d / 2), h = 0.5522848 * (e / 2), k = a + d, j = b + e;
    d = a + d / 2;
    e = b + e / 2;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      a,
      e - h,
      d - f,
      b,
      d,
      b
    ]), new c(this._ctx.bezierCurveTo, [
      d + f,
      b,
      k,
      e - h,
      k,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      k,
      e + h,
      d + f,
      j,
      d,
      j
    ]), new c(this._ctx.bezierCurveTo, [
      d - f,
      j,
      a,
      e + h,
      a,
      e
    ]));
    return this;
  };
  a.drawPolyStar = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == f && (f = 0);
    f = 1 - f;
    h = null == h ? 0 : h / (180 / Math.PI);
    var k = Math.PI / e;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + Math.cos(h) * d,
      b + Math.sin(h) * d
    ]));
    for (var j = 0; j < e; j++)
      h += k, 1 != f && this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d * f,
        b + Math.sin(h) * d * f
      ])), h += k, this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d,
        b + Math.sin(h) * d
      ]));
    return this;
  };
  a.decodePath = function (a) {
    for (var g = [
          this.moveTo,
          this.lineTo,
          this.quadraticCurveTo,
          this.bezierCurveTo,
          this.closePath
        ], d = [
          2,
          2,
          4,
          6,
          0
        ], c = 0, f = a.length, h = [], k = 0, j = 0, l = b.BASE_64; c < f;) {
      var n = a.charAt(c), q = l[n], p = q >> 3, s = g[p];
      if (!s || q & 3)
        throw 'bad path data (@' + c + '): ' + n;
      n = d[p];
      p || (k = j = 0);
      h.length = 0;
      c++;
      q = (q >> 2 & 1) + 2;
      for (p = 0; p < n; p++) {
        var r = l[a.charAt(c)], u = r >> 5 ? -1 : 1, r = (r & 31) << 6 | l[a.charAt(c + 1)];
        3 == q && (r = r << 6 | l[a.charAt(c + 2)]);
        r = u * r / 10;
        p % 2 ? k = r += k : j = r += j;
        h[p] = r;
        c += q;
      }
      s.apply(this, h);
    }
    return this;
  };
  a.clone = function () {
    var a = new b();
    a._instructions = this._instructions.slice();
    a._activeInstructions = this._activeInstructions.slice();
    a._oldInstructions = this._oldInstructions.slice();
    this._fillInstructions && (a._fillInstructions = this._fillInstructions.slice());
    this._strokeInstructions && (a._strokeInstructions = this._strokeInstructions.slice());
    this._strokeStyleInstructions && (a._strokeStyleInstructions = this._strokeStyleInstructions.slice());
    a._active = this._active;
    a._dirty = this._dirty;
    return a;
  };
  a.toString = function () {
    return '[Graphics]';
  };
  a.mt = a.moveTo;
  a.lt = a.lineTo;
  a.at = a.arcTo;
  a.bt = a.bezierCurveTo;
  a.qt = a.quadraticCurveTo;
  a.a = a.arc;
  a.r = a.rect;
  a.cp = a.closePath;
  a.c = a.clear;
  a.f = a.beginFill;
  a.lf = a.beginLinearGradientFill;
  a.rf = a.beginRadialGradientFill;
  a.bf = a.beginBitmapFill;
  a.ef = a.endFill;
  a.ss = a.setStrokeStyle;
  a.s = a.beginStroke;
  a.ls = a.beginLinearGradientStroke;
  a.rs = a.beginRadialGradientStroke;
  a.bs = a.beginBitmapStroke;
  a.es = a.endStroke;
  a.dr = a.drawRect;
  a.rr = a.drawRoundRect;
  a.rc = a.drawRoundRectComplex;
  a.dc = a.drawCircle;
  a.de = a.drawEllipse;
  a.dp = a.drawPolyStar;
  a.p = a.decodePath;
  a._updateInstructions = function () {
    this._instructions = this._oldInstructions.slice();
    this._instructions.push(b.beginCmd);
    this._instructions.push.apply(this._instructions, this._activeInstructions);
    this._fillInstructions && this._instructions.push.apply(this._instructions, this._fillInstructions);
    this._strokeInstructions && (this._strokeStyleInstructions && this._instructions.push.apply(this._instructions, this._strokeStyleInstructions), this._instructions.push.apply(this._instructions, this._strokeInstructions), this._ignoreScaleStroke ? this._instructions.push(new c(this._ctx.save, [], !1), new c(this._ctx.setTransform, [
      1,
      0,
      0,
      1,
      0,
      0
    ], !1), b.strokeCmd, new c(this._ctx.restore, [], !1)) : this._instructions.push(b.strokeCmd));
  };
  a._newPath = function () {
    this._dirty && this._updateInstructions();
    this._oldInstructions = this._instructions;
    this._activeInstructions = [];
    this._active = this._dirty = !1;
  };
  a._setProp = function (a, b) {
    this[a] = b;
  };
  createjs.Graphics = b;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.suppressCrossDomainErrors = !1;
  c._hitTestCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._hitTestCanvas.width = c._hitTestCanvas.height = 1;
  c._hitTestContext = c._hitTestCanvas.getContext('2d');
  c._nextCacheID = 1;
  b.alpha = 1;
  b.cacheCanvas = null;
  b.id = -1;
  b.mouseEnabled = !0;
  b.name = null;
  b.parent = null;
  b.regX = 0;
  b.regY = 0;
  b.rotation = 0;
  b.scaleX = 1;
  b.scaleY = 1;
  b.skewX = 0;
  b.skewY = 0;
  b.shadow = null;
  b.visible = !0;
  b.x = 0;
  b.y = 0;
  b.compositeOperation = null;
  b.snapToPixel = !1;
  b.onPress = null;
  b.onClick = null;
  b.onDoubleClick = null;
  b.onMouseOver = null;
  b.onMouseOut = null;
  b.onTick = null;
  b.filters = null;
  b.cacheID = 0;
  b.mask = null;
  b.hitArea = null;
  b.cursor = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._cacheOffsetX = 0;
  b._cacheOffsetY = 0;
  b._cacheScale = 1;
  b._cacheDataURLID = 0;
  b._cacheDataURL = null;
  b._matrix = null;
  b.initialize = function () {
    this.id = createjs.UID.get();
    this._matrix = new createjs.Matrix2D();
  };
  b.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  b.draw = function (a, b) {
    var c = this.cacheCanvas;
    if (b || !c)
      return !1;
    var d = this._cacheScale;
    a.drawImage(c, this._cacheOffsetX, this._cacheOffsetY, c.width / d, c.height / d);
    return !0;
  };
  b.updateContext = function (a) {
    var b, c = this.mask;
    c && (c.graphics && !c.graphics.isEmpty()) && (b = c.getMatrix(c._matrix), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty), c.graphics.drawAsPath(a), a.clip(), b.invert(), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty));
    b = this._matrix.identity().appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY);
    createjs.Stage._snapToPixelEnabled && this.snapToPixel ? a.transform(b.a, b.b, b.c, b.d, b.tx + 0.5 | 0, b.ty + 0.5 | 0) : a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty);
    a.globalAlpha *= this.alpha;
    this.compositeOperation && (a.globalCompositeOperation = this.compositeOperation);
    this.shadow && this._applyShadow(a, this.shadow);
  };
  b.cache = function (a, b, c, d, e) {
    e = e || 1;
    this.cacheCanvas || (this.cacheCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    this.cacheCanvas.width = Math.ceil(c * e);
    this.cacheCanvas.height = Math.ceil(d * e);
    this._cacheOffsetX = a;
    this._cacheOffsetY = b;
    this._cacheScale = e || 1;
    this.updateCache();
  };
  b.updateCache = function (a) {
    var b = this.cacheCanvas, g = this._cacheScale, d = this._cacheOffsetX * g, e = this._cacheOffsetY * g;
    if (!b)
      throw 'cache() must be called before updateCache()';
    var f = b.getContext('2d');
    f.save();
    a || f.clearRect(0, 0, b.width + 1, b.height + 1);
    f.globalCompositeOperation = a;
    f.setTransform(g, 0, 0, g, -d, -e);
    this.draw(f, !0);
    this._applyFilters();
    f.restore();
    this.cacheID = c._nextCacheID++;
  };
  b.uncache = function () {
    this._cacheDataURL = this.cacheCanvas = null;
    this.cacheID = this._cacheOffsetX = this._cacheOffsetY = 0;
    this._cacheScale = 1;
  };
  b.getCacheDataURL = function () {
    if (!this.cacheCanvas)
      return null;
    this.cacheID != this._cacheDataURLID && (this._cacheDataURL = this.cacheCanvas.toDataURL());
    return this._cacheDataURL;
  };
  b.getStage = function () {
    for (var a = this; a.parent;)
      a = a.parent;
    return a instanceof createjs.Stage ? a : null;
  };
  b.localToGlobal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.globalToLocal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.invert();
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.localToLocal = function (a, b, c) {
    a = this.localToGlobal(a, b);
    return c.globalToLocal(a.x, a.y);
  };
  b.setTransform = function (a, b, c, d, e, f, h, k, j) {
    this.x = a || 0;
    this.y = b || 0;
    this.scaleX = null == c ? 1 : c;
    this.scaleY = null == d ? 1 : d;
    this.rotation = e || 0;
    this.skewX = f || 0;
    this.skewY = h || 0;
    this.regX = k || 0;
    this.regY = j || 0;
    return this;
  };
  b.getMatrix = function (a) {
    return (a ? a.identity() : new createjs.Matrix2D()).appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY).appendProperties(this.alpha, this.shadow, this.compositeOperation);
  };
  b.getConcatenatedMatrix = function (a) {
    a ? a.identity() : a = new createjs.Matrix2D();
    for (var b = this; null != b;)
      a.prependTransform(b.x, b.y, b.scaleX, b.scaleY, b.rotation, b.skewX, b.skewY, b.regX, b.regY).prependProperties(b.alpha, b.shadow, b.compositeOperation), b = b.parent;
    return a;
  };
  b.hitTest = function (a, b) {
    var g = c._hitTestContext;
    g.setTransform(1, 0, 0, 1, -a, -b);
    this.draw(g);
    var d = this._testHit(g);
    g.setTransform(1, 0, 0, 1, 0, 0);
    g.clearRect(0, 0, 2, 2);
    return d;
  };
  b.set = function (a) {
    for (var b in a)
      this[b] = a[b];
    return this;
  };
  b.clone = function () {
    var a = new c();
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[DisplayObject (name=' + this.name + ')]';
  };
  b.cloneProps = function (a) {
    a.alpha = this.alpha;
    a.name = this.name;
    a.regX = this.regX;
    a.regY = this.regY;
    a.rotation = this.rotation;
    a.scaleX = this.scaleX;
    a.scaleY = this.scaleY;
    a.shadow = this.shadow;
    a.skewX = this.skewX;
    a.skewY = this.skewY;
    a.visible = this.visible;
    a.x = this.x;
    a.y = this.y;
    a.mouseEnabled = this.mouseEnabled;
    a.compositeOperation = this.compositeOperation;
    this.cacheCanvas && (a.cacheCanvas = this.cacheCanvas.cloneNode(!0), a.cacheCanvas.getContext('2d').putImageData(this.cacheCanvas.getContext('2d').getImageData(0, 0, this.cacheCanvas.width, this.cacheCanvas.height), 0, 0));
  };
  b._applyShadow = function (a, b) {
    b = b || Shadow.identity;
    a.shadowColor = b.color;
    a.shadowOffsetX = b.offsetX;
    a.shadowOffsetY = b.offsetY;
    a.shadowBlur = b.blur;
  };
  b._tick = function (a) {
    this.onTick && this.onTick.apply(this, a);
    var b = this._listeners;
    b && b.tick && this.dispatchEvent({
      type: 'tick',
      params: a
    });
  };
  b._testHit = function (a) {
    try {
      var b = 1 < a.getImageData(0, 0, 1, 1).data[3];
    } catch (g) {
      if (!c.suppressCrossDomainErrors)
        throw 'An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.';
    }
    return b;
  };
  b._applyFilters = function () {
    if (this.filters && 0 != this.filters.length && this.cacheCanvas)
      for (var a = this.filters.length, b = this.cacheCanvas.getContext('2d'), c = this.cacheCanvas.width, d = this.cacheCanvas.height, e = 0; e < a; e++)
        this.filters[e].applyFilter(b, 0, 0, c, d);
  };
  b._hasMouseHandler = function (a) {
    var b = this._listeners;
    return !!(a & 1 && (this.onPress || this.onClick || this.onDoubleClick || b && (this.hasEventListener('mousedown') || this.hasEventListener('click') || this.hasEventListener('dblclick'))) || a & 2 && (this.onMouseOver || this.onMouseOut || this.cursor || b && (this.hasEventListener('mouseover') || this.hasEventListener('mouseout'))));
  };
  createjs.DisplayObject = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype = new createjs.DisplayObject();
  b.children = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function () {
    this.DisplayObject_initialize();
    this.children = [];
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.children.length;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    for (var c = this.children.slice(0), d = 0, e = c.length; d < e; d++) {
      var f = c[d];
      f.isVisible() && (a.save(), f.updateContext(a), f.draw(a), a.restore());
    }
    return !0;
  };
  b.addChild = function (a) {
    if (null == a)
      return a;
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addChild(arguments[c]);
      return arguments[b - 1];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.push(a);
    return a;
  };
  b.addChildAt = function (a, b) {
    var c = arguments.length, d = arguments[c - 1];
    if (0 > d || d > this.children.length)
      return arguments[c - 2];
    if (2 < c) {
      for (var e = 0; e < c - 1; e++)
        this.addChildAt(arguments[e], d + e);
      return arguments[c - 2];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.splice(b, 0, a);
    return a;
  };
  b.removeChild = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, d = 0; d < b; d++)
        c = c && this.removeChild(arguments[d]);
      return c;
    }
    return this.removeChildAt(this.children.indexOf(a));
  };
  b.removeChildAt = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = [], d = 0; d < b; d++)
        c[d] = arguments[d];
      c.sort(function (a, b) {
        return b - a;
      });
      for (var e = !0, d = 0; d < b; d++)
        e = e && this.removeChildAt(c[d]);
      return e;
    }
    if (0 > a || a > this.children.length - 1)
      return !1;
    if (b = this.children[a])
      b.parent = null;
    this.children.splice(a, 1);
    return !0;
  };
  b.removeAllChildren = function () {
    for (var a = this.children; a.length;)
      a.pop().parent = null;
  };
  b.getChildAt = function (a) {
    return this.children[a];
  };
  b.getChildByName = function (a) {
    for (var b = this.children, c = 0, d = b.length; c < d; c++)
      if (b[c].name == a)
        return b[c];
    return null;
  };
  b.sortChildren = function (a) {
    this.children.sort(a);
  };
  b.getChildIndex = function (a) {
    return this.children.indexOf(a);
  };
  b.getNumChildren = function () {
    return this.children.length;
  };
  b.swapChildrenAt = function (a, b) {
    var c = this.children, d = c[a], e = c[b];
    d && e && (c[a] = e, c[b] = d);
  };
  b.swapChildren = function (a, b) {
    for (var c = this.children, d, e, f = 0, h = c.length; f < h && !(c[f] == a && (d = f), c[f] == b && (e = f), null != d && null != e); f++);
    f != h && (c[d] = b, c[e] = a);
  };
  b.setChildIndex = function (a, b) {
    var c = this.children, d = c.length;
    if (!(a.parent != this || 0 > b || b >= d)) {
      for (var e = 0; e < d && c[e] != a; e++);
      e == d || e == b || (c.splice(e, 1), b < e && b--, c.splice(b, 0, a));
    }
  };
  b.contains = function (a) {
    for (; a;) {
      if (a == this)
        return !0;
      a = a.parent;
    }
    return !1;
  };
  b.hitTest = function (a, b) {
    return null != this.getObjectUnderPoint(a, b);
  };
  b.getObjectsUnderPoint = function (a, b) {
    var c = [], d = this.localToGlobal(a, b);
    this._getObjectsUnderPoint(d.x, d.y, c);
    return c;
  };
  b.getObjectUnderPoint = function (a, b) {
    var c = this.localToGlobal(a, b);
    return this._getObjectsUnderPoint(c.x, c.y);
  };
  b.clone = function (a) {
    var b = new c();
    this.cloneProps(b);
    if (a)
      for (var g = b.children = [], d = 0, e = this.children.length; d < e; d++) {
        var f = this.children[d].clone(a);
        f.parent = b;
        g.push(f);
      }
    return b;
  };
  b.toString = function () {
    return '[Container (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    for (var b = this.children.length - 1; 0 <= b; b--) {
      var c = this.children[b];
      c._tick && c._tick(a);
    }
    this.DisplayObject__tick(a);
  };
  b._getObjectsUnderPoint = function (a, b, g, d) {
    var e = createjs.DisplayObject._hitTestContext, f = this._matrix, h = this._hasMouseHandler(d);
    if (!this.hitArea && (this.cacheCanvas && h) && (this.getConcatenatedMatrix(f), e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), e.globalAlpha = f.alpha, this.draw(e), this._testHit(e)))
      return e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, 2, 2), this;
    for (var k = this.children.length - 1; 0 <= k; k--) {
      var j = this.children[k], l = j.hitArea;
      if (j.visible && !(!l && !j.isVisible() || d && !j.mouseEnabled)) {
        var n = d && j._hasMouseHandler(d);
        if (j instanceof c && (!l || !n))
          if (h) {
            if (j = j._getObjectsUnderPoint(a, b))
              return this;
          } else {
            if (j = j._getObjectsUnderPoint(a, b, g, d), !g && j)
              return j;
          }
        else if (!d || h || n)
          if (j.getConcatenatedMatrix(f), l && (f.appendTransform(l.x, l.y, l.scaleX, l.scaleY, l.rotation, l.skewX, l.skewY, l.regX, l.regY), f.alpha = l.alpha), e.globalAlpha = f.alpha, e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), (l || j).draw(e), this._testHit(e)) {
            e.setTransform(1, 0, 0, 1, 0, 0);
            e.clearRect(0, 0, 2, 2);
            if (h)
              return this;
            if (g)
              g.push(j);
            else
              return j;
          }
      }
    }
    return null;
  };
  createjs.Container = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.Container();
  c._snapToPixelEnabled = !1;
  b.autoClear = !0;
  b.canvas = null;
  b.mouseX = 0;
  b.mouseY = 0;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.onMouseDown = null;
  b.snapToPixelEnabled = !1;
  b.mouseInBounds = !1;
  b.tickOnUpdate = !0;
  b.mouseMoveOutside = !1;
  b._pointerData = null;
  b._pointerCount = 0;
  b._primaryPointerID = null;
  b._mouseOverIntervalID = null;
  b.Container_initialize = b.initialize;
  b.initialize = function (a) {
    this.Container_initialize();
    this.canvas = 'string' == typeof a ? document.getElementById(a) : a;
    this._pointerData = {};
    this.enableDOMEvents(!0);
  };
  b.update = function () {
    if (this.canvas) {
      this.autoClear && this.clear();
      c._snapToPixelEnabled = this.snapToPixelEnabled;
      this.tickOnUpdate && this._tick(arguments.length ? arguments : null);
      var a = this.canvas.getContext('2d');
      a.save();
      this.updateContext(a);
      this.draw(a, !1);
      a.restore();
    }
  };
  b.tick = b.update;
  b.handleEvent = function (a) {
    'tick' == a.type && this.update(a);
  };
  b.clear = function () {
    if (this.canvas) {
      var a = this.canvas.getContext('2d');
      a.setTransform(1, 0, 0, 1, 0, 0);
      a.clearRect(0, 0, this.canvas.width + 1, this.canvas.height + 1);
    }
  };
  b.toDataURL = function (a, b) {
    b || (b = 'image/png');
    var c = this.canvas.getContext('2d'), d = this.canvas.width, e = this.canvas.height, f;
    if (a) {
      f = c.getImageData(0, 0, d, e);
      var h = c.globalCompositeOperation;
      c.globalCompositeOperation = 'destination-over';
      c.fillStyle = a;
      c.fillRect(0, 0, d, e);
    }
    var k = this.canvas.toDataURL(b);
    a && (c.clearRect(0, 0, d + 1, e + 1), c.putImageData(f, 0, 0), c.globalCompositeOperation = h);
    return k;
  };
  b.enableMouseOver = function (a) {
    this._mouseOverIntervalID && (clearInterval(this._mouseOverIntervalID), this._mouseOverIntervalID = null);
    if (null == a)
      a = 20;
    else if (0 >= a)
      return;
    var b = this;
    this._mouseOverIntervalID = setInterval(function () {
      b._testMouseOver();
    }, 1000 / Math.min(50, a));
  };
  b.enableDOMEvents = function (a) {
    null == a && (a = !0);
    var b, c = this._eventListeners;
    if (!a && c) {
      for (b in c)
        a = c[b], a.t.removeEventListener(b, a.f);
      this._eventListeners = null;
    } else if (a && !c && this.canvas) {
      a = window.addEventListener ? window : document;
      var d = this, c = this._eventListeners = {};
      c.mouseup = {
        t: a,
        f: function (a) {
          d._handleMouseUp(a);
        }
      };
      c.mousemove = {
        t: a,
        f: function (a) {
          d._handleMouseMove(a);
        }
      };
      c.dblclick = {
        t: a,
        f: function (a) {
          d._handleDoubleClick(a);
        }
      };
      c.mousedown = {
        t: this.canvas,
        f: function (a) {
          d._handleMouseDown(a);
        }
      };
      for (b in c)
        a = c[b], a.t.addEventListener(b, a.f);
    }
  };
  b.clone = function () {
    var a = new c(null);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Stage (name=' + this.name + ')]';
  };
  b._getPointerData = function (a) {
    var b = this._pointerData[a];
    if (!b && (b = this._pointerData[a] = {
        x: 0,
        y: 0
      }, null == this._primaryPointerID || -1 == this._primaryPointerID))
      this._primaryPointerID = a;
    return b;
  };
  b._handleMouseMove = function (a) {
    a || (a = window.event);
    this._handlePointerMove(-1, a, a.pageX, a.pageY);
  };
  b._handlePointerMove = function (a, b, c, d) {
    if (this.canvas) {
      var e = this._getPointerData(a), f = e.inBounds;
      this._updatePointerPosition(a, c, d);
      if (f || e.inBounds || this.mouseMoveOutside) {
        if (this.onMouseMove || this.hasEventListener('stagemousemove'))
          c = new createjs.MouseEvent('stagemousemove', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseMove && this.onMouseMove(c), this.dispatchEvent(c);
        if ((d = e.event) && (d.onMouseMove || d.hasEventListener('mousemove')))
          c = new createjs.MouseEvent('mousemove', e.x, e.y, d.target, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onMouseMove && d.onMouseMove(c), d.dispatchEvent(c, d.target);
      }
    }
  };
  b._updatePointerPosition = function (a, b, c) {
    var d = this._getElementRect(this.canvas);
    b -= d.left;
    c -= d.top;
    var e = this.canvas.width, f = this.canvas.height;
    b /= (d.right - d.left) / e;
    c /= (d.bottom - d.top) / f;
    d = this._getPointerData(a);
    (d.inBounds = 0 <= b && 0 <= c && b <= e - 1 && c <= f - 1) ? (d.x = b, d.y = c) : this.mouseMoveOutside && (d.x = 0 > b ? 0 : b > e - 1 ? e - 1 : b, d.y = 0 > c ? 0 : c > f - 1 ? f - 1 : c);
    d.rawX = b;
    d.rawY = c;
    a == this._primaryPointerID && (this.mouseX = d.x, this.mouseY = d.y, this.mouseInBounds = d.inBounds);
  };
  b._getElementRect = function (a) {
    var b;
    try {
      b = a.getBoundingClientRect();
    } catch (c) {
      b = {
        top: a.offsetTop,
        left: a.offsetLeft,
        width: a.offsetWidth,
        height: a.offsetHeight
      };
    }
    var d = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0), e = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || document.body.clientTop || 0), f = window.getComputedStyle ? getComputedStyle(a) : a.currentStyle;
    a = parseInt(f.paddingLeft) + parseInt(f.borderLeftWidth);
    var h = parseInt(f.paddingTop) + parseInt(f.borderTopWidth), k = parseInt(f.paddingRight) + parseInt(f.borderRightWidth), f = parseInt(f.paddingBottom) + parseInt(f.borderBottomWidth);
    return {
      left: b.left + d + a,
      right: b.right + d - k,
      top: b.top + e + h,
      bottom: b.bottom + e - f
    };
  };
  b._handleMouseUp = function (a) {
    this._handlePointerUp(-1, a, !1);
  };
  b._handlePointerUp = function (a, b, c) {
    var d = this._getPointerData(a), e;
    if (this.onMouseMove || this.hasEventListener('stagemouseup'))
      e = new createjs.MouseEvent('stagemouseup', d.x, d.y, this, b, a, a == this._primaryPointerID, d.rawX, d.rawY), this.onMouseUp && this.onMouseUp(e), this.dispatchEvent(e);
    var f = d.event;
    if (f && (f.onMouseUp || f.hasEventListener('mouseup')))
      e = new createjs.MouseEvent('mouseup', d.x, d.y, f.target, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onMouseUp && f.onMouseUp(e), f.dispatchEvent(e, f.target);
    if ((f = d.target) && (f.onClick || f.hasEventListener('click')) && this._getObjectsUnderPoint(d.x, d.y, null, !0, this._mouseOverIntervalID ? 3 : 1) == f)
      e = new createjs.MouseEvent('click', d.x, d.y, f, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onClick && f.onClick(e), f.dispatchEvent(e);
    c ? (a == this._primaryPointerID && (this._primaryPointerID = null), delete this._pointerData[a]) : d.event = d.target = null;
  };
  b._handleMouseDown = function (a) {
    this._handlePointerDown(-1, a, !1);
  };
  b._handlePointerDown = function (a, b, c, d) {
    var e = this._getPointerData(a);
    null != d && this._updatePointerPosition(a, c, d);
    if (this.onMouseDown || this.hasEventListener('stagemousedown'))
      c = new createjs.MouseEvent('stagemousedown', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseDown && this.onMouseDown(c), this.dispatchEvent(c);
    if (d = this._getObjectsUnderPoint(e.x, e.y, null, this._mouseOverIntervalID ? 3 : 1))
      if (e.target = d, d.onPress || d.hasEventListener('mousedown'))
        if (c = new createjs.MouseEvent('mousedown', e.x, e.y, d, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onPress && d.onPress(c), d.dispatchEvent(c), c.onMouseMove || c.onMouseUp || c.hasEventListener('mousemove') || c.hasEventListener('mouseup'))
          e.event = c;
  };
  b._testMouseOver = function () {
    if (-1 == this._primaryPointerID && !(this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) {
      var a = null;
      this.mouseInBounds && (a = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, 3), this._mouseOverX = this.mouseX, this._mouseOverY = this.mouseY);
      var b = this._mouseOverTarget;
      if (b != a) {
        var c = this._getPointerData(-1);
        if (b && (b.onMouseOut || b.hasEventListener('mouseout'))) {
          var d = new createjs.MouseEvent('mouseout', c.x, c.y, b, null, -1, c.rawX, c.rawY);
          b.onMouseOut && b.onMouseOut(d);
          b.dispatchEvent(d);
        }
        b && (this.canvas.style.cursor = '');
        if (a && (a.onMouseOver || a.hasEventListener('mouseover')))
          d = new createjs.MouseEvent('mouseover', c.x, c.y, a, null, -1, c.rawX, c.rawY), a.onMouseOver && a.onMouseOver(d), a.dispatchEvent(d);
        a && (this.canvas.style.cursor = a.cursor || '');
        this._mouseOverTarget = a;
      }
    }
  };
  b._handleDoubleClick = function (a) {
    var b = this._getPointerData(-1), c = this._getObjectsUnderPoint(b.x, b.y, null, this._mouseOverIntervalID ? 3 : 1);
    if (c && (c.onDoubleClick || c.hasEventListener('dblclick')))
      evt = new createjs.MouseEvent('dblclick', b.x, b.y, c, a, -1, !0, b.rawX, b.rawY), c.onDoubleClick && c.onDoubleClick(evt), c.dispatchEvent(evt);
  };
  createjs.Stage = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.image = null;
  b.snapToPixel = !0;
  b.sourceRect = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    'string' == typeof a ? (this.image = new Image(), this.image.src = a) : this.image = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.image && (this.image.complete || this.image.getContext || 2 <= this.image.readyState);
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    var c = this.sourceRect;
    c ? a.drawImage(this.image, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height) : a.drawImage(this.image, 0, 0);
    return !0;
  };
  b.clone = function () {
    var a = new c(this.image);
    this.sourceRect && (a.sourceRect = this.sourceRect.clone());
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Bitmap (name=' + this.name + ')]';
  };
  createjs.Bitmap = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.onAnimationEnd = null;
  b.currentFrame = -1;
  b.currentAnimation = null;
  b.paused = !0;
  b.spriteSheet = null;
  b.snapToPixel = !0;
  b.offset = 0;
  b.currentAnimationFrame = 0;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._advanceCount = 0;
  b._animation = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.spriteSheet = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.spriteSheet.complete && 0 <= this.currentFrame;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this._normalizeFrame();
    var c = this.spriteSheet.getFrame(this.currentFrame);
    if (c) {
      var d = c.rect;
      a.drawImage(c.image, d.x, d.y, d.width, d.height, -c.regX, -c.regY, d.width, d.height);
      return !0;
    }
  };
  b.play = function () {
    this.paused = !1;
  };
  b.stop = function () {
    this.paused = !0;
  };
  b.gotoAndPlay = function (a) {
    this.paused = !1;
    this._goto(a);
  };
  b.gotoAndStop = function (a) {
    this.paused = !0;
    this._goto(a);
  };
  b.advance = function () {
    this._animation ? this.currentAnimationFrame++ : this.currentFrame++;
    this._normalizeFrame();
  };
  b.getBounds = function () {
    return this.spriteSheet.getFrameBounds(this.currentFrame);
  };
  b.clone = function () {
    var a = new c(this.spriteSheet);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[BitmapAnimation (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    var b = this._animation ? this._animation.frequency : 1;
    !this.paused && 0 == (++this._advanceCount + this.offset) % b && this.advance();
    this.DisplayObject__tick(a);
  };
  b._normalizeFrame = function () {
    var a = this._animation, b = this.currentFrame, c = this.paused, d;
    if (a)
      if (d = a.frames.length, this.currentAnimationFrame >= d) {
        var e = a.next;
        this._dispatchAnimationEnd(a, b, c, e, d - 1) || (e ? this._goto(e) : (this.paused = !0, this.currentAnimationFrame = a.frames.length - 1, this.currentFrame = a.frames[this.currentAnimationFrame]));
      } else
        this.currentFrame = a.frames[this.currentAnimationFrame];
    else
      d = this.spriteSheet.getNumFrames(), b >= d && !this._dispatchAnimationEnd(a, b, c, d - 1) && (this.currentFrame = 0);
  };
  b._dispatchAnimationEnd = function (a, b, c, d, e) {
    var f = a ? a.name : null;
    this.onAnimationEnd && this.onAnimationEnd(this, f, d);
    this.dispatchEvent({
      type: 'animationend',
      name: f,
      next: d
    });
    !c && this.paused && (this.currentAnimationFrame = e);
    return this.paused != c || this._animation != a || this.currentFrame != b;
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.onAnimationEnd = this.onAnimationEnd;
    a.currentFrame = this.currentFrame;
    a.currentAnimation = this.currentAnimation;
    a.paused = this.paused;
    a.offset = this.offset;
    a._animation = this._animation;
    a.currentAnimationFrame = this.currentAnimationFrame;
  };
  b._goto = function (a) {
    if (isNaN(a)) {
      var b = this.spriteSheet.getAnimation(a);
      b && (this.currentAnimationFrame = 0, this._animation = b, this.currentAnimation = a, this._normalizeFrame());
    } else
      this.currentAnimation = this._animation = null, this.currentFrame = a;
  };
  createjs.BitmapAnimation = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.graphics = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.graphics = a ? a : new createjs.Graphics();
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.graphics && !this.graphics.isEmpty();
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.graphics.draw(a);
    return !0;
  };
  b.clone = function (a) {
    a = new c(a && this.graphics ? this.graphics.clone() : this.graphics);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Shape (name=' + this.name + ')]';
  };
  createjs.Shape = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, c) {
      this.initialize(a, b, c);
    }, b = c.prototype = new createjs.DisplayObject();
  c._workingContext = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.text = '';
  b.font = null;
  b.color = '#000';
  b.textAlign = 'left';
  b.textBaseline = 'top';
  b.maxWidth = null;
  b.outline = !1;
  b.lineHeight = 0;
  b.lineWidth = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a, b, c) {
    this.DisplayObject_initialize();
    this.text = a;
    this.font = b;
    this.color = c ? c : '#000';
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || null != this.text && '' !== this.text;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.outline ? a.strokeStyle = this.color : a.fillStyle = this.color;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    this._drawText(a);
    return !0;
  };
  b.getMeasuredWidth = function () {
    return this._getWorkingContext().measureText(this.text).width;
  };
  b.getMeasuredLineHeight = function () {
    return 1.2 * this._getWorkingContext().measureText('M').width;
  };
  b.getMeasuredHeight = function () {
    return this._drawText() * (this.lineHeight || this.getMeasuredLineHeight());
  };
  b.clone = function () {
    var a = new c(this.text, this.font, this.color);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Text (text=' + (20 < this.text.length ? this.text.substr(0, 17) + '...' : this.text) + ')]';
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.textAlign = this.textAlign;
    a.textBaseline = this.textBaseline;
    a.maxWidth = this.maxWidth;
    a.outline = this.outline;
    a.lineHeight = this.lineHeight;
    a.lineWidth = this.lineWidth;
  };
  b._getWorkingContext = function () {
    var a = c._workingContext;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    return a;
  };
  b._drawText = function (a) {
    var b = !!a;
    b || (a = this._getWorkingContext());
    for (var c = String(this.text).split(/(?:\r\n|\r|\n)/), d = this.lineHeight || this.getMeasuredLineHeight(), e = 0, f = 0, h = c.length; f < h; f++) {
      var k = a.measureText(c[f]).width;
      if (null == this.lineWidth || k < this.lineWidth)
        b && this._drawTextLine(a, c[f], e * d);
      else {
        for (var k = c[f].split(/(\s)/), j = k[0], l = 1, n = k.length; l < n; l += 2)
          a.measureText(j + k[l] + k[l + 1]).width > this.lineWidth ? (b && this._drawTextLine(a, j, e * d), e++, j = k[l + 1]) : j += k[l] + k[l + 1];
        b && this._drawTextLine(a, j, e * d);
      }
      e++;
    }
    return e;
  };
  b._drawTextLine = function (a, b, c) {
    this.outline ? a.strokeText(b, 0, c, this.maxWidth || 65535) : a.fillText(b, 0, c, this.maxWidth || 65535);
  };
  createjs.Text = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'SpriteSheetUtils cannot be instantiated';
  };
  c._workingCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._workingContext = c._workingCanvas.getContext('2d');
  c.addFlippedFrames = function (b, a, m, g) {
    if (a || m || g) {
      var d = 0;
      a && c._flip(b, ++d, !0, !1);
      m && c._flip(b, ++d, !1, !0);
      g && c._flip(b, ++d, !0, !0);
    }
  };
  c.extractFrame = function (b, a) {
    isNaN(a) && (a = b.getAnimation(a).frames[0]);
    var m = b.getFrame(a);
    if (!m)
      return null;
    var g = m.rect, d = c._workingCanvas;
    d.width = g.width;
    d.height = g.height;
    c._workingContext.drawImage(m.image, g.x, g.y, g.width, g.height, 0, 0, g.width, g.height);
    m = new Image();
    m.src = d.toDataURL('image/png');
    return m;
  };
  c.mergeAlpha = function (b, a, c) {
    c || (c = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    c.width = Math.max(a.width, b.width);
    c.height = Math.max(a.height, b.height);
    var g = c.getContext('2d');
    g.save();
    g.drawImage(b, 0, 0);
    g.globalCompositeOperation = 'destination-in';
    g.drawImage(a, 0, 0);
    g.restore();
    return c;
  };
  c._flip = function (b, a, m, g) {
    for (var d = b._images, e = c._workingCanvas, f = c._workingContext, h = d.length / a, k = 0; k < h; k++) {
      var j = d[k];
      j.__tmp = k;
      f.setTransform(1, 0, 0, 1, 0, 0);
      f.clearRect(0, 0, e.width + 1, e.height + 1);
      e.width = j.width;
      e.height = j.height;
      f.setTransform(m ? -1 : 1, 0, 0, g ? -1 : 1, m ? j.width : 0, g ? j.height : 0);
      f.drawImage(j, 0, 0);
      var l = new Image();
      l.src = e.toDataURL('image/png');
      l.width = j.width;
      l.height = j.height;
      d.push(l);
    }
    f = b._frames;
    e = f.length / a;
    for (k = 0; k < e; k++) {
      var j = f[k], n = j.rect.clone(), l = d[j.image.__tmp + h * a], q = {
          image: l,
          rect: n,
          regX: j.regX,
          regY: j.regY
        };
      m && (n.x = l.width - n.x - n.width, q.regX = n.width - j.regX);
      g && (n.y = l.height - n.y - n.height, q.regY = n.height - j.regY);
      f.push(q);
    }
    m = '_' + (m ? 'h' : '') + (g ? 'v' : '');
    g = b._animations;
    b = b._data;
    d = g.length / a;
    for (k = 0; k < d; k++) {
      f = g[k];
      j = b[f];
      h = {
        name: f + m,
        frequency: j.frequency,
        next: j.next,
        frames: []
      };
      j.next && (h.next += m);
      f = j.frames;
      j = 0;
      for (l = f.length; j < l; j++)
        h.frames.push(f[j] + e * a);
      b[h.name] = h;
      g.push(h.name);
    }
  };
  createjs.SpriteSheetUtils = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.ERR_DIMENSIONS = 'frame dimensions exceed max spritesheet dimensions';
  c.ERR_RUNNING = 'a build is already running';
  b.maxWidth = 2048;
  b.maxHeight = 2048;
  b.spriteSheet = null;
  b.scale = 1;
  b.padding = 1;
  b.timeSlice = 0.3;
  b.progress = -1;
  b.onComplete = null;
  b.onProgress = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._frames = null;
  b._animations = null;
  b._data = null;
  b._nextFrameIndex = 0;
  b._index = 0;
  b._timerID = null;
  b._scale = 1;
  b.initialize = function () {
    this._frames = [];
    this._animations = {};
  };
  b.addFrame = function (a, b, g, d, e, f) {
    if (this._data)
      throw c.ERR_RUNNING;
    b = b || a.bounds || a.nominalBounds;
    !b && a.getBounds && (b = a.getBounds());
    if (!b)
      return null;
    g = g || 1;
    return this._frames.push({
      source: a,
      sourceRect: b,
      scale: g,
      funct: d,
      params: e,
      scope: f,
      index: this._frames.length,
      height: b.height * g
    }) - 1;
  };
  b.addAnimation = function (a, b, g, d) {
    if (this._data)
      throw c.ERR_RUNNING;
    this._animations[a] = {
      frames: b,
      next: g,
      frequency: d
    };
  };
  b.addMovieClip = function (a, b, g) {
    if (this._data)
      throw c.ERR_RUNNING;
    var d = a.frameBounds, e = b || a.bounds || a.nominalBounds;
    !e && a.getBounds && (e = a.getBounds());
    if (!e && !d)
      return null;
    b = this._frames.length;
    for (var f = a.timeline.duration, h = 0; h < f; h++)
      this.addFrame(a, d && d[h] ? d[h] : e, g, function (a) {
        var b = this.actionsEnabled;
        this.actionsEnabled = !1;
        this.gotoAndStop(a);
        this.actionsEnabled = b;
      }, [h], a);
    h = a.timeline._labels;
    a = [];
    for (var k in h)
      a.push({
        index: h[k],
        label: k
      });
    if (a.length) {
      a.sort(function (a, b) {
        return a.index - b.index;
      });
      h = 0;
      for (k = a.length; h < k; h++) {
        g = a[h].label;
        for (var d = b + (h == k - 1 ? f : a[h + 1].index), e = [], j = b + a[h].index; j < d; j++)
          e.push(j);
        this.addAnimation(g, e, !0);
      }
    }
  };
  b.build = function () {
    if (this._data)
      throw c.ERR_RUNNING;
    for (this._startBuild(); this._drawNext(););
    this._endBuild();
    return this.spriteSheet;
  };
  b.buildAsync = function (a) {
    if (this._data)
      throw c.ERR_RUNNING;
    this.timeSlice = a;
    this._startBuild();
    var b = this;
    this._timerID = setTimeout(function () {
      b._run();
    }, 50 - 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)));
  };
  b.stopAsync = function () {
    clearTimeout(this._timerID);
    this._data = null;
  };
  b.clone = function () {
    throw 'SpriteSheetBuilder cannot be cloned.';
  };
  b.toString = function () {
    return '[SpriteSheetBuilder]';
  };
  b._startBuild = function () {
    var a = this.padding || 0;
    this.progress = 0;
    this.spriteSheet = null;
    this._index = 0;
    this._scale = this.scale;
    var b = [];
    this._data = {
      images: [],
      frames: b,
      animations: this._animations
    };
    var g = this._frames.slice();
    g.sort(function (a, b) {
      return a.height <= b.height ? -1 : 1;
    });
    if (g[g.length - 1].height + 2 * a > this.maxHeight)
      throw c.ERR_DIMENSIONS;
    for (var d = 0, e = 0, f = 0; g.length;) {
      var h = this._fillRow(g, d, f, b, a);
      h.w > e && (e = h.w);
      d += h.h;
      if (!h.h || !g.length) {
        var k = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
        k.width = this._getSize(e, this.maxWidth);
        k.height = this._getSize(d, this.maxHeight);
        this._data.images[f] = k;
        h.h || (e = d = 0, f++);
      }
    }
  };
  b._getSize = function (a, b) {
    for (var c = 4; Math.pow(2, ++c) < a;);
    return Math.min(b, Math.pow(2, c));
  };
  b._fillRow = function (a, b, g, d, e) {
    var f = this.maxWidth, h = this.maxHeight;
    b += e;
    for (var h = h - b, k = e, j = 0, l = a.length - 1; 0 <= l; l--) {
      var n = a[l], q = this._scale * n.scale, p = n.sourceRect, s = n.source, r = Math.floor(q * p.x - e), u = Math.floor(q * p.y - e), t = Math.ceil(q * p.height + 2 * e), p = Math.ceil(q * p.width + 2 * e);
      if (p > f)
        throw c.ERR_DIMENSIONS;
      t > h || k + p > f || (n.img = g, n.rect = new createjs.Rectangle(k, b, p, t), j = j || t, a.splice(l, 1), d[n.index] = [
        k,
        b,
        p,
        t,
        g,
        Math.round(-r + q * s.regX - e),
        Math.round(-u + q * s.regY - e)
      ], k += p);
    }
    return {
      w: k,
      h: j
    };
  };
  b._endBuild = function () {
    this.spriteSheet = new createjs.SpriteSheet(this._data);
    this._data = null;
    this.progress = 1;
    this.onComplete && this.onComplete(this);
    this.dispatchEvent('complete');
  };
  b._run = function () {
    for (var a = 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)), b = new Date().getTime() + a, c = !1; b > new Date().getTime();)
      if (!this._drawNext()) {
        c = !0;
        break;
      }
    if (c)
      this._endBuild();
    else {
      var d = this;
      this._timerID = setTimeout(function () {
        d._run();
      }, 50 - a);
    }
    a = this.progress = this._index / this._frames.length;
    this.onProgress && this.onProgress(this, a);
    this.dispatchEvent({
      type: 'progress',
      progress: a
    });
  };
  b._drawNext = function () {
    var a = this._frames[this._index], b = a.scale * this._scale, c = a.rect, d = a.sourceRect, e = this._data.images[a.img].getContext('2d');
    a.funct && a.funct.apply(a.scope, a.params);
    e.save();
    e.beginPath();
    e.rect(c.x, c.y, c.width, c.height);
    e.clip();
    e.translate(Math.ceil(c.x - d.x * b), Math.ceil(c.y - d.y * b));
    e.scale(b, b);
    a.source.draw(e);
    e.restore();
    return ++this._index < this._frames.length;
  };
  createjs.SpriteSheetBuilder = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.htmlElement = null;
  b._oldMtx = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    'string' == typeof a && (a = document.getElementById(a));
    this.DisplayObject_initialize();
    this.mouseEnabled = !1;
    this.htmlElement = a;
    a = a.style;
    a.position = 'absolute';
    a.transformOrigin = a.WebkitTransformOrigin = a.msTransformOrigin = a.MozTransformOrigin = a.OTransformOrigin = '0% 0%';
  };
  b.isVisible = function () {
    return null != this.htmlElement;
  };
  b.draw = function () {
    if (null != this.htmlElement) {
      var a = this.getConcatenatedMatrix(this._matrix), b = this.htmlElement.style;
      if (this.visible)
        b.visibility = 'visible';
      else
        return !0;
      var c = this._oldMtx || {};
      c.alpha != a.alpha && (b.opacity = '' + a.alpha, c.alpha = a.alpha);
      if (c.tx != a.tx || c.ty != a.ty || c.a != a.a || c.b != a.b || c.c != a.c || c.d != a.d)
        b.transform = b.WebkitTransform = b.OTransform = b.msTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          a.tx + 0.5 | 0,
          (a.ty + 0.5 | 0) + ')'
        ].join(), b.MozTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          (a.tx + 0.5 | 0) + 'px',
          (a.ty + 0.5 | 0) + 'px)'
        ].join(), this._oldMtx = a.clone();
      return !0;
    }
  };
  b.cache = function () {
  };
  b.uncache = function () {
  };
  b.updateCache = function () {
  };
  b.hitTest = function () {
  };
  b.localToGlobal = function () {
  };
  b.globalToLocal = function () {
  };
  b.localToLocal = function () {
  };
  b.clone = function () {
    throw 'DOMElement cannot be cloned.';
  };
  b.toString = function () {
    return '[DOMElement (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    this.htmlElement.style.visibility = 'hidden';
    this.DisplayObject__tick(a);
  };
  createjs.DOMElement = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  b.initialize = function () {
  };
  b.getBounds = function () {
    return new createjs.Rectangle(0, 0, 0, 0);
  };
  b.applyFilter = function () {
  };
  b.toString = function () {
    return '[Filter]';
  };
  b.clone = function () {
    return new c();
  };
  createjs.Filter = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Touch cannot be instantiated';
  };
  c.isSupported = function () {
    return 'ontouchstart' in window || window.navigator.msPointerEnabled;
  };
  c.enable = function (b, a, m) {
    if (!b || !b.canvas || !c.isSupported())
      return !1;
    b.__touch = {
      pointers: {},
      multitouch: !a,
      preventDefault: !m,
      count: 0
    };
    'ontouchstart' in window ? c._IOS_enable(b) : window.navigator.msPointerEnabled && c._IE_enable(b);
    return !0;
  };
  c.disable = function (b) {
    b && ('ontouchstart' in window ? c._IOS_disable(b) : window.navigator.msPointerEnabled && c._IE_disable(b));
  };
  c._IOS_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IOS_handleEvent(b, a);
      };
    a.addEventListener('touchstart', m, !1);
    a.addEventListener('touchmove', m, !1);
    a.addEventListener('touchend', m, !1);
    a.addEventListener('touchcancel', m, !1);
  };
  c._IOS_disable = function (b) {
    var a = b.canvas;
    a && (b = b.__touch.f, a.removeEventListener('touchstart', b, !1), a.removeEventListener('touchmove', b, !1), a.removeEventListener('touchend', b, !1), a.removeEventListener('touchcancel', b, !1));
  };
  c._IOS_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      for (var c = a.changedTouches, g = a.type, d = 0, e = c.length; d < e; d++) {
        var f = c[d], h = f.identifier;
        f.target == b.canvas && ('touchstart' == g ? this._handleStart(b, h, a, f.pageX, f.pageY) : 'touchmove' == g ? this._handleMove(b, h, a, f.pageX, f.pageY) : ('touchend' == g || 'touchcancel' == g) && this._handleEnd(b, h, a));
      }
    }
  };
  c._IE_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IE_handleEvent(b, a);
      };
    a.addEventListener('MSPointerDown', m, !1);
    window.addEventListener('MSPointerMove', m, !1);
    window.addEventListener('MSPointerUp', m, !1);
    window.addEventListener('MSPointerCancel', m, !1);
    b.__touch.preventDefault && (a.style.msTouchAction = 'none');
    b.__touch.activeIDs = {};
  };
  c._IE_disable = function (b) {
    var a = b.__touch.f;
    window.removeEventListener('MSPointerMove', a, !1);
    window.removeEventListener('MSPointerUp', a, !1);
    window.removeEventListener('MSPointerCancel', a, !1);
    b.canvas && b.canvas.removeEventListener('MSPointerDown', a, !1);
  };
  c._IE_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      var c = a.type, g = a.pointerId, d = b.__touch.activeIDs;
      if ('MSPointerDown' == c)
        a.srcElement == b.canvas && (d[g] = !0, this._handleStart(b, g, a, a.pageX, a.pageY));
      else if (d[g])
        if ('MSPointerMove' == c)
          this._handleMove(b, g, a, a.pageX, a.pageY);
        else if ('MSPointerUp' == c || 'MSPointerCancel' == c)
          delete d[g], this._handleEnd(b, g, a);
    }
  };
  c._handleStart = function (b, a, c, g, d) {
    var e = b.__touch;
    if (e.multitouch || !e.count) {
      var f = e.pointers;
      f[a] || (f[a] = !0, e.count++, b._handlePointerDown(a, c, g, d));
    }
  };
  c._handleMove = function (b, a, c, g, d) {
    b.__touch.pointers[a] && b._handlePointerMove(a, c, g, d);
  };
  c._handleEnd = function (b, a, c) {
    var g = b.__touch, d = g.pointers;
    d[a] && (g.count--, b._handlePointerUp(a, c, !0), delete d[a]);
  };
  createjs.Touch = c;
}());
(function () {
  var c = this.createjs = this.createjs || {}, c = c.EaselJS = c.EaselJS || {};
  c.version = '0.6.1';
  c.buildDate = 'Tue, 14 May 2013 21:43:02 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.initialize = function (d) {
    d.addEventListener = a.addEventListener;
    d.removeEventListener = a.removeEventListener;
    d.removeAllEventListeners = a.removeAllEventListeners;
    d.hasEventListener = a.hasEventListener;
    d.dispatchEvent = a.dispatchEvent;
  };
  a._listeners = null;
  a.initialize = function () {
  };
  a.addEventListener = function (d, a) {
    var c = this._listeners;
    c ? this.removeEventListener(d, a) : c = this._listeners = {};
    var b = c[d];
    b || (b = c[d] = []);
    b.push(a);
    return a;
  };
  a.removeEventListener = function (d, a) {
    var c = this._listeners;
    if (c) {
      var b = c[d];
      if (b)
        for (var f = 0, g = b.length; f < g; f++)
          if (b[f] == a) {
            1 == g ? delete c[d] : b.splice(f, 1);
            break;
          }
    }
  };
  a.removeAllEventListeners = function (d) {
    d ? this._listeners && delete this._listeners[d] : this._listeners = null;
  };
  a.dispatchEvent = function (d, a) {
    var c = !1, b = this._listeners;
    if (d && b) {
      'string' == typeof d && (d = { type: d });
      b = b[d.type];
      if (!b)
        return c;
      d.target = a || this;
      for (var b = b.slice(), f = 0, g = b.length; f < g; f++)
        var j = b[f], c = j.handleEvent ? c || j.handleEvent(d) : c || j(d);
    }
    return !!c;
  };
  a.hasEventListener = function (d) {
    var a = this._listeners;
    return !(!a || !a[d]);
  };
  a.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (d, a, c) {
      this.initialize(d, a, c);
    }, a = b.prototype;
  b.NONE = 0;
  b.LOOP = 1;
  b.REVERSE = 2;
  b.IGNORE = {};
  b._tweens = [];
  b._plugins = {};
  b.get = function (d, a, c, e) {
    e && b.removeTweens(d);
    return new b(d, a, c);
  };
  b.tick = function (d, a) {
    for (var c = b._tweens.slice(), e = c.length - 1; 0 <= e; e--) {
      var f = c[e];
      a && !f.ignoreGlobalPause || f._paused || f.tick(f._useTicks ? 1 : d);
    }
  };
  createjs.Ticker && createjs.Ticker.addListener(b, !1);
  b.removeTweens = function (d) {
    if (d.tweenjs_count) {
      for (var a = b._tweens, c = a.length - 1; 0 <= c; c--)
        a[c]._target == d && (a[c]._paused = !0, a.splice(c, 1));
      d.tweenjs_count = 0;
    }
  };
  b.removeAllTweens = function () {
    for (var d = b._tweens, a = 0, c = d.length; a < c; a++) {
      var e = d[a];
      e.paused = !0;
      e.target.tweenjs_count = 0;
    }
    d.length = 0;
  };
  b.hasActiveTweens = function (d) {
    return d ? d.tweenjs_count : b._tweens && b._tweens.length;
  };
  b.installPlugin = function (d, a) {
    var c = d.priority;
    null == c && (d.priority = c = 0);
    for (var e = 0, f = a.length, g = b._plugins; e < f; e++) {
      var j = a[e];
      if (g[j]) {
        for (var l = g[j], k = 0, p = l.length; k < p && !(c < l[k].priority); k++);
        g[j].splice(k, 0, d);
      } else
        g[j] = [d];
    }
  };
  b._register = function (d, a) {
    var c = d._target;
    a ? (c && (c.tweenjs_count = c.tweenjs_count ? c.tweenjs_count + 1 : 1), b._tweens.push(d)) : (c && c.tweenjs_count--, c = b._tweens.indexOf(d), -1 != c && b._tweens.splice(c, 1));
  };
  a.addEventListener = null;
  a.removeEventListener = null;
  a.removeAllEventListeners = null;
  a.dispatchEvent = null;
  a.hasEventListener = null;
  a._listeners = null;
  createjs.EventDispatcher.initialize(a);
  a.ignoreGlobalPause = !1;
  a.loop = !1;
  a.duration = 0;
  a.pluginData = null;
  a.onChange = null;
  a.change = null;
  a.target = null;
  a.position = null;
  a._paused = !1;
  a._curQueueProps = null;
  a._initQueueProps = null;
  a._steps = null;
  a._actions = null;
  a._prevPosition = 0;
  a._stepPosition = 0;
  a._prevPos = -1;
  a._target = null;
  a._useTicks = !1;
  a.initialize = function (d, a, c) {
    this.target = this._target = d;
    a && (this._useTicks = a.useTicks, this.ignoreGlobalPause = a.ignoreGlobalPause, this.loop = a.loop, this.onChange = a.onChange, a.override && b.removeTweens(d));
    this.pluginData = c || {};
    this._curQueueProps = {};
    this._initQueueProps = {};
    this._steps = [];
    this._actions = [];
    a && a.paused ? this._paused = !0 : b._register(this, !0);
    a && null != a.position && this.setPosition(a.position, b.NONE);
  };
  a.wait = function (a) {
    if (null == a || 0 >= a)
      return this;
    var b = this._cloneProps(this._curQueueProps);
    return this._addStep({
      d: a,
      p0: b,
      e: this._linearEase,
      p1: b
    });
  };
  a.to = function (a, b, c) {
    if (isNaN(b) || 0 > b)
      b = 0;
    return this._addStep({
      d: b || 0,
      p0: this._cloneProps(this._curQueueProps),
      e: c,
      p1: this._cloneProps(this._appendQueueProps(a))
    });
  };
  a.call = function (a, b, c) {
    return this._addAction({
      f: a,
      p: b ? b : [this],
      o: c ? c : this._target
    });
  };
  a.set = function (a, b) {
    return this._addAction({
      f: this._set,
      o: this,
      p: [
        a,
        b ? b : this._target
      ]
    });
  };
  a.play = function (a) {
    return this.call(a.setPaused, [!1], a);
  };
  a.pause = function (a) {
    a || (a = this);
    return this.call(a.setPaused, [!0], a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    null == b && (b = 1);
    var c = a, e = !1;
    c >= this.duration && (this.loop ? c %= this.duration : (c = this.duration, e = !0));
    if (c == this._prevPos)
      return e;
    var f = this._prevPos;
    this.position = this._prevPos = c;
    this._prevPosition = a;
    if (this._target)
      if (e)
        this._updateTargetProps(null, 1);
      else if (0 < this._steps.length) {
        for (var g = 0, j = this._steps.length; g < j && !(this._steps[g].t > c); g++);
        g = this._steps[g - 1];
        this._updateTargetProps(g, (this._stepPosition = c - g.t) / g.d);
      }
    0 != b && 0 < this._actions.length && (this._useTicks ? this._runActions(c, c) : 1 == b && c < f ? (f != this.duration && this._runActions(f, this.duration), this._runActions(0, c, !0)) : this._runActions(f, c));
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    this.dispatchEvent('change');
    return e;
  };
  a.tick = function (a) {
    this._paused || this.setPosition(this._prevPosition + a);
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    b._register(this, !a);
    return this;
  };
  a.w = a.wait;
  a.t = a.to;
  a.c = a.call;
  a.s = a.set;
  a.toString = function () {
    return '[Tween]';
  };
  a.clone = function () {
    throw 'Tween can not be cloned.';
  };
  a._updateTargetProps = function (a, h) {
    var c, e, f, g;
    !a && 1 == h ? c = e = this._curQueueProps : (a.e && (h = a.e(h, 0, 1, 1)), c = a.p0, e = a.p1);
    for (n in this._initQueueProps) {
      if (null == (f = c[n]))
        c[n] = f = this._initQueueProps[n];
      if (null == (g = e[n]))
        e[n] = g = f;
      f = f == g || 0 == h || 1 == h || 'number' != typeof f ? 1 == h ? g : f : f + (g - f) * h;
      var j = !1;
      if (g = b._plugins[n])
        for (var l = 0, k = g.length; l < k; l++) {
          var p = g[l].tween(this, n, f, c, e, h, !!a && c == e, !a);
          p == b.IGNORE ? j = !0 : f = p;
        }
      j || (this._target[n] = f);
    }
  };
  a._runActions = function (a, b, c) {
    var e = a, f = b, g = -1, j = this._actions.length, l = 1;
    a > b && (e = b, f = a, g = j, j = l = -1);
    for (; (g += l) != j;) {
      b = this._actions[g];
      var k = b.t;
      (k == f || k > e && k < f || c && k == a) && b.f.apply(b.o, b.p);
    }
  };
  a._appendQueueProps = function (a) {
    var h, c, e, f, g, j;
    for (j in a) {
      if (void 0 === this._initQueueProps[j]) {
        c = this._target[j];
        if (h = b._plugins[j]) {
          e = 0;
          for (f = h.length; e < f; e++)
            c = h[e].init(this, j, c);
        }
        this._initQueueProps[j] = void 0 === c ? null : c;
      } else
        c = this._curQueueProps[j];
      if (h = b._plugins[j]) {
        g = g || {};
        e = 0;
        for (f = h.length; e < f; e++)
          h[e].step && h[e].step(this, j, c, a[j], g);
      }
      this._curQueueProps[j] = a[j];
    }
    g && this._appendQueueProps(g);
    return this._curQueueProps;
  };
  a._cloneProps = function (a) {
    var b = {}, c;
    for (c in a)
      b[c] = a[c];
    return b;
  };
  a._addStep = function (a) {
    0 < a.d && (this._steps.push(a), a.t = this.duration, this.duration += a.d);
    return this;
  };
  a._addAction = function (a) {
    a.t = this.duration;
    this._actions.push(a);
    return this;
  };
  a._set = function (a, b) {
    for (var c in a)
      b[c] = a[c];
  };
  createjs.Tween = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (a, b, c) {
      this.initialize(a, b, c);
    }, a = b.prototype;
  a.ignoreGlobalPause = !1;
  a.duration = 0;
  a.loop = !1;
  a.onChange = null;
  a.position = null;
  a._paused = !1;
  a._tweens = null;
  a._labels = null;
  a._prevPosition = 0;
  a._prevPos = -1;
  a._useTicks = !1;
  a.initialize = function (a, b, c) {
    this._tweens = [];
    c && (this._useTicks = c.useTicks, this.loop = c.loop, this.ignoreGlobalPause = c.ignoreGlobalPause, this.onChange = c.onChange);
    a && this.addTween.apply(this, a);
    this.setLabels(b);
    c && c.paused ? this._paused = !0 : createjs.Tween._register(this, !0);
    c && null != c.position && this.setPosition(c.position, createjs.Tween.NONE);
  };
  a.addTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addTween(arguments[c]);
      return arguments[0];
    }
    if (0 == b)
      return null;
    this.removeTween(a);
    this._tweens.push(a);
    a.setPaused(!0);
    a._paused = !1;
    a._useTicks = this._useTicks;
    a.duration > this.duration && (this.duration = a.duration);
    0 <= this._prevPos && a.setPosition(this._prevPos, createjs.Tween.NONE);
    return a;
  };
  a.removeTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, e = 0; e < b; e++)
        c = c && this.removeTween(arguments[e]);
      return c;
    }
    if (0 == b)
      return !1;
    b = this._tweens.indexOf(a);
    return -1 != b ? (this._tweens.splice(b, 1), a.duration >= this.duration && this.updateDuration(), !0) : !1;
  };
  a.addLabel = function (a, b) {
    this._labels[a] = b;
  };
  a.setLabels = function (a) {
    this._labels = a ? a : {};
  };
  a.gotoAndPlay = function (a) {
    this.setPaused(!1);
    this._goto(a);
  };
  a.gotoAndStop = function (a) {
    this.setPaused(!0);
    this._goto(a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    var c = this.loop ? a % this.duration : a, e = !this.loop && a >= this.duration;
    if (c == this._prevPos)
      return e;
    this._prevPosition = a;
    this.position = this._prevPos = c;
    for (var f = 0, g = this._tweens.length; f < g; f++)
      if (this._tweens[f].setPosition(c, b), c != this._prevPos)
        return !1;
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    return e;
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    createjs.Tween._register(this, !a);
  };
  a.updateDuration = function () {
    for (var a = this.duration = 0, b = this._tweens.length; a < b; a++) {
      var c = this._tweens[a];
      c.duration > this.duration && (this.duration = c.duration);
    }
  };
  a.tick = function (a) {
    this.setPosition(this._prevPosition + a);
  };
  a.resolve = function (a) {
    var b = parseFloat(a);
    isNaN(b) && (b = this._labels[a]);
    return b;
  };
  a.toString = function () {
    return '[Timeline]';
  };
  a.clone = function () {
    throw 'Timeline can not be cloned.';
  };
  a._goto = function (a) {
    a = this.resolve(a);
    null != a && this.setPosition(a);
  };
  createjs.Timeline = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'Ease cannot be instantiated.';
  };
  b.linear = function (a) {
    return a;
  };
  b.none = b.linear;
  b.get = function (a) {
    -1 > a && (a = -1);
    1 < a && (a = 1);
    return function (b) {
      return 0 == a ? b : 0 > a ? b * (b * -a + 1 + a) : b * ((2 - b) * a + (1 - a));
    };
  };
  b.getPowIn = function (a) {
    return function (b) {
      return Math.pow(b, a);
    };
  };
  b.getPowOut = function (a) {
    return function (b) {
      return 1 - Math.pow(1 - b, a);
    };
  };
  b.getPowInOut = function (a) {
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * Math.pow(b, a) : 1 - 0.5 * Math.abs(Math.pow(2 - b, a));
    };
  };
  b.quadIn = b.getPowIn(2);
  b.quadOut = b.getPowOut(2);
  b.quadInOut = b.getPowInOut(2);
  b.cubicIn = b.getPowIn(3);
  b.cubicOut = b.getPowOut(3);
  b.cubicInOut = b.getPowInOut(3);
  b.quartIn = b.getPowIn(4);
  b.quartOut = b.getPowOut(4);
  b.quartInOut = b.getPowInOut(4);
  b.quintIn = b.getPowIn(5);
  b.quintOut = b.getPowOut(5);
  b.quintInOut = b.getPowInOut(5);
  b.sineIn = function (a) {
    return 1 - Math.cos(a * Math.PI / 2);
  };
  b.sineOut = function (a) {
    return Math.sin(a * Math.PI / 2);
  };
  b.sineInOut = function (a) {
    return -0.5 * (Math.cos(Math.PI * a) - 1);
  };
  b.getBackIn = function (a) {
    return function (b) {
      return b * b * ((a + 1) * b - a);
    };
  };
  b.backIn = b.getBackIn(1.7);
  b.getBackOut = function (a) {
    return function (b) {
      return --b * b * ((a + 1) * b + a) + 1;
    };
  };
  b.backOut = b.getBackOut(1.7);
  b.getBackInOut = function (a) {
    a *= 1.525;
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * b * b * ((a + 1) * b - a) : 0.5 * ((b -= 2) * b * ((a + 1) * b + a) + 2);
    };
  };
  b.backInOut = b.getBackInOut(1.7);
  b.circIn = function (a) {
    return -(Math.sqrt(1 - a * a) - 1);
  };
  b.circOut = function (a) {
    return Math.sqrt(1 - --a * a);
  };
  b.circInOut = function (a) {
    return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
  };
  b.bounceIn = function (a) {
    return 1 - b.bounceOut(1 - a);
  };
  b.bounceOut = function (a) {
    return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
  };
  b.bounceInOut = function (a) {
    return 0.5 > a ? 0.5 * b.bounceIn(2 * a) : 0.5 * b.bounceOut(2 * a - 1) + 0.5;
  };
  b.getElasticIn = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return -(a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b));
    };
  };
  b.elasticIn = b.getElasticIn(1, 0.3);
  b.getElasticOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return a * Math.pow(2, -10 * c) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticOut = b.getElasticOut(1, 0.3);
  b.getElasticInOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      var e = b / h * Math.asin(1 / a);
      return 1 > (c *= 2) ? -0.5 * a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b) : 0.5 * a * Math.pow(2, -10 * (c -= 1)) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticInOut = b.getElasticInOut(1, 0.3 * 1.5);
  createjs.Ease = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'MotionGuidePlugin cannot be instantiated.';
  };
  b.priority = 0;
  b.install = function () {
    createjs.Tween.installPlugin(b, [
      'guide',
      'x',
      'y',
      'rotation'
    ]);
    return createjs.Tween.IGNORE;
  };
  b.init = function (a, b, h) {
    a = a.target;
    a.hasOwnProperty('x') || (a.x = 0);
    a.hasOwnProperty('y') || (a.y = 0);
    a.hasOwnProperty('rotation') || (a.rotation = 0);
    return 'guide' == b ? null : h;
  };
  b.step = function (a, d, h, c, e) {
    if ('guide' != d)
      return c;
    var f;
    c.hasOwnProperty('path') || (c.path = []);
    a = c.path;
    c.hasOwnProperty('end') || (c.end = 1);
    c.hasOwnProperty('start') || (c.start = h && h.hasOwnProperty('end') && h.path === a ? h.end : 0);
    if (c.hasOwnProperty('_segments') && c._length)
      return c;
    h = a.length;
    if (6 <= h && 0 == (h - 2) % 4) {
      c._segments = [];
      c._length = 0;
      for (d = 2; d < h; d += 4) {
        for (var g = a[d - 2], j = a[d - 1], l = a[d + 0], k = a[d + 1], p = a[d + 2], x = a[d + 3], v = g, w = j, s, m, r = 0, t = [], u = 1; 10 >= u; u++) {
          m = u / 10;
          var q = 1 - m;
          s = q * q * g + 2 * q * m * l + m * m * p;
          m = q * q * j + 2 * q * m * k + m * m * x;
          r += t[t.push(Math.sqrt((f = s - v) * f + (f = m - w) * f)) - 1];
          v = s;
          w = m;
        }
        c._segments.push(r);
        c._segments.push(t);
        c._length += r;
      }
    } else
      throw 'invalid \'path\' data, please see documentation for valid paths';
    f = c.orient;
    c.orient = !1;
    b.calc(c, c.end, e);
    c.orient = f;
    return c;
  };
  b.tween = function (a, d, h, c, e, f, g) {
    e = e.guide;
    if (void 0 == e || e === c.guide)
      return h;
    e.lastRatio != f && (b.calc(e, (e.end - e.start) * (g ? e.end : f) + e.start, a.target), e.orient && (a.target.rotation += c.rotation || 0), e.lastRatio = f);
    return !e.orient && 'rotation' == d ? h : a.target[d];
  };
  b.calc = function (a, d, h) {
    void 0 == a._segments && b.validate(a);
    void 0 == h && (h = {
      x: 0,
      y: 0,
      rotation: 0
    });
    var c = a._segments, e = a.path, f = a._length * d, g = c.length - 2;
    for (d = 0; f > c[d] && d < g;)
      f -= c[d], d += 2;
    for (var c = c[d + 1], j = 0, g = c.length - 1; f > c[j] && j < g;)
      f -= c[j], j++;
    f = j / ++g + f / (g * c[j]);
    d = 2 * d + 2;
    g = 1 - f;
    h.x = g * g * e[d - 2] + 2 * g * f * e[d + 0] + f * f * e[d + 2];
    h.y = g * g * e[d - 1] + 2 * g * f * e[d + 1] + f * f * e[d + 3];
    a.orient && (h.rotation = 57.2957795 * Math.atan2((e[d + 1] - e[d - 1]) * g + (e[d + 3] - e[d + 1]) * f, (e[d + 0] - e[d - 2]) * g + (e[d + 2] - e[d + 0]) * f));
    return h;
  };
  createjs.MotionGuidePlugin = b;
}());
(function () {
  var b = this.createjs = this.createjs || {}, b = b.TweenJS = b.TweenJS || {};
  b.version = '0.4.0';
  b.buildDate = 'Tue, 12 Feb 2013 21:08:16 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var d = function (b, a, c, f) {
      this.initialize(b, a, c, f);
    }, a = d.prototype = new createjs.Container();
  d.INDEPENDENT = 'independent';
  d.SINGLE_FRAME = 'single';
  d.SYNCHED = 'synched';
  a.startPosition = 0;
  a.loop = !0;
  a.currentFrame = 0;
  a.timeline = null;
  a.paused = !1;
  a.actionsEnabled = !0;
  a.autoReset = !0;
  a._synchOffset = 0;
  a._prevPos = -1;
  a._prevPosition = 0;
  a.Container_initialize = a.initialize;
  a.initialize = function (b, a, c, f) {
    this.mode = b || d.INDEPENDENT;
    this.startPosition = a || 0;
    this.loop = c;
    props = {
      paused: !0,
      position: a,
      useTicks: !0
    };
    this.Container_initialize();
    this.timeline = new createjs.Timeline(null, f, props);
    this._managed = {};
  };
  a.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  a.Container_draw = a.draw;
  a.draw = function (b, a, c) {
    if (this.DisplayObject_draw(b, a))
      return !0;
    this._updateTimeline();
    this.Container_draw(b, a, c);
  };
  a.play = function () {
    this.paused = !1;
  };
  a.stop = function () {
    this.paused = !0;
  };
  a.gotoAndPlay = function (b) {
    this.paused = !1;
    this._goto(b);
  };
  a.gotoAndStop = function (b) {
    this.paused = !0;
    this._goto(b);
  };
  a.clone = function () {
    throw 'MovieClip cannot be cloned.';
  };
  a.toString = function () {
    return '[MovieClip (name=' + this.name + ')]';
  };
  a.Container__tick = a._tick;
  a._tick = function (b) {
    !this.paused && this.mode == d.INDEPENDENT && (this._prevPosition = 0 > this._prevPos ? 0 : this._prevPosition + 1);
    this.Container__tick(b);
  };
  a._goto = function (b) {
    b = this.timeline.resolve(b);
    null != b && (-1 == this._prevPos && (this._prevPos = NaN), this._prevPosition = b, this._updateTimeline());
  };
  a._reset = function () {
    this._prevPos = -1;
    this.currentFrame = 0;
  };
  a._updateTimeline = function () {
    var b = this.timeline, a = b._tweens, c = this.children, f = this.mode != d.INDEPENDENT;
    b.loop = null == this.loop ? !0 : this.loop;
    f ? b.setPosition(this.startPosition + (this.mode == d.SINGLE_FRAME ? 0 : this._synchOffset), createjs.Tween.NONE) : b.setPosition(0 > this._prevPos ? 0 : this._prevPosition, this.actionsEnabled ? null : createjs.Tween.NONE);
    this._prevPosition = b._prevPosition;
    if (this._prevPos != b._prevPos) {
      this.currentFrame = this._prevPos = b._prevPos;
      for (var e in this._managed)
        this._managed[e] = 1;
      for (b = a.length - 1; 0 <= b; b--)
        e = a[b], f = e._target, f != this && (e = e._stepPosition, f instanceof createjs.DisplayObject ? this._addManagedChild(f, e) : this._setState(f.state, e));
      for (b = c.length - 1; 0 <= b; b--)
        a = c[b].id, 1 == this._managed[a] && (this.removeChildAt(b), delete this._managed[a]);
    }
  };
  a._setState = function (b, a) {
    if (b)
      for (var c = 0, f = b.length; c < f; c++) {
        var e = b[c], d = e.t, e = e.p, g;
        for (g in e)
          d[g] = e[g];
        this._addManagedChild(d, a);
      }
  };
  a._addManagedChild = function (b, a) {
    b._off || (this.addChild(b), b instanceof d && (b._synchOffset = a, b.mode == d.INDEPENDENT && (b.autoReset && !this._managed[b.id]) && b._reset()), this._managed[b.id] = 2);
  };
  createjs.MovieClip = d;
  var g = function () {
    throw 'MovieClipPlugin cannot be instantiated.';
  };
  g.priority = 100;
  g.install = function () {
    createjs.Tween.installPlugin(g, ['startPosition']);
  };
  g.init = function (b, a, c) {
    return c;
  };
  g.step = function () {
  };
  g.tween = function (b, a, c, f, e, g) {
    return !(b.target instanceof d) ? c : 1 == g ? e[a] : f[a];
  };
  g.install();
}());
var THREE = { REVISION: '62' };
self.console = self.console || {
  info: function () {
  },
  log: function () {
  },
  debug: function () {
  },
  warn: function () {
  },
  error: function () {
  }
};
String.prototype.trim = String.prototype.trim || function () {
  return this.replace(/^\s+|\s+$/g, '');
};
THREE.extend = function (obj, source) {
  if (Object.keys) {
    var keys = Object.keys(source);
    for (var i = 0, il = keys.length; i < il; i++) {
      var prop = keys[i];
      Object.defineProperty(obj, prop, Object.getOwnPropertyDescriptor(source, prop));
    }
  } else {
    var safeHasOwnProperty = {}.hasOwnProperty;
    for (var prop in source) {
      if (safeHasOwnProperty.call(source, prop)) {
        obj[prop] = source[prop];
      }
    }
  }
  return obj;
};
(function () {
  var lastTime = 0;
  var vendors = [
      'ms',
      'moz',
      'webkit',
      'o'
    ];
  for (var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x) {
    self.requestAnimationFrame = self[vendors[x] + 'RequestAnimationFrame'];
    self.cancelAnimationFrame = self[vendors[x] + 'CancelAnimationFrame'] || self[vendors[x] + 'CancelRequestAnimationFrame'];
  }
  if (self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined) {
    self.requestAnimationFrame = function (callback) {
      var currTime = Date.now(), timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = self.setTimeout(function () {
          callback(currTime + timeToCall);
        }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined) {
    self.cancelAnimationFrame = function (id) {
      self.clearTimeout(id);
    };
  }
}());
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = function () {
};
THREE.CubeReflectionMapping = function () {
};
THREE.CubeRefractionMapping = function () {
};
THREE.SphericalReflectionMapping = function () {
};
THREE.SphericalRefractionMapping = function () {
};
THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.Color = function (value) {
  if (value !== undefined)
    this.set(value);
  return this;
};
THREE.Color.prototype = {
  constructor: THREE.Color,
  r: 1,
  g: 1,
  b: 1,
  set: function (value) {
    if (value instanceof THREE.Color) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }
    return this;
  },
  setHex: function (hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  },
  setRGB: function (r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  },
  setHSL: function (h, s, l) {
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      var hue2rgb = function (p, q, t) {
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 1 / 6)
          return p + (q - p) * 6 * t;
        if (t < 1 / 2)
          return q;
        if (t < 2 / 3)
          return p + (q - p) * 6 * (2 / 3 - t);
        return p;
      };
      var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      var q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    return this;
  },
  setStyle: function (style) {
    if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(style)) {
      var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(style);
      this.r = Math.min(255, parseInt(color[1], 10)) / 255;
      this.g = Math.min(255, parseInt(color[2], 10)) / 255;
      this.b = Math.min(255, parseInt(color[3], 10)) / 255;
      return this;
    }
    if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(style)) {
      var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(style);
      this.r = Math.min(100, parseInt(color[1], 10)) / 100;
      this.g = Math.min(100, parseInt(color[2], 10)) / 100;
      this.b = Math.min(100, parseInt(color[3], 10)) / 100;
      return this;
    }
    if (/^\#([0-9a-f]{6})$/i.test(style)) {
      var color = /^\#([0-9a-f]{6})$/i.exec(style);
      this.setHex(parseInt(color[1], 16));
      return this;
    }
    if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(style)) {
      var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(style);
      this.setHex(parseInt(color[1] + color[1] + color[2] + color[2] + color[3] + color[3], 16));
      return this;
    }
    if (/^(\w+)$/i.test(style)) {
      this.setHex(THREE.ColorKeywords[style]);
      return this;
    }
  },
  copy: function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  },
  copyGammaToLinear: function (color) {
    this.r = color.r * color.r;
    this.g = color.g * color.g;
    this.b = color.b * color.b;
    return this;
  },
  copyLinearToGamma: function (color) {
    this.r = Math.sqrt(color.r);
    this.g = Math.sqrt(color.g);
    this.b = Math.sqrt(color.b);
    return this;
  },
  convertGammaToLinear: function () {
    var r = this.r, g = this.g, b = this.b;
    this.r = r * r;
    this.g = g * g;
    this.b = b * b;
    return this;
  },
  convertLinearToGamma: function () {
    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);
    return this;
  },
  getHex: function () {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function () {
    var hsl = {
        h: 0,
        s: 0,
        l: 0
      };
    return function () {
      var r = this.r, g = this.g, b = this.b;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var hue, saturation;
      var lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        var delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
        }
        hue /= 6;
      }
      hsl.h = hue;
      hsl.s = saturation;
      hsl.l = lightness;
      return hsl;
    };
  }(),
  getStyle: function () {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  },
  offsetHSL: function (h, s, l) {
    var hsl = this.getHSL();
    hsl.h += h;
    hsl.s += s;
    hsl.l += l;
    this.setHSL(hsl.h, hsl.s, hsl.l);
    return this;
  },
  add: function (color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  },
  addColors: function (color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function (s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  },
  multiply: function (color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  },
  multiplyScalar: function (s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  },
  lerp: function (color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  },
  equals: function (c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  },
  fromArray: function (array) {
    this.r = array[0];
    this.g = array[1];
    this.b = array[2];
    return this;
  },
  toArray: function () {
    return [
      this.r,
      this.g,
      this.b
    ];
  },
  clone: function () {
    return new THREE.Color().setRGB(this.r, this.g, this.b);
  }
};
THREE.ColorKeywords = {
  'aliceblue': 15792383,
  'antiquewhite': 16444375,
  'aqua': 65535,
  'aquamarine': 8388564,
  'azure': 15794175,
  'beige': 16119260,
  'bisque': 16770244,
  'black': 0,
  'blanchedalmond': 16772045,
  'blue': 255,
  'blueviolet': 9055202,
  'brown': 10824234,
  'burlywood': 14596231,
  'cadetblue': 6266528,
  'chartreuse': 8388352,
  'chocolate': 13789470,
  'coral': 16744272,
  'cornflowerblue': 6591981,
  'cornsilk': 16775388,
  'crimson': 14423100,
  'cyan': 65535,
  'darkblue': 139,
  'darkcyan': 35723,
  'darkgoldenrod': 12092939,
  'darkgray': 11119017,
  'darkgreen': 25600,
  'darkgrey': 11119017,
  'darkkhaki': 12433259,
  'darkmagenta': 9109643,
  'darkolivegreen': 5597999,
  'darkorange': 16747520,
  'darkorchid': 10040012,
  'darkred': 9109504,
  'darksalmon': 15308410,
  'darkseagreen': 9419919,
  'darkslateblue': 4734347,
  'darkslategray': 3100495,
  'darkslategrey': 3100495,
  'darkturquoise': 52945,
  'darkviolet': 9699539,
  'deeppink': 16716947,
  'deepskyblue': 49151,
  'dimgray': 6908265,
  'dimgrey': 6908265,
  'dodgerblue': 2003199,
  'firebrick': 11674146,
  'floralwhite': 16775920,
  'forestgreen': 2263842,
  'fuchsia': 16711935,
  'gainsboro': 14474460,
  'ghostwhite': 16316671,
  'gold': 16766720,
  'goldenrod': 14329120,
  'gray': 8421504,
  'green': 32768,
  'greenyellow': 11403055,
  'grey': 8421504,
  'honeydew': 15794160,
  'hotpink': 16738740,
  'indianred': 13458524,
  'indigo': 4915330,
  'ivory': 16777200,
  'khaki': 15787660,
  'lavender': 15132410,
  'lavenderblush': 16773365,
  'lawngreen': 8190976,
  'lemonchiffon': 16775885,
  'lightblue': 11393254,
  'lightcoral': 15761536,
  'lightcyan': 14745599,
  'lightgoldenrodyellow': 16448210,
  'lightgray': 13882323,
  'lightgreen': 9498256,
  'lightgrey': 13882323,
  'lightpink': 16758465,
  'lightsalmon': 16752762,
  'lightseagreen': 2142890,
  'lightskyblue': 8900346,
  'lightslategray': 7833753,
  'lightslategrey': 7833753,
  'lightsteelblue': 11584734,
  'lightyellow': 16777184,
  'lime': 65280,
  'limegreen': 3329330,
  'linen': 16445670,
  'magenta': 16711935,
  'maroon': 8388608,
  'mediumaquamarine': 6737322,
  'mediumblue': 205,
  'mediumorchid': 12211667,
  'mediumpurple': 9662683,
  'mediumseagreen': 3978097,
  'mediumslateblue': 8087790,
  'mediumspringgreen': 64154,
  'mediumturquoise': 4772300,
  'mediumvioletred': 13047173,
  'midnightblue': 1644912,
  'mintcream': 16121850,
  'mistyrose': 16770273,
  'moccasin': 16770229,
  'navajowhite': 16768685,
  'navy': 128,
  'oldlace': 16643558,
  'olive': 8421376,
  'olivedrab': 7048739,
  'orange': 16753920,
  'orangered': 16729344,
  'orchid': 14315734,
  'palegoldenrod': 15657130,
  'palegreen': 10025880,
  'paleturquoise': 11529966,
  'palevioletred': 14381203,
  'papayawhip': 16773077,
  'peachpuff': 16767673,
  'peru': 13468991,
  'pink': 16761035,
  'plum': 14524637,
  'powderblue': 11591910,
  'purple': 8388736,
  'red': 16711680,
  'rosybrown': 12357519,
  'royalblue': 4286945,
  'saddlebrown': 9127187,
  'salmon': 16416882,
  'sandybrown': 16032864,
  'seagreen': 3050327,
  'seashell': 16774638,
  'sienna': 10506797,
  'silver': 12632256,
  'skyblue': 8900331,
  'slateblue': 6970061,
  'slategray': 7372944,
  'slategrey': 7372944,
  'snow': 16775930,
  'springgreen': 65407,
  'steelblue': 4620980,
  'tan': 13808780,
  'teal': 32896,
  'thistle': 14204888,
  'tomato': 16737095,
  'turquoise': 4251856,
  'violet': 15631086,
  'wheat': 16113331,
  'white': 16777215,
  'whitesmoke': 16119285,
  'yellow': 16776960,
  'yellowgreen': 10145074
};
THREE.Quaternion = function (x, y, z, w) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = w !== undefined ? w : 1;
};
THREE.Quaternion.prototype = {
  constructor: THREE.Quaternion,
  _x: 0,
  _y: 0,
  _z: 0,
  _w: 0,
  _euler: undefined,
  _updateEuler: function (callback) {
    if (this._euler !== undefined) {
      this._euler.setFromQuaternion(this, undefined, false);
    }
  },
  get x() {
    return this._x;
  },
  set x(value) {
    this._x = value;
    this._updateEuler();
  },
  get y() {
    return this._y;
  },
  set y(value) {
    this._y = value;
    this._updateEuler();
  },
  get z() {
    return this._z;
  },
  set z(value) {
    this._z = value;
    this._updateEuler();
  },
  get w() {
    return this._w;
  },
  set w(value) {
    this._w = value;
    this._updateEuler();
  },
  set: function (x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._updateEuler();
    return this;
  },
  copy: function (quaternion) {
    this._x = quaternion._x;
    this._y = quaternion._y;
    this._z = quaternion._z;
    this._w = quaternion._w;
    this._updateEuler();
    return this;
  },
  setFromEuler: function (euler, update) {
    if (euler instanceof THREE.Euler === false) {
      throw new Error('ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    }
    var c1 = Math.cos(euler._x / 2);
    var c2 = Math.cos(euler._y / 2);
    var c3 = Math.cos(euler._z / 2);
    var s1 = Math.sin(euler._x / 2);
    var s2 = Math.sin(euler._y / 2);
    var s3 = Math.sin(euler._z / 2);
    if (euler.order === 'XYZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (euler.order === 'YXZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (euler.order === 'ZXY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (euler.order === 'ZYX') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (euler.order === 'YZX') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (euler.order === 'XZY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    }
    if (update !== false)
      this._updateEuler();
    return this;
  },
  setFromAxisAngle: function (axis, angle) {
    var halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._updateEuler();
    return this;
  },
  setFromRotationMatrix: function (m) {
    var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._updateEuler();
    return this;
  },
  inverse: function () {
    this.conjugate().normalize();
    return this;
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._updateEuler();
    return this;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    var l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    return this;
  },
  multiply: function (q, p) {
    if (p !== undefined) {
      console.warn('DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  },
  multiplyQuaternions: function (a, b) {
    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._updateEuler();
    return this;
  },
  multiplyVector3: function (vector) {
    console.warn('DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return vector.applyQuaternion(this);
  },
  slerp: function (qb, t) {
    var x = this._x, y = this._y, z = this._z, w = this._w;
    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    var halfTheta = Math.acos(cosHalfTheta);
    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 0.001) {
      this._w = 0.5 * (w + this._w);
      this._x = 0.5 * (x + this._x);
      this._y = 0.5 * (y + this._y);
      this._z = 0.5 * (z + this._z);
      return this;
    }
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._updateEuler();
    return this;
  },
  equals: function (quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function (array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    this._w = array[3];
    this._updateEuler();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._w
    ];
  },
  clone: function () {
    return new THREE.Quaternion(this._x, this._y, this._z, this._w);
  }
};
THREE.Quaternion.slerp = function (qa, qb, qm, t) {
  return qm.copy(qa).slerp(qb, t);
};
THREE.Vector2 = function (x, y) {
  this.x = x || 0;
  this.y = y || 0;
};
THREE.Vector2.prototype = {
  constructor: THREE.Vector2,
  set: function (x, y) {
    this.x = x;
    this.y = y;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
    case 0:
      this.x = value;
      break;
    case 1:
      this.y = value;
      break;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  getComponent: function (index) {
    switch (index) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiplyScalar: function (s) {
    this.x *= s;
    this.y *= s;
    return this;
  },
  divideScalar: function (scalar) {
    if (scalar !== 0) {
      var invScalar = 1 / scalar;
      this.x *= invScalar;
      this.y *= invScalar;
    } else {
      this.x = 0;
      this.y = 0;
    }
    return this;
  },
  min: function (v) {
    if (this.x > v.x) {
      this.x = v.x;
    }
    if (this.y > v.y) {
      this.y = v.y;
    }
    return this;
  },
  max: function (v) {
    if (this.x < v.x) {
      this.x = v.x;
    }
    if (this.y < v.y) {
      this.y = v.y;
    }
    return this;
  },
  clamp: function (min, max) {
    if (this.x < min.x) {
      this.x = min.x;
    } else if (this.x > max.x) {
      this.x = max.x;
    }
    if (this.y < min.y) {
      this.y = min.y;
    } else if (this.y > max.y) {
      this.y = max.y;
    }
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  },
  setLength: function (l) {
    var oldLength = this.length();
    if (oldLength !== 0 && l !== oldLength) {
      this.multiplyScalar(l / oldLength);
    }
    return this;
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y;
  },
  fromArray: function (array) {
    this.x = array[0];
    this.y = array[1];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y
    ];
  },
  clone: function () {
    return new THREE.Vector2(this.x, this.y);
  }
};
THREE.Vector3 = function (x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
};
THREE.Vector3.prototype = {
  constructor: THREE.Vector3,
  set: function (x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
    case 0:
      this.x = value;
      break;
    case 1:
      this.y = value;
      break;
    case 2:
      this.z = value;
      break;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  getComponent: function (index) {
    switch (index) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyMatrix3: function (m) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
    return this;
  },
  applyProjection: function (m) {
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
    return this;
  },
  applyQuaternion: function (q) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  transformDirection: function (m) {
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    this.normalize();
    return this;
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  },
  divideScalar: function (scalar) {
    if (scalar !== 0) {
      var invScalar = 1 / scalar;
      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }
    return this;
  },
  min: function (v) {
    if (this.x > v.x) {
      this.x = v.x;
    }
    if (this.y > v.y) {
      this.y = v.y;
    }
    if (this.z > v.z) {
      this.z = v.z;
    }
    return this;
  },
  max: function (v) {
    if (this.x < v.x) {
      this.x = v.x;
    }
    if (this.y < v.y) {
      this.y = v.y;
    }
    if (this.z < v.z) {
      this.z = v.z;
    }
    return this;
  },
  clamp: function (min, max) {
    if (this.x < min.x) {
      this.x = min.x;
    } else if (this.x > max.x) {
      this.x = max.x;
    }
    if (this.y < min.y) {
      this.y = min.y;
    } else if (this.y > max.y) {
      this.y = max.y;
    }
    if (this.z < min.z) {
      this.z = min.z;
    } else if (this.z > max.z) {
      this.z = max.z;
    }
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (l) {
    var oldLength = this.length();
    if (oldLength !== 0 && l !== oldLength) {
      this.multiplyScalar(l / oldLength);
    }
    return this;
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  },
  cross: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }
    var x = this.x, y = this.y, z = this.z;
    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;
    return this;
  },
  crossVectors: function (a, b) {
    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  angleTo: function (v) {
    var theta = this.dot(v) / (this.length() * v.length());
    return Math.acos(THREE.Math.clamp(theta, -1, 1));
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  },
  setEulerFromRotationMatrix: function (m, order) {
    console.error('REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.');
  },
  setEulerFromQuaternion: function (q, order) {
    console.error('REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.');
  },
  getPositionFromMatrix: function (m) {
    this.x = m.elements[12];
    this.y = m.elements[13];
    this.z = m.elements[14];
    return this;
  },
  getScaleFromMatrix: function (m) {
    var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
    var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
    var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  getColumnFromMatrix: function (index, matrix) {
    var offset = index * 4;
    var me = matrix.elements;
    this.x = me[offset];
    this.y = me[offset + 1];
    this.z = me[offset + 2];
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  },
  fromArray: function (array) {
    this.x = array[0];
    this.y = array[1];
    this.z = array[2];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z
    ];
  },
  clone: function () {
    return new THREE.Vector3(this.x, this.y, this.z);
  }
};
THREE.extend(THREE.Vector3.prototype, {
  applyEuler: function () {
    var quaternion = new THREE.Quaternion();
    return function (euler) {
      if (euler instanceof THREE.Euler === false) {
        console.error('ERROR: Vector3\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
      }
      this.applyQuaternion(quaternion.setFromEuler(euler));
      return this;
    };
  }(),
  applyAxisAngle: function () {
    var quaternion = new THREE.Quaternion();
    return function (axis, angle) {
      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
      return this;
    };
  }(),
  projectOnVector: function () {
    var v1 = new THREE.Vector3();
    return function (vector) {
      v1.copy(vector).normalize();
      var d = this.dot(v1);
      return this.copy(v1).multiplyScalar(d);
    };
  }(),
  projectOnPlane: function () {
    var v1 = new THREE.Vector3();
    return function (planeNormal) {
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    };
  }(),
  reflect: function () {
    var v1 = new THREE.Vector3();
    return function (vector) {
      v1.copy(this).projectOnVector(vector).multiplyScalar(2);
      return this.subVectors(v1, this);
    };
  }()
});
THREE.Vector4 = function (x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== undefined ? w : 1;
};
THREE.Vector4.prototype = {
  constructor: THREE.Vector4,
  set: function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setW: function (w) {
    this.w = w;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
    case 0:
      this.x = value;
      break;
    case 1:
      this.y = value;
      break;
    case 2:
      this.z = value;
      break;
    case 3:
      this.w = value;
      break;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  getComponent: function (index) {
    switch (index) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    case 3:
      return this.w;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var w = this.w;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  },
  divideScalar: function (scalar) {
    if (scalar !== 0) {
      var invScalar = 1 / scalar;
      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;
      this.w *= invScalar;
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    }
    return this;
  },
  setAxisAngleFromQuaternion: function (q) {
    this.w = 2 * Math.acos(q.w);
    var s = Math.sqrt(1 - q.w * q.w);
    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  },
  setAxisAngleFromRotationMatrix: function (m) {
    var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 0.001)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function (v) {
    if (this.x > v.x) {
      this.x = v.x;
    }
    if (this.y > v.y) {
      this.y = v.y;
    }
    if (this.z > v.z) {
      this.z = v.z;
    }
    if (this.w > v.w) {
      this.w = v.w;
    }
    return this;
  },
  max: function (v) {
    if (this.x < v.x) {
      this.x = v.x;
    }
    if (this.y < v.y) {
      this.y = v.y;
    }
    if (this.z < v.z) {
      this.z = v.z;
    }
    if (this.w < v.w) {
      this.w = v.w;
    }
    return this;
  },
  clamp: function (min, max) {
    if (this.x < min.x) {
      this.x = min.x;
    } else if (this.x > max.x) {
      this.x = max.x;
    }
    if (this.y < min.y) {
      this.y = min.y;
    } else if (this.y > max.y) {
      this.y = max.y;
    }
    if (this.z < min.z) {
      this.z = min.z;
    } else if (this.z > max.z) {
      this.z = max.z;
    }
    if (this.w < min.w) {
      this.w = min.w;
    } else if (this.w > max.w) {
      this.w = max.w;
    }
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (l) {
    var oldLength = this.length();
    if (oldLength !== 0 && l !== oldLength) {
      this.multiplyScalar(l / oldLength);
    }
    return this;
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },
  fromArray: function (array) {
    this.x = array[0];
    this.y = array[1];
    this.z = array[2];
    this.w = array[3];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z,
      this.w
    ];
  },
  clone: function () {
    return new THREE.Vector4(this.x, this.y, this.z, this.w);
  }
};
THREE.Euler = function (x, y, z, order) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || THREE.Euler.DefaultOrder;
};
THREE.Euler.RotationOrders = [
  'XYZ',
  'YZX',
  'ZXY',
  'XZY',
  'YXZ',
  'ZYX'
];
THREE.Euler.DefaultOrder = 'XYZ';
THREE.Euler.prototype = {
  constructor: THREE.Euler,
  _x: 0,
  _y: 0,
  _z: 0,
  _order: THREE.Euler.DefaultOrder,
  _quaternion: undefined,
  _updateQuaternion: function () {
    if (this._quaternion !== undefined) {
      this._quaternion.setFromEuler(this, false);
    }
  },
  get x() {
    return this._x;
  },
  set x(value) {
    this._x = value;
    this._updateQuaternion();
  },
  get y() {
    return this._y;
  },
  set y(value) {
    this._y = value;
    this._updateQuaternion();
  },
  get z() {
    return this._z;
  },
  set z(value) {
    this._z = value;
    this._updateQuaternion();
  },
  get order() {
    return this._order;
  },
  set order(value) {
    this._order = value;
    this._updateQuaternion();
  },
  set: function (x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this._updateQuaternion();
    return this;
  },
  copy: function (euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._updateQuaternion();
    return this;
  },
  setFromRotationMatrix: function (m, order) {
    function clamp(x) {
      return Math.min(Math.max(x, -1), 1);
    }
    var te = m.elements;
    var m11 = te[0], m12 = te[4], m13 = te[8];
    var m21 = te[1], m22 = te[5], m23 = te[9];
    var m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    if (order === 'XYZ') {
      this._y = Math.asin(clamp(m13));
      if (Math.abs(m13) < 0.99999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === 'YXZ') {
      this._x = Math.asin(-clamp(m23));
      if (Math.abs(m23) < 0.99999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === 'ZXY') {
      this._x = Math.asin(clamp(m32));
      if (Math.abs(m32) < 0.99999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === 'ZYX') {
      this._y = Math.asin(-clamp(m31));
      if (Math.abs(m31) < 0.99999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === 'YZX') {
      this._z = Math.asin(clamp(m21));
      if (Math.abs(m21) < 0.99999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === 'XZY') {
      this._z = Math.asin(-clamp(m12));
      if (Math.abs(m12) < 0.99999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {
      console.warn('WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order);
    }
    this._order = order;
    this._updateQuaternion();
    return this;
  },
  setFromQuaternion: function (q, order, update) {
    function clamp(x) {
      return Math.min(Math.max(x, -1), 1);
    }
    var sqx = q.x * q.x;
    var sqy = q.y * q.y;
    var sqz = q.z * q.z;
    var sqw = q.w * q.w;
    order = order || this._order;
    if (order === 'XYZ') {
      this._x = Math.atan2(2 * (q.x * q.w - q.y * q.z), sqw - sqx - sqy + sqz);
      this._y = Math.asin(clamp(2 * (q.x * q.z + q.y * q.w)));
      this._z = Math.atan2(2 * (q.z * q.w - q.x * q.y), sqw + sqx - sqy - sqz);
    } else if (order === 'YXZ') {
      this._x = Math.asin(clamp(2 * (q.x * q.w - q.y * q.z)));
      this._y = Math.atan2(2 * (q.x * q.z + q.y * q.w), sqw - sqx - sqy + sqz);
      this._z = Math.atan2(2 * (q.x * q.y + q.z * q.w), sqw - sqx + sqy - sqz);
    } else if (order === 'ZXY') {
      this._x = Math.asin(clamp(2 * (q.x * q.w + q.y * q.z)));
      this._y = Math.atan2(2 * (q.y * q.w - q.z * q.x), sqw - sqx - sqy + sqz);
      this._z = Math.atan2(2 * (q.z * q.w - q.x * q.y), sqw - sqx + sqy - sqz);
    } else if (order === 'ZYX') {
      this._x = Math.atan2(2 * (q.x * q.w + q.z * q.y), sqw - sqx - sqy + sqz);
      this._y = Math.asin(clamp(2 * (q.y * q.w - q.x * q.z)));
      this._z = Math.atan2(2 * (q.x * q.y + q.z * q.w), sqw + sqx - sqy - sqz);
    } else if (order === 'YZX') {
      this._x = Math.atan2(2 * (q.x * q.w - q.z * q.y), sqw - sqx + sqy - sqz);
      this._y = Math.atan2(2 * (q.y * q.w - q.x * q.z), sqw + sqx - sqy - sqz);
      this._z = Math.asin(clamp(2 * (q.x * q.y + q.z * q.w)));
    } else if (order === 'XZY') {
      this._x = Math.atan2(2 * (q.x * q.w + q.y * q.z), sqw - sqx + sqy - sqz);
      this._y = Math.atan2(2 * (q.x * q.z + q.y * q.w), sqw + sqx - sqy - sqz);
      this._z = Math.asin(clamp(2 * (q.z * q.w - q.x * q.y)));
    } else {
      console.warn('WARNING: Euler.setFromQuaternion() given unsupported order: ' + order);
    }
    this._order = order;
    if (update !== false)
      this._updateQuaternion();
    return this;
  },
  reorder: function () {
    var q = new THREE.Quaternion();
    return function (newOrder) {
      q.setFromEuler(this);
      this.setFromQuaternion(q, newOrder);
    };
  }(),
  fromArray: function (array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined)
      this._order = array[3];
    this._updateQuaternion();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._order
    ];
  },
  equals: function (euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  clone: function () {
    return new THREE.Euler(this._x, this._y, this._z, this._order);
  }
};
THREE.Line3 = function (start, end) {
  this.start = start !== undefined ? start : new THREE.Vector3();
  this.end = end !== undefined ? end : new THREE.Vector3();
};
THREE.Line3.prototype = {
  constructor: THREE.Line3,
  set: function (start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  },
  copy: function (line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  },
  center: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (t, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return this.delta(result).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function () {
    var startP = new THREE.Vector3();
    var startEnd = new THREE.Vector3();
    return function (point, clampToLine) {
      startP.subVectors(point, this.start);
      startEnd.subVectors(this.end, this.start);
      var startEnd2 = startEnd.dot(startEnd);
      var startEnd_startP = startEnd.dot(startP);
      var t = startEnd_startP / startEnd2;
      if (clampToLine) {
        t = THREE.Math.clamp(t, 0, 1);
      }
      return t;
    };
  }(),
  closestPointToPoint: function (point, clampToLine, optionalTarget) {
    var t = this.closestPointToPointParameter(point, clampToLine);
    var result = optionalTarget || new THREE.Vector3();
    return this.delta(result).multiplyScalar(t).add(this.start);
  },
  applyMatrix4: function (matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  },
  equals: function (line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  },
  clone: function () {
    return new THREE.Line3().copy(this);
  }
};
THREE.Box2 = function (min, max) {
  this.min = min !== undefined ? min : new THREE.Vector2(Infinity, Infinity);
  this.max = max !== undefined ? max : new THREE.Vector2(-Infinity, -Infinity);
};
THREE.Box2.prototype = {
  constructor: THREE.Box2,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromPoints: function (points) {
    if (points.length > 0) {
      var point = points[0];
      this.min.copy(point);
      this.max.copy(point);
      for (var i = 1, il = points.length; i < il; i++) {
        point = points[i];
        if (point.x < this.min.x) {
          this.min.x = point.x;
        } else if (point.x > this.max.x) {
          this.max.x = point.x;
        }
        if (point.y < this.min.y) {
          this.min.y = point.y;
        } else if (point.y > this.max.y) {
          this.max.y = point.y;
        }
      }
    } else {
      this.makeEmpty();
    }
    return this;
  },
  setFromCenterAndSize: function () {
    var v1 = new THREE.Vector2();
    return function (center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  center: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector2();
    return result.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector2();
    return result.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function (point) {
    if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
      return false;
    }
    return true;
  },
  containsBox: function (box) {
    if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y) {
      return true;
    }
    return false;
  },
  getParameter: function (point) {
    return new THREE.Vector2((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  },
  isIntersectionBox: function (box) {
    if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
      return false;
    }
    return true;
  },
  clampPoint: function (point, optionalTarget) {
    var result = optionalTarget || new THREE.Vector2();
    return result.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var v1 = new THREE.Vector2();
    return function (point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box2().copy(this);
  }
};
THREE.Box3 = function (min, max) {
  this.min = min !== undefined ? min : new THREE.Vector3(Infinity, Infinity, Infinity);
  this.max = max !== undefined ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
};
THREE.Box3.prototype = {
  constructor: THREE.Box3,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  addPoint: function (point) {
    if (point.x < this.min.x) {
      this.min.x = point.x;
    } else if (point.x > this.max.x) {
      this.max.x = point.x;
    }
    if (point.y < this.min.y) {
      this.min.y = point.y;
    } else if (point.y > this.max.y) {
      this.max.y = point.y;
    }
    if (point.z < this.min.z) {
      this.min.z = point.z;
    } else if (point.z > this.max.z) {
      this.max.z = point.z;
    }
  },
  setFromPoints: function (points) {
    if (points.length > 0) {
      var point = points[0];
      this.min.copy(point);
      this.max.copy(point);
      for (var i = 1, il = points.length; i < il; i++) {
        this.addPoint(points[i]);
      }
    } else {
      this.makeEmpty();
    }
    return this;
  },
  setFromCenterAndSize: function () {
    var v1 = new THREE.Vector3();
    return function (center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  setFromObject: function () {
    var v1 = new THREE.Vector3();
    return function (object) {
      var scope = this;
      object.updateMatrixWorld(true);
      this.makeEmpty();
      object.traverse(function (node) {
        if (node.geometry !== undefined && node.geometry.vertices !== undefined) {
          var vertices = node.geometry.vertices;
          for (var i = 0, il = vertices.length; i < il; i++) {
            v1.copy(vertices[i]);
            v1.applyMatrix4(node.matrixWorld);
            scope.expandByPoint(v1);
          }
        }
      });
      return this;
    };
  }(),
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  center: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function (point) {
    if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
      return false;
    }
    return true;
  },
  containsBox: function (box) {
    if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z) {
      return true;
    }
    return false;
  },
  getParameter: function (point) {
    return new THREE.Vector3((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },
  isIntersectionBox: function (box) {
    if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
      return false;
    }
    return true;
  },
  clampPoint: function (point, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var v1 = new THREE.Vector3();
    return function (point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  getBoundingSphere: function () {
    var v1 = new THREE.Vector3();
    return function (optionalTarget) {
      var result = optionalTarget || new THREE.Sphere();
      result.center = this.center();
      result.radius = this.size(v1).length() * 0.5;
      return result;
    };
  }(),
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function () {
    var points = [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
      ];
    return function (matrix) {
      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.makeEmpty();
      this.setFromPoints(points);
      return this;
    };
  }(),
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box3().copy(this);
  }
};
THREE.Matrix3 = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
  this.elements = new Float32Array(9);
  this.set(n11 !== undefined ? n11 : 1, n12 || 0, n13 || 0, n21 || 0, n22 !== undefined ? n22 : 1, n23 || 0, n31 || 0, n32 || 0, n33 !== undefined ? n33 : 1);
};
THREE.Matrix3.prototype = {
  constructor: THREE.Matrix3,
  set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    var te = this.elements;
    te[0] = n11;
    te[3] = n12;
    te[6] = n13;
    te[1] = n21;
    te[4] = n22;
    te[7] = n23;
    te[2] = n31;
    te[5] = n32;
    te[8] = n33;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  copy: function (m) {
    var me = m.elements;
    this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
    return this;
  },
  multiplyVector3: function (vector) {
    console.warn('DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function () {
    var v1 = new THREE.Vector3();
    return function (a) {
      for (var i = 0, il = a.length; i < il; i += 3) {
        v1.x = a[i];
        v1.y = a[i + 1];
        v1.z = a[i + 2];
        v1.applyMatrix3(this);
        a[i] = v1.x;
        a[i + 1] = v1.y;
        a[i + 2] = v1.z;
      }
      return a;
    };
  }(),
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  },
  determinant: function () {
    var te = this.elements;
    var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },
  getInverse: function (matrix, throwOnInvertible) {
    var me = matrix.elements;
    var te = this.elements;
    te[0] = me[10] * me[5] - me[6] * me[9];
    te[1] = -me[10] * me[1] + me[2] * me[9];
    te[2] = me[6] * me[1] - me[2] * me[5];
    te[3] = -me[10] * me[4] + me[6] * me[8];
    te[4] = me[10] * me[0] - me[2] * me[8];
    te[5] = -me[6] * me[0] + me[2] * me[4];
    te[6] = me[9] * me[4] - me[5] * me[8];
    te[7] = -me[9] * me[0] + me[1] * me[8];
    te[8] = me[5] * me[0] - me[1] * me[4];
    var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
    if (det === 0) {
      var msg = 'Matrix3.getInverse(): can\'t invert matrix, determinant is 0';
      if (throwOnInvertible || false) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / det);
    return this;
  },
  transpose: function () {
    var tmp, m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  },
  getNormalMatrix: function (m) {
    this.getInverse(m).transpose();
    return this;
  },
  transposeIntoArray: function (r) {
    var m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  },
  clone: function () {
    var te = this.elements;
    return new THREE.Matrix3(te[0], te[3], te[6], te[1], te[4], te[7], te[2], te[5], te[8]);
  }
};
THREE.Matrix4 = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
  this.elements = new Float32Array(16);
  var te = this.elements;
  te[0] = n11 !== undefined ? n11 : 1;
  te[4] = n12 || 0;
  te[8] = n13 || 0;
  te[12] = n14 || 0;
  te[1] = n21 || 0;
  te[5] = n22 !== undefined ? n22 : 1;
  te[9] = n23 || 0;
  te[13] = n24 || 0;
  te[2] = n31 || 0;
  te[6] = n32 || 0;
  te[10] = n33 !== undefined ? n33 : 1;
  te[14] = n34 || 0;
  te[3] = n41 || 0;
  te[7] = n42 || 0;
  te[11] = n43 || 0;
  te[15] = n44 !== undefined ? n44 : 1;
};
THREE.Matrix4.prototype = {
  constructor: THREE.Matrix4,
  set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    var te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  copy: function (m) {
    this.elements.set(m.elements);
    return this;
  },
  extractPosition: function (m) {
    console.warn('DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(m);
  },
  copyPosition: function (m) {
    var te = this.elements;
    var me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractRotation: function () {
    var v1 = new THREE.Vector3();
    return function (m) {
      var te = this.elements;
      var me = m.elements;
      var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();
      var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();
      var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      return this;
    };
  }(),
  makeRotationFromEuler: function (euler) {
    if (euler instanceof THREE.Euler === false) {
      console.error('ERROR: Matrix\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    }
    var te = this.elements;
    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos(x), b = Math.sin(x);
    var c = Math.cos(y), d = Math.sin(y);
    var e = Math.cos(z), f = Math.sin(z);
    if (euler.order === 'XYZ') {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  setRotationFromQuaternion: function (q) {
    console.warn('DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.');
    return this.makeRotationFromQuaternion(q);
  },
  makeRotationFromQuaternion: function (q) {
    var te = this.elements;
    var x = q.x, y = q.y, z = q.z, w = q.w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;
    te[0] = 1 - (yy + zz);
    te[4] = xy - wz;
    te[8] = xz + wy;
    te[1] = xy + wz;
    te[5] = 1 - (xx + zz);
    te[9] = yz - wx;
    te[2] = xz - wy;
    te[6] = yz + wx;
    te[10] = 1 - (xx + yy);
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  lookAt: function () {
    var x = new THREE.Vector3();
    var y = new THREE.Vector3();
    var z = new THREE.Vector3();
    return function (eye, target, up) {
      var te = this.elements;
      z.subVectors(eye, target).normalize();
      if (z.length() === 0) {
        z.z = 1;
      }
      x.crossVectors(up, z).normalize();
      if (x.length() === 0) {
        z.x += 0.0001;
        x.crossVectors(up, z).normalize();
      }
      y.crossVectors(z, x);
      te[0] = x.x;
      te[4] = y.x;
      te[8] = z.x;
      te[1] = x.y;
      te[5] = y.y;
      te[9] = z.y;
      te[2] = x.z;
      te[6] = y.z;
      te[10] = z.z;
      return this;
    };
  }(),
  multiply: function (m, n) {
    if (n !== undefined) {
      console.warn('DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }
    return this.multiplyMatrices(this, m);
  },
  multiplyMatrices: function (a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyToArray: function (a, b, r) {
    var te = this.elements;
    this.multiplyMatrices(a, b);
    r[0] = te[0];
    r[1] = te[1];
    r[2] = te[2];
    r[3] = te[3];
    r[4] = te[4];
    r[5] = te[5];
    r[6] = te[6];
    r[7] = te[7];
    r[8] = te[8];
    r[9] = te[9];
    r[10] = te[10];
    r[11] = te[11];
    r[12] = te[12];
    r[13] = te[13];
    r[14] = te[14];
    r[15] = te[15];
    return this;
  },
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  },
  multiplyVector3: function (vector) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
    return vector.applyProjection(this);
  },
  multiplyVector4: function (vector) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function () {
    var v1 = new THREE.Vector3();
    return function (a) {
      for (var i = 0, il = a.length; i < il; i += 3) {
        v1.x = a[i];
        v1.y = a[i + 1];
        v1.z = a[i + 2];
        v1.applyProjection(this);
        a[i] = v1.x;
        a[i + 1] = v1.y;
        a[i + 2] = v1.z;
      }
      return a;
    };
  }(),
  rotateAxis: function (v) {
    console.warn('DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    v.transformDirection(this);
  },
  crossVector: function (vector) {
    console.warn('DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  determinant: function () {
    var te = this.elements;
    var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function () {
    var te = this.elements;
    var tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  },
  flattenToArray: function (flat) {
    var te = this.elements;
    flat[0] = te[0];
    flat[1] = te[1];
    flat[2] = te[2];
    flat[3] = te[3];
    flat[4] = te[4];
    flat[5] = te[5];
    flat[6] = te[6];
    flat[7] = te[7];
    flat[8] = te[8];
    flat[9] = te[9];
    flat[10] = te[10];
    flat[11] = te[11];
    flat[12] = te[12];
    flat[13] = te[13];
    flat[14] = te[14];
    flat[15] = te[15];
    return flat;
  },
  flattenToArrayOffset: function (flat, offset) {
    var te = this.elements;
    flat[offset] = te[0];
    flat[offset + 1] = te[1];
    flat[offset + 2] = te[2];
    flat[offset + 3] = te[3];
    flat[offset + 4] = te[4];
    flat[offset + 5] = te[5];
    flat[offset + 6] = te[6];
    flat[offset + 7] = te[7];
    flat[offset + 8] = te[8];
    flat[offset + 9] = te[9];
    flat[offset + 10] = te[10];
    flat[offset + 11] = te[11];
    flat[offset + 12] = te[12];
    flat[offset + 13] = te[13];
    flat[offset + 14] = te[14];
    flat[offset + 15] = te[15];
    return flat;
  },
  getPosition: function () {
    var v1 = new THREE.Vector3();
    return function () {
      console.warn('DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.');
      var te = this.elements;
      return v1.set(te[12], te[13], te[14]);
    };
  }(),
  setPosition: function (v) {
    var te = this.elements;
    te[12] = v.x;
    te[13] = v.y;
    te[14] = v.z;
    return this;
  },
  getInverse: function (m, throwOnInvertible) {
    var te = this.elements;
    var me = m.elements;
    var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
    var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
    var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
    var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];
    te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
    te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
    te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
    te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
    te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
    te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
    te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
    te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
    te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
    te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
    te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
    te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
    var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
    if (det == 0) {
      var msg = 'Matrix4.getInverse(): can\'t invert matrix, determinant is 0';
      if (throwOnInvertible || false) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / det);
    return this;
  },
  translate: function (v) {
    console.warn('DEPRECATED: Matrix4\'s .translate() has been removed.');
  },
  rotateX: function (angle) {
    console.warn('DEPRECATED: Matrix4\'s .rotateX() has been removed.');
  },
  rotateY: function (angle) {
    console.warn('DEPRECATED: Matrix4\'s .rotateY() has been removed.');
  },
  rotateZ: function (angle) {
    console.warn('DEPRECATED: Matrix4\'s .rotateZ() has been removed.');
  },
  rotateByAxis: function (axis, angle) {
    console.warn('DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');
  },
  scale: function (v) {
    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  },
  getMaxScaleOnAxis: function () {
    var te = this.elements;
    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));
  },
  makeTranslation: function (x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (axis, angle) {
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (position, quaternion, scale) {
    this.makeRotationFromQuaternion(quaternion);
    this.scale(scale);
    this.setPosition(position);
    return this;
  },
  decompose: function () {
    var vector = new THREE.Vector3();
    var matrix = new THREE.Matrix4();
    return function (position, quaternion, scale) {
      var te = this.elements;
      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length();
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      matrix.elements.set(this.elements);
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;
      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;
      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(matrix);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    };
  }(),
  makeFrustum: function (left, right, bottom, top, near, far) {
    var te = this.elements;
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makePerspective: function (fov, aspect, near, far) {
    var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));
    var ymin = -ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;
    return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
  },
  makeOrthographic: function (left, right, top, bottom, near, far) {
    var te = this.elements;
    var w = right - left;
    var h = top - bottom;
    var p = far - near;
    var x = (right + left) / w;
    var y = (top + bottom) / h;
    var z = (far + near) / p;
    te[0] = 2 / w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 / h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 / p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  fromArray: function (array) {
    this.elements.set(array);
    return this;
  },
  toArray: function () {
    var te = this.elements;
    return [
      te[0],
      te[1],
      te[2],
      te[3],
      te[4],
      te[5],
      te[6],
      te[7],
      te[8],
      te[9],
      te[10],
      te[11],
      te[12],
      te[13],
      te[14],
      te[15]
    ];
  },
  clone: function () {
    var te = this.elements;
    return new THREE.Matrix4(te[0], te[4], te[8], te[12], te[1], te[5], te[9], te[13], te[2], te[6], te[10], te[14], te[3], te[7], te[11], te[15]);
  }
};
THREE.Ray = function (origin, direction) {
  this.origin = origin !== undefined ? origin : new THREE.Vector3();
  this.direction = direction !== undefined ? direction : new THREE.Vector3();
};
THREE.Ray.prototype = {
  constructor: THREE.Ray,
  set: function (origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  copy: function (ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function (t, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  recast: function () {
    var v1 = new THREE.Vector3();
    return function (t) {
      this.origin.copy(this.at(t, v1));
      return this;
    };
  }(),
  closestPointToPoint: function (point, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    result.subVectors(point, this.origin);
    var directionDistance = result.dot(this.direction);
    if (directionDistance < 0) {
      return result.copy(this.origin);
    }
    return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function () {
    var v1 = new THREE.Vector3();
    return function (point) {
      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceTo(point);
      }
      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return v1.distanceTo(point);
    };
  }(),
  distanceSqToSegment: function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    var segCenter = v0.clone().add(v1).multiplyScalar(0.5);
    var segDir = v1.clone().sub(v0).normalize();
    var segExtent = v0.distanceTo(v1) * 0.5;
    var diff = this.origin.clone().sub(segCenter);
    var a01 = -this.direction.dot(segDir);
    var b0 = diff.dot(this.direction);
    var b1 = -diff.dot(segDir);
    var c = diff.lengthSq();
    var det = Math.abs(1 - a01 * a01);
    var s0, s1, sqrDist, extDet;
    if (det >= 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            var invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction.clone().multiplyScalar(s0).add(this.origin));
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(segDir.clone().multiplyScalar(s1).add(segCenter));
    }
    return sqrDist;
  },
  isIntersectionSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) <= sphere.radius;
  },
  isIntersectionPlane: function (plane) {
    var distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    var denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  },
  distanceToPlane: function (plane) {
    var denominator = plane.normal.dot(this.direction);
    if (denominator == 0) {
      if (plane.distanceToPoint(this.origin) == 0) {
        return 0;
      }
      return null;
    }
    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  },
  intersectPlane: function (plane, optionalTarget) {
    var t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, optionalTarget);
  },
  isIntersectionBox: function () {
    var v = new THREE.Vector3();
    return function (box) {
      return this.intersectBox(box, v) !== null;
    };
  }(),
  intersectBox: function (box, optionalTarget) {
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    var origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
  },
  intersectTriangle: function () {
    var diff = new THREE.Vector3();
    var edge1 = new THREE.Vector3();
    var edge2 = new THREE.Vector3();
    var normal = new THREE.Vector3();
    return function (a, b, c, backfaceCulling, optionalTarget) {
      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal.crossVectors(edge1, edge2);
      var DdN = this.direction.dot(normal);
      var sign;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      var QdN = -sign * diff.dot(normal);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, optionalTarget);
    };
  }(),
  applyMatrix4: function (matrix4) {
    this.direction.add(this.origin).applyMatrix4(matrix4);
    this.origin.applyMatrix4(matrix4);
    this.direction.sub(this.origin);
    this.direction.normalize();
    return this;
  },
  equals: function (ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  },
  clone: function () {
    return new THREE.Ray().copy(this);
  }
};
THREE.Sphere = function (center, radius) {
  this.center = center !== undefined ? center : new THREE.Vector3();
  this.radius = radius !== undefined ? radius : 0;
};
THREE.Sphere.prototype = {
  constructor: THREE.Sphere,
  set: function (center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  },
  setFromPoints: function () {
    var box = new THREE.Box3();
    return function (points, optionalCenter) {
      var center = this.center;
      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        box.setFromPoints(points).center(center);
      }
      var maxRadiusSq = 0;
      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    };
  }(),
  copy: function (sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  empty: function () {
    return this.radius <= 0;
  },
  containsPoint: function (point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  clampPoint: function (point, optionalTarget) {
    var deltaLengthSq = this.center.distanceToSquared(point);
    var result = optionalTarget || new THREE.Vector3();
    result.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      result.sub(this.center).normalize();
      result.multiplyScalar(this.radius).add(this.center);
    }
    return result;
  },
  getBoundingBox: function (optionalTarget) {
    var box = optionalTarget || new THREE.Box3();
    box.set(this.center, this.center);
    box.expandByScalar(this.radius);
    return box;
  },
  applyMatrix4: function (matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  },
  translate: function (offset) {
    this.center.add(offset);
    return this;
  },
  equals: function (sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  },
  clone: function () {
    return new THREE.Sphere().copy(this);
  }
};
THREE.Frustum = function (p0, p1, p2, p3, p4, p5) {
  this.planes = [
    p0 !== undefined ? p0 : new THREE.Plane(),
    p1 !== undefined ? p1 : new THREE.Plane(),
    p2 !== undefined ? p2 : new THREE.Plane(),
    p3 !== undefined ? p3 : new THREE.Plane(),
    p4 !== undefined ? p4 : new THREE.Plane(),
    p5 !== undefined ? p5 : new THREE.Plane()
  ];
};
THREE.Frustum.prototype = {
  constructor: THREE.Frustum,
  set: function (p0, p1, p2, p3, p4, p5) {
    var planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  copy: function (frustum) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  },
  setFromMatrix: function (m) {
    var planes = this.planes;
    var me = m.elements;
    var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function () {
    var sphere = new THREE.Sphere();
    return function (object) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSphere: function (sphere) {
    var planes = this.planes;
    var center = sphere.center;
    var negRadius = -sphere.radius;
    for (var i = 0; i < 6; i++) {
      var distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  },
  intersectsBox: function () {
    var p1 = new THREE.Vector3(), p2 = new THREE.Vector3();
    return function (box) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        var plane = planes[i];
        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        var d1 = plane.distanceToPoint(p1);
        var d2 = plane.distanceToPoint(p2);
        if (d1 < 0 && d2 < 0) {
          return false;
        }
      }
      return true;
    };
  }(),
  containsPoint: function (point) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  },
  clone: function () {
    return new THREE.Frustum().copy(this);
  }
};
THREE.Plane = function (normal, constant) {
  this.normal = normal !== undefined ? normal : new THREE.Vector3(1, 0, 0);
  this.constant = constant !== undefined ? constant : 0;
};
THREE.Plane.prototype = {
  constructor: THREE.Plane,
  set: function (normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  },
  setComponents: function (x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function () {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    return function (a, b, c) {
      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    };
  }(),
  copy: function (plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function () {
    var inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function (point, optionalTarget) {
    return this.orthoPoint(point, optionalTarget).sub(point).negate();
  },
  orthoPoint: function (point, optionalTarget) {
    var perpendicularMagnitude = this.distanceToPoint(point);
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
  },
  isIntersectionLine: function (line) {
    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectLine: function () {
    var v1 = new THREE.Vector3();
    return function (line, optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      var direction = line.delta(v1);
      var denominator = this.normal.dot(direction);
      if (denominator == 0) {
        if (this.distanceToPoint(line.start) == 0) {
          return result.copy(line.start);
        }
        return undefined;
      }
      var t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return undefined;
      }
      return result.copy(direction).multiplyScalar(t).add(line.start);
    };
  }(),
  coplanarPoint: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function () {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    return function (matrix, optionalNormalMatrix) {
      optionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getNormalMatrix(matrix);
      var newNormal = v1.copy(this.normal).applyMatrix3(optionalNormalMatrix);
      var newCoplanarPoint = this.coplanarPoint(v2);
      newCoplanarPoint.applyMatrix4(matrix);
      this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
      return this;
    };
  }(),
  translate: function (offset) {
    this.constant = this.constant - offset.dot(this.normal);
    return this;
  },
  equals: function (plane) {
    return plane.normal.equals(this.normal) && plane.constant == this.constant;
  },
  clone: function () {
    return new THREE.Plane().copy(this);
  }
};
THREE.Math = {
  PI2: Math.PI * 2,
  generateUUID: function () {
    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    var uuid = new Array(36);
    var rnd = 0, r;
    return function () {
      for (var i = 0; i < 36; i++) {
        if (i == 8 || i == 13 || i == 18 || i == 23) {
          uuid[i] = '-';
        } else if (i == 14) {
          uuid[i] = '4';
        } else {
          if (rnd <= 2)
            rnd = 33554432 + Math.random() * 16777216 | 0;
          r = rnd & 15;
          rnd = rnd >> 4;
          uuid[i] = chars[i == 19 ? r & 3 | 8 : r];
        }
      }
      return uuid.join('');
    };
  }(),
  clamp: function (x, a, b) {
    return x < a ? a : x > b ? b : x;
  },
  clampBottom: function (x, a) {
    return x < a ? a : x;
  },
  mapLinear: function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  smoothstep: function (x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function (x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  random16: function () {
    return (65280 * Math.random() + 255 * Math.random()) / 65535;
  },
  randInt: function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function (low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function (range) {
    return range * (0.5 - Math.random());
  },
  sign: function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : 0;
  },
  degToRad: function () {
    var degreeToRadiansFactor = Math.PI / 180;
    return function (degrees) {
      return degrees * degreeToRadiansFactor;
    };
  }(),
  radToDeg: function () {
    var radianToDegreesFactor = 180 / Math.PI;
    return function (radians) {
      return radians * radianToDegreesFactor;
    };
  }()
};
THREE.Spline = function (points) {
  this.points = points;
  var c = [], v3 = {
      x: 0,
      y: 0,
      z: 0
    }, point, intPoint, weight, w2, w3, pa, pb, pc, pd;
  this.initFromArray = function (a) {
    this.points = [];
    for (var i = 0; i < a.length; i++) {
      this.points[i] = {
        x: a[i][0],
        y: a[i][1],
        z: a[i][2]
      };
    }
  };
  this.getPoint = function (k) {
    point = (this.points.length - 1) * k;
    intPoint = Math.floor(point);
    weight = point - intPoint;
    c[0] = intPoint === 0 ? intPoint : intPoint - 1;
    c[1] = intPoint;
    c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
    pa = this.points[c[0]];
    pb = this.points[c[1]];
    pc = this.points[c[2]];
    pd = this.points[c[3]];
    w2 = weight * weight;
    w3 = weight * w2;
    v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
    v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
    v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
    return v3;
  };
  this.getControlPointsArray = function () {
    var i, p, l = this.points.length, coords = [];
    for (i = 0; i < l; i++) {
      p = this.points[i];
      coords[i] = [
        p.x,
        p.y,
        p.z
      ];
    }
    return coords;
  };
  this.getLength = function (nSubDivisions) {
    var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), chunkLengths = [], totalLength = 0;
    chunkLengths[0] = 0;
    if (!nSubDivisions)
      nSubDivisions = 100;
    nSamples = this.points.length * nSubDivisions;
    oldPosition.copy(this.points[0]);
    for (i = 1; i < nSamples; i++) {
      index = i / nSamples;
      position = this.getPoint(index);
      tmpVec.copy(position);
      totalLength += tmpVec.distanceTo(oldPosition);
      oldPosition.copy(position);
      point = (this.points.length - 1) * index;
      intPoint = Math.floor(point);
      if (intPoint != oldIntPoint) {
        chunkLengths[intPoint] = totalLength;
        oldIntPoint = intPoint;
      }
    }
    chunkLengths[chunkLengths.length] = totalLength;
    return {
      chunks: chunkLengths,
      total: totalLength
    };
  };
  this.reparametrizeByArcLength = function (samplingCoef) {
    var i, j, index, indexCurrent, indexNext, linearDistance, realDistance, sampling, position, newpoints = [], tmpVec = new THREE.Vector3(), sl = this.getLength();
    newpoints.push(tmpVec.copy(this.points[0]).clone());
    for (i = 1; i < this.points.length; i++) {
      realDistance = sl.chunks[i] - sl.chunks[i - 1];
      sampling = Math.ceil(samplingCoef * realDistance / sl.total);
      indexCurrent = (i - 1) / (this.points.length - 1);
      indexNext = i / (this.points.length - 1);
      for (j = 1; j < sampling - 1; j++) {
        index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
        position = this.getPoint(index);
        newpoints.push(tmpVec.copy(position).clone());
      }
      newpoints.push(tmpVec.copy(this.points[i]).clone());
    }
    this.points = newpoints;
  };
  function interpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  ;
};
THREE.Triangle = function (a, b, c) {
  this.a = a !== undefined ? a : new THREE.Vector3();
  this.b = b !== undefined ? b : new THREE.Vector3();
  this.c = c !== undefined ? c : new THREE.Vector3();
};
THREE.Triangle.normal = function () {
  var v0 = new THREE.Vector3();
  return function (a, b, c, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    result.subVectors(c, b);
    v0.subVectors(a, b);
    result.cross(v0);
    var resultLengthSq = result.lengthSq();
    if (resultLengthSq > 0) {
      return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
    }
    return result.set(0, 0, 0);
  };
}();
THREE.Triangle.barycoordFromPoint = function () {
  var v0 = new THREE.Vector3();
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  return function (point, a, b, c, optionalTarget) {
    v0.subVectors(c, a);
    v1.subVectors(b, a);
    v2.subVectors(point, a);
    var dot00 = v0.dot(v0);
    var dot01 = v0.dot(v1);
    var dot02 = v0.dot(v2);
    var dot11 = v1.dot(v1);
    var dot12 = v1.dot(v2);
    var denom = dot00 * dot11 - dot01 * dot01;
    var result = optionalTarget || new THREE.Vector3();
    if (denom == 0) {
      return result.set(-2, -1, -1);
    }
    var invDenom = 1 / denom;
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return result.set(1 - u - v, v, u);
  };
}();
THREE.Triangle.containsPoint = function () {
  var v1 = new THREE.Vector3();
  return function (point, a, b, c) {
    var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
    return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
  };
}();
THREE.Triangle.prototype = {
  constructor: THREE.Triangle,
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  copy: function (triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  area: function () {
    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    return function () {
      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);
      return v0.cross(v1).length() * 0.5;
    };
  }(),
  midpoint: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  normal: function (optionalTarget) {
    return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);
  },
  plane: function (optionalTarget) {
    var result = optionalTarget || new THREE.Plane();
    return result.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  barycoordFromPoint: function (point, optionalTarget) {
    return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
  },
  containsPoint: function (point) {
    return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  equals: function (triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  },
  clone: function () {
    return new THREE.Triangle().copy(this);
  }
};
THREE.Vertex = function (v) {
  console.warn('THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.');
  return v;
};
THREE.UV = function (u, v) {
  console.warn('THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.');
  return new THREE.Vector2(u, v);
};
THREE.Clock = function (autoStart) {
  this.autoStart = autoStart !== undefined ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
};
THREE.Clock.prototype = {
  constructor: THREE.Clock,
  start: function () {
    this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
    this.oldTime = this.startTime;
    this.running = true;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = false;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    var diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
    }
    if (this.running) {
      var newTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
      diff = 0.001 * (newTime - this.oldTime);
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};
THREE.EventDispatcher = function () {
};
THREE.EventDispatcher.prototype = {
  constructor: THREE.EventDispatcher,
  apply: function (object) {
    object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
  },
  addEventListener: function (type, listener) {
    if (this._listeners === undefined)
      this._listeners = {};
    var listeners = this._listeners;
    if (listeners[type] === undefined) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function (type, listener) {
    if (this._listeners === undefined)
      return false;
    var listeners = this._listeners;
    if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
      return true;
    }
    return false;
  },
  removeEventListener: function (type, listener) {
    if (this._listeners === undefined)
      return;
    var listeners = this._listeners;
    var index = listeners[type].indexOf(listener);
    if (index !== -1) {
      listeners[type].splice(index, 1);
    }
  },
  dispatchEvent: function () {
    var array = [];
    return function (event) {
      if (this._listeners === undefined)
        return;
      var listeners = this._listeners;
      var listenerArray = listeners[event.type];
      if (listenerArray !== undefined) {
        event.target = this;
        var length = listenerArray.length;
        for (var i = 0; i < length; i++) {
          array[i] = listenerArray[i];
        }
        for (var i = 0; i < length; i++) {
          array[i].call(this, event);
        }
      }
    };
  }()
};
(function (THREE) {
  THREE.Raycaster = function (origin, direction, near, far) {
    this.ray = new THREE.Ray(origin, direction);
    this.near = near || 0;
    this.far = far || Infinity;
  };
  var sphere = new THREE.Sphere();
  var localRay = new THREE.Ray();
  var facePlane = new THREE.Plane();
  var intersectPoint = new THREE.Vector3();
  var matrixPosition = new THREE.Vector3();
  var inverseMatrix = new THREE.Matrix4();
  var descSort = function (a, b) {
    return a.distance - b.distance;
  };
  var vA = new THREE.Vector3();
  var vB = new THREE.Vector3();
  var vC = new THREE.Vector3();
  var intersectObject = function (object, raycaster, intersects) {
    if (object instanceof THREE.Sprite) {
      matrixPosition.getPositionFromMatrix(object.matrixWorld);
      var distance = raycaster.ray.distanceToPoint(matrixPosition);
      if (distance > object.scale.x) {
        return intersects;
      }
      intersects.push({
        distance: distance,
        point: object.position,
        face: null,
        object: object
      });
    } else if (object instanceof THREE.LOD) {
      matrixPosition.getPositionFromMatrix(object.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(matrixPosition);
      intersectObject(object.getObjectForDistance(distance), raycaster, intersects);
    } else if (object instanceof THREE.Mesh) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(object.matrixWorld);
      if (raycaster.ray.isIntersectionSphere(sphere) === false) {
        return intersects;
      }
      inverseMatrix.getInverse(object.matrixWorld);
      localRay.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      if (geometry.boundingBox !== null) {
        if (localRay.isIntersectionBox(geometry.boundingBox) === false) {
          return intersects;
        }
      }
      if (geometry instanceof THREE.BufferGeometry) {
        var material = object.material;
        if (material === undefined)
          return intersects;
        if (geometry.dynamic === false)
          return intersects;
        var a, b, c;
        var precision = raycaster.precision;
        if (geometry.attributes.index !== undefined) {
          var offsets = geometry.offsets;
          var indices = geometry.attributes.index.array;
          var positions = geometry.attributes.position.array;
          var offLength = geometry.offsets.length;
          var fl = geometry.attributes.index.array.length / 3;
          for (var oi = 0; oi < offLength; ++oi) {
            var start = offsets[oi].start;
            var count = offsets[oi].count;
            var index = offsets[oi].index;
            for (var i = start, il = start + count; i < il; i += 3) {
              a = index + indices[i];
              b = index + indices[i + 1];
              c = index + indices[i + 2];
              vA.set(positions[a * 3], positions[a * 3 + 1], positions[a * 3 + 2]);
              vB.set(positions[b * 3], positions[b * 3 + 1], positions[b * 3 + 2]);
              vC.set(positions[c * 3], positions[c * 3 + 1], positions[c * 3 + 2]);
              if (material.side === THREE.BackSide) {
                var intersectionPoint = localRay.intersectTriangle(vC, vB, vA, true);
              } else {
                var intersectionPoint = localRay.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
              }
              if (intersectionPoint === null)
                continue;
              intersectionPoint.applyMatrix4(object.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
              if (distance < precision || distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: intersectionPoint,
                face: null,
                faceIndex: null,
                object: object
              });
            }
          }
        } else {
          var offsets = geometry.offsets;
          var positions = geometry.attributes.position.array;
          var offLength = geometry.offsets.length;
          var fl = geometry.attributes.position.array.length;
          for (var i = 0; i < fl; i += 3) {
            a = i;
            b = i + 1;
            c = i + 2;
            vA.set(positions[a * 3], positions[a * 3 + 1], positions[a * 3 + 2]);
            vB.set(positions[b * 3], positions[b * 3 + 1], positions[b * 3 + 2]);
            vC.set(positions[c * 3], positions[c * 3 + 1], positions[c * 3 + 2]);
            if (material.side === THREE.BackSide) {
              var intersectionPoint = localRay.intersectTriangle(vC, vB, vA, true);
            } else {
              var intersectionPoint = localRay.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
            }
            if (intersectionPoint === null)
              continue;
            intersectionPoint.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
            if (distance < precision || distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: intersectionPoint,
              face: null,
              faceIndex: null,
              object: object
            });
          }
        }
      } else if (geometry instanceof THREE.Geometry) {
        var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
        var objectMaterials = isFaceMaterial === true ? object.material.materials : null;
        var a, b, c, d;
        var precision = raycaster.precision;
        var vertices = geometry.vertices;
        for (var f = 0, fl = geometry.faces.length; f < fl; f++) {
          var face = geometry.faces[f];
          var material = isFaceMaterial === true ? objectMaterials[face.materialIndex] : object.material;
          if (material === undefined)
            continue;
          a = vertices[face.a];
          b = vertices[face.b];
          c = vertices[face.c];
          if (material.side === THREE.BackSide) {
            var intersectionPoint = localRay.intersectTriangle(c, b, a, true);
          } else {
            var intersectionPoint = localRay.intersectTriangle(a, b, c, material.side !== THREE.DoubleSide);
          }
          if (intersectionPoint === null)
            continue;
          intersectionPoint.applyMatrix4(object.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
          if (distance < precision || distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance: distance,
            point: intersectionPoint,
            face: face,
            faceIndex: f,
            object: object
          });
        }
      }
    } else if (object instanceof THREE.Line) {
      var precision = raycaster.linePrecision;
      var precisionSq = precision * precision;
      var geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(object.matrixWorld);
      if (raycaster.ray.isIntersectionSphere(sphere) === false) {
        return intersects;
      }
      inverseMatrix.getInverse(object.matrixWorld);
      localRay.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      if (geometry instanceof THREE.Geometry) {
        var vertices = geometry.vertices;
        var nbVertices = vertices.length;
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = object.type === THREE.LineStrip ? 1 : 2;
        for (var i = 0; i < nbVertices - 1; i = i + step) {
          var distSq = localRay.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
          if (distSq > precisionSq)
            continue;
          var distance = localRay.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance: distance,
            point: interSegment.clone().applyMatrix4(object.matrixWorld),
            face: null,
            faceIndex: null,
            object: object
          });
        }
      }
    }
  };
  var intersectDescendants = function (object, raycaster, intersects) {
    var descendants = object.getDescendants();
    for (var i = 0, l = descendants.length; i < l; i++) {
      intersectObject(descendants[i], raycaster, intersects);
    }
  };
  THREE.Raycaster.prototype.precision = 0.0001;
  THREE.Raycaster.prototype.linePrecision = 1;
  THREE.Raycaster.prototype.set = function (origin, direction) {
    this.ray.set(origin, direction);
  };
  THREE.Raycaster.prototype.intersectObject = function (object, recursive) {
    var intersects = [];
    if (recursive === true) {
      intersectDescendants(object, this, intersects);
    }
    intersectObject(object, this, intersects);
    intersects.sort(descSort);
    return intersects;
  };
  THREE.Raycaster.prototype.intersectObjects = function (objects, recursive) {
    var intersects = [];
    for (var i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects);
      if (recursive === true) {
        intersectDescendants(objects[i], this, intersects);
      }
    }
    intersects.sort(descSort);
    return intersects;
  };
}(THREE));
THREE.Object3D = function () {
  this.id = THREE.Object3DIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.parent = undefined;
  this.children = [];
  this.up = new THREE.Vector3(0, 1, 0);
  this.position = new THREE.Vector3();
  this.rotation = new THREE.Euler();
  this.quaternion = new THREE.Quaternion();
  this.scale = new THREE.Vector3(1, 1, 1);
  this.rotation._quaternion = this.quaternion;
  this.quaternion._euler = this.rotation;
  this.renderDepth = null;
  this.rotationAutoUpdate = true;
  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();
  this.matrixAutoUpdate = true;
  this.matrixWorldNeedsUpdate = true;
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.userData = {};
};
THREE.Object3D.prototype = {
  constructor: THREE.Object3D,
  get eulerOrder() {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    return this.rotation.order;
  },
  set eulerOrder(value) {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    this.rotation.order = value;
  },
  get useQuaternion() {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  set useQuaternion(value) {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  applyMatrix: function () {
    var m1 = new THREE.Matrix4();
    return function (matrix) {
      this.matrix.multiplyMatrices(matrix, this.matrix);
      this.position.getPositionFromMatrix(this.matrix);
      this.scale.getScaleFromMatrix(this.matrix);
      m1.extractRotation(this.matrix);
      this.quaternion.setFromRotationMatrix(m1);
    };
  }(),
  setRotationFromAxisAngle: function (axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function (euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function (m) {
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function (q) {
    this.quaternion.copy(q);
  },
  rotateOnAxis: function () {
    var q1 = new THREE.Quaternion();
    return function (axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(q1);
      return this;
    };
  }(),
  rotateX: function () {
    var v1 = new THREE.Vector3(1, 0, 0);
    return function (angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateY: function () {
    var v1 = new THREE.Vector3(0, 1, 0);
    return function (angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateZ: function () {
    var v1 = new THREE.Vector3(0, 0, 1);
    return function (angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  translateOnAxis: function () {
    var v1 = new THREE.Vector3();
    return function (axis, distance) {
      v1.copy(axis);
      v1.applyQuaternion(this.quaternion);
      this.position.add(v1.multiplyScalar(distance));
      return this;
    };
  }(),
  translate: function (distance, axis) {
    console.warn('DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.');
    return this.translateOnAxis(axis, distance);
  },
  translateX: function () {
    var v1 = new THREE.Vector3(1, 0, 0);
    return function (distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateY: function () {
    var v1 = new THREE.Vector3(0, 1, 0);
    return function (distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateZ: function () {
    var v1 = new THREE.Vector3(0, 0, 1);
    return function (distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  localToWorld: function (vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function () {
    var m1 = new THREE.Matrix4();
    return function (vector) {
      return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function () {
    var m1 = new THREE.Matrix4();
    return function (vector) {
      m1.lookAt(vector, this.position, this.up);
      this.quaternion.setFromRotationMatrix(m1);
    };
  }(),
  add: function (object) {
    if (object === this) {
      console.warn('THREE.Object3D.add: An object can\'t be added as a child of itself.');
      return;
    }
    if (object instanceof THREE.Object3D) {
      if (object.parent !== undefined) {
        object.parent.remove(object);
      }
      object.parent = this;
      object.dispatchEvent({ type: 'added' });
      this.children.push(object);
      var scene = this;
      while (scene.parent !== undefined) {
        scene = scene.parent;
      }
      if (scene !== undefined && scene instanceof THREE.Scene) {
        scene.__addObject(object);
      }
    }
  },
  remove: function (object) {
    var index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = undefined;
      object.dispatchEvent({ type: 'removed' });
      this.children.splice(index, 1);
      var scene = this;
      while (scene.parent !== undefined) {
        scene = scene.parent;
      }
      if (scene !== undefined && scene instanceof THREE.Scene) {
        scene.__removeObject(object);
      }
    }
  },
  traverse: function (callback) {
    callback(this);
    for (var i = 0, l = this.children.length; i < l; i++) {
      this.children[i].traverse(callback);
    }
  },
  getObjectById: function (id, recursive) {
    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      if (child.id === id) {
        return child;
      }
      if (recursive === true) {
        child = child.getObjectById(id, recursive);
        if (child !== undefined) {
          return child;
        }
      }
    }
    return undefined;
  },
  getObjectByName: function (name, recursive) {
    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      if (child.name === name) {
        return child;
      }
      if (recursive === true) {
        child = child.getObjectByName(name, recursive);
        if (child !== undefined) {
          return child;
        }
      }
    }
    return undefined;
  },
  getChildByName: function (name, recursive) {
    console.warn('DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(name, recursive);
  },
  getDescendants: function (array) {
    if (array === undefined)
      array = [];
    Array.prototype.push.apply(array, this.children);
    for (var i = 0, l = this.children.length; i < l; i++) {
      this.children[i].getDescendants(array);
    }
    return array;
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function (force) {
    if (this.matrixAutoUpdate === true)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate === true || force === true) {
      if (this.parent === undefined) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    for (var i = 0, l = this.children.length; i < l; i++) {
      this.children[i].updateMatrixWorld(force);
    }
  },
  clone: function (object, recursive) {
    if (object === undefined)
      object = new THREE.Object3D();
    if (recursive === undefined)
      recursive = true;
    object.name = this.name;
    object.up.copy(this.up);
    object.position.copy(this.position);
    object.quaternion.copy(this.quaternion);
    object.scale.copy(this.scale);
    object.renderDepth = this.renderDepth;
    object.rotationAutoUpdate = this.rotationAutoUpdate;
    object.matrix.copy(this.matrix);
    object.matrixWorld.copy(this.matrixWorld);
    object.matrixAutoUpdate = this.matrixAutoUpdate;
    object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
    object.visible = this.visible;
    object.castShadow = this.castShadow;
    object.receiveShadow = this.receiveShadow;
    object.frustumCulled = this.frustumCulled;
    object.userData = JSON.parse(JSON.stringify(this.userData));
    if (recursive === true) {
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        object.add(child.clone());
      }
    }
    return object;
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Projector = function () {
  var _object, _objectCount, _objectPool = [], _objectPoolLength = 0, _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0, _face, _face3Count, _face3Pool = [], _face3PoolLength = 0, _line, _lineCount, _linePool = [], _linePoolLength = 0, _sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0, _renderData = {
      objects: [],
      sprites: [],
      lights: [],
      elements: []
    }, _vector3 = new THREE.Vector3(), _vector4 = new THREE.Vector4(), _clipBox = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), _boundingBox = new THREE.Box3(), _points3 = new Array(3), _points4 = new Array(4), _viewMatrix = new THREE.Matrix4(), _viewProjectionMatrix = new THREE.Matrix4(), _modelMatrix, _modelViewProjectionMatrix = new THREE.Matrix4(), _normalMatrix = new THREE.Matrix3(), _normalViewMatrix = new THREE.Matrix3(), _centroid = new THREE.Vector3(), _frustum = new THREE.Frustum(), _clippedVertex1PositionScreen = new THREE.Vector4(), _clippedVertex2PositionScreen = new THREE.Vector4();
  this.projectVector = function (vector, camera) {
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    return vector.applyProjection(_viewProjectionMatrix);
  };
  this.unprojectVector = function (vector, camera) {
    camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);
    _viewProjectionMatrix.multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);
    return vector.applyProjection(_viewProjectionMatrix);
  };
  this.pickingRay = function (vector, camera) {
    vector.z = -1;
    var end = new THREE.Vector3(vector.x, vector.y, 1);
    this.unprojectVector(vector, camera);
    this.unprojectVector(end, camera);
    end.sub(vector).normalize();
    return new THREE.Raycaster(vector, end);
  };
  var getObject = function (object) {
    _object = getNextObjectInPool();
    _object.id = object.id;
    _object.object = object;
    if (object.renderDepth !== null) {
      _object.z = object.renderDepth;
    } else {
      _vector3.getPositionFromMatrix(object.matrixWorld);
      _vector3.applyProjection(_viewProjectionMatrix);
      _object.z = _vector3.z;
    }
    return _object;
  };
  var projectObject = function (object) {
    if (object.visible === false)
      return;
    if (object instanceof THREE.Light) {
      _renderData.lights.push(object);
    } else if (object instanceof THREE.Mesh || object instanceof THREE.Line) {
      if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
        _renderData.objects.push(getObject(object));
      }
    } else if (object instanceof THREE.Sprite) {
      _renderData.sprites.push(getObject(object));
    }
    for (var i = 0, l = object.children.length; i < l; i++) {
      projectObject(object.children[i]);
    }
  };
  var projectGraph = function (root, sortObjects) {
    _objectCount = 0;
    _renderData.objects.length = 0;
    _renderData.sprites.length = 0;
    _renderData.lights.length = 0;
    projectObject(root);
    if (sortObjects === true) {
      _renderData.objects.sort(painterSort);
    }
  };
  this.projectScene = function (scene, camera, sortObjects, sortElements) {
    var visible = false, o, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs, v1, v2, v3, v4, isFaceMaterial, objectMaterials;
    _face3Count = 0;
    _lineCount = 0;
    _spriteCount = 0;
    _renderData.elements.length = 0;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === undefined)
      camera.updateMatrixWorld();
    _viewMatrix.copy(camera.matrixWorldInverse.getInverse(camera.matrixWorld));
    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
    _normalViewMatrix.getNormalMatrix(_viewMatrix);
    _frustum.setFromMatrix(_viewProjectionMatrix);
    projectGraph(scene, sortObjects);
    for (o = 0, ol = _renderData.objects.length; o < ol; o++) {
      object = _renderData.objects[o].object;
      _modelMatrix = object.matrixWorld;
      _vertexCount = 0;
      if (object instanceof THREE.Mesh) {
        geometry = object.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        faceVertexUvs = geometry.faceVertexUvs;
        _normalMatrix.getNormalMatrix(_modelMatrix);
        isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
        objectMaterials = isFaceMaterial === true ? object.material : null;
        for (v = 0, vl = vertices.length; v < vl; v++) {
          _vertex = getNextVertexInPool();
          _vertex.positionWorld.copy(vertices[v]).applyMatrix4(_modelMatrix);
          _vertex.positionScreen.copy(_vertex.positionWorld).applyMatrix4(_viewProjectionMatrix);
          var invW = 1 / _vertex.positionScreen.w;
          _vertex.positionScreen.x *= invW;
          _vertex.positionScreen.y *= invW;
          _vertex.positionScreen.z *= invW;
          _vertex.visible = !(_vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 || _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 || _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1);
        }
        for (f = 0, fl = faces.length; f < fl; f++) {
          face = faces[f];
          var material = isFaceMaterial === true ? objectMaterials.materials[face.materialIndex] : object.material;
          if (material === undefined)
            continue;
          var side = material.side;
          v1 = _vertexPool[face.a];
          v2 = _vertexPool[face.b];
          v3 = _vertexPool[face.c];
          _points3[0] = v1.positionScreen;
          _points3[1] = v2.positionScreen;
          _points3[2] = v3.positionScreen;
          if (v1.visible === true || v2.visible === true || v3.visible === true || _clipBox.isIntersectionBox(_boundingBox.setFromPoints(_points3))) {
            visible = (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;
            if (side === THREE.DoubleSide || visible === (side === THREE.FrontSide)) {
              _face = getNextFace3InPool();
              _face.id = object.id;
              _face.v1.copy(v1);
              _face.v2.copy(v2);
              _face.v3.copy(v3);
            } else {
              continue;
            }
          } else {
            continue;
          }
          _face.normalModel.copy(face.normal);
          if (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) {
            _face.normalModel.negate();
          }
          _face.normalModel.applyMatrix3(_normalMatrix).normalize();
          _face.normalModelView.copy(_face.normalModel).applyMatrix3(_normalViewMatrix);
          _face.centroidModel.copy(face.centroid).applyMatrix4(_modelMatrix);
          faceVertexNormals = face.vertexNormals;
          for (n = 0, nl = Math.min(faceVertexNormals.length, 3); n < nl; n++) {
            var normalModel = _face.vertexNormalsModel[n];
            normalModel.copy(faceVertexNormals[n]);
            if (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) {
              normalModel.negate();
            }
            normalModel.applyMatrix3(_normalMatrix).normalize();
            var normalModelView = _face.vertexNormalsModelView[n];
            normalModelView.copy(normalModel).applyMatrix3(_normalViewMatrix);
          }
          _face.vertexNormalsLength = faceVertexNormals.length;
          for (c = 0, cl = Math.min(faceVertexUvs.length, 3); c < cl; c++) {
            uvs = faceVertexUvs[c][f];
            if (uvs === undefined)
              continue;
            for (u = 0, ul = uvs.length; u < ul; u++) {
              _face.uvs[c][u] = uvs[u];
            }
          }
          _face.color = face.color;
          _face.material = material;
          _centroid.copy(_face.centroidModel).applyProjection(_viewProjectionMatrix);
          _face.z = _centroid.z;
          _renderData.elements.push(_face);
        }
      } else if (object instanceof THREE.Line) {
        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
        vertices = object.geometry.vertices;
        v1 = getNextVertexInPool();
        v1.positionScreen.copy(vertices[0]).applyMatrix4(_modelViewProjectionMatrix);
        var step = object.type === THREE.LinePieces ? 2 : 1;
        for (v = 1, vl = vertices.length; v < vl; v++) {
          v1 = getNextVertexInPool();
          v1.positionScreen.copy(vertices[v]).applyMatrix4(_modelViewProjectionMatrix);
          if ((v + 1) % step > 0)
            continue;
          v2 = _vertexPool[_vertexCount - 2];
          _clippedVertex1PositionScreen.copy(v1.positionScreen);
          _clippedVertex2PositionScreen.copy(v2.positionScreen);
          if (clipLine(_clippedVertex1PositionScreen, _clippedVertex2PositionScreen) === true) {
            _clippedVertex1PositionScreen.multiplyScalar(1 / _clippedVertex1PositionScreen.w);
            _clippedVertex2PositionScreen.multiplyScalar(1 / _clippedVertex2PositionScreen.w);
            _line = getNextLineInPool();
            _line.id = object.id;
            _line.v1.positionScreen.copy(_clippedVertex1PositionScreen);
            _line.v2.positionScreen.copy(_clippedVertex2PositionScreen);
            _line.z = Math.max(_clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z);
            _line.material = object.material;
            if (object.material.vertexColors === THREE.VertexColors) {
              _line.vertexColors[0].copy(object.geometry.colors[v]);
              _line.vertexColors[1].copy(object.geometry.colors[v - 1]);
            }
            _renderData.elements.push(_line);
          }
        }
      }
    }
    for (o = 0, ol = _renderData.sprites.length; o < ol; o++) {
      object = _renderData.sprites[o].object;
      _modelMatrix = object.matrixWorld;
      if (object instanceof THREE.Sprite) {
        _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);
        _vector4.applyMatrix4(_viewProjectionMatrix);
        var invW = 1 / _vector4.w;
        _vector4.z *= invW;
        if (_vector4.z > -1 && _vector4.z < 1) {
          _sprite = getNextSpriteInPool();
          _sprite.id = object.id;
          _sprite.x = _vector4.x * invW;
          _sprite.y = _vector4.y * invW;
          _sprite.z = _vector4.z;
          _sprite.object = object;
          _sprite.rotation = object.rotation;
          _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));
          _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));
          _sprite.material = object.material;
          _renderData.elements.push(_sprite);
        }
      }
    }
    if (sortElements === true)
      _renderData.elements.sort(painterSort);
    return _renderData;
  };
  function getNextObjectInPool() {
    if (_objectCount === _objectPoolLength) {
      var object = new THREE.RenderableObject();
      _objectPool.push(object);
      _objectPoolLength++;
      _objectCount++;
      return object;
    }
    return _objectPool[_objectCount++];
  }
  function getNextVertexInPool() {
    if (_vertexCount === _vertexPoolLength) {
      var vertex = new THREE.RenderableVertex();
      _vertexPool.push(vertex);
      _vertexPoolLength++;
      _vertexCount++;
      return vertex;
    }
    return _vertexPool[_vertexCount++];
  }
  function getNextFace3InPool() {
    if (_face3Count === _face3PoolLength) {
      var face = new THREE.RenderableFace3();
      _face3Pool.push(face);
      _face3PoolLength++;
      _face3Count++;
      return face;
    }
    return _face3Pool[_face3Count++];
  }
  function getNextLineInPool() {
    if (_lineCount === _linePoolLength) {
      var line = new THREE.RenderableLine();
      _linePool.push(line);
      _linePoolLength++;
      _lineCount++;
      return line;
    }
    return _linePool[_lineCount++];
  }
  function getNextSpriteInPool() {
    if (_spriteCount === _spritePoolLength) {
      var sprite = new THREE.RenderableSprite();
      _spritePool.push(sprite);
      _spritePoolLength++;
      _spriteCount++;
      return sprite;
    }
    return _spritePool[_spriteCount++];
  }
  function painterSort(a, b) {
    if (a.z !== b.z) {
      return b.z - a.z;
    } else if (a.id !== b.id) {
      return a.id - b.id;
    } else {
      return 0;
    }
  }
  function clipLine(s1, s2) {
    var alpha1 = 0, alpha2 = 1, bc1near = s1.z + s1.w, bc2near = s2.z + s2.w, bc1far = -s1.z + s1.w, bc2far = -s2.z + s2.w;
    if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {
      return true;
    } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {
      return false;
    } else {
      if (bc1near < 0) {
        alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));
      } else if (bc2near < 0) {
        alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));
      }
      if (bc1far < 0) {
        alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));
      } else if (bc2far < 0) {
        alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));
      }
      if (alpha2 < alpha1) {
        return false;
      } else {
        s1.lerp(s2, alpha1);
        s2.lerp(s1, 1 - alpha2);
        return true;
      }
    }
  }
};
THREE.Face3 = function (a, b, c, normal, color, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
  this.vertexNormals = normal instanceof Array ? normal : [];
  this.color = color instanceof THREE.Color ? color : new THREE.Color();
  this.vertexColors = color instanceof Array ? color : [];
  this.vertexTangents = [];
  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
  this.centroid = new THREE.Vector3();
};
THREE.Face3.prototype = {
  constructor: THREE.Face3,
  clone: function () {
    var face = new THREE.Face3(this.a, this.b, this.c);
    face.normal.copy(this.normal);
    face.color.copy(this.color);
    face.centroid.copy(this.centroid);
    face.materialIndex = this.materialIndex;
    var i, il;
    for (i = 0, il = this.vertexNormals.length; i < il; i++)
      face.vertexNormals[i] = this.vertexNormals[i].clone();
    for (i = 0, il = this.vertexColors.length; i < il; i++)
      face.vertexColors[i] = this.vertexColors[i].clone();
    for (i = 0, il = this.vertexTangents.length; i < il; i++)
      face.vertexTangents[i] = this.vertexTangents[i].clone();
    return face;
  }
};
THREE.Face4 = function (a, b, c, d, normal, color, materialIndex) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new THREE.Face3(a, b, c, normal, color, materialIndex);
};
THREE.Geometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.hasTangents = false;
  this.dynamic = true;
  this.verticesNeedUpdate = false;
  this.elementsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.tangentsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.buffersNeedUpdate = false;
};
THREE.Geometry.prototype = {
  constructor: THREE.Geometry,
  applyMatrix: function (matrix) {
    var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
    for (var i = 0, il = this.vertices.length; i < il; i++) {
      var vertex = this.vertices[i];
      vertex.applyMatrix4(matrix);
    }
    for (var i = 0, il = this.faces.length; i < il; i++) {
      var face = this.faces[i];
      face.normal.applyMatrix3(normalMatrix).normalize();
      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
      face.centroid.applyMatrix4(matrix);
    }
    if (this.boundingBox instanceof THREE.Box3) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere instanceof THREE.Sphere) {
      this.computeBoundingSphere();
    }
  },
  computeCentroids: function () {
    var f, fl, face;
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.centroid.set(0, 0, 0);
      face.centroid.add(this.vertices[face.a]);
      face.centroid.add(this.vertices[face.b]);
      face.centroid.add(this.vertices[face.c]);
      face.centroid.divideScalar(3);
    }
  },
  computeFaceNormals: function () {
    var cb = new THREE.Vector3(), ab = new THREE.Vector3();
    for (var f = 0, fl = this.faces.length; f < fl; f++) {
      var face = this.faces[f];
      var vA = this.vertices[face.a];
      var vB = this.vertices[face.b];
      var vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function (areaWeighted) {
    var v, vl, f, fl, face, vertices;
    if (this.__tmpVertices === undefined) {
      this.__tmpVertices = new Array(this.vertices.length);
      vertices = this.__tmpVertices;
      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v] = new THREE.Vector3();
      }
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        face.vertexNormals = [
          new THREE.Vector3(),
          new THREE.Vector3(),
          new THREE.Vector3()
        ];
      }
    } else {
      vertices = this.__tmpVertices;
      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v].set(0, 0, 0);
      }
    }
    if (areaWeighted) {
      var vA, vB, vC, vD;
      var cb = new THREE.Vector3(), ab = new THREE.Vector3(), db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vA = this.vertices[face.a];
        vB = this.vertices[face.b];
        vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.vertexNormals[0].copy(vertices[face.a]);
      face.vertexNormals[1].copy(vertices[face.b]);
      face.vertexNormals[2].copy(vertices[face.c]);
    }
  },
  computeMorphNormals: function () {
    var i, il, f, fl, face;
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }
      if (!face.__originalVertexNormals)
        face.__originalVertexNormals = [];
      for (i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    }
    var tmpGeo = new THREE.Geometry();
    tmpGeo.faces = this.faces;
    for (i = 0, il = this.morphTargets.length; i < il; i++) {
      if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        var dstNormalsFace = this.morphNormals[i].faceNormals;
        var dstNormalsVertex = this.morphNormals[i].vertexNormals;
        var faceNormal, vertexNormals;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          faceNormal = new THREE.Vector3();
          vertexNormals = {
            a: new THREE.Vector3(),
            b: new THREE.Vector3(),
            c: new THREE.Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }
      var morphNormals = this.morphNormals[i];
      tmpGeo.vertices = this.morphTargets[i].vertices;
      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();
      var faceNormal, vertexNormals;
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        faceNormal = morphNormals.faceNormals[f];
        vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeTangents: function () {
    var f, fl, v, vl, i, il, vertexIndex, face, uv, vA, vB, vC, uvA, uvB, uvC, x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r, t, test, tan1 = [], tan2 = [], sdir = new THREE.Vector3(), tdir = new THREE.Vector3(), tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(), n = new THREE.Vector3(), w;
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      tan1[v] = new THREE.Vector3();
      tan2[v] = new THREE.Vector3();
    }
    function handleTriangle(context, a, b, c, ua, ub, uc) {
      vA = context.vertices[a];
      vB = context.vertices[b];
      vC = context.vertices[c];
      uvA = uv[ua];
      uvB = uv[ub];
      uvC = uv[uc];
      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;
      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;
      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;
      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;
      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;
      r = 1 / (s1 * t2 - s2 * t1);
      sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      uv = this.faceVertexUvs[0][f];
      handleTriangle(this, face.a, face.b, face.c, 0, 1, 2);
    }
    var faceIndex = [
        'a',
        'b',
        'c',
        'd'
      ];
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      for (i = 0; i < Math.min(face.vertexNormals.length, 3); i++) {
        n.copy(face.vertexNormals[i]);
        vertexIndex = face[faceIndex[i]];
        t = tan1[vertexIndex];
        tmp.copy(t);
        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
        tmp2.crossVectors(face.vertexNormals[i], t);
        test = tmp2.dot(tan2[vertexIndex]);
        w = test < 0 ? -1 : 1;
        face.vertexTangents[i] = new THREE.Vector4(tmp.x, tmp.y, tmp.z, w);
      }
    }
    this.hasTangents = true;
  },
  computeLineDistances: function () {
    var d = 0;
    var vertices = this.vertices;
    for (var i = 0, il = vertices.length; i < il; i++) {
      if (i > 0) {
        d += vertices[i].distanceTo(vertices[i - 1]);
      }
      this.lineDistances[i] = d;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new THREE.Box3();
    }
    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new THREE.Sphere();
    }
    this.boundingSphere.setFromPoints(this.vertices);
  },
  mergeVertices: function () {
    var verticesMap = {};
    var unique = [], changes = [];
    var v, key;
    var precisionPoints = 4;
    var precision = Math.pow(10, precisionPoints);
    var i, il, face;
    var indices, k, j, jl, u;
    this.__tmpVertices = undefined;
    for (i = 0, il = this.vertices.length; i < il; i++) {
      v = this.vertices[i];
      key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
      if (verticesMap[key] === undefined) {
        verticesMap[key] = i;
        unique.push(this.vertices[i]);
        changes[i] = unique.length - 1;
      } else {
        changes[i] = changes[verticesMap[key]];
      }
    }
    ;
    var faceIndicesToRemove = [];
    for (i = 0, il = this.faces.length; i < il; i++) {
      face = this.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      indices = [
        face.a,
        face.b,
        face.c
      ];
      var dupIndex = -1;
      for (var n = 0; n < 3; n++) {
        if (indices[n] == indices[(n + 1) % 3]) {
          dupIndex = n;
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }
    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      var idx = faceIndicesToRemove[i];
      this.faces.splice(idx, 1);
      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
      }
    }
    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  clone: function () {
    var geometry = new THREE.Geometry();
    var vertices = this.vertices;
    for (var i = 0, il = vertices.length; i < il; i++) {
      geometry.vertices.push(vertices[i].clone());
    }
    var faces = this.faces;
    for (var i = 0, il = faces.length; i < il; i++) {
      geometry.faces.push(faces[i].clone());
    }
    var uvs = this.faceVertexUvs[0];
    for (var i = 0, il = uvs.length; i < il; i++) {
      var uv = uvs[i], uvCopy = [];
      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(new THREE.Vector2(uv[j].x, uv[j].y));
      }
      geometry.faceVertexUvs[0].push(uvCopy);
    }
    return geometry;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.BufferGeometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.attributes = {};
  this.dynamic = true;
  this.offsets = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.hasTangents = false;
  this.morphTargets = [];
};
THREE.BufferGeometry.prototype = {
  constructor: THREE.BufferGeometry,
  addAttribute: function (name, type, numItems, itemSize) {
    this.attributes[name] = {
      itemSize: itemSize,
      array: new type(numItems * itemSize)
    };
  },
  applyMatrix: function (matrix) {
    var positionArray;
    var normalArray;
    if (this.attributes['position'])
      positionArray = this.attributes['position'].array;
    if (this.attributes['normal'])
      normalArray = this.attributes['normal'].array;
    if (positionArray !== undefined) {
      matrix.multiplyVector3Array(positionArray);
      this.verticesNeedUpdate = true;
    }
    if (normalArray !== undefined) {
      var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
      normalMatrix.multiplyVector3Array(normalArray);
      this.normalizeNormals();
      this.normalsNeedUpdate = true;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new THREE.Box3();
    }
    var positions = this.attributes['position'].array;
    if (positions) {
      var bb = this.boundingBox;
      var x, y, z;
      if (positions.length >= 3) {
        bb.min.x = bb.max.x = positions[0];
        bb.min.y = bb.max.y = positions[1];
        bb.min.z = bb.max.z = positions[2];
      }
      for (var i = 3, il = positions.length; i < il; i += 3) {
        x = positions[i];
        y = positions[i + 1];
        z = positions[i + 2];
        if (x < bb.min.x) {
          bb.min.x = x;
        } else if (x > bb.max.x) {
          bb.max.x = x;
        }
        if (y < bb.min.y) {
          bb.min.y = y;
        } else if (y > bb.max.y) {
          bb.max.y = y;
        }
        if (z < bb.min.z) {
          bb.min.z = z;
        } else if (z > bb.max.z) {
          bb.max.z = z;
        }
      }
    }
    if (positions === undefined || positions.length === 0) {
      this.boundingBox.min.set(0, 0, 0);
      this.boundingBox.max.set(0, 0, 0);
    }
  },
  computeBoundingSphere: function () {
    var box = new THREE.Box3();
    var vector = new THREE.Vector3();
    return function () {
      if (this.boundingSphere === null) {
        this.boundingSphere = new THREE.Sphere();
      }
      var positions = this.attributes['position'].array;
      if (positions) {
        var center = this.boundingSphere.center;
        for (var i = 0, il = positions.length; i < il; i += 3) {
          vector.set(positions[i], positions[i + 1], positions[i + 2]);
          box.addPoint(vector);
        }
        box.center(center);
        var maxRadiusSq = 0;
        for (var i = 0, il = positions.length; i < il; i += 3) {
          vector.set(positions[i], positions[i + 1], positions[i + 2]);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      }
    };
  }(),
  computeVertexNormals: function () {
    if (this.attributes['position']) {
      var i, il;
      var j, jl;
      var nVertexElements = this.attributes['position'].array.length;
      if (this.attributes['normal'] === undefined) {
        this.attributes['normal'] = {
          itemSize: 3,
          array: new Float32Array(nVertexElements)
        };
      } else {
        for (i = 0, il = this.attributes['normal'].array.length; i < il; i++) {
          this.attributes['normal'].array[i] = 0;
        }
      }
      var positions = this.attributes['position'].array;
      var normals = this.attributes['normal'].array;
      var vA, vB, vC, x, y, z, pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3(), cb = new THREE.Vector3(), ab = new THREE.Vector3();
      if (this.attributes['index']) {
        var indices = this.attributes['index'].array;
        var offsets = this.offsets;
        for (j = 0, jl = offsets.length; j < jl; ++j) {
          var start = offsets[j].start;
          var count = offsets[j].count;
          var index = offsets[j].index;
          for (i = start, il = start + count; i < il; i += 3) {
            vA = index + indices[i];
            vB = index + indices[i + 1];
            vC = index + indices[i + 2];
            x = positions[vA * 3];
            y = positions[vA * 3 + 1];
            z = positions[vA * 3 + 2];
            pA.set(x, y, z);
            x = positions[vB * 3];
            y = positions[vB * 3 + 1];
            z = positions[vB * 3 + 2];
            pB.set(x, y, z);
            x = positions[vC * 3];
            y = positions[vC * 3 + 1];
            z = positions[vC * 3 + 2];
            pC.set(x, y, z);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[vA * 3] += cb.x;
            normals[vA * 3 + 1] += cb.y;
            normals[vA * 3 + 2] += cb.z;
            normals[vB * 3] += cb.x;
            normals[vB * 3 + 1] += cb.y;
            normals[vB * 3 + 2] += cb.z;
            normals[vC * 3] += cb.x;
            normals[vC * 3 + 1] += cb.y;
            normals[vC * 3 + 2] += cb.z;
          }
        }
      } else {
        for (i = 0, il = positions.length; i < il; i += 9) {
          x = positions[i];
          y = positions[i + 1];
          z = positions[i + 2];
          pA.set(x, y, z);
          x = positions[i + 3];
          y = positions[i + 4];
          z = positions[i + 5];
          pB.set(x, y, z);
          x = positions[i + 6];
          y = positions[i + 7];
          z = positions[i + 8];
          pC.set(x, y, z);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[i] = cb.x;
          normals[i + 1] = cb.y;
          normals[i + 2] = cb.z;
          normals[i + 3] = cb.x;
          normals[i + 4] = cb.y;
          normals[i + 5] = cb.z;
          normals[i + 6] = cb.x;
          normals[i + 7] = cb.y;
          normals[i + 8] = cb.z;
        }
      }
      this.normalizeNormals();
      this.normalsNeedUpdate = true;
    }
  },
  normalizeNormals: function () {
    var normals = this.attributes['normal'].array;
    var x, y, z, n;
    for (var i = 0, il = normals.length; i < il; i += 3) {
      x = normals[i];
      y = normals[i + 1];
      z = normals[i + 2];
      n = 1 / Math.sqrt(x * x + y * y + z * z);
      normals[i] *= n;
      normals[i + 1] *= n;
      normals[i + 2] *= n;
    }
  },
  computeTangents: function () {
    if (this.attributes['index'] === undefined || this.attributes['position'] === undefined || this.attributes['normal'] === undefined || this.attributes['uv'] === undefined) {
      console.warn('Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');
      return;
    }
    var indices = this.attributes['index'].array;
    var positions = this.attributes['position'].array;
    var normals = this.attributes['normal'].array;
    var uvs = this.attributes['uv'].array;
    var nVertices = positions.length / 3;
    if (this.attributes['tangent'] === undefined) {
      var nTangentElements = 4 * nVertices;
      this.attributes['tangent'] = {
        itemSize: 4,
        array: new Float32Array(nTangentElements)
      };
    }
    var tangents = this.attributes['tangent'].array;
    var tan1 = [], tan2 = [];
    for (var k = 0; k < nVertices; k++) {
      tan1[k] = new THREE.Vector3();
      tan2[k] = new THREE.Vector3();
    }
    var xA, yA, zA, xB, yB, zB, xC, yC, zC, uA, vA, uB, vB, uC, vC, x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r;
    var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();
    function handleTriangle(a, b, c) {
      xA = positions[a * 3];
      yA = positions[a * 3 + 1];
      zA = positions[a * 3 + 2];
      xB = positions[b * 3];
      yB = positions[b * 3 + 1];
      zB = positions[b * 3 + 2];
      xC = positions[c * 3];
      yC = positions[c * 3 + 1];
      zC = positions[c * 3 + 2];
      uA = uvs[a * 2];
      vA = uvs[a * 2 + 1];
      uB = uvs[b * 2];
      vB = uvs[b * 2 + 1];
      uC = uvs[c * 2];
      vC = uvs[c * 2 + 1];
      x1 = xB - xA;
      x2 = xC - xA;
      y1 = yB - yA;
      y2 = yC - yA;
      z1 = zB - zA;
      z2 = zC - zA;
      s1 = uB - uA;
      s2 = uC - uA;
      t1 = vB - vA;
      t2 = vC - vA;
      r = 1 / (s1 * t2 - s2 * t1);
      sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    var i, il;
    var j, jl;
    var iA, iB, iC;
    var offsets = this.offsets;
    for (j = 0, jl = offsets.length; j < jl; ++j) {
      var start = offsets[j].start;
      var count = offsets[j].count;
      var index = offsets[j].index;
      for (i = start, il = start + count; i < il; i += 3) {
        iA = index + indices[i];
        iB = index + indices[i + 1];
        iC = index + indices[i + 2];
        handleTriangle(iA, iB, iC);
      }
    }
    var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
    var n = new THREE.Vector3(), n2 = new THREE.Vector3();
    var w, t, test;
    function handleVertex(v) {
      n.x = normals[v * 3];
      n.y = normals[v * 3 + 1];
      n.z = normals[v * 3 + 2];
      n2.copy(n);
      t = tan1[v];
      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp2.crossVectors(n2, t);
      test = tmp2.dot(tan2[v]);
      w = test < 0 ? -1 : 1;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }
    for (j = 0, jl = offsets.length; j < jl; ++j) {
      var start = offsets[j].start;
      var count = offsets[j].count;
      var index = offsets[j].index;
      for (i = start, il = start + count; i < il; i += 3) {
        iA = index + indices[i];
        iB = index + indices[i + 1];
        iC = index + indices[i + 2];
        handleVertex(iA);
        handleVertex(iB);
        handleVertex(iC);
      }
    }
    this.hasTangents = true;
    this.tangentsNeedUpdate = true;
  },
  clone: function () {
    var geometry = new THREE.BufferGeometry();
    var types = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ];
    for (var attr in this.attributes) {
      var sourceAttr = this.attributes[attr];
      var sourceArray = sourceAttr.array;
      var attribute = {
          itemSize: sourceAttr.itemSize,
          numItems: sourceAttr.numItems,
          array: null
        };
      for (var i = 0, il = types.length; i < il; i++) {
        var type = types[i];
        if (sourceArray instanceof type) {
          attribute.array = new type(sourceArray);
          break;
        }
      }
      geometry.attributes[attr] = attribute;
    }
    for (var i = 0, il = this.offsets.length; i < il; i++) {
      var offset = this.offsets[i];
      geometry.offsets.push({
        start: offset.start,
        index: offset.index,
        count: offset.count
      });
    }
    return geometry;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Camera = function () {
  THREE.Object3D.call(this);
  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();
  this.projectionMatrixInverse = new THREE.Matrix4();
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.lookAt = function () {
  var m1 = new THREE.Matrix4();
  return function (vector) {
    m1.lookAt(this.position, vector, this.up);
    this.quaternion.setFromRotationMatrix(m1);
  };
}();
THREE.Camera.prototype.clone = function (camera) {
  if (camera === undefined)
    camera = new THREE.Camera();
  THREE.Object3D.prototype.clone.call(this, camera);
  camera.matrixWorldInverse.copy(this.matrixWorldInverse);
  camera.projectionMatrix.copy(this.projectionMatrix);
  camera.projectionMatrixInverse.copy(this.projectionMatrixInverse);
  return camera;
};
THREE.OrthographicCamera = function (left, right, top, bottom, near, far) {
  THREE.Camera.call(this);
  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
  this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
};
THREE.OrthographicCamera.prototype.clone = function () {
  var camera = new THREE.OrthographicCamera();
  THREE.Camera.prototype.clone.call(this, camera);
  camera.left = this.left;
  camera.right = this.right;
  camera.top = this.top;
  camera.bottom = this.bottom;
  camera.near = this.near;
  camera.far = this.far;
  return camera;
};
THREE.PerspectiveCamera = function (fov, aspect, near, far) {
  THREE.Camera.call(this);
  this.fov = fov !== undefined ? fov : 50;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.setLens = function (focalLength, frameHeight) {
  if (frameHeight === undefined)
    frameHeight = 24;
  this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
  this.fullWidth = fullWidth;
  this.fullHeight = fullHeight;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
  if (this.fullWidth) {
    var aspect = this.fullWidth / this.fullHeight;
    var top = Math.tan(THREE.Math.degToRad(this.fov * 0.5)) * this.near;
    var bottom = -top;
    var left = aspect * bottom;
    var right = aspect * top;
    var width = Math.abs(right - left);
    var height = Math.abs(top - bottom);
    this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);
  } else {
    this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
  }
};
THREE.PerspectiveCamera.prototype.clone = function () {
  var camera = new THREE.PerspectiveCamera();
  THREE.Camera.prototype.clone.call(this, camera);
  camera.fov = this.fov;
  camera.aspect = this.aspect;
  camera.near = this.near;
  camera.far = this.far;
  return camera;
};
THREE.Light = function (hex) {
  THREE.Object3D.call(this);
  this.color = new THREE.Color(hex);
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.clone = function (light) {
  if (light === undefined)
    light = new THREE.Light();
  THREE.Object3D.prototype.clone.call(this, light);
  light.color.copy(this.color);
  return light;
};
THREE.AmbientLight = function (hex) {
  THREE.Light.call(this, hex);
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.clone = function () {
  var light = new THREE.AmbientLight();
  THREE.Light.prototype.clone.call(this, light);
  return light;
};
THREE.AreaLight = function (hex, intensity) {
  THREE.Light.call(this, hex);
  this.normal = new THREE.Vector3(0, -1, 0);
  this.right = new THREE.Vector3(1, 0, 0);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.width = 1;
  this.height = 1;
  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;
};
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight = function (hex, intensity) {
  THREE.Light.call(this, hex);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = intensity !== undefined ? intensity : 1;
  this.castShadow = false;
  this.onlyShadow = false;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraLeft = -500;
  this.shadowCameraRight = 500;
  this.shadowCameraTop = 500;
  this.shadowCameraBottom = -500;
  this.shadowCameraVisible = false;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;
  this.shadowCascade = false;
  this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1000);
  this.shadowCascadeCount = 2;
  this.shadowCascadeBias = [
    0,
    0,
    0
  ];
  this.shadowCascadeWidth = [
    512,
    512,
    512
  ];
  this.shadowCascadeHeight = [
    512,
    512,
    512
  ];
  this.shadowCascadeNearZ = [
    -1,
    0.99,
    0.998
  ];
  this.shadowCascadeFarZ = [
    0.99,
    0.998,
    1
  ];
  this.shadowCascadeArray = [];
  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone = function () {
  var light = new THREE.DirectionalLight();
  THREE.Light.prototype.clone.call(this, light);
  light.target = this.target.clone();
  light.intensity = this.intensity;
  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;
  return light;
};
THREE.HemisphereLight = function (skyColorHex, groundColorHex, intensity) {
  THREE.Light.call(this, skyColorHex);
  this.position.set(0, 100, 0);
  this.groundColor = new THREE.Color(groundColorHex);
  this.intensity = intensity !== undefined ? intensity : 1;
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.clone = function () {
  var light = new THREE.HemisphereLight();
  THREE.Light.prototype.clone.call(this, light);
  light.groundColor.copy(this.groundColor);
  light.intensity = this.intensity;
  return light;
};
THREE.PointLight = function (hex, intensity, distance) {
  THREE.Light.call(this, hex);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.distance = distance !== undefined ? distance : 0;
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.clone = function () {
  var light = new THREE.PointLight();
  THREE.Light.prototype.clone.call(this, light);
  light.intensity = this.intensity;
  light.distance = this.distance;
  return light;
};
THREE.SpotLight = function (hex, intensity, distance, angle, exponent) {
  THREE.Light.call(this, hex);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = intensity !== undefined ? intensity : 1;
  this.distance = distance !== undefined ? distance : 0;
  this.angle = angle !== undefined ? angle : Math.PI / 3;
  this.exponent = exponent !== undefined ? exponent : 10;
  this.castShadow = false;
  this.onlyShadow = false;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraFov = 50;
  this.shadowCameraVisible = false;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;
  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone = function () {
  var light = new THREE.SpotLight();
  THREE.Light.prototype.clone.call(this, light);
  light.target = this.target.clone();
  light.intensity = this.intensity;
  light.distance = this.distance;
  light.angle = this.angle;
  light.exponent = this.exponent;
  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;
  return light;
};
THREE.Loader = function (showStatus) {
  this.showStatus = showStatus;
  this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
};
THREE.Loader.prototype = {
  constructor: THREE.Loader,
  crossOrigin: 'anonymous',
  addStatusElement: function () {
    var e = document.createElement('div');
    e.style.position = 'absolute';
    e.style.right = '0px';
    e.style.top = '0px';
    e.style.fontSize = '0.8em';
    e.style.textAlign = 'left';
    e.style.background = 'rgba(0,0,0,0.25)';
    e.style.color = '#fff';
    e.style.width = '120px';
    e.style.padding = '0.5em 0.5em 0.5em 0.5em';
    e.style.zIndex = 1000;
    e.innerHTML = 'Loading ...';
    return e;
  },
  updateProgress: function (progress) {
    var message = 'Loaded ';
    if (progress.total) {
      message += (100 * progress.loaded / progress.total).toFixed(0) + '%';
    } else {
      message += (progress.loaded / 1000).toFixed(2) + ' KB';
    }
    this.statusDomElement.innerHTML = message;
  },
  extractUrlBase: function (url) {
    var parts = url.split('/');
    parts.pop();
    return (parts.length < 1 ? '.' : parts.join('/')) + '/';
  },
  initMaterials: function (materials, texturePath) {
    var array = [];
    for (var i = 0; i < materials.length; ++i) {
      array[i] = THREE.Loader.prototype.createMaterial(materials[i], texturePath);
    }
    return array;
  },
  needsTangents: function (materials) {
    for (var i = 0, il = materials.length; i < il; i++) {
      var m = materials[i];
      if (m instanceof THREE.ShaderMaterial)
        return true;
    }
    return false;
  },
  createMaterial: function (m, texturePath) {
    var _this = this;
    function is_pow2(n) {
      var l = Math.log(n) / Math.LN2;
      return Math.floor(l) == l;
    }
    function nearest_pow2(n) {
      var l = Math.log(n) / Math.LN2;
      return Math.pow(2, Math.round(l));
    }
    function load_image(where, url) {
      var image = new Image();
      image.onload = function () {
        if (!is_pow2(this.width) || !is_pow2(this.height)) {
          var width = nearest_pow2(this.width);
          var height = nearest_pow2(this.height);
          where.image.width = width;
          where.image.height = height;
          where.image.getContext('2d').drawImage(this, 0, 0, width, height);
        } else {
          where.image = this;
        }
        where.needsUpdate = true;
      };
      image.crossOrigin = _this.crossOrigin;
      image.src = url;
    }
    function create_texture(where, name, sourceFile, repeat, offset, wrap, anisotropy) {
      var isCompressed = /\.dds$/i.test(sourceFile);
      var fullPath = texturePath + '/' + sourceFile;
      if (isCompressed) {
        var texture = THREE.ImageUtils.loadCompressedTexture(fullPath);
        where[name] = texture;
      } else {
        var texture = document.createElement('canvas');
        where[name] = new THREE.Texture(texture);
      }
      where[name].sourceFile = sourceFile;
      if (repeat) {
        where[name].repeat.set(repeat[0], repeat[1]);
        if (repeat[0] !== 1)
          where[name].wrapS = THREE.RepeatWrapping;
        if (repeat[1] !== 1)
          where[name].wrapT = THREE.RepeatWrapping;
      }
      if (offset) {
        where[name].offset.set(offset[0], offset[1]);
      }
      if (wrap) {
        var wrapMap = {
            'repeat': THREE.RepeatWrapping,
            'mirror': THREE.MirroredRepeatWrapping
          };
        if (wrapMap[wrap[0]] !== undefined)
          where[name].wrapS = wrapMap[wrap[0]];
        if (wrapMap[wrap[1]] !== undefined)
          where[name].wrapT = wrapMap[wrap[1]];
      }
      if (anisotropy) {
        where[name].anisotropy = anisotropy;
      }
      if (!isCompressed) {
        load_image(where[name], fullPath);
      }
    }
    function rgb2hex(rgb) {
      return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;
    }
    var mtype = 'MeshLambertMaterial';
    var mpars = {
        color: 15658734,
        opacity: 1,
        map: null,
        lightMap: null,
        normalMap: null,
        bumpMap: null,
        wireframe: false
      };
    if (m.shading) {
      var shading = m.shading.toLowerCase();
      if (shading === 'phong')
        mtype = 'MeshPhongMaterial';
      else if (shading === 'basic')
        mtype = 'MeshBasicMaterial';
    }
    if (m.blending !== undefined && THREE[m.blending] !== undefined) {
      mpars.blending = THREE[m.blending];
    }
    if (m.transparent !== undefined || m.opacity < 1) {
      mpars.transparent = m.transparent;
    }
    if (m.depthTest !== undefined) {
      mpars.depthTest = m.depthTest;
    }
    if (m.depthWrite !== undefined) {
      mpars.depthWrite = m.depthWrite;
    }
    if (m.visible !== undefined) {
      mpars.visible = m.visible;
    }
    if (m.flipSided !== undefined) {
      mpars.side = THREE.BackSide;
    }
    if (m.doubleSided !== undefined) {
      mpars.side = THREE.DoubleSide;
    }
    if (m.wireframe !== undefined) {
      mpars.wireframe = m.wireframe;
    }
    if (m.vertexColors !== undefined) {
      if (m.vertexColors === 'face') {
        mpars.vertexColors = THREE.FaceColors;
      } else if (m.vertexColors) {
        mpars.vertexColors = THREE.VertexColors;
      }
    }
    if (m.colorDiffuse) {
      mpars.color = rgb2hex(m.colorDiffuse);
    } else if (m.DbgColor) {
      mpars.color = m.DbgColor;
    }
    if (m.colorSpecular) {
      mpars.specular = rgb2hex(m.colorSpecular);
    }
    if (m.colorAmbient) {
      mpars.ambient = rgb2hex(m.colorAmbient);
    }
    if (m.transparency) {
      mpars.opacity = m.transparency;
    }
    if (m.specularCoef) {
      mpars.shininess = m.specularCoef;
    }
    if (m.mapDiffuse && texturePath) {
      create_texture(mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
    }
    if (m.mapLight && texturePath) {
      create_texture(mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
    }
    if (m.mapBump && texturePath) {
      create_texture(mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
    }
    if (m.mapNormal && texturePath) {
      create_texture(mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
    }
    if (m.mapSpecular && texturePath) {
      create_texture(mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
    }
    if (m.mapBumpScale) {
      mpars.bumpScale = m.mapBumpScale;
    }
    if (m.mapNormal) {
      var shader = THREE.ShaderLib['normalmap'];
      var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      uniforms['tNormal'].value = mpars.normalMap;
      if (m.mapNormalFactor) {
        uniforms['uNormalScale'].value.set(m.mapNormalFactor, m.mapNormalFactor);
      }
      if (mpars.map) {
        uniforms['tDiffuse'].value = mpars.map;
        uniforms['enableDiffuse'].value = true;
      }
      if (mpars.specularMap) {
        uniforms['tSpecular'].value = mpars.specularMap;
        uniforms['enableSpecular'].value = true;
      }
      if (mpars.lightMap) {
        uniforms['tAO'].value = mpars.lightMap;
        uniforms['enableAO'].value = true;
      }
      uniforms['uDiffuseColor'].value.setHex(mpars.color);
      uniforms['uSpecularColor'].value.setHex(mpars.specular);
      uniforms['uAmbientColor'].value.setHex(mpars.ambient);
      uniforms['uShininess'].value = mpars.shininess;
      if (mpars.opacity !== undefined) {
        uniforms['uOpacity'].value = mpars.opacity;
      }
      var parameters = {
          fragmentShader: shader.fragmentShader,
          vertexShader: shader.vertexShader,
          uniforms: uniforms,
          lights: true,
          fog: true
        };
      var material = new THREE.ShaderMaterial(parameters);
      if (mpars.transparent) {
        material.transparent = true;
      }
    } else {
      var material = new THREE[mtype](mpars);
    }
    if (m.DbgName !== undefined)
      material.name = m.DbgName;
    return material;
  }
};
THREE.XHRLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.XHRLoader.prototype = {
  constructor: THREE.XHRLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var request = new XMLHttpRequest();
    if (onLoad !== undefined) {
      request.addEventListener('load', function (event) {
        onLoad(event.target.responseText);
        scope.manager.itemEnd(url);
      }, false);
    }
    if (onProgress !== undefined) {
      request.addEventListener('progress', function (event) {
        onProgress(event);
      }, false);
    }
    if (onError !== undefined) {
      request.addEventListener('error', function (event) {
        onError(event);
      }, false);
    }
    if (this.crossOrigin !== undefined)
      request.crossOrigin = this.crossOrigin;
    request.open('GET', url, true);
    request.send(null);
    scope.manager.itemStart(url);
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  }
};
THREE.ImageLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.ImageLoader.prototype = {
  constructor: THREE.ImageLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var image = document.createElement('img');
    if (onLoad !== undefined) {
      image.addEventListener('load', function (event) {
        scope.manager.itemEnd(url);
        onLoad(this);
      }, false);
    }
    if (onProgress !== undefined) {
      image.addEventListener('progress', function (event) {
        onProgress(event);
      }, false);
    }
    if (onError !== undefined) {
      image.addEventListener('error', function (event) {
        onError(event);
      }, false);
    }
    if (this.crossOrigin !== undefined)
      image.crossOrigin = this.crossOrigin;
    image.src = url;
    scope.manager.itemStart(url);
    return image;
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  }
};
THREE.JSONLoader = function (showStatus) {
  THREE.Loader.call(this, showStatus);
  this.withCredentials = false;
};
THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
THREE.JSONLoader.prototype.load = function (url, callback, texturePath) {
  var scope = this;
  texturePath = texturePath && typeof texturePath === 'string' ? texturePath : this.extractUrlBase(url);
  this.onLoadStart();
  this.loadAjaxJSON(this, url, callback, texturePath);
};
THREE.JSONLoader.prototype.loadAjaxJSON = function (context, url, callback, texturePath, callbackProgress) {
  var xhr = new XMLHttpRequest();
  var length = 0;
  xhr.onreadystatechange = function () {
    if (xhr.readyState === xhr.DONE) {
      if (xhr.status === 200 || xhr.status === 0) {
        if (xhr.responseText) {
          var json = JSON.parse(xhr.responseText);
          var result = context.parse(json, texturePath);
          callback(result.geometry, result.materials);
        } else {
          console.warn('THREE.JSONLoader: [' + url + '] seems to be unreachable or file there is empty');
        }
        context.onLoadComplete();
      } else {
        console.error('THREE.JSONLoader: Couldn\'t load [' + url + '] [' + xhr.status + ']');
      }
    } else if (xhr.readyState === xhr.LOADING) {
      if (callbackProgress) {
        if (length === 0) {
          length = xhr.getResponseHeader('Content-Length');
        }
        callbackProgress({
          total: length,
          loaded: xhr.responseText.length
        });
      }
    } else if (xhr.readyState === xhr.HEADERS_RECEIVED) {
      if (callbackProgress !== undefined) {
        length = xhr.getResponseHeader('Content-Length');
      }
    }
  };
  xhr.open('GET', url, true);
  xhr.withCredentials = this.withCredentials;
  xhr.send(null);
};
THREE.JSONLoader.prototype.parse = function (json, texturePath) {
  var scope = this, geometry = new THREE.Geometry(), scale = json.scale !== undefined ? 1 / json.scale : 1;
  parseModel(scale);
  parseSkin();
  parseMorphing(scale);
  geometry.computeCentroids();
  geometry.computeFaceNormals();
  geometry.computeBoundingSphere();
  function parseModel(scale) {
    function isBitSet(value, position) {
      return value & 1 << position;
    }
    var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, color, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
    if (json.uvs !== undefined) {
      for (i = 0; i < json.uvs.length; i++) {
        if (json.uvs[i].length)
          nUvLayers++;
      }
      for (i = 0; i < nUvLayers; i++) {
        geometry.faceVertexUvs[i] = [];
      }
    }
    offset = 0;
    zLength = vertices.length;
    while (offset < zLength) {
      vertex = new THREE.Vector3();
      vertex.x = vertices[offset++] * scale;
      vertex.y = vertices[offset++] * scale;
      vertex.z = vertices[offset++] * scale;
      geometry.vertices.push(vertex);
    }
    offset = 0;
    zLength = faces.length;
    while (offset < zLength) {
      type = faces[offset++];
      isQuad = isBitSet(type, 0);
      hasMaterial = isBitSet(type, 1);
      hasFaceVertexUv = isBitSet(type, 3);
      hasFaceNormal = isBitSet(type, 4);
      hasFaceVertexNormal = isBitSet(type, 5);
      hasFaceColor = isBitSet(type, 6);
      hasFaceVertexColor = isBitSet(type, 7);
      if (isQuad) {
        faceA = new THREE.Face3();
        faceA.a = faces[offset];
        faceA.b = faces[offset + 1];
        faceA.c = faces[offset + 3];
        faceB = new THREE.Face3();
        faceB.a = faces[offset + 1];
        faceB.b = faces[offset + 2];
        faceB.c = faces[offset + 3];
        offset += 4;
        if (hasMaterial) {
          materialIndex = faces[offset++];
          faceA.materialIndex = materialIndex;
          faceB.materialIndex = materialIndex;
        }
        fi = geometry.faces.length;
        if (hasFaceVertexUv) {
          for (i = 0; i < nUvLayers; i++) {
            uvLayer = json.uvs[i];
            geometry.faceVertexUvs[i][fi] = [];
            geometry.faceVertexUvs[i][fi + 1] = [];
            for (j = 0; j < 4; j++) {
              uvIndex = faces[offset++];
              u = uvLayer[uvIndex * 2];
              v = uvLayer[uvIndex * 2 + 1];
              uv = new THREE.Vector2(u, v);
              if (j !== 2)
                geometry.faceVertexUvs[i][fi].push(uv);
              if (j !== 0)
                geometry.faceVertexUvs[i][fi + 1].push(uv);
            }
          }
        }
        if (hasFaceNormal) {
          normalIndex = faces[offset++] * 3;
          faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
          faceB.normal.copy(faceA.normal);
        }
        if (hasFaceVertexNormal) {
          for (i = 0; i < 4; i++) {
            normalIndex = faces[offset++] * 3;
            normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            if (i !== 2)
              faceA.vertexNormals.push(normal);
            if (i !== 0)
              faceB.vertexNormals.push(normal);
          }
        }
        if (hasFaceColor) {
          colorIndex = faces[offset++];
          hex = colors[colorIndex];
          faceA.color.setHex(hex);
          faceB.color.setHex(hex);
        }
        if (hasFaceVertexColor) {
          for (i = 0; i < 4; i++) {
            colorIndex = faces[offset++];
            hex = colors[colorIndex];
            if (i !== 2)
              faceA.vertexColors.push(new THREE.Color(hex));
            if (i !== 0)
              faceB.vertexColors.push(new THREE.Color(hex));
          }
        }
        geometry.faces.push(faceA);
        geometry.faces.push(faceB);
      } else {
        face = new THREE.Face3();
        face.a = faces[offset++];
        face.b = faces[offset++];
        face.c = faces[offset++];
        if (hasMaterial) {
          materialIndex = faces[offset++];
          face.materialIndex = materialIndex;
        }
        fi = geometry.faces.length;
        if (hasFaceVertexUv) {
          for (i = 0; i < nUvLayers; i++) {
            uvLayer = json.uvs[i];
            geometry.faceVertexUvs[i][fi] = [];
            for (j = 0; j < 3; j++) {
              uvIndex = faces[offset++];
              u = uvLayer[uvIndex * 2];
              v = uvLayer[uvIndex * 2 + 1];
              uv = new THREE.Vector2(u, v);
              geometry.faceVertexUvs[i][fi].push(uv);
            }
          }
        }
        if (hasFaceNormal) {
          normalIndex = faces[offset++] * 3;
          face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
        }
        if (hasFaceVertexNormal) {
          for (i = 0; i < 3; i++) {
            normalIndex = faces[offset++] * 3;
            normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            face.vertexNormals.push(normal);
          }
        }
        if (hasFaceColor) {
          colorIndex = faces[offset++];
          face.color.setHex(colors[colorIndex]);
        }
        if (hasFaceVertexColor) {
          for (i = 0; i < 3; i++) {
            colorIndex = faces[offset++];
            face.vertexColors.push(new THREE.Color(colors[colorIndex]));
          }
        }
        geometry.faces.push(face);
      }
    }
  }
  ;
  function parseSkin() {
    var i, l, x, y, z, w, a, b, c, d;
    if (json.skinWeights) {
      for (i = 0, l = json.skinWeights.length; i < l; i += 2) {
        x = json.skinWeights[i];
        y = json.skinWeights[i + 1];
        z = 0;
        w = 0;
        geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
      }
    }
    if (json.skinIndices) {
      for (i = 0, l = json.skinIndices.length; i < l; i += 2) {
        a = json.skinIndices[i];
        b = json.skinIndices[i + 1];
        c = 0;
        d = 0;
        geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
      }
    }
    geometry.bones = json.bones;
    geometry.animation = json.animation;
    geometry.animations = json.animations;
  }
  ;
  function parseMorphing(scale) {
    if (json.morphTargets !== undefined) {
      var i, l, v, vl, dstVertices, srcVertices;
      for (i = 0, l = json.morphTargets.length; i < l; i++) {
        geometry.morphTargets[i] = {};
        geometry.morphTargets[i].name = json.morphTargets[i].name;
        geometry.morphTargets[i].vertices = [];
        dstVertices = geometry.morphTargets[i].vertices;
        srcVertices = json.morphTargets[i].vertices;
        for (v = 0, vl = srcVertices.length; v < vl; v += 3) {
          var vertex = new THREE.Vector3();
          vertex.x = srcVertices[v] * scale;
          vertex.y = srcVertices[v + 1] * scale;
          vertex.z = srcVertices[v + 2] * scale;
          dstVertices.push(vertex);
        }
      }
    }
    if (json.morphColors !== undefined) {
      var i, l, c, cl, dstColors, srcColors, color;
      for (i = 0, l = json.morphColors.length; i < l; i++) {
        geometry.morphColors[i] = {};
        geometry.morphColors[i].name = json.morphColors[i].name;
        geometry.morphColors[i].colors = [];
        dstColors = geometry.morphColors[i].colors;
        srcColors = json.morphColors[i].colors;
        for (c = 0, cl = srcColors.length; c < cl; c += 3) {
          color = new THREE.Color(16755200);
          color.setRGB(srcColors[c], srcColors[c + 1], srcColors[c + 2]);
          dstColors.push(color);
        }
      }
    }
  }
  ;
  if (json.materials === undefined) {
    return { geometry: geometry };
  } else {
    var materials = this.initMaterials(json.materials, texturePath);
    if (this.needsTangents(materials)) {
      geometry.computeTangents();
    }
    return {
      geometry: geometry,
      materials: materials
    };
  }
};
THREE.LoadingManager = function (onLoad, onProgress, onError) {
  var scope = this;
  var loaded = 0, total = 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function (url) {
    total++;
  };
  this.itemEnd = function (url) {
    loaded++;
    if (scope.onProgress !== undefined) {
      scope.onProgress(url, loaded, total);
    }
    if (loaded === total && scope.onLoad !== undefined) {
      scope.onLoad();
    }
  };
};
THREE.DefaultLoadingManager = new THREE.LoadingManager();
THREE.BufferGeometryLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.BufferGeometryLoader.prototype = {
  constructor: THREE.BufferGeometryLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader();
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  parse: function (json) {
    var geometry = new THREE.BufferGeometry();
    var attributes = json.attributes;
    var offsets = json.offsets;
    var boundingSphere = json.boundingSphere;
    for (var key in attributes) {
      var attribute = attributes[key];
      geometry.attributes[key] = {
        itemSize: attribute.itemSize,
        array: new self[attribute.type](attribute.array)
      };
    }
    if (offsets !== undefined) {
      geometry.offsets = JSON.parse(JSON.stringify(offsets));
    }
    if (boundingSphere !== undefined) {
      geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3().fromArray(boundingSphere.center !== undefined ? boundingSphere.center : [
        0,
        0,
        0
      ]), boundingSphere.radius);
    }
    return geometry;
  }
};
THREE.GeometryLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.GeometryLoader.prototype = {
  constructor: THREE.GeometryLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader();
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  parse: function (json) {
  }
};
THREE.MaterialLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.MaterialLoader.prototype = {
  constructor: THREE.MaterialLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader();
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  parse: function (json) {
    var material = new THREE[json.type]();
    if (json.color !== undefined)
      material.color.setHex(json.color);
    if (json.ambient !== undefined)
      material.ambient.setHex(json.ambient);
    if (json.emissive !== undefined)
      material.emissive.setHex(json.emissive);
    if (json.specular !== undefined)
      material.specular.setHex(json.specular);
    if (json.shininess !== undefined)
      material.shininess = json.shininess;
    if (json.vertexColors !== undefined)
      material.vertexColors = json.vertexColors;
    if (json.blending !== undefined)
      material.blending = json.blending;
    if (json.opacity !== undefined)
      material.opacity = json.opacity;
    if (json.transparent !== undefined)
      material.transparent = json.transparent;
    if (json.wireframe !== undefined)
      material.wireframe = json.wireframe;
    if (json.materials !== undefined) {
      for (var i = 0, l = json.materials.length; i < l; i++) {
        material.materials.push(this.parse(json.materials[i]));
      }
    }
    return material;
  }
};
THREE.ObjectLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.ObjectLoader.prototype = {
  constructor: THREE.ObjectLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader(scope.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  parse: function (json) {
    var geometries = this.parseGeometries(json.geometries);
    var materials = this.parseMaterials(json.materials);
    var object = this.parseObject(json.object, geometries, materials);
    return object;
  },
  parseGeometries: function (json) {
    var geometries = {};
    if (json !== undefined) {
      var geometryLoader = new THREE.JSONLoader();
      var bufferGeometryLoader = new THREE.BufferGeometryLoader();
      for (var i = 0, l = json.length; i < l; i++) {
        var geometry;
        var data = json[i];
        switch (data.type) {
        case 'PlaneGeometry':
          geometry = new THREE.PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
          break;
        case 'CircleGeometry':
          geometry = new THREE.CircleGeometry(data.radius, data.segments);
          break;
        case 'CubeGeometry':
          geometry = new THREE.CubeGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
          break;
        case 'CylinderGeometry':
          geometry = new THREE.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radiusSegments, data.heightSegments, data.openEnded);
          break;
        case 'SphereGeometry':
          geometry = new THREE.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
          break;
        case 'IcosahedronGeometry':
          geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);
          break;
        case 'TorusGeometry':
          geometry = new THREE.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
          break;
        case 'TorusKnotGeometry':
          geometry = new THREE.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);
          break;
        case 'BufferGeometry':
          geometry = bufferGeometryLoader.parse(data.data);
          break;
        case 'Geometry':
          geometry = geometryLoader.parse(data.data).geometry;
          break;
        }
        geometry.uuid = data.uuid;
        if (data.name !== undefined)
          geometry.name = data.name;
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  },
  parseMaterials: function (json) {
    var materials = {};
    if (json !== undefined) {
      var loader = new THREE.MaterialLoader();
      for (var i = 0, l = json.length; i < l; i++) {
        var data = json[i];
        var material = loader.parse(data);
        material.uuid = data.uuid;
        if (data.name !== undefined)
          material.name = data.name;
        materials[data.uuid] = material;
      }
    }
    return materials;
  },
  parseObject: function () {
    var matrix = new THREE.Matrix4();
    return function (data, geometries, materials) {
      var object;
      switch (data.type) {
      case 'Scene':
        object = new THREE.Scene();
        break;
      case 'PerspectiveCamera':
        object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        break;
      case 'OrthographicCamera':
        object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        break;
      case 'AmbientLight':
        object = new THREE.AmbientLight(data.color);
        break;
      case 'DirectionalLight':
        object = new THREE.DirectionalLight(data.color, data.intensity);
        break;
      case 'PointLight':
        object = new THREE.PointLight(data.color, data.intensity, data.distance);
        break;
      case 'SpotLight':
        object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent);
        break;
      case 'HemisphereLight':
        object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case 'Mesh':
        var geometry = geometries[data.geometry];
        var material = materials[data.material];
        if (geometry === undefined) {
          console.error('THREE.ObjectLoader: Undefined geometry ' + data.geometry);
        }
        if (material === undefined) {
          console.error('THREE.ObjectLoader: Undefined material ' + data.material);
        }
        object = new THREE.Mesh(geometry, material);
        break;
      default:
        object = new THREE.Object3D();
      }
      object.uuid = data.uuid;
      if (data.name !== undefined)
        object.name = data.name;
      if (data.matrix !== undefined) {
        matrix.fromArray(data.matrix);
        matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        if (data.position !== undefined)
          object.position.fromArray(data.position);
        if (data.rotation !== undefined)
          object.rotation.fromArray(data.rotation);
        if (data.scale !== undefined)
          object.scale.fromArray(data.scale);
      }
      if (data.visible !== undefined)
        object.visible = data.visible;
      if (data.userData !== undefined)
        object.userData = data.userData;
      if (data.children !== undefined) {
        for (var child in data.children) {
          object.add(this.parseObject(data.children[child], geometries, materials));
        }
      }
      return object;
    };
  }()
};
THREE.SceneLoader = function () {
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
  this.callbackSync = function () {
  };
  this.callbackProgress = function () {
  };
  this.geometryHandlers = {};
  this.hierarchyHandlers = {};
  this.addGeometryHandler('ascii', THREE.JSONLoader);
};
THREE.SceneLoader.prototype = {
  constructor: THREE.SceneLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader(scope.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      scope.parse(JSON.parse(text), onLoad, url);
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  addGeometryHandler: function (typeID, loaderClass) {
    this.geometryHandlers[typeID] = { 'loaderClass': loaderClass };
  },
  addHierarchyHandler: function (typeID, loaderClass) {
    this.hierarchyHandlers[typeID] = { 'loaderClass': loaderClass };
  },
  parse: function (json, callbackFinished, url) {
    var scope = this;
    var urlBase = THREE.Loader.prototype.extractUrlBase(url);
    var geometry, material, camera, fog, texture, images, color, light, hex, intensity, counter_models, counter_textures, total_models, total_textures, result;
    var target_array = [];
    var data = json;
    for (var typeID in this.geometryHandlers) {
      var loaderClass = this.geometryHandlers[typeID]['loaderClass'];
      this.geometryHandlers[typeID]['loaderObject'] = new loaderClass();
    }
    for (var typeID in this.hierarchyHandlers) {
      var loaderClass = this.hierarchyHandlers[typeID]['loaderClass'];
      this.hierarchyHandlers[typeID]['loaderObject'] = new loaderClass();
    }
    counter_models = 0;
    counter_textures = 0;
    result = {
      scene: new THREE.Scene(),
      geometries: {},
      face_materials: {},
      materials: {},
      textures: {},
      objects: {},
      cameras: {},
      lights: {},
      fogs: {},
      empties: {},
      groups: {}
    };
    if (data.transform) {
      var position = data.transform.position, rotation = data.transform.rotation, scale = data.transform.scale;
      if (position) {
        result.scene.position.fromArray(position);
      }
      if (rotation) {
        result.scene.rotation.fromArray(rotation);
      }
      if (scale) {
        result.scene.scale.fromArray(scale);
      }
      if (position || rotation || scale) {
        result.scene.updateMatrix();
        result.scene.updateMatrixWorld();
      }
    }
    function get_url(source_url, url_type) {
      if (url_type == 'relativeToHTML') {
        return source_url;
      } else {
        return urlBase + '/' + source_url;
      }
    }
    ;
    function handle_objects() {
      handle_children(result.scene, data.objects);
    }
    function handle_children(parent, children) {
      var mat, dst, pos, rot, scl, quat;
      for (var objID in children) {
        var object = result.objects[objID];
        var objJSON = children[objID];
        if (object === undefined) {
          if (objJSON.type && objJSON.type in scope.hierarchyHandlers) {
            if (objJSON.loading === undefined) {
              var reservedTypes = {
                  'type': 1,
                  'url': 1,
                  'material': 1,
                  'position': 1,
                  'rotation': 1,
                  'scale': 1,
                  'visible': 1,
                  'children': 1,
                  'userData': 1,
                  'skin': 1,
                  'morph': 1,
                  'mirroredLoop': 1,
                  'duration': 1
                };
              var loaderParameters = {};
              for (var parType in objJSON) {
                if (!(parType in reservedTypes)) {
                  loaderParameters[parType] = objJSON[parType];
                }
              }
              material = result.materials[objJSON.material];
              objJSON.loading = true;
              var loader = scope.hierarchyHandlers[objJSON.type]['loaderObject'];
              if (loader.options) {
                loader.load(get_url(objJSON.url, data.urlBaseType), create_callback_hierachy(objID, parent, material, objJSON));
              } else {
                loader.load(get_url(objJSON.url, data.urlBaseType), create_callback_hierachy(objID, parent, material, objJSON), loaderParameters);
              }
            }
          } else if (objJSON.geometry !== undefined) {
            geometry = result.geometries[objJSON.geometry];
            if (geometry) {
              var needsTangents = false;
              material = result.materials[objJSON.material];
              needsTangents = material instanceof THREE.ShaderMaterial;
              pos = objJSON.position;
              rot = objJSON.rotation;
              scl = objJSON.scale;
              mat = objJSON.matrix;
              quat = objJSON.quaternion;
              if (!objJSON.material) {
                material = new THREE.MeshFaceMaterial(result.face_materials[objJSON.geometry]);
              }
              if (material instanceof THREE.MeshFaceMaterial && material.materials.length === 0) {
                material = new THREE.MeshFaceMaterial(result.face_materials[objJSON.geometry]);
              }
              if (material instanceof THREE.MeshFaceMaterial) {
                for (var i = 0; i < material.materials.length; i++) {
                  needsTangents = needsTangents || material.materials[i] instanceof THREE.ShaderMaterial;
                }
              }
              if (needsTangents) {
                geometry.computeTangents();
              }
              if (objJSON.skin) {
                object = new THREE.SkinnedMesh(geometry, material);
              } else if (objJSON.morph) {
                object = new THREE.MorphAnimMesh(geometry, material);
                if (objJSON.duration !== undefined) {
                  object.duration = objJSON.duration;
                }
                if (objJSON.time !== undefined) {
                  object.time = objJSON.time;
                }
                if (objJSON.mirroredLoop !== undefined) {
                  object.mirroredLoop = objJSON.mirroredLoop;
                }
                if (material.morphNormals) {
                  geometry.computeMorphNormals();
                }
              } else {
                object = new THREE.Mesh(geometry, material);
              }
              object.name = objID;
              if (mat) {
                object.matrixAutoUpdate = false;
                object.matrix.set(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
              } else {
                object.position.fromArray(pos);
                if (quat) {
                  object.quaternion.fromArray(quat);
                } else {
                  object.rotation.fromArray(rot);
                }
                object.scale.fromArray(scl);
              }
              object.visible = objJSON.visible;
              object.castShadow = objJSON.castShadow;
              object.receiveShadow = objJSON.receiveShadow;
              parent.add(object);
              result.objects[objID] = object;
            }
          } else if (objJSON.type === 'DirectionalLight' || objJSON.type === 'PointLight' || objJSON.type === 'AmbientLight') {
            hex = objJSON.color !== undefined ? objJSON.color : 16777215;
            intensity = objJSON.intensity !== undefined ? objJSON.intensity : 1;
            if (objJSON.type === 'DirectionalLight') {
              pos = objJSON.direction;
              light = new THREE.DirectionalLight(hex, intensity);
              light.position.fromArray(pos);
              if (objJSON.target) {
                target_array.push({
                  'object': light,
                  'targetName': objJSON.target
                });
                light.target = null;
              }
            } else if (objJSON.type === 'PointLight') {
              pos = objJSON.position;
              dst = objJSON.distance;
              light = new THREE.PointLight(hex, intensity, dst);
              light.position.fromArray(pos);
            } else if (objJSON.type === 'AmbientLight') {
              light = new THREE.AmbientLight(hex);
            }
            parent.add(light);
            light.name = objID;
            result.lights[objID] = light;
            result.objects[objID] = light;
          } else if (objJSON.type === 'PerspectiveCamera' || objJSON.type === 'OrthographicCamera') {
            pos = objJSON.position;
            rot = objJSON.rotation;
            quat = objJSON.quaternion;
            if (objJSON.type === 'PerspectiveCamera') {
              camera = new THREE.PerspectiveCamera(objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far);
            } else if (objJSON.type === 'OrthographicCamera') {
              camera = new THREE.OrthographicCamera(objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far);
            }
            camera.name = objID;
            camera.position.fromArray(pos);
            if (quat !== undefined) {
              camera.quaternion.fromArray(quat);
            } else if (rot !== undefined) {
              camera.rotation.fromArray(rot);
            }
            parent.add(camera);
            result.cameras[objID] = camera;
            result.objects[objID] = camera;
          } else {
            pos = objJSON.position;
            rot = objJSON.rotation;
            scl = objJSON.scale;
            quat = objJSON.quaternion;
            object = new THREE.Object3D();
            object.name = objID;
            object.position.fromArray(pos);
            if (quat) {
              object.quaternion.fromArray(quat);
            } else {
              object.rotation.fromArray(rot);
            }
            object.scale.fromArray(scl);
            object.visible = objJSON.visible !== undefined ? objJSON.visible : false;
            parent.add(object);
            result.objects[objID] = object;
            result.empties[objID] = object;
          }
          if (object) {
            if (objJSON.userData !== undefined) {
              for (var key in objJSON.userData) {
                var value = objJSON.userData[key];
                object.userData[key] = value;
              }
            }
            if (objJSON.groups !== undefined) {
              for (var i = 0; i < objJSON.groups.length; i++) {
                var groupID = objJSON.groups[i];
                if (result.groups[groupID] === undefined) {
                  result.groups[groupID] = [];
                }
                result.groups[groupID].push(objID);
              }
            }
          }
        }
        if (object !== undefined && objJSON.children !== undefined) {
          handle_children(object, objJSON.children);
        }
      }
    }
    ;
    function handle_mesh(geo, mat, id) {
      result.geometries[id] = geo;
      result.face_materials[id] = mat;
      handle_objects();
    }
    ;
    function handle_hierarchy(node, id, parent, material, obj) {
      var p = obj.position;
      var r = obj.rotation;
      var q = obj.quaternion;
      var s = obj.scale;
      node.position.fromArray(p);
      if (q) {
        node.quaternion.fromArray(q);
      } else {
        node.rotation.fromArray(r);
      }
      node.scale.fromArray(s);
      if (material) {
        node.traverse(function (child) {
          child.material = material;
        });
      }
      var visible = obj.visible !== undefined ? obj.visible : true;
      node.traverse(function (child) {
        child.visible = visible;
      });
      parent.add(node);
      node.name = id;
      result.objects[id] = node;
      handle_objects();
    }
    ;
    function create_callback_geometry(id) {
      return function (geo, mat) {
        geo.name = id;
        handle_mesh(geo, mat, id);
        counter_models -= 1;
        scope.onLoadComplete();
        async_callback_gate();
      };
    }
    ;
    function create_callback_hierachy(id, parent, material, obj) {
      return function (event) {
        var result;
        if (event.content) {
          result = event.content;
        } else if (event.dae) {
          result = event.scene;
        } else {
          result = event;
        }
        handle_hierarchy(result, id, parent, material, obj);
        counter_models -= 1;
        scope.onLoadComplete();
        async_callback_gate();
      };
    }
    ;
    function create_callback_embed(id) {
      return function (geo, mat) {
        geo.name = id;
        result.geometries[id] = geo;
        result.face_materials[id] = mat;
      };
    }
    ;
    function async_callback_gate() {
      var progress = {
          totalModels: total_models,
          totalTextures: total_textures,
          loadedModels: total_models - counter_models,
          loadedTextures: total_textures - counter_textures
        };
      scope.callbackProgress(progress, result);
      scope.onLoadProgress();
      if (counter_models === 0 && counter_textures === 0) {
        finalize();
        callbackFinished(result);
      }
    }
    ;
    function finalize() {
      for (var i = 0; i < target_array.length; i++) {
        var ta = target_array[i];
        var target = result.objects[ta.targetName];
        if (target) {
          ta.object.target = target;
        } else {
          ta.object.target = new THREE.Object3D();
          result.scene.add(ta.object.target);
        }
        ta.object.target.userData.targetInverse = ta.object;
      }
    }
    ;
    var callbackTexture = function (count) {
      counter_textures -= count;
      async_callback_gate();
      scope.onLoadComplete();
    };
    var generateTextureCallback = function (count) {
      return function () {
        callbackTexture(count);
      };
    };
    function traverse_json_hierarchy(objJSON, callback) {
      callback(objJSON);
      if (objJSON.children !== undefined) {
        for (var objChildID in objJSON.children) {
          traverse_json_hierarchy(objJSON.children[objChildID], callback);
        }
      }
    }
    ;
    var fogID, fogJSON;
    for (fogID in data.fogs) {
      fogJSON = data.fogs[fogID];
      if (fogJSON.type === 'linear') {
        fog = new THREE.Fog(0, fogJSON.near, fogJSON.far);
      } else if (fogJSON.type === 'exp2') {
        fog = new THREE.FogExp2(0, fogJSON.density);
      }
      color = fogJSON.color;
      fog.color.setRGB(color[0], color[1], color[2]);
      result.fogs[fogID] = fog;
    }
    var geoID, geoJSON;
    for (geoID in data.geometries) {
      geoJSON = data.geometries[geoID];
      if (geoJSON.type in this.geometryHandlers) {
        counter_models += 1;
        scope.onLoadStart();
      }
    }
    for (var objID in data.objects) {
      traverse_json_hierarchy(data.objects[objID], function (objJSON) {
        if (objJSON.type && objJSON.type in scope.hierarchyHandlers) {
          counter_models += 1;
          scope.onLoadStart();
        }
      });
    }
    total_models = counter_models;
    for (geoID in data.geometries) {
      geoJSON = data.geometries[geoID];
      if (geoJSON.type === 'cube') {
        geometry = new THREE.CubeGeometry(geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'plane') {
        geometry = new THREE.PlaneGeometry(geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'sphere') {
        geometry = new THREE.SphereGeometry(geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'cylinder') {
        geometry = new THREE.CylinderGeometry(geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'torus') {
        geometry = new THREE.TorusGeometry(geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'icosahedron') {
        geometry = new THREE.IcosahedronGeometry(geoJSON.radius, geoJSON.subdivisions);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type in this.geometryHandlers) {
        var loaderParameters = {};
        for (var parType in geoJSON) {
          if (parType !== 'type' && parType !== 'url') {
            loaderParameters[parType] = geoJSON[parType];
          }
        }
        var loader = this.geometryHandlers[geoJSON.type]['loaderObject'];
        loader.load(get_url(geoJSON.url, data.urlBaseType), create_callback_geometry(geoID), loaderParameters);
      } else if (geoJSON.type === 'embedded') {
        var modelJson = data.embeds[geoJSON.id], texture_path = '';
        modelJson.metadata = data.metadata;
        if (modelJson) {
          var jsonLoader = this.geometryHandlers['ascii']['loaderObject'];
          var model = jsonLoader.parse(modelJson, texture_path);
          create_callback_embed(geoID)(model.geometry, model.materials);
        }
      }
    }
    var textureID, textureJSON;
    for (textureID in data.textures) {
      textureJSON = data.textures[textureID];
      if (textureJSON.url instanceof Array) {
        counter_textures += textureJSON.url.length;
        for (var n = 0; n < textureJSON.url.length; n++) {
          scope.onLoadStart();
        }
      } else {
        counter_textures += 1;
        scope.onLoadStart();
      }
    }
    total_textures = counter_textures;
    for (textureID in data.textures) {
      textureJSON = data.textures[textureID];
      if (textureJSON.mapping !== undefined && THREE[textureJSON.mapping] !== undefined) {
        textureJSON.mapping = new THREE[textureJSON.mapping]();
      }
      if (textureJSON.url instanceof Array) {
        var count = textureJSON.url.length;
        var url_array = [];
        for (var i = 0; i < count; i++) {
          url_array[i] = get_url(textureJSON.url[i], data.urlBaseType);
        }
        var isCompressed = /\.dds$/i.test(url_array[0]);
        if (isCompressed) {
          texture = THREE.ImageUtils.loadCompressedTextureCube(url_array, textureJSON.mapping, generateTextureCallback(count));
        } else {
          texture = THREE.ImageUtils.loadTextureCube(url_array, textureJSON.mapping, generateTextureCallback(count));
        }
      } else {
        var isCompressed = /\.dds$/i.test(textureJSON.url);
        var fullUrl = get_url(textureJSON.url, data.urlBaseType);
        var textureCallback = generateTextureCallback(1);
        if (isCompressed) {
          texture = THREE.ImageUtils.loadCompressedTexture(fullUrl, textureJSON.mapping, textureCallback);
        } else {
          texture = THREE.ImageUtils.loadTexture(fullUrl, textureJSON.mapping, textureCallback);
        }
        if (THREE[textureJSON.minFilter] !== undefined)
          texture.minFilter = THREE[textureJSON.minFilter];
        if (THREE[textureJSON.magFilter] !== undefined)
          texture.magFilter = THREE[textureJSON.magFilter];
        if (textureJSON.anisotropy)
          texture.anisotropy = textureJSON.anisotropy;
        if (textureJSON.repeat) {
          texture.repeat.set(textureJSON.repeat[0], textureJSON.repeat[1]);
          if (textureJSON.repeat[0] !== 1)
            texture.wrapS = THREE.RepeatWrapping;
          if (textureJSON.repeat[1] !== 1)
            texture.wrapT = THREE.RepeatWrapping;
        }
        if (textureJSON.offset) {
          texture.offset.set(textureJSON.offset[0], textureJSON.offset[1]);
        }
        if (textureJSON.wrap) {
          var wrapMap = {
              'repeat': THREE.RepeatWrapping,
              'mirror': THREE.MirroredRepeatWrapping
            };
          if (wrapMap[textureJSON.wrap[0]] !== undefined)
            texture.wrapS = wrapMap[textureJSON.wrap[0]];
          if (wrapMap[textureJSON.wrap[1]] !== undefined)
            texture.wrapT = wrapMap[textureJSON.wrap[1]];
        }
      }
      result.textures[textureID] = texture;
    }
    var matID, matJSON;
    var parID;
    for (matID in data.materials) {
      matJSON = data.materials[matID];
      for (parID in matJSON.parameters) {
        if (parID === 'envMap' || parID === 'map' || parID === 'lightMap' || parID === 'bumpMap') {
          matJSON.parameters[parID] = result.textures[matJSON.parameters[parID]];
        } else if (parID === 'shading') {
          matJSON.parameters[parID] = matJSON.parameters[parID] === 'flat' ? THREE.FlatShading : THREE.SmoothShading;
        } else if (parID === 'side') {
          if (matJSON.parameters[parID] == 'double') {
            matJSON.parameters[parID] = THREE.DoubleSide;
          } else if (matJSON.parameters[parID] == 'back') {
            matJSON.parameters[parID] = THREE.BackSide;
          } else {
            matJSON.parameters[parID] = THREE.FrontSide;
          }
        } else if (parID === 'blending') {
          matJSON.parameters[parID] = matJSON.parameters[parID] in THREE ? THREE[matJSON.parameters[parID]] : THREE.NormalBlending;
        } else if (parID === 'combine') {
          matJSON.parameters[parID] = matJSON.parameters[parID] in THREE ? THREE[matJSON.parameters[parID]] : THREE.MultiplyOperation;
        } else if (parID === 'vertexColors') {
          if (matJSON.parameters[parID] == 'face') {
            matJSON.parameters[parID] = THREE.FaceColors;
          } else if (matJSON.parameters[parID]) {
            matJSON.parameters[parID] = THREE.VertexColors;
          }
        } else if (parID === 'wrapRGB') {
          var v3 = matJSON.parameters[parID];
          matJSON.parameters[parID] = new THREE.Vector3(v3[0], v3[1], v3[2]);
        }
      }
      if (matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1) {
        matJSON.parameters.transparent = true;
      }
      if (matJSON.parameters.normalMap) {
        var shader = THREE.ShaderLib['normalmap'];
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        var diffuse = matJSON.parameters.color;
        var specular = matJSON.parameters.specular;
        var ambient = matJSON.parameters.ambient;
        var shininess = matJSON.parameters.shininess;
        uniforms['tNormal'].value = result.textures[matJSON.parameters.normalMap];
        if (matJSON.parameters.normalScale) {
          uniforms['uNormalScale'].value.set(matJSON.parameters.normalScale[0], matJSON.parameters.normalScale[1]);
        }
        if (matJSON.parameters.map) {
          uniforms['tDiffuse'].value = matJSON.parameters.map;
          uniforms['enableDiffuse'].value = true;
        }
        if (matJSON.parameters.envMap) {
          uniforms['tCube'].value = matJSON.parameters.envMap;
          uniforms['enableReflection'].value = true;
          uniforms['uReflectivity'].value = matJSON.parameters.reflectivity;
        }
        if (matJSON.parameters.lightMap) {
          uniforms['tAO'].value = matJSON.parameters.lightMap;
          uniforms['enableAO'].value = true;
        }
        if (matJSON.parameters.specularMap) {
          uniforms['tSpecular'].value = result.textures[matJSON.parameters.specularMap];
          uniforms['enableSpecular'].value = true;
        }
        if (matJSON.parameters.displacementMap) {
          uniforms['tDisplacement'].value = result.textures[matJSON.parameters.displacementMap];
          uniforms['enableDisplacement'].value = true;
          uniforms['uDisplacementBias'].value = matJSON.parameters.displacementBias;
          uniforms['uDisplacementScale'].value = matJSON.parameters.displacementScale;
        }
        uniforms['uDiffuseColor'].value.setHex(diffuse);
        uniforms['uSpecularColor'].value.setHex(specular);
        uniforms['uAmbientColor'].value.setHex(ambient);
        uniforms['uShininess'].value = shininess;
        if (matJSON.parameters.opacity) {
          uniforms['uOpacity'].value = matJSON.parameters.opacity;
        }
        var parameters = {
            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            uniforms: uniforms,
            lights: true,
            fog: true
          };
        material = new THREE.ShaderMaterial(parameters);
      } else {
        material = new THREE[matJSON.type](matJSON.parameters);
      }
      material.name = matID;
      result.materials[matID] = material;
    }
    for (matID in data.materials) {
      matJSON = data.materials[matID];
      if (matJSON.parameters.materials) {
        var materialArray = [];
        for (var i = 0; i < matJSON.parameters.materials.length; i++) {
          var label = matJSON.parameters.materials[i];
          materialArray.push(result.materials[label]);
        }
        result.materials[matID].materials = materialArray;
      }
    }
    handle_objects();
    if (result.cameras && data.defaults.camera) {
      result.currentCamera = result.cameras[data.defaults.camera];
    }
    if (result.fogs && data.defaults.fog) {
      result.scene.fog = result.fogs[data.defaults.fog];
    }
    scope.callbackSync(result);
    async_callback_gate();
  }
};
THREE.TextureLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.TextureLoader.prototype = {
  constructor: THREE.TextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.ImageLoader(scope.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (image) {
      var texture = new THREE.Texture(image);
      texture.needsUpdate = true;
      if (onLoad !== undefined) {
        onLoad(texture);
      }
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  }
};
THREE.Material = function () {
  this.id = THREE.MaterialIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.side = THREE.FrontSide;
  this.opacity = 1;
  this.transparent = false;
  this.blending = THREE.NormalBlending;
  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.depthTest = true;
  this.depthWrite = true;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.alphaTest = 0;
  this.overdraw = 0;
  this.visible = true;
  this.needsUpdate = true;
};
THREE.Material.prototype = {
  constructor: THREE.Material,
  setValues: function (values) {
    if (values === undefined)
      return;
    for (var key in values) {
      var newValue = values[key];
      if (newValue === undefined) {
        console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
        continue;
      }
      if (key in this) {
        var currentValue = this[key];
        if (currentValue instanceof THREE.Color) {
          currentValue.set(newValue);
        } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
          currentValue.copy(newValue);
        } else if (key == 'overdraw') {
          this[key] = Number(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
  },
  clone: function (material) {
    if (material === undefined)
      material = new THREE.Material();
    material.name = this.name;
    material.side = this.side;
    material.opacity = this.opacity;
    material.transparent = this.transparent;
    material.blending = this.blending;
    material.blendSrc = this.blendSrc;
    material.blendDst = this.blendDst;
    material.blendEquation = this.blendEquation;
    material.depthTest = this.depthTest;
    material.depthWrite = this.depthWrite;
    material.polygonOffset = this.polygonOffset;
    material.polygonOffsetFactor = this.polygonOffsetFactor;
    material.polygonOffsetUnits = this.polygonOffsetUnits;
    material.alphaTest = this.alphaTest;
    material.overdraw = this.overdraw;
    material.visible = this.visible;
    return material;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';
  this.vertexColors = false;
  this.fog = true;
  this.setValues(parameters);
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone = function () {
  var material = new THREE.LineBasicMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.linewidth = this.linewidth;
  material.linecap = this.linecap;
  material.linejoin = this.linejoin;
  material.vertexColors = this.vertexColors;
  material.fog = this.fog;
  return material;
};
THREE.LineDashedMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.vertexColors = false;
  this.fog = true;
  this.setValues(parameters);
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone = function () {
  var material = new THREE.LineDashedMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.linewidth = this.linewidth;
  material.scale = this.scale;
  material.dashSize = this.dashSize;
  material.gapSize = this.gapSize;
  material.vertexColors = this.vertexColors;
  material.fog = this.fog;
  return material;
};
THREE.MeshBasicMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.specularMap = null;
  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.shading = THREE.SmoothShading;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.setValues(parameters);
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone = function () {
  var material = new THREE.MeshBasicMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.map = this.map;
  material.lightMap = this.lightMap;
  material.specularMap = this.specularMap;
  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;
  material.fog = this.fog;
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;
  material.vertexColors = this.vertexColors;
  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  return material;
};
THREE.MeshLambertMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.wrapAround = false;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.map = null;
  this.lightMap = null;
  this.specularMap = null;
  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.shading = THREE.SmoothShading;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone = function () {
  var material = new THREE.MeshLambertMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.ambient.copy(this.ambient);
  material.emissive.copy(this.emissive);
  material.wrapAround = this.wrapAround;
  material.wrapRGB.copy(this.wrapRGB);
  material.map = this.map;
  material.lightMap = this.lightMap;
  material.specularMap = this.specularMap;
  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;
  material.fog = this.fog;
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;
  material.vertexColors = this.vertexColors;
  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;
  return material;
};
THREE.MeshPhongMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.specular = new THREE.Color(1118481);
  this.shininess = 30;
  this.metal = false;
  this.perPixel = true;
  this.wrapAround = false;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.map = null;
  this.lightMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new THREE.Vector2(1, 1);
  this.specularMap = null;
  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.shading = THREE.SmoothShading;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone = function () {
  var material = new THREE.MeshPhongMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.ambient.copy(this.ambient);
  material.emissive.copy(this.emissive);
  material.specular.copy(this.specular);
  material.shininess = this.shininess;
  material.metal = this.metal;
  material.perPixel = this.perPixel;
  material.wrapAround = this.wrapAround;
  material.wrapRGB.copy(this.wrapRGB);
  material.map = this.map;
  material.lightMap = this.lightMap;
  material.bumpMap = this.bumpMap;
  material.bumpScale = this.bumpScale;
  material.normalMap = this.normalMap;
  material.normalScale.copy(this.normalScale);
  material.specularMap = this.specularMap;
  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;
  material.fog = this.fog;
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;
  material.vertexColors = this.vertexColors;
  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;
  return material;
};
THREE.MeshDepthMaterial = function (parameters) {
  THREE.Material.call(this);
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.setValues(parameters);
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.clone = function () {
  var material = new THREE.MeshDepthMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  return material;
};
THREE.MeshNormalMaterial = function (parameters) {
  THREE.Material.call(this, parameters);
  this.shading = THREE.FlatShading;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.morphTargets = false;
  this.setValues(parameters);
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.clone = function () {
  var material = new THREE.MeshNormalMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  return material;
};
THREE.MeshFaceMaterial = function (materials) {
  this.materials = materials instanceof Array ? materials : [];
};
THREE.MeshFaceMaterial.prototype.clone = function () {
  var material = new THREE.MeshFaceMaterial();
  for (var i = 0; i < this.materials.length; i++) {
    material.materials.push(this.materials[i].clone());
  }
  return material;
};
THREE.ParticleSystemMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.vertexColors = false;
  this.fog = true;
  this.setValues(parameters);
};
THREE.ParticleSystemMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ParticleSystemMaterial.prototype.clone = function () {
  var material = new THREE.ParticleSystemMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.map = this.map;
  material.size = this.size;
  material.sizeAttenuation = this.sizeAttenuation;
  material.vertexColors = this.vertexColors;
  material.fog = this.fog;
  return material;
};
THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;
THREE.ShaderMaterial = function (parameters) {
  THREE.Material.call(this);
  this.fragmentShader = 'void main() {}';
  this.vertexShader = 'void main() {}';
  this.uniforms = {};
  this.defines = {};
  this.attributes = null;
  this.shading = THREE.SmoothShading;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.defaultAttributeValues = {
    'color': [
      1,
      1,
      1
    ],
    'uv': [
      0,
      0
    ],
    'uv2': [
      0,
      0
    ]
  };
  this.index0AttributeName = 'position';
  this.setValues(parameters);
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone = function () {
  var material = new THREE.ShaderMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.fragmentShader = this.fragmentShader;
  material.vertexShader = this.vertexShader;
  material.uniforms = THREE.UniformsUtils.clone(this.uniforms);
  material.attributes = this.attributes;
  material.defines = this.defines;
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.fog = this.fog;
  material.lights = this.lights;
  material.vertexColors = this.vertexColors;
  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;
  return material;
};
THREE.SpriteMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = new THREE.Texture();
  this.useScreenCoordinates = true;
  this.depthTest = !this.useScreenCoordinates;
  this.sizeAttenuation = !this.useScreenCoordinates;
  this.alignment = THREE.SpriteAlignment.center.clone();
  this.fog = false;
  this.uvOffset = new THREE.Vector2(0, 0);
  this.uvScale = new THREE.Vector2(1, 1);
  this.setValues(parameters);
  parameters = parameters || {};
  if (parameters.depthTest === undefined)
    this.depthTest = !this.useScreenCoordinates;
  if (parameters.sizeAttenuation === undefined)
    this.sizeAttenuation = !this.useScreenCoordinates;
};
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteMaterial.prototype.clone = function () {
  var material = new THREE.SpriteMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.map = this.map;
  material.useScreenCoordinates = this.useScreenCoordinates;
  material.sizeAttenuation = this.sizeAttenuation;
  material.alignment.copy(this.alignment);
  material.uvOffset.copy(this.uvOffset);
  material.uvScale.copy(this.uvScale);
  material.fog = this.fog;
  return material;
};
THREE.SpriteAlignment = {};
THREE.SpriteAlignment.topLeft = new THREE.Vector2(0.5, -0.5);
THREE.SpriteAlignment.topCenter = new THREE.Vector2(0, -0.5);
THREE.SpriteAlignment.topRight = new THREE.Vector2(-0.5, -0.5);
THREE.SpriteAlignment.centerLeft = new THREE.Vector2(0.5, 0);
THREE.SpriteAlignment.center = new THREE.Vector2(0, 0);
THREE.SpriteAlignment.centerRight = new THREE.Vector2(-0.5, 0);
THREE.SpriteAlignment.bottomLeft = new THREE.Vector2(0.5, 0.5);
THREE.SpriteAlignment.bottomCenter = new THREE.Vector2(0, 0.5);
THREE.SpriteAlignment.bottomRight = new THREE.Vector2(-0.5, 0.5);
THREE.SpriteCanvasMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.program = function (context, color) {
  };
  this.setValues(parameters);
};
THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteCanvasMaterial.prototype.clone = function () {
  var material = new THREE.SpriteCanvasMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.program = this.program;
  return material;
};
THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;
THREE.Texture = function (image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  this.id = THREE.TextureIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.image = image;
  this.mipmaps = [];
  this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();
  this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
  this.format = format !== undefined ? format : THREE.RGBAFormat;
  this.type = type !== undefined ? type : THREE.UnsignedByteType;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4;
  this.needsUpdate = false;
  this.onUpdate = null;
};
THREE.Texture.prototype = {
  constructor: THREE.Texture,
  clone: function (texture) {
    if (texture === undefined)
      texture = new THREE.Texture();
    texture.image = this.image;
    texture.mipmaps = this.mipmaps.slice(0);
    texture.mapping = this.mapping;
    texture.wrapS = this.wrapS;
    texture.wrapT = this.wrapT;
    texture.magFilter = this.magFilter;
    texture.minFilter = this.minFilter;
    texture.anisotropy = this.anisotropy;
    texture.format = this.format;
    texture.type = this.type;
    texture.offset.copy(this.offset);
    texture.repeat.copy(this.repeat);
    texture.generateMipmaps = this.generateMipmaps;
    texture.premultiplyAlpha = this.premultiplyAlpha;
    texture.flipY = this.flipY;
    texture.unpackAlignment = this.unpackAlignment;
    return texture;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CompressedTexture = function (mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
  THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    width: width,
    height: height
  };
  this.mipmaps = mipmaps;
  this.generateMipmaps = false;
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone = function () {
  var texture = new THREE.CompressedTexture();
  THREE.Texture.prototype.clone.call(this, texture);
  return texture;
};
THREE.DataTexture = function (data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
  THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    data: data,
    width: width,
    height: height
  };
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.clone = function () {
  var texture = new THREE.DataTexture();
  THREE.Texture.prototype.clone.call(this, texture);
  return texture;
};
THREE.ParticleSystem = function (geometry, material) {
  THREE.Object3D.call(this);
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.ParticleSystemMaterial({ color: Math.random() * 16777215 });
  this.sortParticles = false;
  this.frustumCulled = false;
};
THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype);
THREE.ParticleSystem.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.ParticleSystem(this.geometry, this.material);
  object.sortParticles = this.sortParticles;
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.Line = function (geometry, material, type) {
  THREE.Object3D.call(this);
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.LineBasicMaterial({ color: Math.random() * 16777215 });
  this.type = type !== undefined ? type : THREE.LineStrip;
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Line(this.geometry, this.material, this.type);
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.Mesh = function (geometry, material) {
  THREE.Object3D.call(this);
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({ color: Math.random() * 16777215 });
  this.updateMorphTargets();
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets = function () {
  if (this.geometry.morphTargets.length > 0) {
    this.morphTargetBase = -1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};
    for (var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++) {
      this.morphTargetInfluences.push(0);
      this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
    }
  }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function (name) {
  if (this.morphTargetDictionary[name] !== undefined) {
    return this.morphTargetDictionary[name];
  }
  console.log('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
  return 0;
};
THREE.Mesh.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Mesh(this.geometry, this.material);
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.Bone = function (belongsToSkin) {
  THREE.Object3D.call(this);
  this.skin = belongsToSkin;
  this.skinMatrix = new THREE.Matrix4();
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update = function (parentSkinMatrix, forceUpdate) {
  if (this.matrixAutoUpdate) {
    forceUpdate |= this.updateMatrix();
  }
  if (forceUpdate || this.matrixWorldNeedsUpdate) {
    if (parentSkinMatrix) {
      this.skinMatrix.multiplyMatrices(parentSkinMatrix, this.matrix);
    } else {
      this.skinMatrix.copy(this.matrix);
    }
    this.matrixWorldNeedsUpdate = false;
    forceUpdate = true;
  }
  var child, i, l = this.children.length;
  for (i = 0; i < l; i++) {
    this.children[i].update(this.skinMatrix, forceUpdate);
  }
};
THREE.SkinnedMesh = function (geometry, material, useVertexTexture) {
  THREE.Mesh.call(this, geometry, material);
  this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
  this.identityMatrix = new THREE.Matrix4();
  this.bones = [];
  this.boneMatrices = [];
  var b, bone, gbone, p, q, s;
  if (this.geometry && this.geometry.bones !== undefined) {
    for (b = 0; b < this.geometry.bones.length; b++) {
      gbone = this.geometry.bones[b];
      p = gbone.pos;
      q = gbone.rotq;
      s = gbone.scl;
      bone = this.addBone();
      bone.name = gbone.name;
      bone.position.set(p[0], p[1], p[2]);
      bone.quaternion.set(q[0], q[1], q[2], q[3]);
      if (s !== undefined) {
        bone.scale.set(s[0], s[1], s[2]);
      } else {
        bone.scale.set(1, 1, 1);
      }
    }
    for (b = 0; b < this.bones.length; b++) {
      gbone = this.geometry.bones[b];
      bone = this.bones[b];
      if (gbone.parent === -1) {
        this.add(bone);
      } else {
        this.bones[gbone.parent].add(bone);
      }
    }
    var nBones = this.bones.length;
    if (this.useVertexTexture) {
      var size;
      if (nBones > 256)
        size = 64;
      else if (nBones > 64)
        size = 32;
      else if (nBones > 16)
        size = 16;
      else
        size = 8;
      this.boneTextureWidth = size;
      this.boneTextureHeight = size;
      this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
      this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
      this.boneTexture.minFilter = THREE.NearestFilter;
      this.boneTexture.magFilter = THREE.NearestFilter;
      this.boneTexture.generateMipmaps = false;
      this.boneTexture.flipY = false;
    } else {
      this.boneMatrices = new Float32Array(16 * nBones);
    }
    this.pose();
  }
};
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.SkinnedMesh.prototype.addBone = function (bone) {
  if (bone === undefined) {
    bone = new THREE.Bone(this);
  }
  this.bones.push(bone);
  return bone;
};
THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {
  var offsetMatrix = new THREE.Matrix4();
  return function (force) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent) {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      } else {
        this.matrixWorld.copy(this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      if (child instanceof THREE.Bone) {
        child.update(this.identityMatrix, false);
      } else {
        child.updateMatrixWorld(true);
      }
    }
    if (this.boneInverses == undefined) {
      this.boneInverses = [];
      for (var b = 0, bl = this.bones.length; b < bl; b++) {
        var inverse = new THREE.Matrix4();
        inverse.getInverse(this.bones[b].skinMatrix);
        this.boneInverses.push(inverse);
      }
    }
    for (var b = 0, bl = this.bones.length; b < bl; b++) {
      offsetMatrix.multiplyMatrices(this.bones[b].skinMatrix, this.boneInverses[b]);
      offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);
    }
    if (this.useVertexTexture) {
      this.boneTexture.needsUpdate = true;
    }
  };
}();
THREE.SkinnedMesh.prototype.pose = function () {
  this.updateMatrixWorld(true);
  this.normalizeSkinWeights();
};
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
  if (this.geometry instanceof THREE.Geometry) {
    for (var i = 0; i < this.geometry.skinIndices.length; i++) {
      var sw = this.geometry.skinWeights[i];
      var scale = 1 / sw.lengthManhattan();
      if (scale !== Infinity) {
        sw.multiplyScalar(scale);
      } else {
        sw.set(1);
      }
    }
  } else {
  }
};
THREE.SkinnedMesh.prototype.clone = function (object) {
  if (object === undefined) {
    object = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture);
  }
  THREE.Mesh.prototype.clone.call(this, object);
  return object;
};
THREE.MorphAnimMesh = function (geometry, material) {
  THREE.Mesh.call(this, geometry, material);
  this.duration = 1000;
  this.mirroredLoop = false;
  this.time = 0;
  this.lastKeyframe = 0;
  this.currentKeyframe = 0;
  this.direction = 1;
  this.directionBackwards = false;
  this.setFrameRange(0, this.geometry.morphTargets.length - 1);
};
THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphAnimMesh.prototype.setFrameRange = function (start, end) {
  this.startKeyframe = start;
  this.endKeyframe = end;
  this.length = this.endKeyframe - this.startKeyframe + 1;
};
THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
  this.direction = 1;
  this.directionBackwards = false;
};
THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
  this.direction = -1;
  this.directionBackwards = true;
};
THREE.MorphAnimMesh.prototype.parseAnimations = function () {
  var geometry = this.geometry;
  if (!geometry.animations)
    geometry.animations = {};
  var firstAnimation, animations = geometry.animations;
  var pattern = /([a-z]+)(\d+)/;
  for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
    var morph = geometry.morphTargets[i];
    var parts = morph.name.match(pattern);
    if (parts && parts.length > 1) {
      var label = parts[1];
      var num = parts[2];
      if (!animations[label])
        animations[label] = {
          start: Infinity,
          end: -Infinity
        };
      var animation = animations[label];
      if (i < animation.start)
        animation.start = i;
      if (i > animation.end)
        animation.end = i;
      if (!firstAnimation)
        firstAnimation = label;
    }
  }
  geometry.firstAnimation = firstAnimation;
};
THREE.MorphAnimMesh.prototype.setAnimationLabel = function (label, start, end) {
  if (!this.geometry.animations)
    this.geometry.animations = {};
  this.geometry.animations[label] = {
    start: start,
    end: end
  };
};
THREE.MorphAnimMesh.prototype.playAnimation = function (label, fps) {
  var animation = this.geometry.animations[label];
  if (animation) {
    this.setFrameRange(animation.start, animation.end);
    this.duration = 1000 * ((animation.end - animation.start) / fps);
    this.time = 0;
  } else {
    console.warn('animation[' + label + '] undefined');
  }
};
THREE.MorphAnimMesh.prototype.updateAnimation = function (delta) {
  var frameTime = this.duration / this.length;
  this.time += this.direction * delta;
  if (this.mirroredLoop) {
    if (this.time > this.duration || this.time < 0) {
      this.direction *= -1;
      if (this.time > this.duration) {
        this.time = this.duration;
        this.directionBackwards = true;
      }
      if (this.time < 0) {
        this.time = 0;
        this.directionBackwards = false;
      }
    }
  } else {
    this.time = this.time % this.duration;
    if (this.time < 0)
      this.time += this.duration;
  }
  var keyframe = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / frameTime), 0, this.length - 1);
  if (keyframe !== this.currentKeyframe) {
    this.morphTargetInfluences[this.lastKeyframe] = 0;
    this.morphTargetInfluences[this.currentKeyframe] = 1;
    this.morphTargetInfluences[keyframe] = 0;
    this.lastKeyframe = this.currentKeyframe;
    this.currentKeyframe = keyframe;
  }
  var mix = this.time % frameTime / frameTime;
  if (this.directionBackwards) {
    mix = 1 - mix;
  }
  this.morphTargetInfluences[this.currentKeyframe] = mix;
  this.morphTargetInfluences[this.lastKeyframe] = 1 - mix;
};
THREE.MorphAnimMesh.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.MorphAnimMesh(this.geometry, this.material);
  object.duration = this.duration;
  object.mirroredLoop = this.mirroredLoop;
  object.time = this.time;
  object.lastKeyframe = this.lastKeyframe;
  object.currentKeyframe = this.currentKeyframe;
  object.direction = this.direction;
  object.directionBackwards = this.directionBackwards;
  THREE.Mesh.prototype.clone.call(this, object);
  return object;
};
THREE.LOD = function () {
  THREE.Object3D.call(this);
  this.objects = [];
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.addLevel = function (object, distance) {
  if (distance === undefined)
    distance = 0;
  distance = Math.abs(distance);
  for (var l = 0; l < this.objects.length; l++) {
    if (distance < this.objects[l].distance) {
      break;
    }
  }
  this.objects.splice(l, 0, {
    distance: distance,
    object: object
  });
  this.add(object);
};
THREE.LOD.prototype.getObjectForDistance = function (distance) {
  for (var i = 1, l = this.objects.length; i < l; i++) {
    if (distance < this.objects[i].distance) {
      break;
    }
  }
  return this.objects[i - 1].object;
};
THREE.LOD.prototype.update = function () {
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  return function (camera) {
    if (this.objects.length > 1) {
      v1.getPositionFromMatrix(camera.matrixWorld);
      v2.getPositionFromMatrix(this.matrixWorld);
      var distance = v1.distanceTo(v2);
      this.objects[0].object.visible = true;
      for (var i = 1, l = this.objects.length; i < l; i++) {
        if (distance >= this.objects[i].distance) {
          this.objects[i - 1].object.visible = false;
          this.objects[i].object.visible = true;
        } else {
          break;
        }
      }
      for (; i < l; i++) {
        this.objects[i].object.visible = false;
      }
    }
  };
}();
THREE.LOD.prototype.clone = function () {
};
THREE.Sprite = function (material) {
  THREE.Object3D.call(this);
  this.material = material !== undefined ? material : new THREE.SpriteMaterial();
  this.rotation = 0;
};
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.updateMatrix = function () {
  this.matrix.compose(this.position, this.quaternion, this.scale);
  this.matrixWorldNeedsUpdate = true;
};
THREE.Sprite.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Sprite(this.material);
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.Particle = THREE.Sprite;
THREE.Scene = function () {
  THREE.Object3D.call(this);
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true;
  this.matrixAutoUpdate = false;
  this.__lights = [];
  this.__objectsAdded = [];
  this.__objectsRemoved = [];
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject = function (object) {
  if (object instanceof THREE.Light) {
    if (this.__lights.indexOf(object) === -1) {
      this.__lights.push(object);
    }
    if (object.target && object.target.parent === undefined) {
      this.add(object.target);
    }
  } else if (!(object instanceof THREE.Camera || object instanceof THREE.Bone)) {
    this.__objectsAdded.push(object);
    var i = this.__objectsRemoved.indexOf(object);
    if (i !== -1) {
      this.__objectsRemoved.splice(i, 1);
    }
  }
  for (var c = 0; c < object.children.length; c++) {
    this.__addObject(object.children[c]);
  }
};
THREE.Scene.prototype.__removeObject = function (object) {
  if (object instanceof THREE.Light) {
    var i = this.__lights.indexOf(object);
    if (i !== -1) {
      this.__lights.splice(i, 1);
    }
    if (object.shadowCascadeArray) {
      for (var x = 0; x < object.shadowCascadeArray.length; x++) {
        this.__removeObject(object.shadowCascadeArray[x]);
      }
    }
  } else if (!(object instanceof THREE.Camera)) {
    this.__objectsRemoved.push(object);
    var i = this.__objectsAdded.indexOf(object);
    if (i !== -1) {
      this.__objectsAdded.splice(i, 1);
    }
  }
  for (var c = 0; c < object.children.length; c++) {
    this.__removeObject(object.children[c]);
  }
};
THREE.Scene.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Scene();
  THREE.Object3D.prototype.clone.call(this, object);
  if (this.fog !== null)
    object.fog = this.fog.clone();
  if (this.overrideMaterial !== null)
    object.overrideMaterial = this.overrideMaterial.clone();
  object.autoUpdate = this.autoUpdate;
  object.matrixAutoUpdate = this.matrixAutoUpdate;
  return object;
};
THREE.Fog = function (hex, near, far) {
  this.name = '';
  this.color = new THREE.Color(hex);
  this.near = near !== undefined ? near : 1;
  this.far = far !== undefined ? far : 1000;
};
THREE.Fog.prototype.clone = function () {
  return new THREE.Fog(this.color.getHex(), this.near, this.far);
};
THREE.FogExp2 = function (hex, density) {
  this.name = '';
  this.color = new THREE.Color(hex);
  this.density = density !== undefined ? density : 0.00025;
};
THREE.FogExp2.prototype.clone = function () {
  return new THREE.FogExp2(this.color.getHex(), this.density);
};
THREE.CanvasRenderer = function (parameters) {
  console.log('THREE.CanvasRenderer', THREE.REVISION);
  var smoothstep = THREE.Math.smoothstep;
  parameters = parameters || {};
  var _this = this, _renderData, _elements, _lights, _projector = new THREE.Projector(), _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'), _canvasWidth = _canvas.width, _canvasHeight = _canvas.height, _canvasWidthHalf = Math.floor(_canvasWidth / 2), _canvasHeightHalf = Math.floor(_canvasHeight / 2), _context = _canvas.getContext('2d'), _clearColor = new THREE.Color(0), _clearAlpha = 0, _contextGlobalAlpha = 1, _contextGlobalCompositeOperation = 0, _contextStrokeStyle = null, _contextFillStyle = null, _contextLineWidth = null, _contextLineCap = null, _contextLineJoin = null, _contextDashSize = null, _contextGapSize = 0, _camera, _v1, _v2, _v3, _v4, _v5 = new THREE.RenderableVertex(), _v6 = new THREE.RenderableVertex(), _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y, _v5x, _v5y, _v6x, _v6y, _color = new THREE.Color(), _color1 = new THREE.Color(), _color2 = new THREE.Color(), _color3 = new THREE.Color(), _color4 = new THREE.Color(), _diffuseColor = new THREE.Color(), _emissiveColor = new THREE.Color(), _lightColor = new THREE.Color(), _patterns = {}, _imagedatas = {}, _near, _far, _image, _uvs, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, _clipBox = new THREE.Box2(), _clearBox = new THREE.Box2(), _elemBox = new THREE.Box2(), _ambientLight = new THREE.Color(), _directionalLights = new THREE.Color(), _pointLights = new THREE.Color(), _vector3 = new THREE.Vector3(), _pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData, _gradientMap, _gradientMapContext, _gradientMapQuality = 16;
  _pixelMap = document.createElement('canvas');
  _pixelMap.width = _pixelMap.height = 2;
  _pixelMapContext = _pixelMap.getContext('2d');
  _pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
  _pixelMapContext.fillRect(0, 0, 2, 2);
  _pixelMapImage = _pixelMapContext.getImageData(0, 0, 2, 2);
  _pixelMapData = _pixelMapImage.data;
  _gradientMap = document.createElement('canvas');
  _gradientMap.width = _gradientMap.height = _gradientMapQuality;
  _gradientMapContext = _gradientMap.getContext('2d');
  _gradientMapContext.translate(-_gradientMapQuality / 2, -_gradientMapQuality / 2);
  _gradientMapContext.scale(_gradientMapQuality, _gradientMapQuality);
  _gradientMapQuality--;
  if (_context.setLineDash === undefined) {
    if (_context.mozDash !== undefined) {
      _context.setLineDash = function (values) {
        _context.mozDash = values[0] !== null ? values : null;
      };
    } else {
      _context.setLineDash = function () {
      };
    }
  }
  this.domElement = _canvas;
  this.devicePixelRatio = parameters.devicePixelRatio !== undefined ? parameters.devicePixelRatio : self.devicePixelRatio !== undefined ? self.devicePixelRatio : 1;
  this.autoClear = true;
  this.sortObjects = true;
  this.sortElements = true;
  this.info = {
    render: {
      vertices: 0,
      faces: 0
    }
  };
  this.supportsVertexTextures = function () {
  };
  this.setFaceCulling = function () {
  };
  this.setSize = function (width, height, updateStyle) {
    _canvasWidth = width * this.devicePixelRatio;
    _canvasHeight = height * this.devicePixelRatio;
    _canvasWidthHalf = Math.floor(_canvasWidth / 2);
    _canvasHeightHalf = Math.floor(_canvasHeight / 2);
    _canvas.width = _canvasWidth;
    _canvas.height = _canvasHeight;
    if (this.devicePixelRatio !== 1 && updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }
    _clipBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));
    _clearBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));
    _contextGlobalAlpha = 1;
    _contextGlobalCompositeOperation = 0;
    _contextStrokeStyle = null;
    _contextFillStyle = null;
    _contextLineWidth = null;
    _contextLineCap = null;
    _contextLineJoin = null;
  };
  this.setClearColor = function (color, alpha) {
    _clearColor.set(color);
    _clearAlpha = alpha !== undefined ? alpha : 1;
    _clearBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));
  };
  this.setClearColorHex = function (hex, alpha) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(hex, alpha);
  };
  this.getMaxAnisotropy = function () {
    return 0;
  };
  this.clear = function () {
    _context.setTransform(1, 0, 0, -1, _canvasWidthHalf, _canvasHeightHalf);
    if (_clearBox.empty() === false) {
      _clearBox.intersect(_clipBox);
      _clearBox.expandByScalar(2);
      if (_clearAlpha < 1) {
        _context.clearRect(_clearBox.min.x | 0, _clearBox.min.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.max.y - _clearBox.min.y | 0);
      }
      if (_clearAlpha > 0) {
        setBlending(THREE.NormalBlending);
        setOpacity(1);
        setFillStyle('rgba(' + Math.floor(_clearColor.r * 255) + ',' + Math.floor(_clearColor.g * 255) + ',' + Math.floor(_clearColor.b * 255) + ',' + _clearAlpha + ')');
        _context.fillRect(_clearBox.min.x | 0, _clearBox.min.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.max.y - _clearBox.min.y | 0);
      }
      _clearBox.makeEmpty();
    }
  };
  this.render = function (scene, camera) {
    if (camera instanceof THREE.Camera === false) {
      console.error('THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }
    if (this.autoClear === true)
      this.clear();
    _context.setTransform(1, 0, 0, -1, _canvasWidthHalf, _canvasHeightHalf);
    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;
    _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);
    _elements = _renderData.elements;
    _lights = _renderData.lights;
    _camera = camera;
    calculateLights();
    for (var e = 0, el = _elements.length; e < el; e++) {
      var element = _elements[e];
      var material = element.material;
      if (material === undefined || material.visible === false)
        continue;
      _elemBox.makeEmpty();
      if (element instanceof THREE.RenderableSprite) {
        _v1 = element;
        _v1.x *= _canvasWidthHalf;
        _v1.y *= _canvasHeightHalf;
        renderSprite(_v1, element, material);
      } else if (element instanceof THREE.RenderableLine) {
        _v1 = element.v1;
        _v2 = element.v2;
        _v1.positionScreen.x *= _canvasWidthHalf;
        _v1.positionScreen.y *= _canvasHeightHalf;
        _v2.positionScreen.x *= _canvasWidthHalf;
        _v2.positionScreen.y *= _canvasHeightHalf;
        _elemBox.setFromPoints([
          _v1.positionScreen,
          _v2.positionScreen
        ]);
        if (_clipBox.isIntersectionBox(_elemBox) === true) {
          renderLine(_v1, _v2, element, material);
        }
      } else if (element instanceof THREE.RenderableFace3) {
        _v1 = element.v1;
        _v2 = element.v2;
        _v3 = element.v3;
        if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1)
          continue;
        if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1)
          continue;
        if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1)
          continue;
        _v1.positionScreen.x *= _canvasWidthHalf;
        _v1.positionScreen.y *= _canvasHeightHalf;
        _v2.positionScreen.x *= _canvasWidthHalf;
        _v2.positionScreen.y *= _canvasHeightHalf;
        _v3.positionScreen.x *= _canvasWidthHalf;
        _v3.positionScreen.y *= _canvasHeightHalf;
        if (material.overdraw > 0) {
          expand(_v1.positionScreen, _v2.positionScreen, material.overdraw);
          expand(_v2.positionScreen, _v3.positionScreen, material.overdraw);
          expand(_v3.positionScreen, _v1.positionScreen, material.overdraw);
        }
        _elemBox.setFromPoints([
          _v1.positionScreen,
          _v2.positionScreen,
          _v3.positionScreen
        ]);
        if (_clipBox.isIntersectionBox(_elemBox) === true) {
          renderFace3(_v1, _v2, _v3, 0, 1, 2, element, material);
        }
      }
      _clearBox.union(_elemBox);
    }
    _context.setTransform(1, 0, 0, 1, 0, 0);
  };
  function calculateLights() {
    _ambientLight.setRGB(0, 0, 0);
    _directionalLights.setRGB(0, 0, 0);
    _pointLights.setRGB(0, 0, 0);
    for (var l = 0, ll = _lights.length; l < ll; l++) {
      var light = _lights[l];
      var lightColor = light.color;
      if (light instanceof THREE.AmbientLight) {
        _ambientLight.add(lightColor);
      } else if (light instanceof THREE.DirectionalLight) {
        _directionalLights.add(lightColor);
      } else if (light instanceof THREE.PointLight) {
        _pointLights.add(lightColor);
      }
    }
  }
  function calculateLight(position, normal, color) {
    for (var l = 0, ll = _lights.length; l < ll; l++) {
      var light = _lights[l];
      _lightColor.copy(light.color);
      if (light instanceof THREE.DirectionalLight) {
        var lightPosition = _vector3.getPositionFromMatrix(light.matrixWorld).normalize();
        var amount = normal.dot(lightPosition);
        if (amount <= 0)
          continue;
        amount *= light.intensity;
        color.add(_lightColor.multiplyScalar(amount));
      } else if (light instanceof THREE.PointLight) {
        var lightPosition = _vector3.getPositionFromMatrix(light.matrixWorld);
        var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());
        if (amount <= 0)
          continue;
        amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);
        if (amount == 0)
          continue;
        amount *= light.intensity;
        color.add(_lightColor.multiplyScalar(amount));
      }
    }
  }
  function renderSprite(v1, element, material) {
    setOpacity(material.opacity);
    setBlending(material.blending);
    var width, height, scaleX, scaleY, bitmap, bitmapWidth, bitmapHeight;
    if (material instanceof THREE.SpriteMaterial || material instanceof THREE.ParticleSystemMaterial) {
      if (material.map.image !== undefined) {
        bitmap = material.map.image;
        bitmapWidth = bitmap.width >> 1;
        bitmapHeight = bitmap.height >> 1;
        scaleX = element.scale.x * _canvasWidthHalf;
        scaleY = element.scale.y * _canvasHeightHalf;
        width = scaleX * bitmapWidth;
        height = scaleY * bitmapHeight;
        _elemBox.min.set(v1.x - width, v1.y - height);
        _elemBox.max.set(v1.x + width, v1.y + height);
        if (_clipBox.isIntersectionBox(_elemBox) === false) {
          _elemBox.makeEmpty();
          return;
        }
        _context.save();
        _context.translate(v1.x, v1.y);
        _context.rotate(-element.rotation);
        _context.scale(scaleX, -scaleY);
        _context.translate(-bitmapWidth, -bitmapHeight);
        _context.drawImage(bitmap, 0, 0);
        _context.restore();
      } else {
        scaleX = element.object.scale.x;
        scaleY = element.object.scale.y;
        scaleX *= element.scale.x * _canvasWidthHalf;
        scaleY *= element.scale.y * _canvasHeightHalf;
        _elemBox.min.set(v1.x - scaleX, v1.y - scaleY);
        _elemBox.max.set(v1.x + scaleX, v1.y + scaleY);
        if (_clipBox.isIntersectionBox(_elemBox) === false) {
          _elemBox.makeEmpty();
          return;
        }
        setFillStyle(material.color.getStyle());
        _context.save();
        _context.translate(v1.x, v1.y);
        _context.rotate(-element.rotation);
        _context.scale(scaleX, scaleY);
        _context.fillRect(-1, -1, 2, 2);
        _context.restore();
      }
    } else if (material instanceof THREE.SpriteCanvasMaterial) {
      width = element.scale.x * _canvasWidthHalf;
      height = element.scale.y * _canvasHeightHalf;
      _elemBox.min.set(v1.x - width, v1.y - height);
      _elemBox.max.set(v1.x + width, v1.y + height);
      if (_clipBox.isIntersectionBox(_elemBox) === false) {
        _elemBox.makeEmpty();
        return;
      }
      setStrokeStyle(material.color.getStyle());
      setFillStyle(material.color.getStyle());
      _context.save();
      _context.translate(v1.x, v1.y);
      _context.rotate(-element.rotation);
      _context.scale(width, height);
      material.program(_context);
      _context.restore();
    }
  }
  function renderLine(v1, v2, element, material) {
    setOpacity(material.opacity);
    setBlending(material.blending);
    _context.beginPath();
    _context.moveTo(v1.positionScreen.x, v1.positionScreen.y);
    _context.lineTo(v2.positionScreen.x, v2.positionScreen.y);
    if (material instanceof THREE.LineBasicMaterial) {
      setLineWidth(material.linewidth);
      setLineCap(material.linecap);
      setLineJoin(material.linejoin);
      if (material.vertexColors !== THREE.VertexColors) {
        setStrokeStyle(material.color.getStyle());
      } else {
        var colorStyle1 = element.vertexColors[0].getStyle();
        var colorStyle2 = element.vertexColors[1].getStyle();
        if (colorStyle1 === colorStyle2) {
          setStrokeStyle(colorStyle1);
        } else {
          try {
            var grad = _context.createLinearGradient(v1.positionScreen.x, v1.positionScreen.y, v2.positionScreen.x, v2.positionScreen.y);
            grad.addColorStop(0, colorStyle1);
            grad.addColorStop(1, colorStyle2);
          } catch (exception) {
            grad = colorStyle1;
          }
          setStrokeStyle(grad);
        }
      }
      _context.stroke();
      _elemBox.expandByScalar(material.linewidth * 2);
    } else if (material instanceof THREE.LineDashedMaterial) {
      setLineWidth(material.linewidth);
      setLineCap(material.linecap);
      setLineJoin(material.linejoin);
      setStrokeStyle(material.color.getStyle());
      setDashAndGap(material.dashSize, material.gapSize);
      _context.stroke();
      _elemBox.expandByScalar(material.linewidth * 2);
      setDashAndGap(null, null);
    }
  }
  function renderFace3(v1, v2, v3, uv1, uv2, uv3, element, material) {
    _this.info.render.vertices += 3;
    _this.info.render.faces++;
    setOpacity(material.opacity);
    setBlending(material.blending);
    _v1x = v1.positionScreen.x;
    _v1y = v1.positionScreen.y;
    _v2x = v2.positionScreen.x;
    _v2y = v2.positionScreen.y;
    _v3x = v3.positionScreen.x;
    _v3y = v3.positionScreen.y;
    drawTriangle(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y);
    if ((material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) && material.map === null) {
      _diffuseColor.copy(material.color);
      _emissiveColor.copy(material.emissive);
      if (material.vertexColors === THREE.FaceColors) {
        _diffuseColor.multiply(element.color);
      }
      if (material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3) {
        _color1.copy(_ambientLight);
        _color2.copy(_ambientLight);
        _color3.copy(_ambientLight);
        calculateLight(element.v1.positionWorld, element.vertexNormalsModel[0], _color1);
        calculateLight(element.v2.positionWorld, element.vertexNormalsModel[1], _color2);
        calculateLight(element.v3.positionWorld, element.vertexNormalsModel[2], _color3);
        _color1.multiply(_diffuseColor).add(_emissiveColor);
        _color2.multiply(_diffuseColor).add(_emissiveColor);
        _color3.multiply(_diffuseColor).add(_emissiveColor);
        _color4.addColors(_color2, _color3).multiplyScalar(0.5);
        _image = getGradientTexture(_color1, _color2, _color3, _color4);
        clipImage(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image);
      } else {
        _color.copy(_ambientLight);
        calculateLight(element.centroidModel, element.normalModel, _color);
        _color.multiply(_diffuseColor).add(_emissiveColor);
        material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
      }
    } else if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
      if (material.map !== null) {
        if (material.map.mapping instanceof THREE.UVMapping) {
          _uvs = element.uvs[0];
          patternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[uv1].x, _uvs[uv1].y, _uvs[uv2].x, _uvs[uv2].y, _uvs[uv3].x, _uvs[uv3].y, material.map);
        }
      } else if (material.envMap !== null) {
        if (material.envMap.mapping instanceof THREE.SphericalReflectionMapping) {
          _vector3.copy(element.vertexNormalsModelView[uv1]);
          _uv1x = 0.5 * _vector3.x + 0.5;
          _uv1y = 0.5 * _vector3.y + 0.5;
          _vector3.copy(element.vertexNormalsModelView[uv2]);
          _uv2x = 0.5 * _vector3.x + 0.5;
          _uv2y = 0.5 * _vector3.y + 0.5;
          _vector3.copy(element.vertexNormalsModelView[uv3]);
          _uv3x = 0.5 * _vector3.x + 0.5;
          _uv3y = 0.5 * _vector3.y + 0.5;
          patternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap);
        }
      } else {
        _color.copy(material.color);
        if (material.vertexColors === THREE.FaceColors) {
          _color.multiply(element.color);
        }
        material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
      }
    } else if (material instanceof THREE.MeshDepthMaterial) {
      _near = _camera.near;
      _far = _camera.far;
      _color1.r = _color1.g = _color1.b = 1 - smoothstep(v1.positionScreen.z * v1.positionScreen.w, _near, _far);
      _color2.r = _color2.g = _color2.b = 1 - smoothstep(v2.positionScreen.z * v2.positionScreen.w, _near, _far);
      _color3.r = _color3.g = _color3.b = 1 - smoothstep(v3.positionScreen.z * v3.positionScreen.w, _near, _far);
      _color4.addColors(_color2, _color3).multiplyScalar(0.5);
      _image = getGradientTexture(_color1, _color2, _color3, _color4);
      clipImage(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image);
    } else if (material instanceof THREE.MeshNormalMaterial) {
      var normal;
      if (material.shading == THREE.FlatShading) {
        normal = element.normalModelView;
        _color.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);
        material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
      } else if (material.shading == THREE.SmoothShading) {
        normal = element.vertexNormalsModelView[uv1];
        _color1.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);
        normal = element.vertexNormalsModelView[uv2];
        _color2.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);
        normal = element.vertexNormalsModelView[uv3];
        _color3.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);
        _color4.addColors(_color2, _color3).multiplyScalar(0.5);
        _image = getGradientTexture(_color1, _color2, _color3, _color4);
        clipImage(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image);
      }
    }
  }
  function drawTriangle(x0, y0, x1, y1, x2, y2) {
    _context.beginPath();
    _context.moveTo(x0, y0);
    _context.lineTo(x1, y1);
    _context.lineTo(x2, y2);
    _context.closePath();
  }
  function strokePath(color, linewidth, linecap, linejoin) {
    setLineWidth(linewidth);
    setLineCap(linecap);
    setLineJoin(linejoin);
    setStrokeStyle(color.getStyle());
    _context.stroke();
    _elemBox.expandByScalar(linewidth * 2);
  }
  function fillPath(color) {
    setFillStyle(color.getStyle());
    _context.fill();
  }
  function patternPath(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture) {
    if (texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0)
      return;
    if (texture.needsUpdate === true) {
      var repeatX = texture.wrapS == THREE.RepeatWrapping;
      var repeatY = texture.wrapT == THREE.RepeatWrapping;
      _patterns[texture.id] = _context.createPattern(texture.image, repeatX === true && repeatY === true ? 'repeat' : repeatX === true && repeatY === false ? 'repeat-x' : repeatX === false && repeatY === true ? 'repeat-y' : 'no-repeat');
      texture.needsUpdate = false;
    }
    _patterns[texture.id] === undefined ? setFillStyle('rgba(0,0,0,1)') : setFillStyle(_patterns[texture.id]);
    var a, b, c, d, e, f, det, idet, offsetX = texture.offset.x / texture.repeat.x, offsetY = texture.offset.y / texture.repeat.y, width = texture.image.width * texture.repeat.x, height = texture.image.height * texture.repeat.y;
    u0 = (u0 + offsetX) * width;
    v0 = (1 - v0 + offsetY) * height;
    u1 = (u1 + offsetX) * width;
    v1 = (1 - v1 + offsetY) * height;
    u2 = (u2 + offsetX) * width;
    v2 = (1 - v2 + offsetY) * height;
    x1 -= x0;
    y1 -= y0;
    x2 -= x0;
    y2 -= y0;
    u1 -= u0;
    v1 -= v0;
    u2 -= u0;
    v2 -= v0;
    det = u1 * v2 - u2 * v1;
    if (det === 0) {
      if (_imagedatas[texture.id] === undefined) {
        var canvas = document.createElement('canvas');
        canvas.width = texture.image.width;
        canvas.height = texture.image.height;
        var context = canvas.getContext('2d');
        context.drawImage(texture.image, 0, 0);
        _imagedatas[texture.id] = context.getImageData(0, 0, texture.image.width, texture.image.height).data;
      }
      var data = _imagedatas[texture.id];
      var index = (Math.floor(u0) + Math.floor(v0) * texture.image.width) * 4;
      _color.setRGB(data[index] / 255, data[index + 1] / 255, data[index + 2] / 255);
      fillPath(_color);
      return;
    }
    idet = 1 / det;
    a = (v2 * x1 - v1 * x2) * idet;
    b = (v2 * y1 - v1 * y2) * idet;
    c = (u1 * x2 - u2 * x1) * idet;
    d = (u1 * y2 - u2 * y1) * idet;
    e = x0 - a * u0 - c * v0;
    f = y0 - b * u0 - d * v0;
    _context.save();
    _context.transform(a, b, c, d, e, f);
    _context.fill();
    _context.restore();
  }
  function clipImage(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image) {
    var a, b, c, d, e, f, det, idet, width = image.width - 1, height = image.height - 1;
    u0 *= width;
    v0 *= height;
    u1 *= width;
    v1 *= height;
    u2 *= width;
    v2 *= height;
    x1 -= x0;
    y1 -= y0;
    x2 -= x0;
    y2 -= y0;
    u1 -= u0;
    v1 -= v0;
    u2 -= u0;
    v2 -= v0;
    det = u1 * v2 - u2 * v1;
    idet = 1 / det;
    a = (v2 * x1 - v1 * x2) * idet;
    b = (v2 * y1 - v1 * y2) * idet;
    c = (u1 * x2 - u2 * x1) * idet;
    d = (u1 * y2 - u2 * y1) * idet;
    e = x0 - a * u0 - c * v0;
    f = y0 - b * u0 - d * v0;
    _context.save();
    _context.transform(a, b, c, d, e, f);
    _context.clip();
    _context.drawImage(image, 0, 0);
    _context.restore();
  }
  function getGradientTexture(color1, color2, color3, color4) {
    _pixelMapData[0] = color1.r * 255 | 0;
    _pixelMapData[1] = color1.g * 255 | 0;
    _pixelMapData[2] = color1.b * 255 | 0;
    _pixelMapData[4] = color2.r * 255 | 0;
    _pixelMapData[5] = color2.g * 255 | 0;
    _pixelMapData[6] = color2.b * 255 | 0;
    _pixelMapData[8] = color3.r * 255 | 0;
    _pixelMapData[9] = color3.g * 255 | 0;
    _pixelMapData[10] = color3.b * 255 | 0;
    _pixelMapData[12] = color4.r * 255 | 0;
    _pixelMapData[13] = color4.g * 255 | 0;
    _pixelMapData[14] = color4.b * 255 | 0;
    _pixelMapContext.putImageData(_pixelMapImage, 0, 0);
    _gradientMapContext.drawImage(_pixelMap, 0, 0);
    return _gradientMap;
  }
  function expand(v1, v2, pixels) {
    var x = v2.x - v1.x, y = v2.y - v1.y, det = x * x + y * y, idet;
    if (det === 0)
      return;
    idet = pixels / Math.sqrt(det);
    x *= idet;
    y *= idet;
    v2.x += x;
    v2.y += y;
    v1.x -= x;
    v1.y -= y;
  }
  function setOpacity(value) {
    if (_contextGlobalAlpha !== value) {
      _context.globalAlpha = value;
      _contextGlobalAlpha = value;
    }
  }
  function setBlending(value) {
    if (_contextGlobalCompositeOperation !== value) {
      if (value === THREE.NormalBlending) {
        _context.globalCompositeOperation = 'source-over';
      } else if (value === THREE.AdditiveBlending) {
        _context.globalCompositeOperation = 'lighter';
      } else if (value === THREE.SubtractiveBlending) {
        _context.globalCompositeOperation = 'darker';
      }
      _contextGlobalCompositeOperation = value;
    }
  }
  function setLineWidth(value) {
    if (_contextLineWidth !== value) {
      _context.lineWidth = value;
      _contextLineWidth = value;
    }
  }
  function setLineCap(value) {
    if (_contextLineCap !== value) {
      _context.lineCap = value;
      _contextLineCap = value;
    }
  }
  function setLineJoin(value) {
    if (_contextLineJoin !== value) {
      _context.lineJoin = value;
      _contextLineJoin = value;
    }
  }
  function setStrokeStyle(value) {
    if (_contextStrokeStyle !== value) {
      _context.strokeStyle = value;
      _contextStrokeStyle = value;
    }
  }
  function setFillStyle(value) {
    if (_contextFillStyle !== value) {
      _context.fillStyle = value;
      _contextFillStyle = value;
    }
  }
  function setDashAndGap(dashSizeValue, gapSizeValue) {
    if (_contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue) {
      _context.setLineDash([
        dashSizeValue,
        gapSizeValue
      ]);
      _contextDashSize = dashSizeValue;
      _contextGapSize = gapSizeValue;
    }
  }
};
THREE.ShaderChunk = {
  fog_pars_fragment: [
    '#ifdef USE_FOG',
    'uniform vec3 fogColor;',
    '#ifdef FOG_EXP2',
    'uniform float fogDensity;',
    '#else',
    'uniform float fogNear;',
    'uniform float fogFar;',
    '#endif',
    '#endif'
  ].join('\n'),
  fog_fragment: [
    '#ifdef USE_FOG',
    'float depth = gl_FragCoord.z / gl_FragCoord.w;',
    '#ifdef FOG_EXP2',
    'const float LOG2 = 1.442695;',
    'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
    'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
    '#else',
    'float fogFactor = smoothstep( fogNear, fogFar, depth );',
    '#endif',
    'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
    '#endif'
  ].join('\n'),
  envmap_pars_fragment: [
    '#ifdef USE_ENVMAP',
    'uniform float reflectivity;',
    'uniform samplerCube envMap;',
    'uniform float flipEnvMap;',
    'uniform int combine;',
    '#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )',
    'uniform bool useRefract;',
    'uniform float refractionRatio;',
    '#else',
    'varying vec3 vReflect;',
    '#endif',
    '#endif'
  ].join('\n'),
  envmap_fragment: [
    '#ifdef USE_ENVMAP',
    'vec3 reflectVec;',
    '#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )',
    'vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );',
    'if ( useRefract ) {',
    'reflectVec = refract( cameraToVertex, normal, refractionRatio );',
    '} else { ',
    'reflectVec = reflect( cameraToVertex, normal );',
    '}',
    '#else',
    'reflectVec = vReflect;',
    '#endif',
    '#ifdef DOUBLE_SIDED',
    'float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );',
    'vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );',
    '#else',
    'vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );',
    '#endif',
    '#ifdef GAMMA_INPUT',
    'cubeColor.xyz *= cubeColor.xyz;',
    '#endif',
    'if ( combine == 1 ) {',
    'gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );',
    '} else if ( combine == 2 ) {',
    'gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;',
    '} else {',
    'gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );',
    '}',
    '#endif'
  ].join('\n'),
  envmap_pars_vertex: [
    '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )',
    'varying vec3 vReflect;',
    'uniform float refractionRatio;',
    'uniform bool useRefract;',
    '#endif'
  ].join('\n'),
  worldpos_vertex: [
    '#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )',
    '#ifdef USE_SKINNING',
    'vec4 worldPosition = modelMatrix * skinned;',
    '#endif',
    '#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )',
    'vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );',
    '#endif',
    '#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )',
    'vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
    '#endif',
    '#endif'
  ].join('\n'),
  envmap_vertex: [
    '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )',
    'vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;',
    'worldNormal = normalize( worldNormal );',
    'vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );',
    'if ( useRefract ) {',
    'vReflect = refract( cameraToVertex, worldNormal, refractionRatio );',
    '} else {',
    'vReflect = reflect( cameraToVertex, worldNormal );',
    '}',
    '#endif'
  ].join('\n'),
  map_particle_pars_fragment: [
    '#ifdef USE_MAP',
    'uniform sampler2D map;',
    '#endif'
  ].join('\n'),
  map_particle_fragment: [
    '#ifdef USE_MAP',
    'gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );',
    '#endif'
  ].join('\n'),
  map_pars_vertex: [
    '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )',
    'varying vec2 vUv;',
    'uniform vec4 offsetRepeat;',
    '#endif'
  ].join('\n'),
  map_pars_fragment: [
    '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )',
    'varying vec2 vUv;',
    '#endif',
    '#ifdef USE_MAP',
    'uniform sampler2D map;',
    '#endif'
  ].join('\n'),
  map_vertex: [
    '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )',
    'vUv = uv * offsetRepeat.zw + offsetRepeat.xy;',
    '#endif'
  ].join('\n'),
  map_fragment: [
    '#ifdef USE_MAP',
    'vec4 texelColor = texture2D( map, vUv );',
    '#ifdef GAMMA_INPUT',
    'texelColor.xyz *= texelColor.xyz;',
    '#endif',
    'gl_FragColor = gl_FragColor * texelColor;',
    '#endif'
  ].join('\n'),
  lightmap_pars_fragment: [
    '#ifdef USE_LIGHTMAP',
    'varying vec2 vUv2;',
    'uniform sampler2D lightMap;',
    '#endif'
  ].join('\n'),
  lightmap_pars_vertex: [
    '#ifdef USE_LIGHTMAP',
    'varying vec2 vUv2;',
    '#endif'
  ].join('\n'),
  lightmap_fragment: [
    '#ifdef USE_LIGHTMAP',
    'gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );',
    '#endif'
  ].join('\n'),
  lightmap_vertex: [
    '#ifdef USE_LIGHTMAP',
    'vUv2 = uv2;',
    '#endif'
  ].join('\n'),
  bumpmap_pars_fragment: [
    '#ifdef USE_BUMPMAP',
    'uniform sampler2D bumpMap;',
    'uniform float bumpScale;',
    'vec2 dHdxy_fwd() {',
    'vec2 dSTdx = dFdx( vUv );',
    'vec2 dSTdy = dFdy( vUv );',
    'float Hll = bumpScale * texture2D( bumpMap, vUv ).x;',
    'float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;',
    'float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;',
    'return vec2( dBx, dBy );',
    '}',
    'vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {',
    'vec3 vSigmaX = dFdx( surf_pos );',
    'vec3 vSigmaY = dFdy( surf_pos );',
    'vec3 vN = surf_norm;',
    'vec3 R1 = cross( vSigmaY, vN );',
    'vec3 R2 = cross( vN, vSigmaX );',
    'float fDet = dot( vSigmaX, R1 );',
    'vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );',
    'return normalize( abs( fDet ) * surf_norm - vGrad );',
    '}',
    '#endif'
  ].join('\n'),
  normalmap_pars_fragment: [
    '#ifdef USE_NORMALMAP',
    'uniform sampler2D normalMap;',
    'uniform vec2 normalScale;',
    'vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {',
    'vec3 q0 = dFdx( eye_pos.xyz );',
    'vec3 q1 = dFdy( eye_pos.xyz );',
    'vec2 st0 = dFdx( vUv.st );',
    'vec2 st1 = dFdy( vUv.st );',
    'vec3 S = normalize(  q0 * st1.t - q1 * st0.t );',
    'vec3 T = normalize( -q0 * st1.s + q1 * st0.s );',
    'vec3 N = normalize( surf_norm );',
    'vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;',
    'mapN.xy = normalScale * mapN.xy;',
    'mat3 tsn = mat3( S, T, N );',
    'return normalize( tsn * mapN );',
    '}',
    '#endif'
  ].join('\n'),
  specularmap_pars_fragment: [
    '#ifdef USE_SPECULARMAP',
    'uniform sampler2D specularMap;',
    '#endif'
  ].join('\n'),
  specularmap_fragment: [
    'float specularStrength;',
    '#ifdef USE_SPECULARMAP',
    'vec4 texelSpecular = texture2D( specularMap, vUv );',
    'specularStrength = texelSpecular.r;',
    '#else',
    'specularStrength = 1.0;',
    '#endif'
  ].join('\n'),
  lights_lambert_pars_vertex: [
    'uniform vec3 ambient;',
    'uniform vec3 diffuse;',
    'uniform vec3 emissive;',
    'uniform vec3 ambientLightColor;',
    '#if MAX_DIR_LIGHTS > 0',
    'uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];',
    'uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];',
    'uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];',
    'uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];',
    'uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];',
    'uniform float pointLightDistance[ MAX_POINT_LIGHTS ];',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];',
    'uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];',
    'uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];',
    '#endif',
    '#ifdef WRAP_AROUND',
    'uniform vec3 wrapRGB;',
    '#endif'
  ].join('\n'),
  lights_lambert_vertex: [
    'vLightFront = vec3( 0.0 );',
    '#ifdef DOUBLE_SIDED',
    'vLightBack = vec3( 0.0 );',
    '#endif',
    'transformedNormal = normalize( transformedNormal );',
    '#if MAX_DIR_LIGHTS > 0',
    'for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {',
    'vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );',
    'vec3 dirVector = normalize( lDirection.xyz );',
    'float dotProduct = dot( transformedNormal, dirVector );',
    'vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );',
    '#ifdef DOUBLE_SIDED',
    'vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );',
    '#ifdef WRAP_AROUND',
    'vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );',
    '#endif',
    '#endif',
    '#ifdef WRAP_AROUND',
    'vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );',
    'directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );',
    '#ifdef DOUBLE_SIDED',
    'directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );',
    '#endif',
    '#endif',
    'vLightFront += directionalLightColor[ i ] * directionalLightWeighting;',
    '#ifdef DOUBLE_SIDED',
    'vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;',
    '#endif',
    '}',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {',
    'vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz - mvPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( pointLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );',
    'lVector = normalize( lVector );',
    'float dotProduct = dot( transformedNormal, lVector );',
    'vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );',
    '#ifdef DOUBLE_SIDED',
    'vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );',
    '#ifdef WRAP_AROUND',
    'vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );',
    '#endif',
    '#endif',
    '#ifdef WRAP_AROUND',
    'vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );',
    'pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );',
    '#ifdef DOUBLE_SIDED',
    'pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );',
    '#endif',
    '#endif',
    'vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;',
    '#ifdef DOUBLE_SIDED',
    'vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;',
    '#endif',
    '}',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {',
    'vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz - mvPosition.xyz;',
    'float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );',
    'if ( spotEffect > spotLightAngleCos[ i ] ) {',
    'spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );',
    'float lDistance = 1.0;',
    'if ( spotLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );',
    'lVector = normalize( lVector );',
    'float dotProduct = dot( transformedNormal, lVector );',
    'vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );',
    '#ifdef DOUBLE_SIDED',
    'vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );',
    '#ifdef WRAP_AROUND',
    'vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );',
    '#endif',
    '#endif',
    '#ifdef WRAP_AROUND',
    'vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );',
    'spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );',
    '#ifdef DOUBLE_SIDED',
    'spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );',
    '#endif',
    '#endif',
    'vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;',
    '#ifdef DOUBLE_SIDED',
    'vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;',
    '#endif',
    '}',
    '}',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {',
    'vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );',
    'vec3 lVector = normalize( lDirection.xyz );',
    'float dotProduct = dot( transformedNormal, lVector );',
    'float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;',
    'float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;',
    'vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );',
    '#ifdef DOUBLE_SIDED',
    'vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );',
    '#endif',
    '}',
    '#endif',
    'vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;',
    '#ifdef DOUBLE_SIDED',
    'vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;',
    '#endif'
  ].join('\n'),
  lights_phong_pars_vertex: [
    '#ifndef PHONG_PER_PIXEL',
    '#if MAX_POINT_LIGHTS > 0',
    'uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];',
    'uniform float pointLightDistance[ MAX_POINT_LIGHTS ];',
    'varying vec4 vPointLight[ MAX_POINT_LIGHTS ];',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];',
    'varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];',
    '#endif',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )',
    'varying vec3 vWorldPosition;',
    '#endif'
  ].join('\n'),
  lights_phong_vertex: [
    '#ifndef PHONG_PER_PIXEL',
    '#if MAX_POINT_LIGHTS > 0',
    'for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {',
    'vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz - mvPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( pointLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );',
    'vPointLight[ i ] = vec4( lVector, lDistance );',
    '}',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {',
    'vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz - mvPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( spotLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );',
    'vSpotLight[ i ] = vec4( lVector, lDistance );',
    '}',
    '#endif',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )',
    'vWorldPosition = worldPosition.xyz;',
    '#endif'
  ].join('\n'),
  lights_phong_pars_fragment: [
    'uniform vec3 ambientLightColor;',
    '#if MAX_DIR_LIGHTS > 0',
    'uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];',
    'uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];',
    'uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];',
    'uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];',
    '#ifdef PHONG_PER_PIXEL',
    'uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];',
    'uniform float pointLightDistance[ MAX_POINT_LIGHTS ];',
    '#else',
    'varying vec4 vPointLight[ MAX_POINT_LIGHTS ];',
    '#endif',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];',
    'uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];',
    'uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];',
    '#ifdef PHONG_PER_PIXEL',
    'uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];',
    '#else',
    'varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];',
    '#endif',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )',
    'varying vec3 vWorldPosition;',
    '#endif',
    '#ifdef WRAP_AROUND',
    'uniform vec3 wrapRGB;',
    '#endif',
    'varying vec3 vViewPosition;',
    'varying vec3 vNormal;'
  ].join('\n'),
  lights_phong_fragment: [
    'vec3 normal = normalize( vNormal );',
    'vec3 viewPosition = normalize( vViewPosition );',
    '#ifdef DOUBLE_SIDED',
    'normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );',
    '#endif',
    '#ifdef USE_NORMALMAP',
    'normal = perturbNormal2Arb( -vViewPosition, normal );',
    '#elif defined( USE_BUMPMAP )',
    'normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'vec3 pointDiffuse  = vec3( 0.0 );',
    'vec3 pointSpecular = vec3( 0.0 );',
    'for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {',
    '#ifdef PHONG_PER_PIXEL',
    'vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz + vViewPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( pointLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );',
    'lVector = normalize( lVector );',
    '#else',
    'vec3 lVector = normalize( vPointLight[ i ].xyz );',
    'float lDistance = vPointLight[ i ].w;',
    '#endif',
    'float dotProduct = dot( normal, lVector );',
    '#ifdef WRAP_AROUND',
    'float pointDiffuseWeightFull = max( dotProduct, 0.0 );',
    'float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );',
    'vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );',
    '#else',
    'float pointDiffuseWeight = max( dotProduct, 0.0 );',
    '#endif',
    'pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;',
    'vec3 pointHalfVector = normalize( lVector + viewPosition );',
    'float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );',
    'float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );',
    '#ifdef PHYSICALLY_BASED_SHADING',
    'float specularNormalization = ( shininess + 2.0001 ) / 8.0;',
    'vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );',
    'pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;',
    '#else',
    'pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;',
    '#endif',
    '}',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'vec3 spotDiffuse  = vec3( 0.0 );',
    'vec3 spotSpecular = vec3( 0.0 );',
    'for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {',
    '#ifdef PHONG_PER_PIXEL',
    'vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz + vViewPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( spotLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );',
    'lVector = normalize( lVector );',
    '#else',
    'vec3 lVector = normalize( vSpotLight[ i ].xyz );',
    'float lDistance = vSpotLight[ i ].w;',
    '#endif',
    'float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );',
    'if ( spotEffect > spotLightAngleCos[ i ] ) {',
    'spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );',
    'float dotProduct = dot( normal, lVector );',
    '#ifdef WRAP_AROUND',
    'float spotDiffuseWeightFull = max( dotProduct, 0.0 );',
    'float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );',
    'vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );',
    '#else',
    'float spotDiffuseWeight = max( dotProduct, 0.0 );',
    '#endif',
    'spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;',
    'vec3 spotHalfVector = normalize( lVector + viewPosition );',
    'float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );',
    'float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );',
    '#ifdef PHYSICALLY_BASED_SHADING',
    'float specularNormalization = ( shininess + 2.0001 ) / 8.0;',
    'vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );',
    'spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;',
    '#else',
    'spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;',
    '#endif',
    '}',
    '}',
    '#endif',
    '#if MAX_DIR_LIGHTS > 0',
    'vec3 dirDiffuse  = vec3( 0.0 );',
    'vec3 dirSpecular = vec3( 0.0 );',
    'for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {',
    'vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );',
    'vec3 dirVector = normalize( lDirection.xyz );',
    'float dotProduct = dot( normal, dirVector );',
    '#ifdef WRAP_AROUND',
    'float dirDiffuseWeightFull = max( dotProduct, 0.0 );',
    'float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );',
    'vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );',
    '#else',
    'float dirDiffuseWeight = max( dotProduct, 0.0 );',
    '#endif',
    'dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;',
    'vec3 dirHalfVector = normalize( dirVector + viewPosition );',
    'float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );',
    'float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );',
    '#ifdef PHYSICALLY_BASED_SHADING',
    'float specularNormalization = ( shininess + 2.0001 ) / 8.0;',
    'vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );',
    'dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;',
    '#else',
    'dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;',
    '#endif',
    '}',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'vec3 hemiDiffuse  = vec3( 0.0 );',
    'vec3 hemiSpecular = vec3( 0.0 );',
    'for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {',
    'vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );',
    'vec3 lVector = normalize( lDirection.xyz );',
    'float dotProduct = dot( normal, lVector );',
    'float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;',
    'vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );',
    'hemiDiffuse += diffuse * hemiColor;',
    'vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );',
    'float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;',
    'float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );',
    'vec3 lVectorGround = -lVector;',
    'vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );',
    'float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;',
    'float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );',
    '#ifdef PHYSICALLY_BASED_SHADING',
    'float dotProductGround = dot( normal, lVectorGround );',
    'float specularNormalization = ( shininess + 2.0001 ) / 8.0;',
    'vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );',
    'vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );',
    'hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );',
    '#else',
    'hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;',
    '#endif',
    '}',
    '#endif',
    'vec3 totalDiffuse = vec3( 0.0 );',
    'vec3 totalSpecular = vec3( 0.0 );',
    '#if MAX_DIR_LIGHTS > 0',
    'totalDiffuse += dirDiffuse;',
    'totalSpecular += dirSpecular;',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'totalDiffuse += hemiDiffuse;',
    'totalSpecular += hemiSpecular;',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'totalDiffuse += pointDiffuse;',
    'totalSpecular += pointSpecular;',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'totalDiffuse += spotDiffuse;',
    'totalSpecular += spotSpecular;',
    '#endif',
    '#ifdef METAL',
    'gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );',
    '#else',
    'gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;',
    '#endif'
  ].join('\n'),
  color_pars_fragment: [
    '#ifdef USE_COLOR',
    'varying vec3 vColor;',
    '#endif'
  ].join('\n'),
  color_fragment: [
    '#ifdef USE_COLOR',
    'gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );',
    '#endif'
  ].join('\n'),
  color_pars_vertex: [
    '#ifdef USE_COLOR',
    'varying vec3 vColor;',
    '#endif'
  ].join('\n'),
  color_vertex: [
    '#ifdef USE_COLOR',
    '#ifdef GAMMA_INPUT',
    'vColor = color * color;',
    '#else',
    'vColor = color;',
    '#endif',
    '#endif'
  ].join('\n'),
  skinning_pars_vertex: [
    '#ifdef USE_SKINNING',
    '#ifdef BONE_TEXTURE',
    'uniform sampler2D boneTexture;',
    'uniform int boneTextureWidth;',
    'uniform int boneTextureHeight;',
    'mat4 getBoneMatrix( const in float i ) {',
    'float j = i * 4.0;',
    'float x = mod( j, float( boneTextureWidth ) );',
    'float y = floor( j / float( boneTextureWidth ) );',
    'float dx = 1.0 / float( boneTextureWidth );',
    'float dy = 1.0 / float( boneTextureHeight );',
    'y = dy * ( y + 0.5 );',
    'vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );',
    'vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );',
    'vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );',
    'vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );',
    'mat4 bone = mat4( v1, v2, v3, v4 );',
    'return bone;',
    '}',
    '#else',
    'uniform mat4 boneGlobalMatrices[ MAX_BONES ];',
    'mat4 getBoneMatrix( const in float i ) {',
    'mat4 bone = boneGlobalMatrices[ int(i) ];',
    'return bone;',
    '}',
    '#endif',
    '#endif'
  ].join('\n'),
  skinbase_vertex: [
    '#ifdef USE_SKINNING',
    'mat4 boneMatX = getBoneMatrix( skinIndex.x );',
    'mat4 boneMatY = getBoneMatrix( skinIndex.y );',
    '#endif'
  ].join('\n'),
  skinning_vertex: [
    '#ifdef USE_SKINNING',
    '#ifdef USE_MORPHTARGETS',
    'vec4 skinVertex = vec4( morphed, 1.0 );',
    '#else',
    'vec4 skinVertex = vec4( position, 1.0 );',
    '#endif',
    'vec4 skinned  = boneMatX * skinVertex * skinWeight.x;',
    'skinned \t  += boneMatY * skinVertex * skinWeight.y;',
    '#endif'
  ].join('\n'),
  morphtarget_pars_vertex: [
    '#ifdef USE_MORPHTARGETS',
    '#ifndef USE_MORPHNORMALS',
    'uniform float morphTargetInfluences[ 8 ];',
    '#else',
    'uniform float morphTargetInfluences[ 4 ];',
    '#endif',
    '#endif'
  ].join('\n'),
  morphtarget_vertex: [
    '#ifdef USE_MORPHTARGETS',
    'vec3 morphed = vec3( 0.0 );',
    'morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];',
    'morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];',
    'morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];',
    'morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];',
    '#ifndef USE_MORPHNORMALS',
    'morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];',
    'morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];',
    'morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];',
    'morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];',
    '#endif',
    'morphed += position;',
    '#endif'
  ].join('\n'),
  default_vertex: [
    'vec4 mvPosition;',
    '#ifdef USE_SKINNING',
    'mvPosition = modelViewMatrix * skinned;',
    '#endif',
    '#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )',
    'mvPosition = modelViewMatrix * vec4( morphed, 1.0 );',
    '#endif',
    '#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )',
    'mvPosition = modelViewMatrix * vec4( position, 1.0 );',
    '#endif',
    'gl_Position = projectionMatrix * mvPosition;'
  ].join('\n'),
  morphnormal_vertex: [
    '#ifdef USE_MORPHNORMALS',
    'vec3 morphedNormal = vec3( 0.0 );',
    'morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];',
    'morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];',
    'morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];',
    'morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];',
    'morphedNormal += normal;',
    '#endif'
  ].join('\n'),
  skinnormal_vertex: [
    '#ifdef USE_SKINNING',
    'mat4 skinMatrix = skinWeight.x * boneMatX;',
    'skinMatrix \t+= skinWeight.y * boneMatY;',
    '#ifdef USE_MORPHNORMALS',
    'vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );',
    '#else',
    'vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );',
    '#endif',
    '#endif'
  ].join('\n'),
  defaultnormal_vertex: [
    'vec3 objectNormal;',
    '#ifdef USE_SKINNING',
    'objectNormal = skinnedNormal.xyz;',
    '#endif',
    '#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )',
    'objectNormal = morphedNormal;',
    '#endif',
    '#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )',
    'objectNormal = normal;',
    '#endif',
    '#ifdef FLIP_SIDED',
    'objectNormal = -objectNormal;',
    '#endif',
    'vec3 transformedNormal = normalMatrix * objectNormal;'
  ].join('\n'),
  shadowmap_pars_fragment: [
    '#ifdef USE_SHADOWMAP',
    'uniform sampler2D shadowMap[ MAX_SHADOWS ];',
    'uniform vec2 shadowMapSize[ MAX_SHADOWS ];',
    'uniform float shadowDarkness[ MAX_SHADOWS ];',
    'uniform float shadowBias[ MAX_SHADOWS ];',
    'varying vec4 vShadowCoord[ MAX_SHADOWS ];',
    'float unpackDepth( const in vec4 rgba_depth ) {',
    'const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );',
    'float depth = dot( rgba_depth, bit_shift );',
    'return depth;',
    '}',
    '#endif'
  ].join('\n'),
  shadowmap_fragment: [
    '#ifdef USE_SHADOWMAP',
    '#ifdef SHADOWMAP_DEBUG',
    'vec3 frustumColors[3];',
    'frustumColors[0] = vec3( 1.0, 0.5, 0.0 );',
    'frustumColors[1] = vec3( 0.0, 1.0, 0.8 );',
    'frustumColors[2] = vec3( 0.0, 0.5, 1.0 );',
    '#endif',
    '#ifdef SHADOWMAP_CASCADE',
    'int inFrustumCount = 0;',
    '#endif',
    'float fDepth;',
    'vec3 shadowColor = vec3( 1.0 );',
    'for( int i = 0; i < MAX_SHADOWS; i ++ ) {',
    'vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;',
    'bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );',
    'bool inFrustum = all( inFrustumVec );',
    '#ifdef SHADOWMAP_CASCADE',
    'inFrustumCount += int( inFrustum );',
    'bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );',
    '#else',
    'bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );',
    '#endif',
    'bool frustumTest = all( frustumTestVec );',
    'if ( frustumTest ) {',
    'shadowCoord.z += shadowBias[ i ];',
    '#if defined( SHADOWMAP_TYPE_PCF )',
    'float shadow = 0.0;',
    'const float shadowDelta = 1.0 / 9.0;',
    'float xPixelOffset = 1.0 / shadowMapSize[ i ].x;',
    'float yPixelOffset = 1.0 / shadowMapSize[ i ].y;',
    'float dx0 = -1.25 * xPixelOffset;',
    'float dy0 = -1.25 * yPixelOffset;',
    'float dx1 = 1.25 * xPixelOffset;',
    'float dy1 = 1.25 * yPixelOffset;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );',
    '#elif defined( SHADOWMAP_TYPE_PCF_SOFT )',
    'float shadow = 0.0;',
    'float xPixelOffset = 1.0 / shadowMapSize[ i ].x;',
    'float yPixelOffset = 1.0 / shadowMapSize[ i ].y;',
    'float dx0 = -1.0 * xPixelOffset;',
    'float dy0 = -1.0 * yPixelOffset;',
    'float dx1 = 1.0 * xPixelOffset;',
    'float dy1 = 1.0 * yPixelOffset;',
    'mat3 shadowKernel;',
    'mat3 depthKernel;',
    'depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );',
    'depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );',
    'depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );',
    'depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );',
    'depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );',
    'depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );',
    'depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );',
    'depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );',
    'depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );',
    'vec3 shadowZ = vec3( shadowCoord.z );',
    'shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));',
    'shadowKernel[0] *= vec3(0.25);',
    'shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));',
    'shadowKernel[1] *= vec3(0.25);',
    'shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));',
    'shadowKernel[2] *= vec3(0.25);',
    'vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );',
    'shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );',
    'shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );',
    'vec4 shadowValues;',
    'shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );',
    'shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );',
    'shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );',
    'shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );',
    'shadow = dot( shadowValues, vec4( 1.0 ) );',
    'shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );',
    '#else',
    'vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );',
    'float fDepth = unpackDepth( rgbaDepth );',
    'if ( fDepth < shadowCoord.z )',
    'shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );',
    '#endif',
    '}',
    '#ifdef SHADOWMAP_DEBUG',
    '#ifdef SHADOWMAP_CASCADE',
    'if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];',
    '#else',
    'if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];',
    '#endif',
    '#endif',
    '}',
    '#ifdef GAMMA_OUTPUT',
    'shadowColor *= shadowColor;',
    '#endif',
    'gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;',
    '#endif'
  ].join('\n'),
  shadowmap_pars_vertex: [
    '#ifdef USE_SHADOWMAP',
    'varying vec4 vShadowCoord[ MAX_SHADOWS ];',
    'uniform mat4 shadowMatrix[ MAX_SHADOWS ];',
    '#endif'
  ].join('\n'),
  shadowmap_vertex: [
    '#ifdef USE_SHADOWMAP',
    'for( int i = 0; i < MAX_SHADOWS; i ++ ) {',
    'vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;',
    '}',
    '#endif'
  ].join('\n'),
  alphatest_fragment: [
    '#ifdef ALPHATEST',
    'if ( gl_FragColor.a < ALPHATEST ) discard;',
    '#endif'
  ].join('\n'),
  linear_to_gamma_fragment: [
    '#ifdef GAMMA_OUTPUT',
    'gl_FragColor.xyz = sqrt( gl_FragColor.xyz );',
    '#endif'
  ].join('\n')
};
THREE.UniformsUtils = {
  merge: function (uniforms) {
    var u, p, tmp, merged = {};
    for (u = 0; u < uniforms.length; u++) {
      tmp = this.clone(uniforms[u]);
      for (p in tmp) {
        merged[p] = tmp[p];
      }
    }
    return merged;
  },
  clone: function (uniforms_src) {
    var u, p, parameter, parameter_src, uniforms_dst = {};
    for (u in uniforms_src) {
      uniforms_dst[u] = {};
      for (p in uniforms_src[u]) {
        parameter_src = uniforms_src[u][p];
        if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {
          uniforms_dst[u][p] = parameter_src.clone();
        } else if (parameter_src instanceof Array) {
          uniforms_dst[u][p] = parameter_src.slice();
        } else {
          uniforms_dst[u][p] = parameter_src;
        }
      }
    }
    return uniforms_dst;
  }
};
THREE.UniformsLib = {
  common: {
    'diffuse': {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    'opacity': {
      type: 'f',
      value: 1
    },
    'map': {
      type: 't',
      value: null
    },
    'offsetRepeat': {
      type: 'v4',
      value: new THREE.Vector4(0, 0, 1, 1)
    },
    'lightMap': {
      type: 't',
      value: null
    },
    'specularMap': {
      type: 't',
      value: null
    },
    'envMap': {
      type: 't',
      value: null
    },
    'flipEnvMap': {
      type: 'f',
      value: -1
    },
    'useRefract': {
      type: 'i',
      value: 0
    },
    'reflectivity': {
      type: 'f',
      value: 1
    },
    'refractionRatio': {
      type: 'f',
      value: 0.98
    },
    'combine': {
      type: 'i',
      value: 0
    },
    'morphTargetInfluences': {
      type: 'f',
      value: 0
    }
  },
  bump: {
    'bumpMap': {
      type: 't',
      value: null
    },
    'bumpScale': {
      type: 'f',
      value: 1
    }
  },
  normalmap: {
    'normalMap': {
      type: 't',
      value: null
    },
    'normalScale': {
      type: 'v2',
      value: new THREE.Vector2(1, 1)
    }
  },
  fog: {
    'fogDensity': {
      type: 'f',
      value: 0.00025
    },
    'fogNear': {
      type: 'f',
      value: 1
    },
    'fogFar': {
      type: 'f',
      value: 2000
    },
    'fogColor': {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  lights: {
    'ambientLightColor': {
      type: 'fv',
      value: []
    },
    'directionalLightDirection': {
      type: 'fv',
      value: []
    },
    'directionalLightColor': {
      type: 'fv',
      value: []
    },
    'hemisphereLightDirection': {
      type: 'fv',
      value: []
    },
    'hemisphereLightSkyColor': {
      type: 'fv',
      value: []
    },
    'hemisphereLightGroundColor': {
      type: 'fv',
      value: []
    },
    'pointLightColor': {
      type: 'fv',
      value: []
    },
    'pointLightPosition': {
      type: 'fv',
      value: []
    },
    'pointLightDistance': {
      type: 'fv1',
      value: []
    },
    'spotLightColor': {
      type: 'fv',
      value: []
    },
    'spotLightPosition': {
      type: 'fv',
      value: []
    },
    'spotLightDirection': {
      type: 'fv',
      value: []
    },
    'spotLightDistance': {
      type: 'fv1',
      value: []
    },
    'spotLightAngleCos': {
      type: 'fv1',
      value: []
    },
    'spotLightExponent': {
      type: 'fv1',
      value: []
    }
  },
  particle: {
    'psColor': {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    'opacity': {
      type: 'f',
      value: 1
    },
    'size': {
      type: 'f',
      value: 1
    },
    'scale': {
      type: 'f',
      value: 1
    },
    'map': {
      type: 't',
      value: null
    },
    'fogDensity': {
      type: 'f',
      value: 0.00025
    },
    'fogNear': {
      type: 'f',
      value: 1
    },
    'fogFar': {
      type: 'f',
      value: 2000
    },
    'fogColor': {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  shadowmap: {
    'shadowMap': {
      type: 'tv',
      value: []
    },
    'shadowMapSize': {
      type: 'v2v',
      value: []
    },
    'shadowBias': {
      type: 'fv1',
      value: []
    },
    'shadowDarkness': {
      type: 'fv1',
      value: []
    },
    'shadowMatrix': {
      type: 'm4v',
      value: []
    }
  }
};
THREE.ShaderLib = {
  'basic': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['shadowmap']
    ]),
    vertexShader: [
      THREE.ShaderChunk['map_pars_vertex'],
      THREE.ShaderChunk['lightmap_pars_vertex'],
      THREE.ShaderChunk['envmap_pars_vertex'],
      THREE.ShaderChunk['color_pars_vertex'],
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      THREE.ShaderChunk['skinning_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['map_vertex'],
      THREE.ShaderChunk['lightmap_vertex'],
      THREE.ShaderChunk['color_vertex'],
      THREE.ShaderChunk['skinbase_vertex'],
      '#ifdef USE_ENVMAP',
      THREE.ShaderChunk['morphnormal_vertex'],
      THREE.ShaderChunk['skinnormal_vertex'],
      THREE.ShaderChunk['defaultnormal_vertex'],
      '#endif',
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['skinning_vertex'],
      THREE.ShaderChunk['default_vertex'],
      THREE.ShaderChunk['worldpos_vertex'],
      THREE.ShaderChunk['envmap_vertex'],
      THREE.ShaderChunk['shadowmap_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;',
      'uniform float opacity;',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['map_pars_fragment'],
      THREE.ShaderChunk['lightmap_pars_fragment'],
      THREE.ShaderChunk['envmap_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      THREE.ShaderChunk['specularmap_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk['map_fragment'],
      THREE.ShaderChunk['alphatest_fragment'],
      THREE.ShaderChunk['specularmap_fragment'],
      THREE.ShaderChunk['lightmap_fragment'],
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['envmap_fragment'],
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['linear_to_gamma_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'lambert': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['lights'],
      THREE.UniformsLib['shadowmap'],
      {
        'ambient': {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        'emissive': {
          type: 'c',
          value: new THREE.Color(0)
        },
        'wrapRGB': {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define LAMBERT',
      'varying vec3 vLightFront;',
      '#ifdef DOUBLE_SIDED',
      'varying vec3 vLightBack;',
      '#endif',
      THREE.ShaderChunk['map_pars_vertex'],
      THREE.ShaderChunk['lightmap_pars_vertex'],
      THREE.ShaderChunk['envmap_pars_vertex'],
      THREE.ShaderChunk['lights_lambert_pars_vertex'],
      THREE.ShaderChunk['color_pars_vertex'],
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      THREE.ShaderChunk['skinning_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['map_vertex'],
      THREE.ShaderChunk['lightmap_vertex'],
      THREE.ShaderChunk['color_vertex'],
      THREE.ShaderChunk['morphnormal_vertex'],
      THREE.ShaderChunk['skinbase_vertex'],
      THREE.ShaderChunk['skinnormal_vertex'],
      THREE.ShaderChunk['defaultnormal_vertex'],
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['skinning_vertex'],
      THREE.ShaderChunk['default_vertex'],
      THREE.ShaderChunk['worldpos_vertex'],
      THREE.ShaderChunk['envmap_vertex'],
      THREE.ShaderChunk['lights_lambert_vertex'],
      THREE.ShaderChunk['shadowmap_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float opacity;',
      'varying vec3 vLightFront;',
      '#ifdef DOUBLE_SIDED',
      'varying vec3 vLightBack;',
      '#endif',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['map_pars_fragment'],
      THREE.ShaderChunk['lightmap_pars_fragment'],
      THREE.ShaderChunk['envmap_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      THREE.ShaderChunk['specularmap_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( vec3 ( 1.0 ), opacity );',
      THREE.ShaderChunk['map_fragment'],
      THREE.ShaderChunk['alphatest_fragment'],
      THREE.ShaderChunk['specularmap_fragment'],
      '#ifdef DOUBLE_SIDED',
      'if ( gl_FrontFacing )',
      'gl_FragColor.xyz *= vLightFront;',
      'else',
      'gl_FragColor.xyz *= vLightBack;',
      '#else',
      'gl_FragColor.xyz *= vLightFront;',
      '#endif',
      THREE.ShaderChunk['lightmap_fragment'],
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['envmap_fragment'],
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['linear_to_gamma_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'phong': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['bump'],
      THREE.UniformsLib['normalmap'],
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['lights'],
      THREE.UniformsLib['shadowmap'],
      {
        'ambient': {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        'emissive': {
          type: 'c',
          value: new THREE.Color(0)
        },
        'specular': {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        'shininess': {
          type: 'f',
          value: 30
        },
        'wrapRGB': {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define PHONG',
      'varying vec3 vViewPosition;',
      'varying vec3 vNormal;',
      THREE.ShaderChunk['map_pars_vertex'],
      THREE.ShaderChunk['lightmap_pars_vertex'],
      THREE.ShaderChunk['envmap_pars_vertex'],
      THREE.ShaderChunk['lights_phong_pars_vertex'],
      THREE.ShaderChunk['color_pars_vertex'],
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      THREE.ShaderChunk['skinning_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['map_vertex'],
      THREE.ShaderChunk['lightmap_vertex'],
      THREE.ShaderChunk['color_vertex'],
      THREE.ShaderChunk['morphnormal_vertex'],
      THREE.ShaderChunk['skinbase_vertex'],
      THREE.ShaderChunk['skinnormal_vertex'],
      THREE.ShaderChunk['defaultnormal_vertex'],
      'vNormal = normalize( transformedNormal );',
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['skinning_vertex'],
      THREE.ShaderChunk['default_vertex'],
      'vViewPosition = -mvPosition.xyz;',
      THREE.ShaderChunk['worldpos_vertex'],
      THREE.ShaderChunk['envmap_vertex'],
      THREE.ShaderChunk['lights_phong_vertex'],
      THREE.ShaderChunk['shadowmap_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;',
      'uniform float opacity;',
      'uniform vec3 ambient;',
      'uniform vec3 emissive;',
      'uniform vec3 specular;',
      'uniform float shininess;',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['map_pars_fragment'],
      THREE.ShaderChunk['lightmap_pars_fragment'],
      THREE.ShaderChunk['envmap_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      THREE.ShaderChunk['lights_phong_pars_fragment'],
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      THREE.ShaderChunk['bumpmap_pars_fragment'],
      THREE.ShaderChunk['normalmap_pars_fragment'],
      THREE.ShaderChunk['specularmap_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( vec3 ( 1.0 ), opacity );',
      THREE.ShaderChunk['map_fragment'],
      THREE.ShaderChunk['alphatest_fragment'],
      THREE.ShaderChunk['specularmap_fragment'],
      THREE.ShaderChunk['lights_phong_fragment'],
      THREE.ShaderChunk['lightmap_fragment'],
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['envmap_fragment'],
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['linear_to_gamma_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'particle_basic': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['particle'],
      THREE.UniformsLib['shadowmap']
    ]),
    vertexShader: [
      'uniform float size;',
      'uniform float scale;',
      THREE.ShaderChunk['color_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['color_vertex'],
      'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
      '#ifdef USE_SIZEATTENUATION',
      'gl_PointSize = size * ( scale / length( mvPosition.xyz ) );',
      '#else',
      'gl_PointSize = size;',
      '#endif',
      'gl_Position = projectionMatrix * mvPosition;',
      THREE.ShaderChunk['worldpos_vertex'],
      THREE.ShaderChunk['shadowmap_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 psColor;',
      'uniform float opacity;',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['map_particle_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( psColor, opacity );',
      THREE.ShaderChunk['map_particle_fragment'],
      THREE.ShaderChunk['alphatest_fragment'],
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'dashed': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['fog'],
      {
        'scale': {
          type: 'f',
          value: 1
        },
        'dashSize': {
          type: 'f',
          value: 1
        },
        'totalSize': {
          type: 'f',
          value: 2
        }
      }
    ]),
    vertexShader: [
      'uniform float scale;',
      'attribute float lineDistance;',
      'varying float vLineDistance;',
      THREE.ShaderChunk['color_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['color_vertex'],
      'vLineDistance = scale * lineDistance;',
      'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
      'gl_Position = projectionMatrix * mvPosition;',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;',
      'uniform float opacity;',
      'uniform float dashSize;',
      'uniform float totalSize;',
      'varying float vLineDistance;',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      'void main() {',
      'if ( mod( vLineDistance, totalSize ) > dashSize ) {',
      'discard;',
      '}',
      'gl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'depth': {
    uniforms: {
      'mNear': {
        type: 'f',
        value: 1
      },
      'mFar': {
        type: 'f',
        value: 2000
      },
      'opacity': {
        type: 'f',
        value: 1
      }
    },
    vertexShader: [
      'void main() {',
      'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float mNear;',
      'uniform float mFar;',
      'uniform float opacity;',
      'void main() {',
      'float depth = gl_FragCoord.z / gl_FragCoord.w;',
      'float color = 1.0 - smoothstep( mNear, mFar, depth );',
      'gl_FragColor = vec4( vec3( color ), opacity );',
      '}'
    ].join('\n')
  },
  'normal': {
    uniforms: {
      'opacity': {
        type: 'f',
        value: 1
      }
    },
    vertexShader: [
      'varying vec3 vNormal;',
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      'void main() {',
      'vNormal = normalize( normalMatrix * normal );',
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['default_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float opacity;',
      'varying vec3 vNormal;',
      'void main() {',
      'gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );',
      '}'
    ].join('\n')
  },
  'normalmap': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['lights'],
      THREE.UniformsLib['shadowmap'],
      {
        'enableAO': {
          type: 'i',
          value: 0
        },
        'enableDiffuse': {
          type: 'i',
          value: 0
        },
        'enableSpecular': {
          type: 'i',
          value: 0
        },
        'enableReflection': {
          type: 'i',
          value: 0
        },
        'enableDisplacement': {
          type: 'i',
          value: 0
        },
        'tDisplacement': {
          type: 't',
          value: null
        },
        'tDiffuse': {
          type: 't',
          value: null
        },
        'tCube': {
          type: 't',
          value: null
        },
        'tNormal': {
          type: 't',
          value: null
        },
        'tSpecular': {
          type: 't',
          value: null
        },
        'tAO': {
          type: 't',
          value: null
        },
        'uNormalScale': {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        'uDisplacementBias': {
          type: 'f',
          value: 0
        },
        'uDisplacementScale': {
          type: 'f',
          value: 1
        },
        'uDiffuseColor': {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        'uSpecularColor': {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        'uAmbientColor': {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        'uShininess': {
          type: 'f',
          value: 30
        },
        'uOpacity': {
          type: 'f',
          value: 1
        },
        'useRefract': {
          type: 'i',
          value: 0
        },
        'uRefractionRatio': {
          type: 'f',
          value: 0.98
        },
        'uReflectivity': {
          type: 'f',
          value: 0.5
        },
        'uOffset': {
          type: 'v2',
          value: new THREE.Vector2(0, 0)
        },
        'uRepeat': {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        'wrapRGB': {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    fragmentShader: [
      'uniform vec3 uAmbientColor;',
      'uniform vec3 uDiffuseColor;',
      'uniform vec3 uSpecularColor;',
      'uniform float uShininess;',
      'uniform float uOpacity;',
      'uniform bool enableDiffuse;',
      'uniform bool enableSpecular;',
      'uniform bool enableAO;',
      'uniform bool enableReflection;',
      'uniform sampler2D tDiffuse;',
      'uniform sampler2D tNormal;',
      'uniform sampler2D tSpecular;',
      'uniform sampler2D tAO;',
      'uniform samplerCube tCube;',
      'uniform vec2 uNormalScale;',
      'uniform bool useRefract;',
      'uniform float uRefractionRatio;',
      'uniform float uReflectivity;',
      'varying vec3 vTangent;',
      'varying vec3 vBinormal;',
      'varying vec3 vNormal;',
      'varying vec2 vUv;',
      'uniform vec3 ambientLightColor;',
      '#if MAX_DIR_LIGHTS > 0',
      'uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];',
      'uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];',
      '#endif',
      '#if MAX_HEMI_LIGHTS > 0',
      'uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];',
      'uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];',
      'uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];',
      '#endif',
      '#if MAX_POINT_LIGHTS > 0',
      'uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];',
      'uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];',
      'uniform float pointLightDistance[ MAX_POINT_LIGHTS ];',
      '#endif',
      '#if MAX_SPOT_LIGHTS > 0',
      'uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];',
      'uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];',
      'uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];',
      'uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];',
      'uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];',
      'uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];',
      '#endif',
      '#ifdef WRAP_AROUND',
      'uniform vec3 wrapRGB;',
      '#endif',
      'varying vec3 vWorldPosition;',
      'varying vec3 vViewPosition;',
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( vec3( 1.0 ), uOpacity );',
      'vec3 specularTex = vec3( 1.0 );',
      'vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;',
      'normalTex.xy *= uNormalScale;',
      'normalTex = normalize( normalTex );',
      'if( enableDiffuse ) {',
      '#ifdef GAMMA_INPUT',
      'vec4 texelColor = texture2D( tDiffuse, vUv );',
      'texelColor.xyz *= texelColor.xyz;',
      'gl_FragColor = gl_FragColor * texelColor;',
      '#else',
      'gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );',
      '#endif',
      '}',
      'if( enableAO ) {',
      '#ifdef GAMMA_INPUT',
      'vec4 aoColor = texture2D( tAO, vUv );',
      'aoColor.xyz *= aoColor.xyz;',
      'gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;',
      '#else',
      'gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;',
      '#endif',
      '}',
      'if( enableSpecular )',
      'specularTex = texture2D( tSpecular, vUv ).xyz;',
      'mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );',
      'vec3 finalNormal = tsb * normalTex;',
      '#ifdef FLIP_SIDED',
      'finalNormal = -finalNormal;',
      '#endif',
      'vec3 normal = normalize( finalNormal );',
      'vec3 viewPosition = normalize( vViewPosition );',
      '#if MAX_POINT_LIGHTS > 0',
      'vec3 pointDiffuse = vec3( 0.0 );',
      'vec3 pointSpecular = vec3( 0.0 );',
      'for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {',
      'vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );',
      'vec3 pointVector = lPosition.xyz + vViewPosition.xyz;',
      'float pointDistance = 1.0;',
      'if ( pointLightDistance[ i ] > 0.0 )',
      'pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );',
      'pointVector = normalize( pointVector );',
      '#ifdef WRAP_AROUND',
      'float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );',
      'float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );',
      'vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );',
      '#else',
      'float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );',
      '#endif',
      'pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;',
      'vec3 pointHalfVector = normalize( pointVector + viewPosition );',
      'float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );',
      'float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );',
      '#ifdef PHYSICALLY_BASED_SHADING',
      'float specularNormalization = ( uShininess + 2.0001 ) / 8.0;',
      'vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );',
      'pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;',
      '#else',
      'pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;',
      '#endif',
      '}',
      '#endif',
      '#if MAX_SPOT_LIGHTS > 0',
      'vec3 spotDiffuse = vec3( 0.0 );',
      'vec3 spotSpecular = vec3( 0.0 );',
      'for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {',
      'vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );',
      'vec3 spotVector = lPosition.xyz + vViewPosition.xyz;',
      'float spotDistance = 1.0;',
      'if ( spotLightDistance[ i ] > 0.0 )',
      'spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );',
      'spotVector = normalize( spotVector );',
      'float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );',
      'if ( spotEffect > spotLightAngleCos[ i ] ) {',
      'spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );',
      '#ifdef WRAP_AROUND',
      'float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );',
      'float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );',
      'vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );',
      '#else',
      'float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );',
      '#endif',
      'spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;',
      'vec3 spotHalfVector = normalize( spotVector + viewPosition );',
      'float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );',
      'float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );',
      '#ifdef PHYSICALLY_BASED_SHADING',
      'float specularNormalization = ( uShininess + 2.0001 ) / 8.0;',
      'vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );',
      'spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;',
      '#else',
      'spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;',
      '#endif',
      '}',
      '}',
      '#endif',
      '#if MAX_DIR_LIGHTS > 0',
      'vec3 dirDiffuse = vec3( 0.0 );',
      'vec3 dirSpecular = vec3( 0.0 );',
      'for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {',
      'vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );',
      'vec3 dirVector = normalize( lDirection.xyz );',
      '#ifdef WRAP_AROUND',
      'float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );',
      'float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );',
      'vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );',
      '#else',
      'float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );',
      '#endif',
      'dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;',
      'vec3 dirHalfVector = normalize( dirVector + viewPosition );',
      'float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );',
      'float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );',
      '#ifdef PHYSICALLY_BASED_SHADING',
      'float specularNormalization = ( uShininess + 2.0001 ) / 8.0;',
      'vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );',
      'dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;',
      '#else',
      'dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;',
      '#endif',
      '}',
      '#endif',
      '#if MAX_HEMI_LIGHTS > 0',
      'vec3 hemiDiffuse  = vec3( 0.0 );',
      'vec3 hemiSpecular = vec3( 0.0 );',
      'for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {',
      'vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );',
      'vec3 lVector = normalize( lDirection.xyz );',
      'float dotProduct = dot( normal, lVector );',
      'float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;',
      'vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );',
      'hemiDiffuse += uDiffuseColor * hemiColor;',
      'vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );',
      'float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;',
      'float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );',
      'vec3 lVectorGround = -lVector;',
      'vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );',
      'float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;',
      'float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );',
      '#ifdef PHYSICALLY_BASED_SHADING',
      'float dotProductGround = dot( normal, lVectorGround );',
      'float specularNormalization = ( uShininess + 2.0001 ) / 8.0;',
      'vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );',
      'vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );',
      'hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );',
      '#else',
      'hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;',
      '#endif',
      '}',
      '#endif',
      'vec3 totalDiffuse = vec3( 0.0 );',
      'vec3 totalSpecular = vec3( 0.0 );',
      '#if MAX_DIR_LIGHTS > 0',
      'totalDiffuse += dirDiffuse;',
      'totalSpecular += dirSpecular;',
      '#endif',
      '#if MAX_HEMI_LIGHTS > 0',
      'totalDiffuse += hemiDiffuse;',
      'totalSpecular += hemiSpecular;',
      '#endif',
      '#if MAX_POINT_LIGHTS > 0',
      'totalDiffuse += pointDiffuse;',
      'totalSpecular += pointSpecular;',
      '#endif',
      '#if MAX_SPOT_LIGHTS > 0',
      'totalDiffuse += spotDiffuse;',
      'totalSpecular += spotSpecular;',
      '#endif',
      '#ifdef METAL',
      'gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );',
      '#else',
      'gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;',
      '#endif',
      'if ( enableReflection ) {',
      'vec3 vReflect;',
      'vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );',
      'if ( useRefract ) {',
      'vReflect = refract( cameraToVertex, normal, uRefractionRatio );',
      '} else {',
      'vReflect = reflect( cameraToVertex, normal );',
      '}',
      'vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );',
      '#ifdef GAMMA_INPUT',
      'cubeColor.xyz *= cubeColor.xyz;',
      '#endif',
      'gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );',
      '}',
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['linear_to_gamma_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n'),
    vertexShader: [
      'attribute vec4 tangent;',
      'uniform vec2 uOffset;',
      'uniform vec2 uRepeat;',
      'uniform bool enableDisplacement;',
      '#ifdef VERTEX_TEXTURES',
      'uniform sampler2D tDisplacement;',
      'uniform float uDisplacementScale;',
      'uniform float uDisplacementBias;',
      '#endif',
      'varying vec3 vTangent;',
      'varying vec3 vBinormal;',
      'varying vec3 vNormal;',
      'varying vec2 vUv;',
      'varying vec3 vWorldPosition;',
      'varying vec3 vViewPosition;',
      THREE.ShaderChunk['skinning_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['skinbase_vertex'],
      THREE.ShaderChunk['skinnormal_vertex'],
      '#ifdef USE_SKINNING',
      'vNormal = normalize( normalMatrix * skinnedNormal.xyz );',
      'vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );',
      'vTangent = normalize( normalMatrix * skinnedTangent.xyz );',
      '#else',
      'vNormal = normalize( normalMatrix * normal );',
      'vTangent = normalize( normalMatrix * tangent.xyz );',
      '#endif',
      'vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );',
      'vUv = uv * uRepeat + uOffset;',
      'vec3 displacedPosition;',
      '#ifdef VERTEX_TEXTURES',
      'if ( enableDisplacement ) {',
      'vec3 dv = texture2D( tDisplacement, uv ).xyz;',
      'float df = uDisplacementScale * dv.x + uDisplacementBias;',
      'displacedPosition = position + normalize( normal ) * df;',
      '} else {',
      '#ifdef USE_SKINNING',
      'vec4 skinVertex = vec4( position, 1.0 );',
      'vec4 skinned  = boneMatX * skinVertex * skinWeight.x;',
      'skinned \t  += boneMatY * skinVertex * skinWeight.y;',
      'displacedPosition  = skinned.xyz;',
      '#else',
      'displacedPosition = position;',
      '#endif',
      '}',
      '#else',
      '#ifdef USE_SKINNING',
      'vec4 skinVertex = vec4( position, 1.0 );',
      'vec4 skinned  = boneMatX * skinVertex * skinWeight.x;',
      'skinned \t  += boneMatY * skinVertex * skinWeight.y;',
      'displacedPosition  = skinned.xyz;',
      '#else',
      'displacedPosition = position;',
      '#endif',
      '#endif',
      'vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );',
      'vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );',
      'gl_Position = projectionMatrix * mvPosition;',
      'vWorldPosition = worldPosition.xyz;',
      'vViewPosition = -mvPosition.xyz;',
      '#ifdef USE_SHADOWMAP',
      'for( int i = 0; i < MAX_SHADOWS; i ++ ) {',
      'vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;',
      '}',
      '#endif',
      '}'
    ].join('\n')
  },
  'cube': {
    uniforms: {
      'tCube': {
        type: 't',
        value: null
      },
      'tFlip': {
        type: 'f',
        value: -1
      }
    },
    vertexShader: [
      'varying vec3 vWorldPosition;',
      'void main() {',
      'vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
      'vWorldPosition = worldPosition.xyz;',
      'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform samplerCube tCube;',
      'uniform float tFlip;',
      'varying vec3 vWorldPosition;',
      'void main() {',
      'gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );',
      '}'
    ].join('\n')
  },
  'depthRGBA': {
    uniforms: {},
    vertexShader: [
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      THREE.ShaderChunk['skinning_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['skinbase_vertex'],
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['skinning_vertex'],
      THREE.ShaderChunk['default_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'vec4 pack_depth( const in float depth ) {',
      'const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );',
      'const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );',
      'vec4 res = fract( depth * bit_shift );',
      'res -= res.xxyz * bit_mask;',
      'return res;',
      '}',
      'void main() {',
      'gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );',
      '}'
    ].join('\n')
  }
};
THREE.WebGLRenderer = function (parameters) {
  console.log('THREE.WebGLRenderer', THREE.REVISION);
  parameters = parameters || {};
  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'), _precision = parameters.precision !== undefined ? parameters.precision : 'highp', _alpha = parameters.alpha !== undefined ? parameters.alpha : true, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _clearColor = new THREE.Color(0), _clearAlpha = 0;
  this.domElement = _canvas;
  this.context = null;
  this.devicePixelRatio = parameters.devicePixelRatio !== undefined ? parameters.devicePixelRatio : self.devicePixelRatio !== undefined ? self.devicePixelRatio : 1;
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.autoUpdateObjects = true;
  this.gammaInput = false;
  this.gammaOutput = false;
  this.physicallyBasedShading = false;
  this.shadowMapEnabled = false;
  this.shadowMapAutoUpdate = true;
  this.shadowMapType = THREE.PCFShadowMap;
  this.shadowMapCullFace = THREE.CullFaceFront;
  this.shadowMapDebug = false;
  this.shadowMapCascade = false;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  this.autoScaleCubemaps = true;
  this.renderPluginsPre = [];
  this.renderPluginsPost = [];
  this.info = {
    memory: {
      programs: 0,
      geometries: 0,
      textures: 0
    },
    render: {
      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0
    }
  };
  var _this = this, _programs = [], _programs_counter = 0, _currentProgram = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryGroupHash = null, _currentCamera = null, _geometryGroupCounter = 0, _usedTextureUnits = 0, _oldDoubleSided = -1, _oldFlipSided = -1, _oldBlending = -1, _oldBlendEquation = -1, _oldBlendSrc = -1, _oldBlendDst = -1, _oldDepthTest = -1, _oldDepthWrite = -1, _oldPolygonOffset = null, _oldPolygonOffsetFactor = null, _oldPolygonOffsetUnits = null, _oldLineWidth = null, _viewportX = 0, _viewportY = 0, _viewportWidth = _canvas.width, _viewportHeight = _canvas.height, _currentWidth = 0, _currentHeight = 0, _enabledAttributes = {}, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4(), _projScreenMatrixPS = new THREE.Matrix4(), _vector3 = new THREE.Vector3(), _direction = new THREE.Vector3(), _lightsNeedUpdate = true, _lights = {
      ambient: [
        0,
        0,
        0
      ],
      directional: {
        length: 0,
        colors: new Array(),
        positions: new Array()
      },
      point: {
        length: 0,
        colors: new Array(),
        positions: new Array(),
        distances: new Array()
      },
      spot: {
        length: 0,
        colors: new Array(),
        positions: new Array(),
        distances: new Array(),
        directions: new Array(),
        anglesCos: new Array(),
        exponents: new Array()
      },
      hemi: {
        length: 0,
        skyColors: new Array(),
        groundColors: new Array(),
        positions: new Array()
      }
    };
  var _gl;
  var _glExtensionTextureFloat;
  var _glExtensionTextureFloatLinear;
  var _glExtensionStandardDerivatives;
  var _glExtensionTextureFilterAnisotropic;
  var _glExtensionCompressedTextureS3TC;
  initGL();
  setDefaultGLState();
  this.context = _gl;
  var _maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);
  var _maxVertexTextures = _gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  var _maxTextureSize = _gl.getParameter(_gl.MAX_TEXTURE_SIZE);
  var _maxCubemapSize = _gl.getParameter(_gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter(_glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
  var _supportsVertexTextures = _maxVertexTextures > 0;
  var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;
  var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter(_gl.COMPRESSED_TEXTURE_FORMATS) : [];
  var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_FLOAT);
  var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT);
  var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.LOW_FLOAT);
  var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT);
  var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT);
  var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.LOW_FLOAT);
  var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_INT);
  var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_INT);
  var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.LOW_INT);
  var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_INT);
  var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_INT);
  var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.LOW_INT);
  var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
  var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;
  if (_precision === 'highp' && !highpAvailable) {
    if (mediumpAvailable) {
      _precision = 'mediump';
      console.warn('WebGLRenderer: highp not supported, using mediump');
    } else {
      _precision = 'lowp';
      console.warn('WebGLRenderer: highp and mediump not supported, using lowp');
    }
  }
  if (_precision === 'mediump' && !mediumpAvailable) {
    _precision = 'lowp';
    console.warn('WebGLRenderer: mediump not supported, using lowp');
  }
  this.getContext = function () {
    return _gl;
  };
  this.supportsVertexTextures = function () {
    return _supportsVertexTextures;
  };
  this.supportsFloatTextures = function () {
    return _glExtensionTextureFloat;
  };
  this.supportsStandardDerivatives = function () {
    return _glExtensionStandardDerivatives;
  };
  this.supportsCompressedTextureS3TC = function () {
    return _glExtensionCompressedTextureS3TC;
  };
  this.getMaxAnisotropy = function () {
    return _maxAnisotropy;
  };
  this.getPrecision = function () {
    return _precision;
  };
  this.setSize = function (width, height, updateStyle) {
    _canvas.width = width * this.devicePixelRatio;
    _canvas.height = height * this.devicePixelRatio;
    if (this.devicePixelRatio !== 1 && updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }
    this.setViewport(0, 0, _canvas.width, _canvas.height);
  };
  this.setViewport = function (x, y, width, height) {
    _viewportX = x !== undefined ? x : 0;
    _viewportY = y !== undefined ? y : 0;
    _viewportWidth = width !== undefined ? width : _canvas.width;
    _viewportHeight = height !== undefined ? height : _canvas.height;
    _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
  };
  this.setScissor = function (x, y, width, height) {
    _gl.scissor(x, y, width, height);
  };
  this.enableScissorTest = function (enable) {
    enable ? _gl.enable(_gl.SCISSOR_TEST) : _gl.disable(_gl.SCISSOR_TEST);
  };
  this.setClearColor = function (color, alpha) {
    _clearColor.set(color);
    _clearAlpha = alpha !== undefined ? alpha : 1;
    _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
  };
  this.setClearColorHex = function (hex, alpha) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(hex, alpha);
  };
  this.getClearColor = function () {
    return _clearColor;
  };
  this.getClearAlpha = function () {
    return _clearAlpha;
  };
  this.clear = function (color, depth, stencil) {
    var bits = 0;
    if (color === undefined || color)
      bits |= _gl.COLOR_BUFFER_BIT;
    if (depth === undefined || depth)
      bits |= _gl.DEPTH_BUFFER_BIT;
    if (stencil === undefined || stencil)
      bits |= _gl.STENCIL_BUFFER_BIT;
    _gl.clear(bits);
  };
  this.clearTarget = function (renderTarget, color, depth, stencil) {
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  };
  this.addPostPlugin = function (plugin) {
    plugin.init(this);
    this.renderPluginsPost.push(plugin);
  };
  this.addPrePlugin = function (plugin) {
    plugin.init(this);
    this.renderPluginsPre.push(plugin);
  };
  this.updateShadowMap = function (scene, camera) {
    _currentProgram = null;
    _oldBlending = -1;
    _oldDepthTest = -1;
    _oldDepthWrite = -1;
    _currentGeometryGroupHash = -1;
    _currentMaterialId = -1;
    _lightsNeedUpdate = true;
    _oldDoubleSided = -1;
    _oldFlipSided = -1;
    this.shadowMapPlugin.update(scene, camera);
  };
  function createParticleBuffers(geometry) {
    geometry.__webglVertexBuffer = _gl.createBuffer();
    geometry.__webglColorBuffer = _gl.createBuffer();
    _this.info.memory.geometries++;
  }
  ;
  function createLineBuffers(geometry) {
    geometry.__webglVertexBuffer = _gl.createBuffer();
    geometry.__webglColorBuffer = _gl.createBuffer();
    geometry.__webglLineDistanceBuffer = _gl.createBuffer();
    _this.info.memory.geometries++;
  }
  ;
  function createMeshBuffers(geometryGroup) {
    geometryGroup.__webglVertexBuffer = _gl.createBuffer();
    geometryGroup.__webglNormalBuffer = _gl.createBuffer();
    geometryGroup.__webglTangentBuffer = _gl.createBuffer();
    geometryGroup.__webglColorBuffer = _gl.createBuffer();
    geometryGroup.__webglUVBuffer = _gl.createBuffer();
    geometryGroup.__webglUV2Buffer = _gl.createBuffer();
    geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
    geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();
    geometryGroup.__webglFaceBuffer = _gl.createBuffer();
    geometryGroup.__webglLineBuffer = _gl.createBuffer();
    var m, ml;
    if (geometryGroup.numMorphTargets) {
      geometryGroup.__webglMorphTargetsBuffers = [];
      for (m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++) {
        geometryGroup.__webglMorphTargetsBuffers.push(_gl.createBuffer());
      }
    }
    if (geometryGroup.numMorphNormals) {
      geometryGroup.__webglMorphNormalsBuffers = [];
      for (m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++) {
        geometryGroup.__webglMorphNormalsBuffers.push(_gl.createBuffer());
      }
    }
    _this.info.memory.geometries++;
  }
  ;
  var onGeometryDispose = function (event) {
    var geometry = event.target;
    geometry.removeEventListener('dispose', onGeometryDispose);
    deallocateGeometry(geometry);
  };
  var onTextureDispose = function (event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);
    _this.info.memory.textures--;
  };
  var onRenderTargetDispose = function (event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    _this.info.memory.textures--;
  };
  var onMaterialDispose = function (event) {
    var material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  };
  var deleteBuffers = function (geometry) {
    if (geometry.__webglVertexBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglVertexBuffer);
    if (geometry.__webglNormalBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglNormalBuffer);
    if (geometry.__webglTangentBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglTangentBuffer);
    if (geometry.__webglColorBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglColorBuffer);
    if (geometry.__webglUVBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglUVBuffer);
    if (geometry.__webglUV2Buffer !== undefined)
      _gl.deleteBuffer(geometry.__webglUV2Buffer);
    if (geometry.__webglSkinIndicesBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglSkinIndicesBuffer);
    if (geometry.__webglSkinWeightsBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglSkinWeightsBuffer);
    if (geometry.__webglFaceBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglFaceBuffer);
    if (geometry.__webglLineBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglLineBuffer);
    if (geometry.__webglLineDistanceBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglLineDistanceBuffer);
    if (geometry.__webglCustomAttributesList !== undefined) {
      for (var id in geometry.__webglCustomAttributesList) {
        _gl.deleteBuffer(geometry.__webglCustomAttributesList[id].buffer);
      }
    }
    _this.info.memory.geometries--;
  };
  var deallocateGeometry = function (geometry) {
    geometry.__webglInit = undefined;
    if (geometry instanceof THREE.BufferGeometry) {
      var attributes = geometry.attributes;
      for (var key in attributes) {
        if (attributes[key].buffer !== undefined) {
          _gl.deleteBuffer(attributes[key].buffer);
        }
      }
      _this.info.memory.geometries--;
    } else {
      if (geometry.geometryGroups !== undefined) {
        for (var g in geometry.geometryGroups) {
          var geometryGroup = geometry.geometryGroups[g];
          if (geometryGroup.numMorphTargets !== undefined) {
            for (var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++) {
              _gl.deleteBuffer(geometryGroup.__webglMorphTargetsBuffers[m]);
            }
          }
          if (geometryGroup.numMorphNormals !== undefined) {
            for (var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++) {
              _gl.deleteBuffer(geometryGroup.__webglMorphNormalsBuffers[m]);
            }
          }
          deleteBuffers(geometryGroup);
        }
      } else {
        deleteBuffers(geometry);
      }
    }
  };
  var deallocateTexture = function (texture) {
    if (texture.image && texture.image.__webglTextureCube) {
      _gl.deleteTexture(texture.image.__webglTextureCube);
    } else {
      if (!texture.__webglInit)
        return;
      texture.__webglInit = false;
      _gl.deleteTexture(texture.__webglTexture);
    }
  };
  var deallocateRenderTarget = function (renderTarget) {
    if (!renderTarget || !renderTarget.__webglTexture)
      return;
    _gl.deleteTexture(renderTarget.__webglTexture);
    if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
      for (var i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTarget.__webglFramebuffer[i]);
        _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTarget.__webglFramebuffer);
      _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer);
    }
  };
  var deallocateMaterial = function (material) {
    var program = material.program;
    if (program === undefined)
      return;
    material.program = undefined;
    var i, il, programInfo;
    var deleteProgram = false;
    for (i = 0, il = _programs.length; i < il; i++) {
      programInfo = _programs[i];
      if (programInfo.program === program) {
        programInfo.usedTimes--;
        if (programInfo.usedTimes === 0) {
          deleteProgram = true;
        }
        break;
      }
    }
    if (deleteProgram === true) {
      var newPrograms = [];
      for (i = 0, il = _programs.length; i < il; i++) {
        programInfo = _programs[i];
        if (programInfo.program !== program) {
          newPrograms.push(programInfo);
        }
      }
      _programs = newPrograms;
      _gl.deleteProgram(program);
      _this.info.memory.programs--;
    }
  };
  function initCustomAttributes(geometry, object) {
    var nvertices = geometry.vertices.length;
    var material = object.material;
    if (material.attributes) {
      if (geometry.__webglCustomAttributesList === undefined) {
        geometry.__webglCustomAttributesList = [];
      }
      for (var a in material.attributes) {
        var attribute = material.attributes[a];
        if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
          attribute.__webglInitialized = true;
          var size = 1;
          if (attribute.type === 'v2')
            size = 2;
          else if (attribute.type === 'v3')
            size = 3;
          else if (attribute.type === 'v4')
            size = 4;
          else if (attribute.type === 'c')
            size = 3;
          attribute.size = size;
          attribute.array = new Float32Array(nvertices * size);
          attribute.buffer = _gl.createBuffer();
          attribute.buffer.belongsToAttribute = a;
          attribute.needsUpdate = true;
        }
        geometry.__webglCustomAttributesList.push(attribute);
      }
    }
  }
  ;
  function initParticleBuffers(geometry, object) {
    var nvertices = geometry.vertices.length;
    geometry.__vertexArray = new Float32Array(nvertices * 3);
    geometry.__colorArray = new Float32Array(nvertices * 3);
    geometry.__sortArray = [];
    geometry.__webglParticleCount = nvertices;
    initCustomAttributes(geometry, object);
  }
  ;
  function initLineBuffers(geometry, object) {
    var nvertices = geometry.vertices.length;
    geometry.__vertexArray = new Float32Array(nvertices * 3);
    geometry.__colorArray = new Float32Array(nvertices * 3);
    geometry.__lineDistanceArray = new Float32Array(nvertices * 1);
    geometry.__webglLineCount = nvertices;
    initCustomAttributes(geometry, object);
  }
  ;
  function initMeshBuffers(geometryGroup, object) {
    var geometry = object.geometry, faces3 = geometryGroup.faces3, nvertices = faces3.length * 3, ntris = faces3.length * 1, nlines = faces3.length * 3, material = getBufferMaterial(object, geometryGroup), uvType = bufferGuessUVType(material), normalType = bufferGuessNormalType(material), vertexColorType = bufferGuessVertexColorType(material);
    geometryGroup.__vertexArray = new Float32Array(nvertices * 3);
    if (normalType) {
      geometryGroup.__normalArray = new Float32Array(nvertices * 3);
    }
    if (geometry.hasTangents) {
      geometryGroup.__tangentArray = new Float32Array(nvertices * 4);
    }
    if (vertexColorType) {
      geometryGroup.__colorArray = new Float32Array(nvertices * 3);
    }
    if (uvType) {
      if (geometry.faceVertexUvs.length > 0) {
        geometryGroup.__uvArray = new Float32Array(nvertices * 2);
      }
      if (geometry.faceVertexUvs.length > 1) {
        geometryGroup.__uv2Array = new Float32Array(nvertices * 2);
      }
    }
    if (object.geometry.skinWeights.length && object.geometry.skinIndices.length) {
      geometryGroup.__skinIndexArray = new Float32Array(nvertices * 4);
      geometryGroup.__skinWeightArray = new Float32Array(nvertices * 4);
    }
    geometryGroup.__faceArray = new Uint16Array(ntris * 3);
    geometryGroup.__lineArray = new Uint16Array(nlines * 2);
    var m, ml;
    if (geometryGroup.numMorphTargets) {
      geometryGroup.__morphTargetsArrays = [];
      for (m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++) {
        geometryGroup.__morphTargetsArrays.push(new Float32Array(nvertices * 3));
      }
    }
    if (geometryGroup.numMorphNormals) {
      geometryGroup.__morphNormalsArrays = [];
      for (m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++) {
        geometryGroup.__morphNormalsArrays.push(new Float32Array(nvertices * 3));
      }
    }
    geometryGroup.__webglFaceCount = ntris * 3;
    geometryGroup.__webglLineCount = nlines * 2;
    if (material.attributes) {
      if (geometryGroup.__webglCustomAttributesList === undefined) {
        geometryGroup.__webglCustomAttributesList = [];
      }
      for (var a in material.attributes) {
        var originalAttribute = material.attributes[a];
        var attribute = {};
        for (var property in originalAttribute) {
          attribute[property] = originalAttribute[property];
        }
        if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
          attribute.__webglInitialized = true;
          var size = 1;
          if (attribute.type === 'v2')
            size = 2;
          else if (attribute.type === 'v3')
            size = 3;
          else if (attribute.type === 'v4')
            size = 4;
          else if (attribute.type === 'c')
            size = 3;
          attribute.size = size;
          attribute.array = new Float32Array(nvertices * size);
          attribute.buffer = _gl.createBuffer();
          attribute.buffer.belongsToAttribute = a;
          originalAttribute.needsUpdate = true;
          attribute.__original = originalAttribute;
        }
        geometryGroup.__webglCustomAttributesList.push(attribute);
      }
    }
    geometryGroup.__inittedArrays = true;
  }
  ;
  function getBufferMaterial(object, geometryGroup) {
    return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[geometryGroup.materialIndex] : object.material;
  }
  ;
  function materialNeedsSmoothNormals(material) {
    return material && material.shading !== undefined && material.shading === THREE.SmoothShading;
  }
  ;
  function bufferGuessNormalType(material) {
    if (material instanceof THREE.MeshBasicMaterial && !material.envMap || material instanceof THREE.MeshDepthMaterial) {
      return false;
    }
    if (materialNeedsSmoothNormals(material)) {
      return THREE.SmoothShading;
    } else {
      return THREE.FlatShading;
    }
  }
  ;
  function bufferGuessVertexColorType(material) {
    if (material.vertexColors) {
      return material.vertexColors;
    }
    return false;
  }
  ;
  function bufferGuessUVType(material) {
    if (material.map || material.lightMap || material.bumpMap || material.normalMap || material.specularMap || material instanceof THREE.ShaderMaterial) {
      return true;
    }
    return false;
  }
  ;
  function initDirectBuffers(geometry) {
    var a, attribute, type;
    for (a in geometry.attributes) {
      if (a === 'index') {
        type = _gl.ELEMENT_ARRAY_BUFFER;
      } else {
        type = _gl.ARRAY_BUFFER;
      }
      attribute = geometry.attributes[a];
      if (attribute.numItems === undefined) {
        attribute.numItems = attribute.array.length;
      }
      attribute.buffer = _gl.createBuffer();
      _gl.bindBuffer(type, attribute.buffer);
      _gl.bufferData(type, attribute.array, _gl.STATIC_DRAW);
    }
  }
  ;
  function setParticleBuffers(geometry, hint, object) {
    var v, c, vertex, offset, index, color, vertices = geometry.vertices, vl = vertices.length, colors = geometry.colors, cl = colors.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, sortArray = geometry.__sortArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyElements = geometry.elementsNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, customAttributes = geometry.__webglCustomAttributesList, i, il, a, ca, cal, value, customAttribute;
    if (object.sortParticles) {
      _projScreenMatrixPS.copy(_projScreenMatrix);
      _projScreenMatrixPS.multiply(object.matrixWorld);
      for (v = 0; v < vl; v++) {
        vertex = vertices[v];
        _vector3.copy(vertex);
        _vector3.applyProjection(_projScreenMatrixPS);
        sortArray[v] = [
          _vector3.z,
          v
        ];
      }
      sortArray.sort(numericalSort);
      for (v = 0; v < vl; v++) {
        vertex = vertices[sortArray[v][1]];
        offset = v * 3;
        vertexArray[offset] = vertex.x;
        vertexArray[offset + 1] = vertex.y;
        vertexArray[offset + 2] = vertex.z;
      }
      for (c = 0; c < cl; c++) {
        offset = c * 3;
        color = colors[sortArray[c][1]];
        colorArray[offset] = color.r;
        colorArray[offset + 1] = color.g;
        colorArray[offset + 2] = color.b;
      }
      if (customAttributes) {
        for (i = 0, il = customAttributes.length; i < il; i++) {
          customAttribute = customAttributes[i];
          if (!(customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices'))
            continue;
          offset = 0;
          cal = customAttribute.value.length;
          if (customAttribute.size === 1) {
            for (ca = 0; ca < cal; ca++) {
              index = sortArray[ca][1];
              customAttribute.array[ca] = customAttribute.value[index];
            }
          } else if (customAttribute.size === 2) {
            for (ca = 0; ca < cal; ca++) {
              index = sortArray[ca][1];
              value = customAttribute.value[index];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              offset += 2;
            }
          } else if (customAttribute.size === 3) {
            if (customAttribute.type === 'c') {
              for (ca = 0; ca < cal; ca++) {
                index = sortArray[ca][1];
                value = customAttribute.value[index];
                customAttribute.array[offset] = value.r;
                customAttribute.array[offset + 1] = value.g;
                customAttribute.array[offset + 2] = value.b;
                offset += 3;
              }
            } else {
              for (ca = 0; ca < cal; ca++) {
                index = sortArray[ca][1];
                value = customAttribute.value[index];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                customAttribute.array[offset + 2] = value.z;
                offset += 3;
              }
            }
          } else if (customAttribute.size === 4) {
            for (ca = 0; ca < cal; ca++) {
              index = sortArray[ca][1];
              value = customAttribute.value[index];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              customAttribute.array[offset + 2] = value.z;
              customAttribute.array[offset + 3] = value.w;
              offset += 4;
            }
          }
        }
      }
    } else {
      if (dirtyVertices) {
        for (v = 0; v < vl; v++) {
          vertex = vertices[v];
          offset = v * 3;
          vertexArray[offset] = vertex.x;
          vertexArray[offset + 1] = vertex.y;
          vertexArray[offset + 2] = vertex.z;
        }
      }
      if (dirtyColors) {
        for (c = 0; c < cl; c++) {
          color = colors[c];
          offset = c * 3;
          colorArray[offset] = color.r;
          colorArray[offset + 1] = color.g;
          colorArray[offset + 2] = color.b;
        }
      }
      if (customAttributes) {
        for (i = 0, il = customAttributes.length; i < il; i++) {
          customAttribute = customAttributes[i];
          if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices')) {
            cal = customAttribute.value.length;
            offset = 0;
            if (customAttribute.size === 1) {
              for (ca = 0; ca < cal; ca++) {
                customAttribute.array[ca] = customAttribute.value[ca];
              }
            } else if (customAttribute.size === 2) {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                offset += 2;
              }
            } else if (customAttribute.size === 3) {
              if (customAttribute.type === 'c') {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.r;
                  customAttribute.array[offset + 1] = value.g;
                  customAttribute.array[offset + 2] = value.b;
                  offset += 3;
                }
              } else {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  customAttribute.array[offset + 2] = value.z;
                  offset += 3;
                }
              }
            } else if (customAttribute.size === 4) {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                customAttribute.array[offset + 2] = value.z;
                customAttribute.array[offset + 3] = value.w;
                offset += 4;
              }
            }
          }
        }
      }
    }
    if (dirtyVertices || object.sortParticles) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
    }
    if (dirtyColors || object.sortParticles) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
    }
    if (customAttributes) {
      for (i = 0, il = customAttributes.length; i < il; i++) {
        customAttribute = customAttributes[i];
        if (customAttribute.needsUpdate || object.sortParticles) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
        }
      }
    }
  }
  ;
  function setLineBuffers(geometry, hint) {
    var v, c, d, vertex, offset, color, vertices = geometry.vertices, colors = geometry.colors, lineDistances = geometry.lineDistances, vl = vertices.length, cl = colors.length, dl = lineDistances.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, lineDistanceArray = geometry.__lineDistanceArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyLineDistances = geometry.lineDistancesNeedUpdate, customAttributes = geometry.__webglCustomAttributesList, i, il, a, ca, cal, value, customAttribute;
    if (dirtyVertices) {
      for (v = 0; v < vl; v++) {
        vertex = vertices[v];
        offset = v * 3;
        vertexArray[offset] = vertex.x;
        vertexArray[offset + 1] = vertex.y;
        vertexArray[offset + 2] = vertex.z;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
    }
    if (dirtyColors) {
      for (c = 0; c < cl; c++) {
        color = colors[c];
        offset = c * 3;
        colorArray[offset] = color.r;
        colorArray[offset + 1] = color.g;
        colorArray[offset + 2] = color.b;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
    }
    if (dirtyLineDistances) {
      for (d = 0; d < dl; d++) {
        lineDistanceArray[d] = lineDistances[d];
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, lineDistanceArray, hint);
    }
    if (customAttributes) {
      for (i = 0, il = customAttributes.length; i < il; i++) {
        customAttribute = customAttributes[i];
        if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices')) {
          offset = 0;
          cal = customAttribute.value.length;
          if (customAttribute.size === 1) {
            for (ca = 0; ca < cal; ca++) {
              customAttribute.array[ca] = customAttribute.value[ca];
            }
          } else if (customAttribute.size === 2) {
            for (ca = 0; ca < cal; ca++) {
              value = customAttribute.value[ca];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              offset += 2;
            }
          } else if (customAttribute.size === 3) {
            if (customAttribute.type === 'c') {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.r;
                customAttribute.array[offset + 1] = value.g;
                customAttribute.array[offset + 2] = value.b;
                offset += 3;
              }
            } else {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                customAttribute.array[offset + 2] = value.z;
                offset += 3;
              }
            }
          } else if (customAttribute.size === 4) {
            for (ca = 0; ca < cal; ca++) {
              value = customAttribute.value[ca];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              customAttribute.array[offset + 2] = value.z;
              customAttribute.array[offset + 3] = value.w;
              offset += 4;
            }
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
        }
      }
    }
  }
  ;
  function setMeshBuffers(geometryGroup, object, hint, dispose, material) {
    if (!geometryGroup.__inittedArrays) {
      return;
    }
    var normalType = bufferGuessNormalType(material), vertexColorType = bufferGuessVertexColorType(material), uvType = bufferGuessUVType(material), needsSmoothNormals = normalType === THREE.SmoothShading;
    var f, fl, fi, face, vertexNormals, faceNormal, normal, vertexColors, faceColor, vertexTangents, uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4, c1, c2, c3, c4, sw1, sw2, sw3, sw4, si1, si2, si3, si4, sa1, sa2, sa3, sa4, sb1, sb2, sb3, sb4, m, ml, i, il, vn, uvi, uv2i, vk, vkl, vka, nka, chf, faceVertexNormals, a, vertexIndex = 0, offset = 0, offset_uv = 0, offset_uv2 = 0, offset_face = 0, offset_normal = 0, offset_tangent = 0, offset_line = 0, offset_color = 0, offset_skin = 0, offset_morphTarget = 0, offset_custom = 0, offset_customSrc = 0, value, vertexArray = geometryGroup.__vertexArray, uvArray = geometryGroup.__uvArray, uv2Array = geometryGroup.__uv2Array, normalArray = geometryGroup.__normalArray, tangentArray = geometryGroup.__tangentArray, colorArray = geometryGroup.__colorArray, skinIndexArray = geometryGroup.__skinIndexArray, skinWeightArray = geometryGroup.__skinWeightArray, morphTargetsArrays = geometryGroup.__morphTargetsArrays, morphNormalsArrays = geometryGroup.__morphNormalsArrays, customAttributes = geometryGroup.__webglCustomAttributesList, customAttribute, faceArray = geometryGroup.__faceArray, lineArray = geometryGroup.__lineArray, geometry = object.geometry, dirtyVertices = geometry.verticesNeedUpdate, dirtyElements = geometry.elementsNeedUpdate, dirtyUvs = geometry.uvsNeedUpdate, dirtyNormals = geometry.normalsNeedUpdate, dirtyTangents = geometry.tangentsNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyMorphTargets = geometry.morphTargetsNeedUpdate, vertices = geometry.vertices, chunk_faces3 = geometryGroup.faces3, obj_faces = geometry.faces, obj_uvs = geometry.faceVertexUvs[0], obj_uvs2 = geometry.faceVertexUvs[1], obj_colors = geometry.colors, obj_skinIndices = geometry.skinIndices, obj_skinWeights = geometry.skinWeights, morphTargets = geometry.morphTargets, morphNormals = geometry.morphNormals;
    if (dirtyVertices) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        v1 = vertices[face.a];
        v2 = vertices[face.b];
        v3 = vertices[face.c];
        vertexArray[offset] = v1.x;
        vertexArray[offset + 1] = v1.y;
        vertexArray[offset + 2] = v1.z;
        vertexArray[offset + 3] = v2.x;
        vertexArray[offset + 4] = v2.y;
        vertexArray[offset + 5] = v2.z;
        vertexArray[offset + 6] = v3.x;
        vertexArray[offset + 7] = v3.y;
        vertexArray[offset + 8] = v3.z;
        offset += 9;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
    }
    if (dirtyMorphTargets) {
      for (vk = 0, vkl = morphTargets.length; vk < vkl; vk++) {
        offset_morphTarget = 0;
        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
          chf = chunk_faces3[f];
          face = obj_faces[chf];
          v1 = morphTargets[vk].vertices[face.a];
          v2 = morphTargets[vk].vertices[face.b];
          v3 = morphTargets[vk].vertices[face.c];
          vka = morphTargetsArrays[vk];
          vka[offset_morphTarget] = v1.x;
          vka[offset_morphTarget + 1] = v1.y;
          vka[offset_morphTarget + 2] = v1.z;
          vka[offset_morphTarget + 3] = v2.x;
          vka[offset_morphTarget + 4] = v2.y;
          vka[offset_morphTarget + 5] = v2.z;
          vka[offset_morphTarget + 6] = v3.x;
          vka[offset_morphTarget + 7] = v3.y;
          vka[offset_morphTarget + 8] = v3.z;
          if (material.morphNormals) {
            if (needsSmoothNormals) {
              faceVertexNormals = morphNormals[vk].vertexNormals[chf];
              n1 = faceVertexNormals.a;
              n2 = faceVertexNormals.b;
              n3 = faceVertexNormals.c;
            } else {
              n1 = morphNormals[vk].faceNormals[chf];
              n2 = n1;
              n3 = n1;
            }
            nka = morphNormalsArrays[vk];
            nka[offset_morphTarget] = n1.x;
            nka[offset_morphTarget + 1] = n1.y;
            nka[offset_morphTarget + 2] = n1.z;
            nka[offset_morphTarget + 3] = n2.x;
            nka[offset_morphTarget + 4] = n2.y;
            nka[offset_morphTarget + 5] = n2.z;
            nka[offset_morphTarget + 6] = n3.x;
            nka[offset_morphTarget + 7] = n3.y;
            nka[offset_morphTarget + 8] = n3.z;
          }
          offset_morphTarget += 9;
        }
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[vk]);
        _gl.bufferData(_gl.ARRAY_BUFFER, morphTargetsArrays[vk], hint);
        if (material.morphNormals) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[vk]);
          _gl.bufferData(_gl.ARRAY_BUFFER, morphNormalsArrays[vk], hint);
        }
      }
    }
    if (obj_skinWeights.length) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        sw1 = obj_skinWeights[face.a];
        sw2 = obj_skinWeights[face.b];
        sw3 = obj_skinWeights[face.c];
        skinWeightArray[offset_skin] = sw1.x;
        skinWeightArray[offset_skin + 1] = sw1.y;
        skinWeightArray[offset_skin + 2] = sw1.z;
        skinWeightArray[offset_skin + 3] = sw1.w;
        skinWeightArray[offset_skin + 4] = sw2.x;
        skinWeightArray[offset_skin + 5] = sw2.y;
        skinWeightArray[offset_skin + 6] = sw2.z;
        skinWeightArray[offset_skin + 7] = sw2.w;
        skinWeightArray[offset_skin + 8] = sw3.x;
        skinWeightArray[offset_skin + 9] = sw3.y;
        skinWeightArray[offset_skin + 10] = sw3.z;
        skinWeightArray[offset_skin + 11] = sw3.w;
        si1 = obj_skinIndices[face.a];
        si2 = obj_skinIndices[face.b];
        si3 = obj_skinIndices[face.c];
        skinIndexArray[offset_skin] = si1.x;
        skinIndexArray[offset_skin + 1] = si1.y;
        skinIndexArray[offset_skin + 2] = si1.z;
        skinIndexArray[offset_skin + 3] = si1.w;
        skinIndexArray[offset_skin + 4] = si2.x;
        skinIndexArray[offset_skin + 5] = si2.y;
        skinIndexArray[offset_skin + 6] = si2.z;
        skinIndexArray[offset_skin + 7] = si2.w;
        skinIndexArray[offset_skin + 8] = si3.x;
        skinIndexArray[offset_skin + 9] = si3.y;
        skinIndexArray[offset_skin + 10] = si3.z;
        skinIndexArray[offset_skin + 11] = si3.w;
        offset_skin += 12;
      }
      if (offset_skin > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, skinIndexArray, hint);
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, skinWeightArray, hint);
      }
    }
    if (dirtyColors && vertexColorType) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        vertexColors = face.vertexColors;
        faceColor = face.color;
        if (vertexColors.length === 3 && vertexColorType === THREE.VertexColors) {
          c1 = vertexColors[0];
          c2 = vertexColors[1];
          c3 = vertexColors[2];
        } else {
          c1 = faceColor;
          c2 = faceColor;
          c3 = faceColor;
        }
        colorArray[offset_color] = c1.r;
        colorArray[offset_color + 1] = c1.g;
        colorArray[offset_color + 2] = c1.b;
        colorArray[offset_color + 3] = c2.r;
        colorArray[offset_color + 4] = c2.g;
        colorArray[offset_color + 5] = c2.b;
        colorArray[offset_color + 6] = c3.r;
        colorArray[offset_color + 7] = c3.g;
        colorArray[offset_color + 8] = c3.b;
        offset_color += 9;
      }
      if (offset_color > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
      }
    }
    if (dirtyTangents && geometry.hasTangents) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        vertexTangents = face.vertexTangents;
        t1 = vertexTangents[0];
        t2 = vertexTangents[1];
        t3 = vertexTangents[2];
        tangentArray[offset_tangent] = t1.x;
        tangentArray[offset_tangent + 1] = t1.y;
        tangentArray[offset_tangent + 2] = t1.z;
        tangentArray[offset_tangent + 3] = t1.w;
        tangentArray[offset_tangent + 4] = t2.x;
        tangentArray[offset_tangent + 5] = t2.y;
        tangentArray[offset_tangent + 6] = t2.z;
        tangentArray[offset_tangent + 7] = t2.w;
        tangentArray[offset_tangent + 8] = t3.x;
        tangentArray[offset_tangent + 9] = t3.y;
        tangentArray[offset_tangent + 10] = t3.z;
        tangentArray[offset_tangent + 11] = t3.w;
        offset_tangent += 12;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, tangentArray, hint);
    }
    if (dirtyNormals && normalType) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        vertexNormals = face.vertexNormals;
        faceNormal = face.normal;
        if (vertexNormals.length === 3 && needsSmoothNormals) {
          for (i = 0; i < 3; i++) {
            vn = vertexNormals[i];
            normalArray[offset_normal] = vn.x;
            normalArray[offset_normal + 1] = vn.y;
            normalArray[offset_normal + 2] = vn.z;
            offset_normal += 3;
          }
        } else {
          for (i = 0; i < 3; i++) {
            normalArray[offset_normal] = faceNormal.x;
            normalArray[offset_normal + 1] = faceNormal.y;
            normalArray[offset_normal + 2] = faceNormal.z;
            offset_normal += 3;
          }
        }
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);
    }
    if (dirtyUvs && obj_uvs && uvType) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        fi = chunk_faces3[f];
        uv = obj_uvs[fi];
        if (uv === undefined)
          continue;
        for (i = 0; i < 3; i++) {
          uvi = uv[i];
          uvArray[offset_uv] = uvi.x;
          uvArray[offset_uv + 1] = uvi.y;
          offset_uv += 2;
        }
      }
      if (offset_uv > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, uvArray, hint);
      }
    }
    if (dirtyUvs && obj_uvs2 && uvType) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        fi = chunk_faces3[f];
        uv2 = obj_uvs2[fi];
        if (uv2 === undefined)
          continue;
        for (i = 0; i < 3; i++) {
          uv2i = uv2[i];
          uv2Array[offset_uv2] = uv2i.x;
          uv2Array[offset_uv2 + 1] = uv2i.y;
          offset_uv2 += 2;
        }
      }
      if (offset_uv2 > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, uv2Array, hint);
      }
    }
    if (dirtyElements) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        faceArray[offset_face] = vertexIndex;
        faceArray[offset_face + 1] = vertexIndex + 1;
        faceArray[offset_face + 2] = vertexIndex + 2;
        offset_face += 3;
        lineArray[offset_line] = vertexIndex;
        lineArray[offset_line + 1] = vertexIndex + 1;
        lineArray[offset_line + 2] = vertexIndex;
        lineArray[offset_line + 3] = vertexIndex + 2;
        lineArray[offset_line + 4] = vertexIndex + 1;
        lineArray[offset_line + 5] = vertexIndex + 2;
        offset_line += 6;
        vertexIndex += 3;
      }
      _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
      _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);
      _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
      _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);
    }
    if (customAttributes) {
      for (i = 0, il = customAttributes.length; i < il; i++) {
        customAttribute = customAttributes[i];
        if (!customAttribute.__original.needsUpdate)
          continue;
        offset_custom = 0;
        offset_customSrc = 0;
        if (customAttribute.size === 1) {
          if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              face = obj_faces[chunk_faces3[f]];
              customAttribute.array[offset_custom] = customAttribute.value[face.a];
              customAttribute.array[offset_custom + 1] = customAttribute.value[face.b];
              customAttribute.array[offset_custom + 2] = customAttribute.value[face.c];
              offset_custom += 3;
            }
          } else if (customAttribute.boundTo === 'faces') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              customAttribute.array[offset_custom] = value;
              customAttribute.array[offset_custom + 1] = value;
              customAttribute.array[offset_custom + 2] = value;
              offset_custom += 3;
            }
          }
        } else if (customAttribute.size === 2) {
          if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              face = obj_faces[chunk_faces3[f]];
              v1 = customAttribute.value[face.a];
              v2 = customAttribute.value[face.b];
              v3 = customAttribute.value[face.c];
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v2.x;
              customAttribute.array[offset_custom + 3] = v2.y;
              customAttribute.array[offset_custom + 4] = v3.x;
              customAttribute.array[offset_custom + 5] = v3.y;
              offset_custom += 6;
            }
          } else if (customAttribute.boundTo === 'faces') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value;
              v2 = value;
              v3 = value;
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v2.x;
              customAttribute.array[offset_custom + 3] = v2.y;
              customAttribute.array[offset_custom + 4] = v3.x;
              customAttribute.array[offset_custom + 5] = v3.y;
              offset_custom += 6;
            }
          }
        } else if (customAttribute.size === 3) {
          var pp;
          if (customAttribute.type === 'c') {
            pp = [
              'r',
              'g',
              'b'
            ];
          } else {
            pp = [
              'x',
              'y',
              'z'
            ];
          }
          if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              face = obj_faces[chunk_faces3[f]];
              v1 = customAttribute.value[face.a];
              v2 = customAttribute.value[face.b];
              v3 = customAttribute.value[face.c];
              customAttribute.array[offset_custom] = v1[pp[0]];
              customAttribute.array[offset_custom + 1] = v1[pp[1]];
              customAttribute.array[offset_custom + 2] = v1[pp[2]];
              customAttribute.array[offset_custom + 3] = v2[pp[0]];
              customAttribute.array[offset_custom + 4] = v2[pp[1]];
              customAttribute.array[offset_custom + 5] = v2[pp[2]];
              customAttribute.array[offset_custom + 6] = v3[pp[0]];
              customAttribute.array[offset_custom + 7] = v3[pp[1]];
              customAttribute.array[offset_custom + 8] = v3[pp[2]];
              offset_custom += 9;
            }
          } else if (customAttribute.boundTo === 'faces') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value;
              v2 = value;
              v3 = value;
              customAttribute.array[offset_custom] = v1[pp[0]];
              customAttribute.array[offset_custom + 1] = v1[pp[1]];
              customAttribute.array[offset_custom + 2] = v1[pp[2]];
              customAttribute.array[offset_custom + 3] = v2[pp[0]];
              customAttribute.array[offset_custom + 4] = v2[pp[1]];
              customAttribute.array[offset_custom + 5] = v2[pp[2]];
              customAttribute.array[offset_custom + 6] = v3[pp[0]];
              customAttribute.array[offset_custom + 7] = v3[pp[1]];
              customAttribute.array[offset_custom + 8] = v3[pp[2]];
              offset_custom += 9;
            }
          } else if (customAttribute.boundTo === 'faceVertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value[0];
              v2 = value[1];
              v3 = value[2];
              customAttribute.array[offset_custom] = v1[pp[0]];
              customAttribute.array[offset_custom + 1] = v1[pp[1]];
              customAttribute.array[offset_custom + 2] = v1[pp[2]];
              customAttribute.array[offset_custom + 3] = v2[pp[0]];
              customAttribute.array[offset_custom + 4] = v2[pp[1]];
              customAttribute.array[offset_custom + 5] = v2[pp[2]];
              customAttribute.array[offset_custom + 6] = v3[pp[0]];
              customAttribute.array[offset_custom + 7] = v3[pp[1]];
              customAttribute.array[offset_custom + 8] = v3[pp[2]];
              offset_custom += 9;
            }
          }
        } else if (customAttribute.size === 4) {
          if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              face = obj_faces[chunk_faces3[f]];
              v1 = customAttribute.value[face.a];
              v2 = customAttribute.value[face.b];
              v3 = customAttribute.value[face.c];
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v1.z;
              customAttribute.array[offset_custom + 3] = v1.w;
              customAttribute.array[offset_custom + 4] = v2.x;
              customAttribute.array[offset_custom + 5] = v2.y;
              customAttribute.array[offset_custom + 6] = v2.z;
              customAttribute.array[offset_custom + 7] = v2.w;
              customAttribute.array[offset_custom + 8] = v3.x;
              customAttribute.array[offset_custom + 9] = v3.y;
              customAttribute.array[offset_custom + 10] = v3.z;
              customAttribute.array[offset_custom + 11] = v3.w;
              offset_custom += 12;
            }
          } else if (customAttribute.boundTo === 'faces') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value;
              v2 = value;
              v3 = value;
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v1.z;
              customAttribute.array[offset_custom + 3] = v1.w;
              customAttribute.array[offset_custom + 4] = v2.x;
              customAttribute.array[offset_custom + 5] = v2.y;
              customAttribute.array[offset_custom + 6] = v2.z;
              customAttribute.array[offset_custom + 7] = v2.w;
              customAttribute.array[offset_custom + 8] = v3.x;
              customAttribute.array[offset_custom + 9] = v3.y;
              customAttribute.array[offset_custom + 10] = v3.z;
              customAttribute.array[offset_custom + 11] = v3.w;
              offset_custom += 12;
            }
          } else if (customAttribute.boundTo === 'faceVertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value[0];
              v2 = value[1];
              v3 = value[2];
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v1.z;
              customAttribute.array[offset_custom + 3] = v1.w;
              customAttribute.array[offset_custom + 4] = v2.x;
              customAttribute.array[offset_custom + 5] = v2.y;
              customAttribute.array[offset_custom + 6] = v2.z;
              customAttribute.array[offset_custom + 7] = v2.w;
              customAttribute.array[offset_custom + 8] = v3.x;
              customAttribute.array[offset_custom + 9] = v3.y;
              customAttribute.array[offset_custom + 10] = v3.z;
              customAttribute.array[offset_custom + 11] = v3.w;
              offset_custom += 12;
            }
          }
        }
        _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
      }
    }
    if (dispose) {
      delete geometryGroup.__inittedArrays;
      delete geometryGroup.__colorArray;
      delete geometryGroup.__normalArray;
      delete geometryGroup.__tangentArray;
      delete geometryGroup.__uvArray;
      delete geometryGroup.__uv2Array;
      delete geometryGroup.__faceArray;
      delete geometryGroup.__vertexArray;
      delete geometryGroup.__lineArray;
      delete geometryGroup.__skinIndexArray;
      delete geometryGroup.__skinWeightArray;
    }
  }
  ;
  function setDirectBuffers(geometry, hint, dispose) {
    var attributes = geometry.attributes;
    var attributeName, attributeItem;
    for (attributeName in attributes) {
      attributeItem = attributes[attributeName];
      if (attributeItem.needsUpdate) {
        if (attributeName === 'index') {
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer);
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint);
        } else {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, attributeItem.array, hint);
        }
        attributeItem.needsUpdate = false;
      }
      if (dispose && !attributeItem.dynamic) {
        attributeItem.array = null;
      }
    }
  }
  ;
  this.renderBufferImmediate = function (object, program, material) {
    if (object.hasPositions && !object.__webglVertexBuffer)
      object.__webglVertexBuffer = _gl.createBuffer();
    if (object.hasNormals && !object.__webglNormalBuffer)
      object.__webglNormalBuffer = _gl.createBuffer();
    if (object.hasUvs && !object.__webglUvBuffer)
      object.__webglUvBuffer = _gl.createBuffer();
    if (object.hasColors && !object.__webglColorBuffer)
      object.__webglColorBuffer = _gl.createBuffer();
    if (object.hasPositions) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
      _gl.enableVertexAttribArray(program.attributes.position);
      _gl.vertexAttribPointer(program.attributes.position, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglNormalBuffer);
      if (material.shading === THREE.FlatShading) {
        var nx, ny, nz, nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz, normalArray, i, il = object.count * 3;
        for (i = 0; i < il; i += 9) {
          normalArray = object.normalArray;
          nax = normalArray[i];
          nay = normalArray[i + 1];
          naz = normalArray[i + 2];
          nbx = normalArray[i + 3];
          nby = normalArray[i + 4];
          nbz = normalArray[i + 5];
          ncx = normalArray[i + 6];
          ncy = normalArray[i + 7];
          ncz = normalArray[i + 8];
          nx = (nax + nbx + ncx) / 3;
          ny = (nay + nby + ncy) / 3;
          nz = (naz + nbz + ncz) / 3;
          normalArray[i] = nx;
          normalArray[i + 1] = ny;
          normalArray[i + 2] = nz;
          normalArray[i + 3] = nx;
          normalArray[i + 4] = ny;
          normalArray[i + 5] = nz;
          normalArray[i + 6] = nx;
          normalArray[i + 7] = ny;
          normalArray[i + 8] = nz;
        }
      }
      _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
      _gl.enableVertexAttribArray(program.attributes.normal);
      _gl.vertexAttribPointer(program.attributes.normal, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasUvs && material.map) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglUvBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
      _gl.enableVertexAttribArray(program.attributes.uv);
      _gl.vertexAttribPointer(program.attributes.uv, 2, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasColors && material.vertexColors !== THREE.NoColors) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglColorBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
      _gl.enableVertexAttribArray(program.attributes.color);
      _gl.vertexAttribPointer(program.attributes.color, 3, _gl.FLOAT, false, 0, 0);
    }
    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function (camera, lights, fog, material, geometry, object) {
    if (material.visible === false)
      return;
    var linewidth, a, attribute;
    var attributeItem, attributeName, attributePointer, attributeSize;
    var program = setProgram(camera, lights, fog, material, object);
    var programAttributes = program.attributes;
    var geometryAttributes = geometry.attributes;
    var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryHash = geometry.id * 16777215 + program.id * 2 + wireframeBit;
    if (geometryHash !== _currentGeometryGroupHash) {
      _currentGeometryGroupHash = geometryHash;
      updateBuffers = true;
    }
    if (updateBuffers) {
      disableAttributes();
    }
    if (object instanceof THREE.Mesh) {
      var index = geometryAttributes['index'];
      if (index) {
        var offsets = geometry.offsets;
        if (offsets.length > 1)
          updateBuffers = true;
        for (var i = 0, il = offsets.length; i < il; i++) {
          var startIndex = offsets[i].index;
          if (updateBuffers) {
            for (attributeName in programAttributes) {
              attributePointer = programAttributes[attributeName];
              attributeItem = geometryAttributes[attributeName];
              if (attributePointer >= 0) {
                if (attributeItem) {
                  attributeSize = attributeItem.itemSize;
                  _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
                  enableAttribute(attributePointer);
                  _gl.vertexAttribPointer(attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4);
                } else if (material.defaultAttributeValues) {
                  if (material.defaultAttributeValues[attributeName].length === 2) {
                    _gl.vertexAttrib2fv(attributePointer, material.defaultAttributeValues[attributeName]);
                  } else if (material.defaultAttributeValues[attributeName].length === 3) {
                    _gl.vertexAttrib3fv(attributePointer, material.defaultAttributeValues[attributeName]);
                  }
                }
              }
            }
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
          }
          _gl.drawElements(_gl.TRIANGLES, offsets[i].count, _gl.UNSIGNED_SHORT, offsets[i].start * 2);
          _this.info.render.calls++;
          _this.info.render.vertices += offsets[i].count;
          _this.info.render.faces += offsets[i].count / 3;
        }
      } else {
        if (updateBuffers) {
          for (attributeName in programAttributes) {
            if (attributeName === 'index')
              continue;
            attributePointer = programAttributes[attributeName];
            attributeItem = geometryAttributes[attributeName];
            if (attributePointer >= 0) {
              if (attributeItem) {
                attributeSize = attributeItem.itemSize;
                _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
                enableAttribute(attributePointer);
                _gl.vertexAttribPointer(attributePointer, attributeSize, _gl.FLOAT, false, 0, 0);
              } else if (material.defaultAttributeValues && material.defaultAttributeValues[attributeName]) {
                if (material.defaultAttributeValues[attributeName].length === 2) {
                  _gl.vertexAttrib2fv(attributePointer, material.defaultAttributeValues[attributeName]);
                } else if (material.defaultAttributeValues[attributeName].length === 3) {
                  _gl.vertexAttrib3fv(attributePointer, material.defaultAttributeValues[attributeName]);
                }
              }
            }
          }
        }
        var position = geometry.attributes['position'];
        _gl.drawArrays(_gl.TRIANGLES, 0, position.numItems / 3);
        _this.info.render.calls++;
        _this.info.render.vertices += position.numItems / 3;
        _this.info.render.faces += position.numItems / 3 / 3;
      }
    } else if (object instanceof THREE.ParticleSystem) {
      if (updateBuffers) {
        for (attributeName in programAttributes) {
          attributePointer = programAttributes[attributeName];
          attributeItem = geometryAttributes[attributeName];
          if (attributePointer >= 0) {
            if (attributeItem) {
              attributeSize = attributeItem.itemSize;
              _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
              enableAttribute(attributePointer);
              _gl.vertexAttribPointer(attributePointer, attributeSize, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues && material.defaultAttributeValues[attributeName]) {
              if (material.defaultAttributeValues[attributeName].length === 2) {
                _gl.vertexAttrib2fv(attributePointer, material.defaultAttributeValues[attributeName]);
              } else if (material.defaultAttributeValues[attributeName].length === 3) {
                _gl.vertexAttrib3fv(attributePointer, material.defaultAttributeValues[attributeName]);
              }
            }
          }
        }
        var position = geometryAttributes['position'];
        _gl.drawArrays(_gl.POINTS, 0, position.numItems / 3);
        _this.info.render.calls++;
        _this.info.render.points += position.numItems / 3;
      }
    } else if (object instanceof THREE.Line) {
      if (updateBuffers) {
        for (attributeName in programAttributes) {
          attributePointer = programAttributes[attributeName];
          attributeItem = geometryAttributes[attributeName];
          if (attributePointer >= 0) {
            if (attributeItem) {
              attributeSize = attributeItem.itemSize;
              _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
              enableAttribute(attributePointer);
              _gl.vertexAttribPointer(attributePointer, attributeSize, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues && material.defaultAttributeValues[attributeName]) {
              if (material.defaultAttributeValues[attributeName].length === 2) {
                _gl.vertexAttrib2fv(attributePointer, material.defaultAttributeValues[attributeName]);
              } else if (material.defaultAttributeValues[attributeName].length === 3) {
                _gl.vertexAttrib3fv(attributePointer, material.defaultAttributeValues[attributeName]);
              }
            }
          }
        }
        var primitives = object.type === THREE.LineStrip ? _gl.LINE_STRIP : _gl.LINES;
        setLineWidth(material.linewidth);
        var position = geometryAttributes['position'];
        _gl.drawArrays(primitives, 0, position.numItems / 3);
        _this.info.render.calls++;
        _this.info.render.points += position.numItems;
      }
    }
  };
  this.renderBuffer = function (camera, lights, fog, material, geometryGroup, object) {
    if (material.visible === false)
      return;
    var linewidth, a, attribute, i, il;
    var program = setProgram(camera, lights, fog, material, object);
    var attributes = program.attributes;
    var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryGroupHash = geometryGroup.id * 16777215 + program.id * 2 + wireframeBit;
    if (geometryGroupHash !== _currentGeometryGroupHash) {
      _currentGeometryGroupHash = geometryGroupHash;
      updateBuffers = true;
    }
    if (updateBuffers) {
      disableAttributes();
    }
    if (!material.morphTargets && attributes.position >= 0) {
      if (updateBuffers) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
        enableAttribute(attributes.position);
        _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
      }
    } else {
      if (object.morphTargetBase) {
        setupMorphTargets(material, geometryGroup, object);
      }
    }
    if (updateBuffers) {
      if (geometryGroup.__webglCustomAttributesList) {
        for (i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i++) {
          attribute = geometryGroup.__webglCustomAttributesList[i];
          if (attributes[attribute.buffer.belongsToAttribute] >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, attribute.buffer);
            enableAttribute(attributes[attribute.buffer.belongsToAttribute]);
            _gl.vertexAttribPointer(attributes[attribute.buffer.belongsToAttribute], attribute.size, _gl.FLOAT, false, 0, 0);
          }
        }
      }
      if (attributes.color >= 0) {
        if (object.geometry.colors.length > 0 || object.geometry.faces.length > 0) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
          enableAttribute(attributes.color);
          _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
        } else if (material.defaultAttributeValues) {
          _gl.vertexAttrib3fv(attributes.color, material.defaultAttributeValues.color);
        }
      }
      if (attributes.normal >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
        enableAttribute(attributes.normal);
        _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
      }
      if (attributes.tangent >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
        enableAttribute(attributes.tangent);
        _gl.vertexAttribPointer(attributes.tangent, 4, _gl.FLOAT, false, 0, 0);
      }
      if (attributes.uv >= 0) {
        if (object.geometry.faceVertexUvs[0]) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
          enableAttribute(attributes.uv);
          _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
        } else if (material.defaultAttributeValues) {
          _gl.vertexAttrib2fv(attributes.uv, material.defaultAttributeValues.uv);
        }
      }
      if (attributes.uv2 >= 0) {
        if (object.geometry.faceVertexUvs[1]) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
          enableAttribute(attributes.uv2);
          _gl.vertexAttribPointer(attributes.uv2, 2, _gl.FLOAT, false, 0, 0);
        } else if (material.defaultAttributeValues) {
          _gl.vertexAttrib2fv(attributes.uv2, material.defaultAttributeValues.uv2);
        }
      }
      if (material.skinning && attributes.skinIndex >= 0 && attributes.skinWeight >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
        enableAttribute(attributes.skinIndex);
        _gl.vertexAttribPointer(attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0);
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
        enableAttribute(attributes.skinWeight);
        _gl.vertexAttribPointer(attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0);
      }
      if (attributes.lineDistance >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer);
        enableAttribute(attributes.lineDistance);
        _gl.vertexAttribPointer(attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0);
      }
    }
    if (object instanceof THREE.Mesh) {
      if (material.wireframe) {
        setLineWidth(material.wireframeLinewidth);
        if (updateBuffers)
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
        _gl.drawElements(_gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0);
      } else {
        if (updateBuffers)
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
        _gl.drawElements(_gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0);
      }
      _this.info.render.calls++;
      _this.info.render.vertices += geometryGroup.__webglFaceCount;
      _this.info.render.faces += geometryGroup.__webglFaceCount / 3;
    } else if (object instanceof THREE.Line) {
      var primitives = object.type === THREE.LineStrip ? _gl.LINE_STRIP : _gl.LINES;
      setLineWidth(material.linewidth);
      _gl.drawArrays(primitives, 0, geometryGroup.__webglLineCount);
      _this.info.render.calls++;
    } else if (object instanceof THREE.ParticleSystem) {
      _gl.drawArrays(_gl.POINTS, 0, geometryGroup.__webglParticleCount);
      _this.info.render.calls++;
      _this.info.render.points += geometryGroup.__webglParticleCount;
    }
  };
  function enableAttribute(attribute) {
    if (!_enabledAttributes[attribute]) {
      _gl.enableVertexAttribArray(attribute);
      _enabledAttributes[attribute] = true;
    }
  }
  ;
  function disableAttributes() {
    for (var attribute in _enabledAttributes) {
      if (_enabledAttributes[attribute]) {
        _gl.disableVertexAttribArray(attribute);
        _enabledAttributes[attribute] = false;
      }
    }
  }
  ;
  function setupMorphTargets(material, geometryGroup, object) {
    var attributes = material.program.attributes;
    if (object.morphTargetBase !== -1 && attributes.position >= 0) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[object.morphTargetBase]);
      enableAttribute(attributes.position);
      _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
    } else if (attributes.position >= 0) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
      enableAttribute(attributes.position);
      _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.morphTargetForcedOrder.length) {
      var m = 0;
      var order = object.morphTargetForcedOrder;
      var influences = object.morphTargetInfluences;
      while (m < material.numSupportedMorphTargets && m < order.length) {
        if (attributes['morphTarget' + m] >= 0) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[order[m]]);
          enableAttribute(attributes['morphTarget' + m]);
          _gl.vertexAttribPointer(attributes['morphTarget' + m], 3, _gl.FLOAT, false, 0, 0);
        }
        if (attributes['morphNormal' + m] >= 0 && material.morphNormals) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[order[m]]);
          enableAttribute(attributes['morphNormal' + m]);
          _gl.vertexAttribPointer(attributes['morphNormal' + m], 3, _gl.FLOAT, false, 0, 0);
        }
        object.__webglMorphTargetInfluences[m] = influences[order[m]];
        m++;
      }
    } else {
      var influence, activeInfluenceIndices = [];
      var influences = object.morphTargetInfluences;
      var i, il = influences.length;
      for (i = 0; i < il; i++) {
        influence = influences[i];
        if (influence > 0) {
          activeInfluenceIndices.push([
            influence,
            i
          ]);
        }
      }
      if (activeInfluenceIndices.length > material.numSupportedMorphTargets) {
        activeInfluenceIndices.sort(numericalSort);
        activeInfluenceIndices.length = material.numSupportedMorphTargets;
      } else if (activeInfluenceIndices.length > material.numSupportedMorphNormals) {
        activeInfluenceIndices.sort(numericalSort);
      } else if (activeInfluenceIndices.length === 0) {
        activeInfluenceIndices.push([
          0,
          0
        ]);
      }
      ;
      var influenceIndex, m = 0;
      while (m < material.numSupportedMorphTargets) {
        if (activeInfluenceIndices[m]) {
          influenceIndex = activeInfluenceIndices[m][1];
          if (attributes['morphTarget' + m] >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[influenceIndex]);
            enableAttribute(attributes['morphTarget' + m]);
            _gl.vertexAttribPointer(attributes['morphTarget' + m], 3, _gl.FLOAT, false, 0, 0);
          }
          if (attributes['morphNormal' + m] >= 0 && material.morphNormals) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[influenceIndex]);
            enableAttribute(attributes['morphNormal' + m]);
            _gl.vertexAttribPointer(attributes['morphNormal' + m], 3, _gl.FLOAT, false, 0, 0);
          }
          object.__webglMorphTargetInfluences[m] = influences[influenceIndex];
        } else {
          object.__webglMorphTargetInfluences[m] = 0;
        }
        m++;
      }
    }
    if (material.program.uniforms.morphTargetInfluences !== null) {
      _gl.uniform1fv(material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences);
    }
  }
  ;
  function painterSortStable(a, b) {
    if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  ;
  function numericalSort(a, b) {
    return b[0] - a[0];
  }
  ;
  this.render = function (scene, camera, renderTarget, forceClear) {
    if (camera instanceof THREE.Camera === false) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }
    var i, il, webglObject, object, renderList, lights = scene.__lights, fog = scene.fog;
    _currentMaterialId = -1;
    _lightsNeedUpdate = true;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === undefined)
      camera.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    if (this.autoUpdateObjects)
      this.initWebGLObjects(scene);
    renderPlugins(this.renderPluginsPre, scene, camera);
    _this.info.render.calls = 0;
    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;
    _this.info.render.points = 0;
    this.setRenderTarget(renderTarget);
    if (this.autoClear || forceClear) {
      this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
    }
    renderList = scene.__webglObjects;
    for (i = 0, il = renderList.length; i < il; i++) {
      webglObject = renderList[i];
      object = webglObject.object;
      webglObject.id = i;
      webglObject.render = false;
      if (object.visible) {
        if (!(object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem) || !object.frustumCulled || _frustum.intersectsObject(object)) {
          setupMatrices(object, camera);
          unrollBufferMaterial(webglObject);
          webglObject.render = true;
          if (this.sortObjects === true) {
            if (object.renderDepth !== null) {
              webglObject.z = object.renderDepth;
            } else {
              _vector3.getPositionFromMatrix(object.matrixWorld);
              _vector3.applyProjection(_projScreenMatrix);
              webglObject.z = _vector3.z;
            }
          }
        }
      }
    }
    if (this.sortObjects) {
      renderList.sort(painterSortStable);
    }
    renderList = scene.__webglObjectsImmediate;
    for (i = 0, il = renderList.length; i < il; i++) {
      webglObject = renderList[i];
      object = webglObject.object;
      if (object.visible) {
        setupMatrices(object, camera);
        unrollImmediateBufferMaterial(webglObject);
      }
    }
    if (scene.overrideMaterial) {
      var material = scene.overrideMaterial;
      this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
      this.setDepthTest(material.depthTest);
      this.setDepthWrite(material.depthWrite);
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      renderObjects(scene.__webglObjects, false, '', camera, lights, fog, true, material);
      renderObjectsImmediate(scene.__webglObjectsImmediate, '', camera, lights, fog, false, material);
    } else {
      var material = null;
      this.setBlending(THREE.NoBlending);
      renderObjects(scene.__webglObjects, true, 'opaque', camera, lights, fog, false, material);
      renderObjectsImmediate(scene.__webglObjectsImmediate, 'opaque', camera, lights, fog, false, material);
      renderObjects(scene.__webglObjects, false, 'transparent', camera, lights, fog, true, material);
      renderObjectsImmediate(scene.__webglObjectsImmediate, 'transparent', camera, lights, fog, true, material);
    }
    renderPlugins(this.renderPluginsPost, scene, camera);
    if (renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter) {
      updateRenderTargetMipmap(renderTarget);
    }
    this.setDepthTest(true);
    this.setDepthWrite(true);
  };
  function renderPlugins(plugins, scene, camera) {
    if (!plugins.length)
      return;
    for (var i = 0, il = plugins.length; i < il; i++) {
      _currentProgram = null;
      _currentCamera = null;
      _oldBlending = -1;
      _oldDepthTest = -1;
      _oldDepthWrite = -1;
      _oldDoubleSided = -1;
      _oldFlipSided = -1;
      _currentGeometryGroupHash = -1;
      _currentMaterialId = -1;
      _lightsNeedUpdate = true;
      plugins[i].render(scene, camera, _currentWidth, _currentHeight);
      _currentProgram = null;
      _currentCamera = null;
      _oldBlending = -1;
      _oldDepthTest = -1;
      _oldDepthWrite = -1;
      _oldDoubleSided = -1;
      _oldFlipSided = -1;
      _currentGeometryGroupHash = -1;
      _currentMaterialId = -1;
      _lightsNeedUpdate = true;
    }
  }
  ;
  function renderObjects(renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial) {
    var webglObject, object, buffer, material, start, end, delta;
    if (reverse) {
      start = renderList.length - 1;
      end = -1;
      delta = -1;
    } else {
      start = 0;
      end = renderList.length;
      delta = 1;
    }
    for (var i = start; i !== end; i += delta) {
      webglObject = renderList[i];
      if (webglObject.render) {
        object = webglObject.object;
        buffer = webglObject.buffer;
        if (overrideMaterial) {
          material = overrideMaterial;
        } else {
          material = webglObject[materialType];
          if (!material)
            continue;
          if (useBlending)
            _this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
          _this.setDepthTest(material.depthTest);
          _this.setDepthWrite(material.depthWrite);
          setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        _this.setMaterialFaces(material);
        if (buffer instanceof THREE.BufferGeometry) {
          _this.renderBufferDirect(camera, lights, fog, material, buffer, object);
        } else {
          _this.renderBuffer(camera, lights, fog, material, buffer, object);
        }
      }
    }
  }
  ;
  function renderObjectsImmediate(renderList, materialType, camera, lights, fog, useBlending, overrideMaterial) {
    var webglObject, object, material, program;
    for (var i = 0, il = renderList.length; i < il; i++) {
      webglObject = renderList[i];
      object = webglObject.object;
      if (object.visible) {
        if (overrideMaterial) {
          material = overrideMaterial;
        } else {
          material = webglObject[materialType];
          if (!material)
            continue;
          if (useBlending)
            _this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
          _this.setDepthTest(material.depthTest);
          _this.setDepthWrite(material.depthWrite);
          setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        _this.renderImmediateObject(camera, lights, fog, material, object);
      }
    }
  }
  ;
  this.renderImmediateObject = function (camera, lights, fog, material, object) {
    var program = setProgram(camera, lights, fog, material, object);
    _currentGeometryGroupHash = -1;
    _this.setMaterialFaces(material);
    if (object.immediateRenderCallback) {
      object.immediateRenderCallback(program, _gl, _frustum);
    } else {
      object.render(function (object) {
        _this.renderBufferImmediate(object, program, material);
      });
    }
  };
  function unrollImmediateBufferMaterial(globject) {
    var object = globject.object, material = object.material;
    if (material.transparent) {
      globject.transparent = material;
      globject.opaque = null;
    } else {
      globject.opaque = material;
      globject.transparent = null;
    }
  }
  ;
  function unrollBufferMaterial(globject) {
    var object = globject.object, buffer = globject.buffer, material, materialIndex, meshMaterial;
    meshMaterial = object.material;
    if (meshMaterial instanceof THREE.MeshFaceMaterial) {
      materialIndex = buffer.materialIndex;
      material = meshMaterial.materials[materialIndex];
      if (material.transparent) {
        globject.transparent = material;
        globject.opaque = null;
      } else {
        globject.opaque = material;
        globject.transparent = null;
      }
    } else {
      material = meshMaterial;
      if (material) {
        if (material.transparent) {
          globject.transparent = material;
          globject.opaque = null;
        } else {
          globject.opaque = material;
          globject.transparent = null;
        }
      }
    }
  }
  ;
  function sortFacesByMaterial(geometry, material) {
    var f, fl, face, materialIndex, vertices, groupHash, hash_map = {};
    var numMorphTargets = geometry.morphTargets.length;
    var numMorphNormals = geometry.morphNormals.length;
    var usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;
    geometry.geometryGroups = {};
    for (f = 0, fl = geometry.faces.length; f < fl; f++) {
      face = geometry.faces[f];
      materialIndex = usesFaceMaterial ? face.materialIndex : 0;
      if (hash_map[materialIndex] === undefined) {
        hash_map[materialIndex] = {
          'hash': materialIndex,
          'counter': 0
        };
      }
      groupHash = hash_map[materialIndex].hash + '_' + hash_map[materialIndex].counter;
      if (geometry.geometryGroups[groupHash] === undefined) {
        geometry.geometryGroups[groupHash] = {
          'faces3': [],
          'materialIndex': materialIndex,
          'vertices': 0,
          'numMorphTargets': numMorphTargets,
          'numMorphNormals': numMorphNormals
        };
      }
      vertices = 3;
      if (geometry.geometryGroups[groupHash].vertices + vertices > 65535) {
        hash_map[materialIndex].counter += 1;
        groupHash = hash_map[materialIndex].hash + '_' + hash_map[materialIndex].counter;
        if (geometry.geometryGroups[groupHash] === undefined) {
          geometry.geometryGroups[groupHash] = {
            'faces3': [],
            'materialIndex': materialIndex,
            'vertices': 0,
            'numMorphTargets': numMorphTargets,
            'numMorphNormals': numMorphNormals
          };
        }
      }
      geometry.geometryGroups[groupHash].faces3.push(f);
      geometry.geometryGroups[groupHash].vertices += vertices;
    }
    geometry.geometryGroupsList = [];
    for (var g in geometry.geometryGroups) {
      geometry.geometryGroups[g].id = _geometryGroupCounter++;
      geometry.geometryGroupsList.push(geometry.geometryGroups[g]);
    }
  }
  ;
  this.initWebGLObjects = function (scene) {
    if (!scene.__webglObjects) {
      scene.__webglObjects = [];
      scene.__webglObjectsImmediate = [];
      scene.__webglSprites = [];
      scene.__webglFlares = [];
    }
    while (scene.__objectsAdded.length) {
      addObject(scene.__objectsAdded[0], scene);
      scene.__objectsAdded.splice(0, 1);
    }
    while (scene.__objectsRemoved.length) {
      removeObject(scene.__objectsRemoved[0], scene);
      scene.__objectsRemoved.splice(0, 1);
    }
    for (var o = 0, ol = scene.__webglObjects.length; o < ol; o++) {
      var object = scene.__webglObjects[o].object;
      if (object.__webglInit === undefined) {
        if (object.__webglActive !== undefined) {
          removeObject(object, scene);
        }
        addObject(object, scene);
      }
      updateObject(object);
    }
  };
  function addObject(object, scene) {
    var g, geometry, material, geometryGroup;
    if (object.__webglInit === undefined) {
      object.__webglInit = true;
      object._modelViewMatrix = new THREE.Matrix4();
      object._normalMatrix = new THREE.Matrix3();
      if (object.geometry !== undefined && object.geometry.__webglInit === undefined) {
        object.geometry.__webglInit = true;
        object.geometry.addEventListener('dispose', onGeometryDispose);
      }
      geometry = object.geometry;
      if (geometry === undefined) {
      } else if (geometry instanceof THREE.BufferGeometry) {
        initDirectBuffers(geometry);
      } else if (object instanceof THREE.Mesh) {
        material = object.material;
        if (geometry.geometryGroups === undefined) {
          sortFacesByMaterial(geometry, material);
        }
        for (g in geometry.geometryGroups) {
          geometryGroup = geometry.geometryGroups[g];
          if (!geometryGroup.__webglVertexBuffer) {
            createMeshBuffers(geometryGroup);
            initMeshBuffers(geometryGroup, object);
            geometry.verticesNeedUpdate = true;
            geometry.morphTargetsNeedUpdate = true;
            geometry.elementsNeedUpdate = true;
            geometry.uvsNeedUpdate = true;
            geometry.normalsNeedUpdate = true;
            geometry.tangentsNeedUpdate = true;
            geometry.colorsNeedUpdate = true;
          }
        }
      } else if (object instanceof THREE.Line) {
        if (!geometry.__webglVertexBuffer) {
          createLineBuffers(geometry);
          initLineBuffers(geometry, object);
          geometry.verticesNeedUpdate = true;
          geometry.colorsNeedUpdate = true;
          geometry.lineDistancesNeedUpdate = true;
        }
      } else if (object instanceof THREE.ParticleSystem) {
        if (!geometry.__webglVertexBuffer) {
          createParticleBuffers(geometry);
          initParticleBuffers(geometry, object);
          geometry.verticesNeedUpdate = true;
          geometry.colorsNeedUpdate = true;
        }
      }
    }
    if (object.__webglActive === undefined) {
      if (object instanceof THREE.Mesh) {
        geometry = object.geometry;
        if (geometry instanceof THREE.BufferGeometry) {
          addBuffer(scene.__webglObjects, geometry, object);
        } else if (geometry instanceof THREE.Geometry) {
          for (g in geometry.geometryGroups) {
            geometryGroup = geometry.geometryGroups[g];
            addBuffer(scene.__webglObjects, geometryGroup, object);
          }
        }
      } else if (object instanceof THREE.Line || object instanceof THREE.ParticleSystem) {
        geometry = object.geometry;
        addBuffer(scene.__webglObjects, geometry, object);
      } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
        addBufferImmediate(scene.__webglObjectsImmediate, object);
      } else if (object instanceof THREE.Sprite) {
        scene.__webglSprites.push(object);
      } else if (object instanceof THREE.LensFlare) {
        scene.__webglFlares.push(object);
      }
      object.__webglActive = true;
    }
  }
  ;
  function addBuffer(objlist, buffer, object) {
    objlist.push({
      id: null,
      buffer: buffer,
      object: object,
      opaque: null,
      transparent: null,
      z: 0
    });
  }
  ;
  function addBufferImmediate(objlist, object) {
    objlist.push({
      id: null,
      object: object,
      opaque: null,
      transparent: null,
      z: 0
    });
  }
  ;
  function updateObject(object) {
    var geometry = object.geometry, geometryGroup, customAttributesDirty, material;
    if (geometry instanceof THREE.BufferGeometry) {
      setDirectBuffers(geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic);
    } else if (object instanceof THREE.Mesh) {
      for (var i = 0, il = geometry.geometryGroupsList.length; i < il; i++) {
        geometryGroup = geometry.geometryGroupsList[i];
        material = getBufferMaterial(object, geometryGroup);
        if (geometry.buffersNeedUpdate) {
          initMeshBuffers(geometryGroup, object);
        }
        customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
        if (geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate || geometry.uvsNeedUpdate || geometry.normalsNeedUpdate || geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty) {
          setMeshBuffers(geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material);
        }
      }
      geometry.verticesNeedUpdate = false;
      geometry.morphTargetsNeedUpdate = false;
      geometry.elementsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.tangentsNeedUpdate = false;
      geometry.buffersNeedUpdate = false;
      material.attributes && clearCustomAttributes(material);
    } else if (object instanceof THREE.Line) {
      material = getBufferMaterial(object, geometry);
      customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
      if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty) {
        setLineBuffers(geometry, _gl.DYNAMIC_DRAW);
      }
      geometry.verticesNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.lineDistancesNeedUpdate = false;
      material.attributes && clearCustomAttributes(material);
    } else if (object instanceof THREE.ParticleSystem) {
      material = getBufferMaterial(object, geometry);
      customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
      if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty) {
        setParticleBuffers(geometry, _gl.DYNAMIC_DRAW, object);
      }
      geometry.verticesNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      material.attributes && clearCustomAttributes(material);
    }
  }
  ;
  function areCustomAttributesDirty(material) {
    for (var a in material.attributes) {
      if (material.attributes[a].needsUpdate)
        return true;
    }
    return false;
  }
  ;
  function clearCustomAttributes(material) {
    for (var a in material.attributes) {
      material.attributes[a].needsUpdate = false;
    }
  }
  ;
  function removeObject(object, scene) {
    if (object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem || object instanceof THREE.Line) {
      removeInstances(scene.__webglObjects, object);
    } else if (object instanceof THREE.Sprite) {
      removeInstancesDirect(scene.__webglSprites, object);
    } else if (object instanceof THREE.LensFlare) {
      removeInstancesDirect(scene.__webglFlares, object);
    } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
      removeInstances(scene.__webglObjectsImmediate, object);
    }
    delete object.__webglActive;
  }
  ;
  function removeInstances(objlist, object) {
    for (var o = objlist.length - 1; o >= 0; o--) {
      if (objlist[o].object === object) {
        objlist.splice(o, 1);
      }
    }
  }
  ;
  function removeInstancesDirect(objlist, object) {
    for (var o = objlist.length - 1; o >= 0; o--) {
      if (objlist[o] === object) {
        objlist.splice(o, 1);
      }
    }
  }
  ;
  this.initMaterial = function (material, lights, fog, object) {
    material.addEventListener('dispose', onMaterialDispose);
    var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;
    if (material instanceof THREE.MeshDepthMaterial) {
      shaderID = 'depth';
    } else if (material instanceof THREE.MeshNormalMaterial) {
      shaderID = 'normal';
    } else if (material instanceof THREE.MeshBasicMaterial) {
      shaderID = 'basic';
    } else if (material instanceof THREE.MeshLambertMaterial) {
      shaderID = 'lambert';
    } else if (material instanceof THREE.MeshPhongMaterial) {
      shaderID = 'phong';
    } else if (material instanceof THREE.LineBasicMaterial) {
      shaderID = 'basic';
    } else if (material instanceof THREE.LineDashedMaterial) {
      shaderID = 'dashed';
    } else if (material instanceof THREE.ParticleSystemMaterial) {
      shaderID = 'particle_basic';
    }
    if (shaderID) {
      setMaterialShaders(material, THREE.ShaderLib[shaderID]);
    }
    maxLightCount = allocateLights(lights);
    maxShadows = allocateShadows(lights);
    maxBones = allocateBones(object);
    parameters = {
      map: !!material.map,
      envMap: !!material.envMap,
      lightMap: !!material.lightMap,
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      specularMap: !!material.specularMap,
      vertexColors: material.vertexColors,
      fog: fog,
      useFog: material.fog,
      fogExp: fog instanceof THREE.FogExp2,
      sizeAttenuation: material.sizeAttenuation,
      skinning: material.skinning,
      maxBones: maxBones,
      useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: this.maxMorphTargets,
      maxMorphNormals: this.maxMorphNormals,
      maxDirLights: maxLightCount.directional,
      maxPointLights: maxLightCount.point,
      maxSpotLights: maxLightCount.spot,
      maxHemiLights: maxLightCount.hemi,
      maxShadows: maxShadows,
      shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,
      shadowMapType: this.shadowMapType,
      shadowMapDebug: this.shadowMapDebug,
      shadowMapCascade: this.shadowMapCascade,
      alphaTest: material.alphaTest,
      metal: material.metal,
      perPixel: material.perPixel,
      wrapAround: material.wrapAround,
      doubleSided: material.side === THREE.DoubleSide,
      flipSided: material.side === THREE.BackSide
    };
    material.program = buildProgram(shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName);
    var attributes = material.program.attributes;
    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;
      var id, base = 'morphTarget';
      for (i = 0; i < this.maxMorphTargets; i++) {
        id = base + i;
        if (attributes[id] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }
    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;
      var id, base = 'morphNormal';
      for (i = 0; i < this.maxMorphNormals; i++) {
        id = base + i;
        if (attributes[id] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }
    material.uniformsList = [];
    for (u in material.uniforms) {
      material.uniformsList.push([
        material.uniforms[u],
        u
      ]);
    }
  };
  function setMaterialShaders(material, shaders) {
    material.uniforms = THREE.UniformsUtils.clone(shaders.uniforms);
    material.vertexShader = shaders.vertexShader;
    material.fragmentShader = shaders.fragmentShader;
  }
  ;
  function setProgram(camera, lights, fog, material, object) {
    _usedTextureUnits = 0;
    if (material.needsUpdate) {
      if (material.program)
        deallocateMaterial(material);
      _this.initMaterial(material, lights, fog, object);
      material.needsUpdate = false;
    }
    if (material.morphTargets) {
      if (!object.__webglMorphTargetInfluences) {
        object.__webglMorphTargetInfluences = new Float32Array(_this.maxMorphTargets);
      }
    }
    var refreshMaterial = false;
    var program = material.program, p_uniforms = program.uniforms, m_uniforms = material.uniforms;
    if (program !== _currentProgram) {
      _gl.useProgram(program);
      _currentProgram = program;
      refreshMaterial = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshMaterial || camera !== _currentCamera) {
      _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
      if (camera !== _currentCamera)
        _currentCamera = camera;
    }
    if (material.skinning) {
      if (_supportsBoneTextures && object.useVertexTexture) {
        if (p_uniforms.boneTexture !== null) {
          var textureUnit = getTextureUnit();
          _gl.uniform1i(p_uniforms.boneTexture, textureUnit);
          _this.setTexture(object.boneTexture, textureUnit);
        }
        if (p_uniforms.boneTextureWidth !== null) {
          _gl.uniform1i(p_uniforms.boneTextureWidth, object.boneTextureWidth);
        }
        if (p_uniforms.boneTextureHeight !== null) {
          _gl.uniform1i(p_uniforms.boneTextureHeight, object.boneTextureHeight);
        }
      } else {
        if (p_uniforms.boneGlobalMatrices !== null) {
          _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.boneMatrices);
        }
      }
    }
    if (refreshMaterial) {
      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }
      if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {
        if (_lightsNeedUpdate) {
          setupLights(program, lights);
          _lightsNeedUpdate = false;
        }
        refreshUniformsLights(m_uniforms, _lights);
      }
      if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
        refreshUniformsCommon(m_uniforms, material);
      }
      if (material instanceof THREE.LineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);
      } else if (material instanceof THREE.LineDashedMaterial) {
        refreshUniformsLine(m_uniforms, material);
        refreshUniformsDash(m_uniforms, material);
      } else if (material instanceof THREE.ParticleSystemMaterial) {
        refreshUniformsParticle(m_uniforms, material);
      } else if (material instanceof THREE.MeshPhongMaterial) {
        refreshUniformsPhong(m_uniforms, material);
      } else if (material instanceof THREE.MeshLambertMaterial) {
        refreshUniformsLambert(m_uniforms, material);
      } else if (material instanceof THREE.MeshDepthMaterial) {
        m_uniforms.mNear.value = camera.near;
        m_uniforms.mFar.value = camera.far;
        m_uniforms.opacity.value = material.opacity;
      } else if (material instanceof THREE.MeshNormalMaterial) {
        m_uniforms.opacity.value = material.opacity;
      }
      if (object.receiveShadow && !material._shadowPass) {
        refreshUniformsShadow(m_uniforms, lights);
      }
      loadUniformsGeneric(program, material.uniformsList);
      if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {
        if (p_uniforms.cameraPosition !== null) {
          _vector3.getPositionFromMatrix(camera.matrixWorld);
          _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
        }
      }
      if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {
        if (p_uniforms.viewMatrix !== null) {
          _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
        }
      }
    }
    loadUniformsMatrices(p_uniforms, object);
    if (p_uniforms.modelMatrix !== null) {
      _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
    }
    return program;
  }
  ;
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (_this.gammaInput) {
      uniforms.diffuse.value.copyGammaToLinear(material.color);
    } else {
      uniforms.diffuse.value = material.color;
    }
    uniforms.map.value = material.map;
    uniforms.lightMap.value = material.lightMap;
    uniforms.specularMap.value = material.specularMap;
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
    }
    var uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    }
    if (uvScaleMap !== undefined) {
      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;
      uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = material.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
    if (_this.gammaInput) {
      uniforms.reflectivity.value = material.reflectivity;
    } else {
      uniforms.reflectivity.value = material.reflectivity;
    }
    uniforms.refractionRatio.value = material.refractionRatio;
    uniforms.combine.value = material.combine;
    uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;
  }
  ;
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
  }
  ;
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  ;
  function refreshUniformsParticle(uniforms, material) {
    uniforms.psColor.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size;
    uniforms.scale.value = _canvas.height / 2;
    uniforms.map.value = material.map;
  }
  ;
  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value = fog.color;
    if (fog instanceof THREE.Fog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog instanceof THREE.FogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  ;
  function refreshUniformsPhong(uniforms, material) {
    uniforms.shininess.value = material.shininess;
    if (_this.gammaInput) {
      uniforms.ambient.value.copyGammaToLinear(material.ambient);
      uniforms.emissive.value.copyGammaToLinear(material.emissive);
      uniforms.specular.value.copyGammaToLinear(material.specular);
    } else {
      uniforms.ambient.value = material.ambient;
      uniforms.emissive.value = material.emissive;
      uniforms.specular.value = material.specular;
    }
    if (material.wrapAround) {
      uniforms.wrapRGB.value.copy(material.wrapRGB);
    }
  }
  ;
  function refreshUniformsLambert(uniforms, material) {
    if (_this.gammaInput) {
      uniforms.ambient.value.copyGammaToLinear(material.ambient);
      uniforms.emissive.value.copyGammaToLinear(material.emissive);
    } else {
      uniforms.ambient.value = material.ambient;
      uniforms.emissive.value = material.emissive;
    }
    if (material.wrapAround) {
      uniforms.wrapRGB.value.copy(material.wrapRGB);
    }
  }
  ;
  function refreshUniformsLights(uniforms, lights) {
    uniforms.ambientLightColor.value = lights.ambient;
    uniforms.directionalLightColor.value = lights.directional.colors;
    uniforms.directionalLightDirection.value = lights.directional.positions;
    uniforms.pointLightColor.value = lights.point.colors;
    uniforms.pointLightPosition.value = lights.point.positions;
    uniforms.pointLightDistance.value = lights.point.distances;
    uniforms.spotLightColor.value = lights.spot.colors;
    uniforms.spotLightPosition.value = lights.spot.positions;
    uniforms.spotLightDistance.value = lights.spot.distances;
    uniforms.spotLightDirection.value = lights.spot.directions;
    uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
    uniforms.spotLightExponent.value = lights.spot.exponents;
    uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
    uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
    uniforms.hemisphereLightDirection.value = lights.hemi.positions;
  }
  ;
  function refreshUniformsShadow(uniforms, lights) {
    if (uniforms.shadowMatrix) {
      var j = 0;
      for (var i = 0, il = lights.length; i < il; i++) {
        var light = lights[i];
        if (!light.castShadow)
          continue;
        if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight && !light.shadowCascade) {
          uniforms.shadowMap.value[j] = light.shadowMap;
          uniforms.shadowMapSize.value[j] = light.shadowMapSize;
          uniforms.shadowMatrix.value[j] = light.shadowMatrix;
          uniforms.shadowDarkness.value[j] = light.shadowDarkness;
          uniforms.shadowBias.value[j] = light.shadowBias;
          j++;
        }
      }
    }
  }
  ;
  function loadUniformsMatrices(uniforms, object) {
    _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object._modelViewMatrix.elements);
    if (uniforms.normalMatrix) {
      _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object._normalMatrix.elements);
    }
  }
  ;
  function getTextureUnit() {
    var textureUnit = _usedTextureUnits;
    if (textureUnit >= _maxTextures) {
      console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures);
    }
    _usedTextureUnits += 1;
    return textureUnit;
  }
  ;
  function loadUniformsGeneric(program, uniforms) {
    var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;
    for (j = 0, jl = uniforms.length; j < jl; j++) {
      location = program.uniforms[uniforms[j][1]];
      if (!location)
        continue;
      uniform = uniforms[j][0];
      type = uniform.type;
      value = uniform.value;
      if (type === 'i') {
        _gl.uniform1i(location, value);
      } else if (type === 'f') {
        _gl.uniform1f(location, value);
      } else if (type === 'v2') {
        _gl.uniform2f(location, value.x, value.y);
      } else if (type === 'v3') {
        _gl.uniform3f(location, value.x, value.y, value.z);
      } else if (type === 'v4') {
        _gl.uniform4f(location, value.x, value.y, value.z, value.w);
      } else if (type === 'c') {
        _gl.uniform3f(location, value.r, value.g, value.b);
      } else if (type === 'iv1') {
        _gl.uniform1iv(location, value);
      } else if (type === 'iv') {
        _gl.uniform3iv(location, value);
      } else if (type === 'fv1') {
        _gl.uniform1fv(location, value);
      } else if (type === 'fv') {
        _gl.uniform3fv(location, value);
      } else if (type === 'v2v') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(2 * value.length);
        }
        for (i = 0, il = value.length; i < il; i++) {
          offset = i * 2;
          uniform._array[offset] = value[i].x;
          uniform._array[offset + 1] = value[i].y;
        }
        _gl.uniform2fv(location, uniform._array);
      } else if (type === 'v3v') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(3 * value.length);
        }
        for (i = 0, il = value.length; i < il; i++) {
          offset = i * 3;
          uniform._array[offset] = value[i].x;
          uniform._array[offset + 1] = value[i].y;
          uniform._array[offset + 2] = value[i].z;
        }
        _gl.uniform3fv(location, uniform._array);
      } else if (type === 'v4v') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(4 * value.length);
        }
        for (i = 0, il = value.length; i < il; i++) {
          offset = i * 4;
          uniform._array[offset] = value[i].x;
          uniform._array[offset + 1] = value[i].y;
          uniform._array[offset + 2] = value[i].z;
          uniform._array[offset + 3] = value[i].w;
        }
        _gl.uniform4fv(location, uniform._array);
      } else if (type === 'm4') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(16);
        }
        value.flattenToArray(uniform._array);
        _gl.uniformMatrix4fv(location, false, uniform._array);
      } else if (type === 'm4v') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(16 * value.length);
        }
        for (i = 0, il = value.length; i < il; i++) {
          value[i].flattenToArrayOffset(uniform._array, i * 16);
        }
        _gl.uniformMatrix4fv(location, false, uniform._array);
      } else if (type === 't') {
        texture = value;
        textureUnit = getTextureUnit();
        _gl.uniform1i(location, textureUnit);
        if (!texture)
          continue;
        if (texture.image instanceof Array && texture.image.length === 6) {
          setCubeTexture(texture, textureUnit);
        } else if (texture instanceof THREE.WebGLRenderTargetCube) {
          setCubeTextureDynamic(texture, textureUnit);
        } else {
          _this.setTexture(texture, textureUnit);
        }
      } else if (type === 'tv') {
        if (uniform._array === undefined) {
          uniform._array = [];
        }
        for (i = 0, il = uniform.value.length; i < il; i++) {
          uniform._array[i] = getTextureUnit();
        }
        _gl.uniform1iv(location, uniform._array);
        for (i = 0, il = uniform.value.length; i < il; i++) {
          texture = uniform.value[i];
          textureUnit = uniform._array[i];
          if (!texture)
            continue;
          _this.setTexture(texture, textureUnit);
        }
      } else {
        console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + type);
      }
    }
  }
  ;
  function setupMatrices(object, camera) {
    object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object._normalMatrix.getNormalMatrix(object._modelViewMatrix);
  }
  ;
  function setColorGamma(array, offset, color, intensitySq) {
    array[offset] = color.r * color.r * intensitySq;
    array[offset + 1] = color.g * color.g * intensitySq;
    array[offset + 2] = color.b * color.b * intensitySq;
  }
  ;
  function setColorLinear(array, offset, color, intensity) {
    array[offset] = color.r * intensity;
    array[offset + 1] = color.g * intensity;
    array[offset + 2] = color.b * intensity;
  }
  ;
  function setupLights(program, lights) {
    var l, ll, light, n, r = 0, g = 0, b = 0, color, skyColor, groundColor, intensity, intensitySq, position, distance, zlights = _lights, dirColors = zlights.directional.colors, dirPositions = zlights.directional.positions, pointColors = zlights.point.colors, pointPositions = zlights.point.positions, pointDistances = zlights.point.distances, spotColors = zlights.spot.colors, spotPositions = zlights.spot.positions, spotDistances = zlights.spot.distances, spotDirections = zlights.spot.directions, spotAnglesCos = zlights.spot.anglesCos, spotExponents = zlights.spot.exponents, hemiSkyColors = zlights.hemi.skyColors, hemiGroundColors = zlights.hemi.groundColors, hemiPositions = zlights.hemi.positions, dirLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0, dirCount = 0, pointCount = 0, spotCount = 0, hemiCount = 0, dirOffset = 0, pointOffset = 0, spotOffset = 0, hemiOffset = 0;
    for (l = 0, ll = lights.length; l < ll; l++) {
      light = lights[l];
      if (light.onlyShadow)
        continue;
      color = light.color;
      intensity = light.intensity;
      distance = light.distance;
      if (light instanceof THREE.AmbientLight) {
        if (!light.visible)
          continue;
        if (_this.gammaInput) {
          r += color.r * color.r;
          g += color.g * color.g;
          b += color.b * color.b;
        } else {
          r += color.r;
          g += color.g;
          b += color.b;
        }
      } else if (light instanceof THREE.DirectionalLight) {
        dirCount += 1;
        if (!light.visible)
          continue;
        _direction.getPositionFromMatrix(light.matrixWorld);
        _vector3.getPositionFromMatrix(light.target.matrixWorld);
        _direction.sub(_vector3);
        _direction.normalize();
        if (_direction.x === 0 && _direction.y === 0 && _direction.z === 0)
          continue;
        dirOffset = dirLength * 3;
        dirPositions[dirOffset] = _direction.x;
        dirPositions[dirOffset + 1] = _direction.y;
        dirPositions[dirOffset + 2] = _direction.z;
        if (_this.gammaInput) {
          setColorGamma(dirColors, dirOffset, color, intensity * intensity);
        } else {
          setColorLinear(dirColors, dirOffset, color, intensity);
        }
        dirLength += 1;
      } else if (light instanceof THREE.PointLight) {
        pointCount += 1;
        if (!light.visible)
          continue;
        pointOffset = pointLength * 3;
        if (_this.gammaInput) {
          setColorGamma(pointColors, pointOffset, color, intensity * intensity);
        } else {
          setColorLinear(pointColors, pointOffset, color, intensity);
        }
        _vector3.getPositionFromMatrix(light.matrixWorld);
        pointPositions[pointOffset] = _vector3.x;
        pointPositions[pointOffset + 1] = _vector3.y;
        pointPositions[pointOffset + 2] = _vector3.z;
        pointDistances[pointLength] = distance;
        pointLength += 1;
      } else if (light instanceof THREE.SpotLight) {
        spotCount += 1;
        if (!light.visible)
          continue;
        spotOffset = spotLength * 3;
        if (_this.gammaInput) {
          setColorGamma(spotColors, spotOffset, color, intensity * intensity);
        } else {
          setColorLinear(spotColors, spotOffset, color, intensity);
        }
        _vector3.getPositionFromMatrix(light.matrixWorld);
        spotPositions[spotOffset] = _vector3.x;
        spotPositions[spotOffset + 1] = _vector3.y;
        spotPositions[spotOffset + 2] = _vector3.z;
        spotDistances[spotLength] = distance;
        _direction.copy(_vector3);
        _vector3.getPositionFromMatrix(light.target.matrixWorld);
        _direction.sub(_vector3);
        _direction.normalize();
        spotDirections[spotOffset] = _direction.x;
        spotDirections[spotOffset + 1] = _direction.y;
        spotDirections[spotOffset + 2] = _direction.z;
        spotAnglesCos[spotLength] = Math.cos(light.angle);
        spotExponents[spotLength] = light.exponent;
        spotLength += 1;
      } else if (light instanceof THREE.HemisphereLight) {
        hemiCount += 1;
        if (!light.visible)
          continue;
        _direction.getPositionFromMatrix(light.matrixWorld);
        _direction.normalize();
        if (_direction.x === 0 && _direction.y === 0 && _direction.z === 0)
          continue;
        hemiOffset = hemiLength * 3;
        hemiPositions[hemiOffset] = _direction.x;
        hemiPositions[hemiOffset + 1] = _direction.y;
        hemiPositions[hemiOffset + 2] = _direction.z;
        skyColor = light.color;
        groundColor = light.groundColor;
        if (_this.gammaInput) {
          intensitySq = intensity * intensity;
          setColorGamma(hemiSkyColors, hemiOffset, skyColor, intensitySq);
          setColorGamma(hemiGroundColors, hemiOffset, groundColor, intensitySq);
        } else {
          setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);
          setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);
        }
        hemiLength += 1;
      }
    }
    for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++)
      dirColors[l] = 0;
    for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++)
      pointColors[l] = 0;
    for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++)
      spotColors[l] = 0;
    for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++)
      hemiSkyColors[l] = 0;
    for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++)
      hemiGroundColors[l] = 0;
    zlights.directional.length = dirLength;
    zlights.point.length = pointLength;
    zlights.spot.length = spotLength;
    zlights.hemi.length = hemiLength;
    zlights.ambient[0] = r;
    zlights.ambient[1] = g;
    zlights.ambient[2] = b;
  }
  ;
  this.setFaceCulling = function (cullFace, frontFaceDirection) {
    if (cullFace === THREE.CullFaceNone) {
      _gl.disable(_gl.CULL_FACE);
    } else {
      if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
        _gl.frontFace(_gl.CW);
      } else {
        _gl.frontFace(_gl.CCW);
      }
      if (cullFace === THREE.CullFaceBack) {
        _gl.cullFace(_gl.BACK);
      } else if (cullFace === THREE.CullFaceFront) {
        _gl.cullFace(_gl.FRONT);
      } else {
        _gl.cullFace(_gl.FRONT_AND_BACK);
      }
      _gl.enable(_gl.CULL_FACE);
    }
  };
  this.setMaterialFaces = function (material) {
    var doubleSided = material.side === THREE.DoubleSide;
    var flipSided = material.side === THREE.BackSide;
    if (_oldDoubleSided !== doubleSided) {
      if (doubleSided) {
        _gl.disable(_gl.CULL_FACE);
      } else {
        _gl.enable(_gl.CULL_FACE);
      }
      _oldDoubleSided = doubleSided;
    }
    if (_oldFlipSided !== flipSided) {
      if (flipSided) {
        _gl.frontFace(_gl.CW);
      } else {
        _gl.frontFace(_gl.CCW);
      }
      _oldFlipSided = flipSided;
    }
  };
  this.setDepthTest = function (depthTest) {
    if (_oldDepthTest !== depthTest) {
      if (depthTest) {
        _gl.enable(_gl.DEPTH_TEST);
      } else {
        _gl.disable(_gl.DEPTH_TEST);
      }
      _oldDepthTest = depthTest;
    }
  };
  this.setDepthWrite = function (depthWrite) {
    if (_oldDepthWrite !== depthWrite) {
      _gl.depthMask(depthWrite);
      _oldDepthWrite = depthWrite;
    }
  };
  function setLineWidth(width) {
    if (width !== _oldLineWidth) {
      _gl.lineWidth(width);
      _oldLineWidth = width;
    }
  }
  ;
  function setPolygonOffset(polygonoffset, factor, units) {
    if (_oldPolygonOffset !== polygonoffset) {
      if (polygonoffset) {
        _gl.enable(_gl.POLYGON_OFFSET_FILL);
      } else {
        _gl.disable(_gl.POLYGON_OFFSET_FILL);
      }
      _oldPolygonOffset = polygonoffset;
    }
    if (polygonoffset && (_oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units)) {
      _gl.polygonOffset(factor, units);
      _oldPolygonOffsetFactor = factor;
      _oldPolygonOffsetUnits = units;
    }
  }
  ;
  this.setBlending = function (blending, blendEquation, blendSrc, blendDst) {
    if (blending !== _oldBlending) {
      if (blending === THREE.NoBlending) {
        _gl.disable(_gl.BLEND);
      } else if (blending === THREE.AdditiveBlending) {
        _gl.enable(_gl.BLEND);
        _gl.blendEquation(_gl.FUNC_ADD);
        _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);
      } else if (blending === THREE.SubtractiveBlending) {
        _gl.enable(_gl.BLEND);
        _gl.blendEquation(_gl.FUNC_ADD);
        _gl.blendFunc(_gl.ZERO, _gl.ONE_MINUS_SRC_COLOR);
      } else if (blending === THREE.MultiplyBlending) {
        _gl.enable(_gl.BLEND);
        _gl.blendEquation(_gl.FUNC_ADD);
        _gl.blendFunc(_gl.ZERO, _gl.SRC_COLOR);
      } else if (blending === THREE.CustomBlending) {
        _gl.enable(_gl.BLEND);
      } else {
        _gl.enable(_gl.BLEND);
        _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
        _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
      }
      _oldBlending = blending;
    }
    if (blending === THREE.CustomBlending) {
      if (blendEquation !== _oldBlendEquation) {
        _gl.blendEquation(paramThreeToGL(blendEquation));
        _oldBlendEquation = blendEquation;
      }
      if (blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst) {
        _gl.blendFunc(paramThreeToGL(blendSrc), paramThreeToGL(blendDst));
        _oldBlendSrc = blendSrc;
        _oldBlendDst = blendDst;
      }
    } else {
      _oldBlendEquation = null;
      _oldBlendSrc = null;
      _oldBlendDst = null;
    }
  };
  function generateDefines(defines) {
    var value, chunk, chunks = [];
    for (var d in defines) {
      value = defines[d];
      if (value === false)
        continue;
      chunk = '#define ' + d + ' ' + value;
      chunks.push(chunk);
    }
    return chunks.join('\n');
  }
  ;
  function buildProgram(shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName) {
    var p, pl, d, program, code;
    var chunks = [];
    if (shaderID) {
      chunks.push(shaderID);
    } else {
      chunks.push(fragmentShader);
      chunks.push(vertexShader);
    }
    for (d in defines) {
      chunks.push(d);
      chunks.push(defines[d]);
    }
    for (p in parameters) {
      chunks.push(p);
      chunks.push(parameters[p]);
    }
    code = chunks.join();
    for (p = 0, pl = _programs.length; p < pl; p++) {
      var programInfo = _programs[p];
      if (programInfo.code === code) {
        programInfo.usedTimes++;
        return programInfo.program;
      }
    }
    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters.shadowMapType === THREE.PCFShadowMap) {
      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    }
    var customDefines = generateDefines(defines);
    program = _gl.createProgram();
    var prefix_vertex = [
        'precision ' + _precision + ' float;',
        'precision ' + _precision + ' int;',
        customDefines,
        _supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
        _this.gammaInput ? '#define GAMMA_INPUT' : '',
        _this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        _this.physicallyBasedShading ? '#define PHYSICALLY_BASED_SHADING' : '',
        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,
        '#define MAX_SHADOWS ' + parameters.maxShadows,
        '#define MAX_BONES ' + parameters.maxBones,
        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',
        parameters.skinning ? '#define USE_SKINNING' : '',
        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
        parameters.morphNormals ? '#define USE_MORPHNORMALS' : '',
        parameters.perPixel ? '#define PHONG_PER_PIXEL' : '',
        parameters.wrapAround ? '#define WRAP_AROUND' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',
        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        'attribute vec2 uv2;',
        '#ifdef USE_COLOR',
        'attribute vec3 color;',
        '#endif',
        '#ifdef USE_MORPHTARGETS',
        'attribute vec3 morphTarget0;',
        'attribute vec3 morphTarget1;',
        'attribute vec3 morphTarget2;',
        'attribute vec3 morphTarget3;',
        '#ifdef USE_MORPHNORMALS',
        'attribute vec3 morphNormal0;',
        'attribute vec3 morphNormal1;',
        'attribute vec3 morphNormal2;',
        'attribute vec3 morphNormal3;',
        '#else',
        'attribute vec3 morphTarget4;',
        'attribute vec3 morphTarget5;',
        'attribute vec3 morphTarget6;',
        'attribute vec3 morphTarget7;',
        '#endif',
        '#endif',
        '#ifdef USE_SKINNING',
        'attribute vec4 skinIndex;',
        'attribute vec4 skinWeight;',
        '#endif',
        ''
      ].join('\n');
    var prefix_fragment = [
        'precision ' + _precision + ' float;',
        'precision ' + _precision + ' int;',
        parameters.bumpMap || parameters.normalMap ? '#extension GL_OES_standard_derivatives : enable' : '',
        customDefines,
        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,
        '#define MAX_SHADOWS ' + parameters.maxShadows,
        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
        _this.gammaInput ? '#define GAMMA_INPUT' : '',
        _this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        _this.physicallyBasedShading ? '#define PHYSICALLY_BASED_SHADING' : '',
        parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
        parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '',
        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',
        parameters.metal ? '#define METAL' : '',
        parameters.perPixel ? '#define PHONG_PER_PIXEL' : '',
        parameters.wrapAround ? '#define WRAP_AROUND' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',
        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        ''
      ].join('\n');
    var glVertexShader = getShader('vertex', prefix_vertex + vertexShader);
    var glFragmentShader = getShader('fragment', prefix_fragment + fragmentShader);
    _gl.attachShader(program, glVertexShader);
    _gl.attachShader(program, glFragmentShader);
    if (index0AttributeName) {
      _gl.bindAttribLocation(program, 0, index0AttributeName);
    }
    _gl.linkProgram(program);
    if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) {
      console.error('Could not initialise shader\n' + 'VALIDATE_STATUS: ' + _gl.getProgramParameter(program, _gl.VALIDATE_STATUS) + ', gl error [' + _gl.getError() + ']');
      console.error('Program Info Log: ' + _gl.getProgramInfoLog(program));
    }
    _gl.deleteShader(glFragmentShader);
    _gl.deleteShader(glVertexShader);
    program.uniforms = {};
    program.attributes = {};
    var identifiers, u, a, i;
    identifiers = [
      'viewMatrix',
      'modelViewMatrix',
      'projectionMatrix',
      'normalMatrix',
      'modelMatrix',
      'cameraPosition',
      'morphTargetInfluences'
    ];
    if (parameters.useVertexTexture) {
      identifiers.push('boneTexture');
      identifiers.push('boneTextureWidth');
      identifiers.push('boneTextureHeight');
    } else {
      identifiers.push('boneGlobalMatrices');
    }
    for (u in uniforms) {
      identifiers.push(u);
    }
    cacheUniformLocations(program, identifiers);
    identifiers = [
      'position',
      'normal',
      'uv',
      'uv2',
      'tangent',
      'color',
      'skinIndex',
      'skinWeight',
      'lineDistance'
    ];
    for (i = 0; i < parameters.maxMorphTargets; i++) {
      identifiers.push('morphTarget' + i);
    }
    for (i = 0; i < parameters.maxMorphNormals; i++) {
      identifiers.push('morphNormal' + i);
    }
    for (a in attributes) {
      identifiers.push(a);
    }
    cacheAttributeLocations(program, identifiers);
    program.id = _programs_counter++;
    _programs.push({
      program: program,
      code: code,
      usedTimes: 1
    });
    _this.info.memory.programs = _programs.length;
    return program;
  }
  ;
  function cacheUniformLocations(program, identifiers) {
    var i, l, id;
    for (i = 0, l = identifiers.length; i < l; i++) {
      id = identifiers[i];
      program.uniforms[id] = _gl.getUniformLocation(program, id);
    }
  }
  ;
  function cacheAttributeLocations(program, identifiers) {
    var i, l, id;
    for (i = 0, l = identifiers.length; i < l; i++) {
      id = identifiers[i];
      program.attributes[id] = _gl.getAttribLocation(program, id);
    }
  }
  ;
  function addLineNumbers(string) {
    var chunks = string.split('\n');
    for (var i = 0, il = chunks.length; i < il; i++) {
      chunks[i] = i + 1 + ': ' + chunks[i];
    }
    return chunks.join('\n');
  }
  ;
  function getShader(type, string) {
    var shader;
    if (type === 'fragment') {
      shader = _gl.createShader(_gl.FRAGMENT_SHADER);
    } else if (type === 'vertex') {
      shader = _gl.createShader(_gl.VERTEX_SHADER);
    }
    _gl.shaderSource(shader, string);
    _gl.compileShader(shader);
    if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
      console.error(_gl.getShaderInfoLog(shader));
      console.error(addLineNumbers(string));
      return null;
    }
    return shader;
  }
  ;
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0;
  }
  ;
  function setTextureParameters(textureType, texture, isImagePowerOfTwo) {
    if (isImagePowerOfTwo) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
    }
    if (_glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType) {
      if (texture.anisotropy > 1 || texture.__oldAnisotropy) {
        _gl.texParameterf(textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _maxAnisotropy));
        texture.__oldAnisotropy = texture.anisotropy;
      }
    }
  }
  ;
  this.setTexture = function (texture, slot) {
    if (texture.needsUpdate) {
      if (!texture.__webglInit) {
        texture.__webglInit = true;
        texture.addEventListener('dispose', onTextureDispose);
        texture.__webglTexture = _gl.createTexture();
        _this.info.memory.textures++;
      }
      _gl.activeTexture(_gl.TEXTURE0 + slot);
      _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      var image = texture.image, isImagePowerOfTwo = isPowerOfTwo(image.width) && isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
      setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);
      var mipmap, mipmaps = texture.mipmaps;
      if (texture instanceof THREE.DataTexture) {
        if (mipmaps.length > 0 && isImagePowerOfTwo) {
          for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
          texture.generateMipmaps = false;
        } else {
          _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
        }
      } else if (texture instanceof THREE.CompressedTexture) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          if (texture.format !== THREE.RGBAFormat) {
            _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      } else {
        if (mipmaps.length > 0 && isImagePowerOfTwo) {
          for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
          }
          texture.generateMipmaps = false;
        } else {
          _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
        }
      }
      if (texture.generateMipmaps && isImagePowerOfTwo)
        _gl.generateMipmap(_gl.TEXTURE_2D);
      texture.needsUpdate = false;
      if (texture.onUpdate)
        texture.onUpdate();
    } else {
      _gl.activeTexture(_gl.TEXTURE0 + slot);
      _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
    }
  };
  function clampToMaxSize(image, maxSize) {
    if (image.width <= maxSize && image.height <= maxSize) {
      return image;
    }
    var maxDimension = Math.max(image.width, image.height);
    var newWidth = Math.floor(image.width * maxSize / maxDimension);
    var newHeight = Math.floor(image.height * maxSize / maxDimension);
    var canvas = document.createElement('canvas');
    canvas.width = newWidth;
    canvas.height = newHeight;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight);
    return canvas;
  }
  function setCubeTexture(texture, slot) {
    if (texture.image.length === 6) {
      if (texture.needsUpdate) {
        if (!texture.image.__webglTextureCube) {
          texture.addEventListener('dispose', onTextureDispose);
          texture.image.__webglTextureCube = _gl.createTexture();
          _this.info.memory.textures++;
        }
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        var isCompressed = texture instanceof THREE.CompressedTexture;
        var cubeImage = [];
        for (var i = 0; i < 6; i++) {
          if (_this.autoScaleCubemaps && !isCompressed) {
            cubeImage[i] = clampToMaxSize(texture.image[i], _maxCubemapSize);
          } else {
            cubeImage[i] = texture.image[i];
          }
        }
        var image = cubeImage[0], isImagePowerOfTwo = isPowerOfTwo(image.width) && isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);
        for (var i = 0; i < 6; i++) {
          if (!isCompressed) {
            _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
          } else {
            var mipmap, mipmaps = cubeImage[i].mipmaps;
            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
              mipmap = mipmaps[j];
              if (texture.format !== THREE.RGBAFormat) {
                _gl.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
        if (texture.generateMipmaps && isImagePowerOfTwo) {
          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        texture.needsUpdate = false;
        if (texture.onUpdate)
          texture.onUpdate();
      } else {
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
      }
    }
  }
  ;
  function setCubeTextureDynamic(texture, slot) {
    _gl.activeTexture(_gl.TEXTURE0 + slot);
    _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.__webglTexture);
  }
  ;
  function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0);
  }
  ;
  function setupRenderBuffer(renderbuffer, renderTarget) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
    }
  }
  ;
  this.setRenderTarget = function (renderTarget) {
    var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;
    if (renderTarget && !renderTarget.__webglFramebuffer) {
      if (renderTarget.depthBuffer === undefined)
        renderTarget.depthBuffer = true;
      if (renderTarget.stencilBuffer === undefined)
        renderTarget.stencilBuffer = true;
      renderTarget.addEventListener('dispose', onRenderTargetDispose);
      renderTarget.__webglTexture = _gl.createTexture();
      _this.info.memory.textures++;
      var isTargetPowerOfTwo = isPowerOfTwo(renderTarget.width) && isPowerOfTwo(renderTarget.height), glFormat = paramThreeToGL(renderTarget.format), glType = paramThreeToGL(renderTarget.type);
      if (isCube) {
        renderTarget.__webglFramebuffer = [];
        renderTarget.__webglRenderbuffer = [];
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo);
        for (var i = 0; i < 6; i++) {
          renderTarget.__webglFramebuffer[i] = _gl.createFramebuffer();
          renderTarget.__webglRenderbuffer[i] = _gl.createRenderbuffer();
          _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
          setupFrameBuffer(renderTarget.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
          setupRenderBuffer(renderTarget.__webglRenderbuffer[i], renderTarget);
        }
        if (isTargetPowerOfTwo)
          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
      } else {
        renderTarget.__webglFramebuffer = _gl.createFramebuffer();
        if (renderTarget.shareDepthFrom) {
          renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
        } else {
          renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();
        }
        _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo);
        _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        setupFrameBuffer(renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);
        if (renderTarget.shareDepthFrom) {
          if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
          } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
          }
        } else {
          setupRenderBuffer(renderTarget.__webglRenderbuffer, renderTarget);
        }
        if (isTargetPowerOfTwo)
          _gl.generateMipmap(_gl.TEXTURE_2D);
      }
      if (isCube) {
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
      } else {
        _gl.bindTexture(_gl.TEXTURE_2D, null);
      }
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    var framebuffer, width, height, vx, vy;
    if (renderTarget) {
      if (isCube) {
        framebuffer = renderTarget.__webglFramebuffer[renderTarget.activeCubeFace];
      } else {
        framebuffer = renderTarget.__webglFramebuffer;
      }
      width = renderTarget.width;
      height = renderTarget.height;
      vx = 0;
      vy = 0;
    } else {
      framebuffer = null;
      width = _viewportWidth;
      height = _viewportHeight;
      vx = _viewportX;
      vy = _viewportY;
    }
    if (framebuffer !== _currentFramebuffer) {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      _gl.viewport(vx, vy, width, height);
      _currentFramebuffer = framebuffer;
    }
    _currentWidth = width;
    _currentHeight = height;
  };
  function updateRenderTargetMipmap(renderTarget) {
    if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
      _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
      _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
      _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
    } else {
      _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
      _gl.generateMipmap(_gl.TEXTURE_2D);
      _gl.bindTexture(_gl.TEXTURE_2D, null);
    }
  }
  ;
  function filterFallback(f) {
    if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  ;
  function paramThreeToGL(p) {
    if (p === THREE.RepeatWrapping)
      return _gl.REPEAT;
    if (p === THREE.ClampToEdgeWrapping)
      return _gl.CLAMP_TO_EDGE;
    if (p === THREE.MirroredRepeatWrapping)
      return _gl.MIRRORED_REPEAT;
    if (p === THREE.NearestFilter)
      return _gl.NEAREST;
    if (p === THREE.NearestMipMapNearestFilter)
      return _gl.NEAREST_MIPMAP_NEAREST;
    if (p === THREE.NearestMipMapLinearFilter)
      return _gl.NEAREST_MIPMAP_LINEAR;
    if (p === THREE.LinearFilter)
      return _gl.LINEAR;
    if (p === THREE.LinearMipMapNearestFilter)
      return _gl.LINEAR_MIPMAP_NEAREST;
    if (p === THREE.LinearMipMapLinearFilter)
      return _gl.LINEAR_MIPMAP_LINEAR;
    if (p === THREE.UnsignedByteType)
      return _gl.UNSIGNED_BYTE;
    if (p === THREE.UnsignedShort4444Type)
      return _gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === THREE.UnsignedShort5551Type)
      return _gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === THREE.UnsignedShort565Type)
      return _gl.UNSIGNED_SHORT_5_6_5;
    if (p === THREE.ByteType)
      return _gl.BYTE;
    if (p === THREE.ShortType)
      return _gl.SHORT;
    if (p === THREE.UnsignedShortType)
      return _gl.UNSIGNED_SHORT;
    if (p === THREE.IntType)
      return _gl.INT;
    if (p === THREE.UnsignedIntType)
      return _gl.UNSIGNED_INT;
    if (p === THREE.FloatType)
      return _gl.FLOAT;
    if (p === THREE.AlphaFormat)
      return _gl.ALPHA;
    if (p === THREE.RGBFormat)
      return _gl.RGB;
    if (p === THREE.RGBAFormat)
      return _gl.RGBA;
    if (p === THREE.LuminanceFormat)
      return _gl.LUMINANCE;
    if (p === THREE.LuminanceAlphaFormat)
      return _gl.LUMINANCE_ALPHA;
    if (p === THREE.AddEquation)
      return _gl.FUNC_ADD;
    if (p === THREE.SubtractEquation)
      return _gl.FUNC_SUBTRACT;
    if (p === THREE.ReverseSubtractEquation)
      return _gl.FUNC_REVERSE_SUBTRACT;
    if (p === THREE.ZeroFactor)
      return _gl.ZERO;
    if (p === THREE.OneFactor)
      return _gl.ONE;
    if (p === THREE.SrcColorFactor)
      return _gl.SRC_COLOR;
    if (p === THREE.OneMinusSrcColorFactor)
      return _gl.ONE_MINUS_SRC_COLOR;
    if (p === THREE.SrcAlphaFactor)
      return _gl.SRC_ALPHA;
    if (p === THREE.OneMinusSrcAlphaFactor)
      return _gl.ONE_MINUS_SRC_ALPHA;
    if (p === THREE.DstAlphaFactor)
      return _gl.DST_ALPHA;
    if (p === THREE.OneMinusDstAlphaFactor)
      return _gl.ONE_MINUS_DST_ALPHA;
    if (p === THREE.DstColorFactor)
      return _gl.DST_COLOR;
    if (p === THREE.OneMinusDstColorFactor)
      return _gl.ONE_MINUS_DST_COLOR;
    if (p === THREE.SrcAlphaSaturateFactor)
      return _gl.SRC_ALPHA_SATURATE;
    if (_glExtensionCompressedTextureS3TC !== undefined) {
      if (p === THREE.RGB_S3TC_DXT1_Format)
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (p === THREE.RGBA_S3TC_DXT1_Format)
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (p === THREE.RGBA_S3TC_DXT3_Format)
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (p === THREE.RGBA_S3TC_DXT5_Format)
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    return 0;
  }
  ;
  function allocateBones(object) {
    if (_supportsBoneTextures && object && object.useVertexTexture) {
      return 1024;
    } else {
      var nVertexUniforms = _gl.getParameter(_gl.MAX_VERTEX_UNIFORM_VECTORS);
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = nVertexMatrices;
      if (object !== undefined && object instanceof THREE.SkinnedMesh) {
        maxBones = Math.min(object.bones.length, maxBones);
        if (maxBones < object.bones.length) {
          console.warn('WebGLRenderer: too many bones - ' + object.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
        }
      }
      return maxBones;
    }
  }
  ;
  function allocateLights(lights) {
    var dirLights = 0;
    var pointLights = 0;
    var spotLights = 0;
    var hemiLights = 0;
    for (var l = 0, ll = lights.length; l < ll; l++) {
      var light = lights[l];
      if (light.onlyShadow)
        continue;
      if (light instanceof THREE.DirectionalLight)
        dirLights++;
      if (light instanceof THREE.PointLight)
        pointLights++;
      if (light instanceof THREE.SpotLight)
        spotLights++;
      if (light instanceof THREE.HemisphereLight)
        hemiLights++;
    }
    return {
      'directional': dirLights,
      'point': pointLights,
      'spot': spotLights,
      'hemi': hemiLights
    };
  }
  ;
  function allocateShadows(lights) {
    var maxShadows = 0;
    for (var l = 0, ll = lights.length; l < ll; l++) {
      var light = lights[l];
      if (!light.castShadow)
        continue;
      if (light instanceof THREE.SpotLight)
        maxShadows++;
      if (light instanceof THREE.DirectionalLight && !light.shadowCascade)
        maxShadows++;
    }
    return maxShadows;
  }
  ;
  function initGL() {
    try {
      var attributes = {
          alpha: _alpha,
          premultipliedAlpha: _premultipliedAlpha,
          antialias: _antialias,
          stencil: _stencil,
          preserveDrawingBuffer: _preserveDrawingBuffer
        };
      _gl = _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
      if (_gl === null) {
        throw 'Error creating WebGL context.';
      }
    } catch (error) {
      console.error(error);
    }
    _glExtensionTextureFloat = _gl.getExtension('OES_texture_float');
    _glExtensionTextureFloatLinear = _gl.getExtension('OES_texture_float_linear');
    _glExtensionStandardDerivatives = _gl.getExtension('OES_standard_derivatives');
    _glExtensionTextureFilterAnisotropic = _gl.getExtension('EXT_texture_filter_anisotropic') || _gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || _gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
    _glExtensionCompressedTextureS3TC = _gl.getExtension('WEBGL_compressed_texture_s3tc') || _gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || _gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
    if (!_glExtensionTextureFloat) {
      console.log('THREE.WebGLRenderer: Float textures not supported.');
    }
    if (!_glExtensionStandardDerivatives) {
      console.log('THREE.WebGLRenderer: Standard derivatives not supported.');
    }
    if (!_glExtensionTextureFilterAnisotropic) {
      console.log('THREE.WebGLRenderer: Anisotropic texture filtering not supported.');
    }
    if (!_glExtensionCompressedTextureS3TC) {
      console.log('THREE.WebGLRenderer: S3TC compressed textures not supported.');
    }
    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  }
  ;
  function setDefaultGLState() {
    _gl.clearColor(0, 0, 0, 1);
    _gl.clearDepth(1);
    _gl.clearStencil(0);
    _gl.enable(_gl.DEPTH_TEST);
    _gl.depthFunc(_gl.LEQUAL);
    _gl.frontFace(_gl.CCW);
    _gl.cullFace(_gl.BACK);
    _gl.enable(_gl.CULL_FACE);
    _gl.enable(_gl.BLEND);
    _gl.blendEquation(_gl.FUNC_ADD);
    _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);
    _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
    _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
  }
  ;
  this.shadowMapPlugin = new THREE.ShadowMapPlugin();
  this.addPrePlugin(this.shadowMapPlugin);
  this.addPostPlugin(new THREE.SpritePlugin());
  this.addPostPlugin(new THREE.LensFlarePlugin());
};
THREE.WebGLRenderTarget = function (width, height, options) {
  this.width = width;
  this.height = height;
  options = options || {};
  this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
  this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
  this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;
  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  this.generateMipmaps = true;
  this.shareDepthFrom = null;
};
THREE.WebGLRenderTarget.prototype = {
  constructor: THREE.WebGLRenderTarget,
  clone: function () {
    var tmp = new THREE.WebGLRenderTarget(this.width, this.height);
    tmp.wrapS = this.wrapS;
    tmp.wrapT = this.wrapT;
    tmp.magFilter = this.magFilter;
    tmp.minFilter = this.minFilter;
    tmp.anisotropy = this.anisotropy;
    tmp.offset.copy(this.offset);
    tmp.repeat.copy(this.repeat);
    tmp.format = this.format;
    tmp.type = this.type;
    tmp.depthBuffer = this.depthBuffer;
    tmp.stencilBuffer = this.stencilBuffer;
    tmp.generateMipmaps = this.generateMipmaps;
    tmp.shareDepthFrom = this.shareDepthFrom;
    return tmp;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube = function (width, height, options) {
  THREE.WebGLRenderTarget.call(this, width, height, options);
  this.activeCubeFace = 0;
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.RenderableVertex = function () {
  this.positionWorld = new THREE.Vector3();
  this.positionScreen = new THREE.Vector4();
  this.visible = true;
};
THREE.RenderableVertex.prototype.copy = function (vertex) {
  this.positionWorld.copy(vertex.positionWorld);
  this.positionScreen.copy(vertex.positionScreen);
};
THREE.RenderableFace3 = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.v3 = new THREE.RenderableVertex();
  this.centroidModel = new THREE.Vector3();
  this.normalModel = new THREE.Vector3();
  this.normalModelView = new THREE.Vector3();
  this.vertexNormalsLength = 0;
  this.vertexNormalsModel = [
    new THREE.Vector3(),
    new THREE.Vector3(),
    new THREE.Vector3()
  ];
  this.vertexNormalsModelView = [
    new THREE.Vector3(),
    new THREE.Vector3(),
    new THREE.Vector3()
  ];
  this.color = null;
  this.material = null;
  this.uvs = [[]];
  this.z = 0;
};
THREE.RenderableObject = function () {
  this.id = 0;
  this.object = null;
  this.z = 0;
};
THREE.RenderableSprite = function () {
  this.id = 0;
  this.object = null;
  this.x = 0;
  this.y = 0;
  this.z = 0;
  this.rotation = 0;
  this.scale = new THREE.Vector2();
  this.material = null;
};
THREE.RenderableLine = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.vertexColors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  this.material = null;
  this.z = 0;
};
THREE.GeometryUtils = {
  merge: function (geometry1, object2, materialIndexOffset) {
    var matrix, normalMatrix, vertexOffset = geometry1.vertices.length, uvPosition = geometry1.faceVertexUvs[0].length, geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2, vertices1 = geometry1.vertices, vertices2 = geometry2.vertices, faces1 = geometry1.faces, faces2 = geometry2.faces, uvs1 = geometry1.faceVertexUvs[0], uvs2 = geometry2.faceVertexUvs[0];
    if (materialIndexOffset === undefined)
      materialIndexOffset = 0;
    if (object2 instanceof THREE.Mesh) {
      object2.matrixAutoUpdate && object2.updateMatrix();
      matrix = object2.matrix;
      normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
    }
    for (var i = 0, il = vertices2.length; i < il; i++) {
      var vertex = vertices2[i];
      var vertexCopy = vertex.clone();
      if (matrix)
        vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    }
    for (i = 0, il = faces2.length; i < il; i++) {
      var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
      faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);
      if (normalMatrix) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }
      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();
        if (normalMatrix) {
          normal.applyMatrix3(normalMatrix).normalize();
        }
        faceCopy.vertexNormals.push(normal);
      }
      faceCopy.color.copy(face.color);
      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }
      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faceCopy.centroid.copy(face.centroid);
      if (matrix) {
        faceCopy.centroid.applyMatrix4(matrix);
      }
      faces1.push(faceCopy);
    }
    for (i = 0, il = uvs2.length; i < il; i++) {
      var uv = uvs2[i], uvCopy = [];
      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(new THREE.Vector2(uv[j].x, uv[j].y));
      }
      uvs1.push(uvCopy);
    }
  },
  randomPointInTriangle: function () {
    var vector = new THREE.Vector3();
    return function (vectorA, vectorB, vectorC) {
      var point = new THREE.Vector3();
      var a = THREE.Math.random16();
      var b = THREE.Math.random16();
      if (a + b > 1) {
        a = 1 - a;
        b = 1 - b;
      }
      var c = 1 - a - b;
      point.copy(vectorA);
      point.multiplyScalar(a);
      vector.copy(vectorB);
      vector.multiplyScalar(b);
      point.add(vector);
      vector.copy(vectorC);
      vector.multiplyScalar(c);
      point.add(vector);
      return point;
    };
  }(),
  randomPointInFace: function (face, geometry, useCachedAreas) {
    var vA, vB, vC, vD;
    vA = geometry.vertices[face.a];
    vB = geometry.vertices[face.b];
    vC = geometry.vertices[face.c];
    return THREE.GeometryUtils.randomPointInTriangle(vA, vB, vC);
  },
  randomPointsInGeometry: function (geometry, n) {
    var face, i, faces = geometry.faces, vertices = geometry.vertices, il = faces.length, totalArea = 0, cumulativeAreas = [], vA, vB, vC, vD;
    for (i = 0; i < il; i++) {
      face = faces[i];
      vA = vertices[face.a];
      vB = vertices[face.b];
      vC = vertices[face.c];
      face._area = THREE.GeometryUtils.triangleArea(vA, vB, vC);
      totalArea += face._area;
      cumulativeAreas[i] = totalArea;
    }
    function binarySearchIndices(value) {
      function binarySearch(start, end) {
        if (end < start)
          return start;
        var mid = start + Math.floor((end - start) / 2);
        if (cumulativeAreas[mid] > value) {
          return binarySearch(start, mid - 1);
        } else if (cumulativeAreas[mid] < value) {
          return binarySearch(mid + 1, end);
        } else {
          return mid;
        }
      }
      var result = binarySearch(0, cumulativeAreas.length - 1);
      return result;
    }
    var r, index, result = [];
    var stats = {};
    for (i = 0; i < n; i++) {
      r = THREE.Math.random16() * totalArea;
      index = binarySearchIndices(r);
      result[i] = THREE.GeometryUtils.randomPointInFace(faces[index], geometry, true);
      if (!stats[index]) {
        stats[index] = 1;
      } else {
        stats[index] += 1;
      }
    }
    return result;
  },
  triangleArea: function () {
    var vector1 = new THREE.Vector3();
    var vector2 = new THREE.Vector3();
    return function (vectorA, vectorB, vectorC) {
      vector1.subVectors(vectorB, vectorA);
      vector2.subVectors(vectorC, vectorA);
      vector1.cross(vector2);
      return 0.5 * vector1.length();
    };
  }(),
  center: function (geometry) {
    geometry.computeBoundingBox();
    var bb = geometry.boundingBox;
    var offset = new THREE.Vector3();
    offset.addVectors(bb.min, bb.max);
    offset.multiplyScalar(-0.5);
    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(offset.x, offset.y, offset.z));
    geometry.computeBoundingBox();
    return offset;
  },
  triangulateQuads: function (geometry) {
    var i, il, j, jl;
    var faces = [];
    var faceVertexUvs = [];
    for (i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
      faceVertexUvs[i] = [];
    }
    for (i = 0, il = geometry.faces.length; i < il; i++) {
      var face = geometry.faces[i];
      faces.push(face);
      for (j = 0, jl = geometry.faceVertexUvs.length; j < jl; j++) {
        faceVertexUvs[j].push(geometry.faceVertexUvs[j][i]);
      }
    }
    geometry.faces = faces;
    geometry.faceVertexUvs = faceVertexUvs;
    geometry.computeCentroids();
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    if (geometry.hasTangents)
      geometry.computeTangents();
  }
};
THREE.ImageUtils = {
  crossOrigin: 'anonymous',
  loadTexture: function (url, mapping, onLoad, onError) {
    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;
    var texture = new THREE.Texture(undefined, mapping);
    var image = loader.load(url, function () {
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      });
    texture.image = image;
    texture.sourceFile = url;
    return texture;
  },
  loadCompressedTexture: function (url, mapping, onLoad, onError) {
    var texture = new THREE.CompressedTexture();
    texture.mapping = mapping;
    var request = new XMLHttpRequest();
    request.onload = function () {
      var buffer = request.response;
      var dds = THREE.ImageUtils.parseDDS(buffer, true);
      texture.format = dds.format;
      texture.mipmaps = dds.mipmaps;
      texture.image.width = dds.width;
      texture.image.height = dds.height;
      texture.generateMipmaps = false;
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture);
    };
    request.onerror = onError;
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';
    request.send(null);
    return texture;
  },
  loadTextureCube: function (array, mapping, onLoad, onError) {
    var images = [];
    images.loadCount = 0;
    var texture = new THREE.Texture();
    texture.image = images;
    if (mapping !== undefined)
      texture.mapping = mapping;
    texture.flipY = false;
    for (var i = 0, il = array.length; i < il; ++i) {
      var cubeImage = new Image();
      images[i] = cubeImage;
      cubeImage.onload = function () {
        images.loadCount += 1;
        if (images.loadCount === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      };
      cubeImage.onerror = onError;
      cubeImage.crossOrigin = this.crossOrigin;
      cubeImage.src = array[i];
    }
    return texture;
  },
  loadCompressedTextureCube: function (array, mapping, onLoad, onError) {
    var images = [];
    images.loadCount = 0;
    var texture = new THREE.CompressedTexture();
    texture.image = images;
    if (mapping !== undefined)
      texture.mapping = mapping;
    texture.flipY = false;
    texture.generateMipmaps = false;
    var generateCubeFaceCallback = function (rq, img) {
      return function () {
        var buffer = rq.response;
        var dds = THREE.ImageUtils.parseDDS(buffer, true);
        img.format = dds.format;
        img.mipmaps = dds.mipmaps;
        img.width = dds.width;
        img.height = dds.height;
        images.loadCount += 1;
        if (images.loadCount === 6) {
          texture.format = dds.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      };
    };
    if (array instanceof Array) {
      for (var i = 0, il = array.length; i < il; ++i) {
        var cubeImage = {};
        images[i] = cubeImage;
        var request = new XMLHttpRequest();
        request.onload = generateCubeFaceCallback(request, cubeImage);
        request.onerror = onError;
        var url = array[i];
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';
        request.send(null);
      }
    } else {
      var url = array;
      var request = new XMLHttpRequest();
      request.onload = function () {
        var buffer = request.response;
        var dds = THREE.ImageUtils.parseDDS(buffer, true);
        if (dds.isCubemap) {
          var faces = dds.mipmaps.length / dds.mipmapCount;
          for (var f = 0; f < faces; f++) {
            images[f] = { mipmaps: [] };
            for (var i = 0; i < dds.mipmapCount; i++) {
              images[f].mipmaps.push(dds.mipmaps[f * dds.mipmapCount + i]);
              images[f].format = dds.format;
              images[f].width = dds.width;
              images[f].height = dds.height;
            }
          }
          texture.format = dds.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      };
      request.onerror = onError;
      request.open('GET', url, true);
      request.responseType = 'arraybuffer';
      request.send(null);
    }
    return texture;
  },
  loadDDSTexture: function (url, mapping, onLoad, onError) {
    var images = [];
    images.loadCount = 0;
    var texture = new THREE.CompressedTexture();
    texture.image = images;
    if (mapping !== undefined)
      texture.mapping = mapping;
    texture.flipY = false;
    texture.generateMipmaps = false;
    {
      var request = new XMLHttpRequest();
      request.onload = function () {
        var buffer = request.response;
        var dds = THREE.ImageUtils.parseDDS(buffer, true);
        if (dds.isCubemap) {
          var faces = dds.mipmaps.length / dds.mipmapCount;
          for (var f = 0; f < faces; f++) {
            images[f] = { mipmaps: [] };
            for (var i = 0; i < dds.mipmapCount; i++) {
              images[f].mipmaps.push(dds.mipmaps[f * dds.mipmapCount + i]);
              images[f].format = dds.format;
              images[f].width = dds.width;
              images[f].height = dds.height;
            }
          }
        } else {
          texture.image.width = dds.width;
          texture.image.height = dds.height;
          texture.mipmaps = dds.mipmaps;
        }
        texture.format = dds.format;
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      };
      request.onerror = onError;
      request.open('GET', url, true);
      request.responseType = 'arraybuffer';
      request.send(null);
    }
    return texture;
  },
  parseDDS: function (buffer, loadMipmaps) {
    var dds = {
        mipmaps: [],
        width: 0,
        height: 0,
        format: null,
        mipmapCount: 1
      };
    var DDS_MAGIC = 542327876;
    var DDSD_CAPS = 1, DDSD_HEIGHT = 2, DDSD_WIDTH = 4, DDSD_PITCH = 8, DDSD_PIXELFORMAT = 4096, DDSD_MIPMAPCOUNT = 131072, DDSD_LINEARSIZE = 524288, DDSD_DEPTH = 8388608;
    var DDSCAPS_COMPLEX = 8, DDSCAPS_MIPMAP = 4194304, DDSCAPS_TEXTURE = 4096;
    var DDSCAPS2_CUBEMAP = 512, DDSCAPS2_CUBEMAP_POSITIVEX = 1024, DDSCAPS2_CUBEMAP_NEGATIVEX = 2048, DDSCAPS2_CUBEMAP_POSITIVEY = 4096, DDSCAPS2_CUBEMAP_NEGATIVEY = 8192, DDSCAPS2_CUBEMAP_POSITIVEZ = 16384, DDSCAPS2_CUBEMAP_NEGATIVEZ = 32768, DDSCAPS2_VOLUME = 2097152;
    var DDPF_ALPHAPIXELS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072;
    function fourCCToInt32(value) {
      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
    }
    function int32ToFourCC(value) {
      return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
    }
    function loadARGBMip(buffer, dataOffset, width, height) {
      var dataLength = width * height * 4;
      var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);
      var byteArray = new Uint8Array(dataLength);
      var dst = 0;
      var src = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var b = srcBuffer[src];
          src++;
          var g = srcBuffer[src];
          src++;
          var r = srcBuffer[src];
          src++;
          var a = srcBuffer[src];
          src++;
          byteArray[dst] = r;
          dst++;
          byteArray[dst] = g;
          dst++;
          byteArray[dst] = b;
          dst++;
          byteArray[dst] = a;
          dst++;
        }
      }
      return byteArray;
    }
    var FOURCC_DXT1 = fourCCToInt32('DXT1');
    var FOURCC_DXT3 = fourCCToInt32('DXT3');
    var FOURCC_DXT5 = fourCCToInt32('DXT5');
    var headerLengthInt = 31;
    var off_magic = 0;
    var off_size = 1;
    var off_flags = 2;
    var off_height = 3;
    var off_width = 4;
    var off_mipmapCount = 7;
    var off_pfFlags = 20;
    var off_pfFourCC = 21;
    var off_RGBBitCount = 22;
    var off_RBitMask = 23;
    var off_GBitMask = 24;
    var off_BBitMask = 25;
    var off_ABitMask = 26;
    var off_caps = 27;
    var off_caps2 = 28;
    var off_caps3 = 29;
    var off_caps4 = 30;
    var header = new Int32Array(buffer, 0, headerLengthInt);
    if (header[off_magic] !== DDS_MAGIC) {
      console.error('ImageUtils.parseDDS(): Invalid magic number in DDS header');
      return dds;
    }
    if (!header[off_pfFlags] & DDPF_FOURCC) {
      console.error('ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code');
      return dds;
    }
    var blockBytes;
    var fourCC = header[off_pfFourCC];
    var isRGBAUncompressed = false;
    switch (fourCC) {
    case FOURCC_DXT1:
      blockBytes = 8;
      dds.format = THREE.RGB_S3TC_DXT1_Format;
      break;
    case FOURCC_DXT3:
      blockBytes = 16;
      dds.format = THREE.RGBA_S3TC_DXT3_Format;
      break;
    case FOURCC_DXT5:
      blockBytes = 16;
      dds.format = THREE.RGBA_S3TC_DXT5_Format;
      break;
    default:
      if (header[off_RGBBitCount] == 32 && header[off_RBitMask] & 16711680 && header[off_GBitMask] & 65280 && header[off_BBitMask] & 255 && header[off_ABitMask] & 4278190080) {
        isRGBAUncompressed = true;
        blockBytes = 64;
        dds.format = THREE.RGBAFormat;
      } else {
        console.error('ImageUtils.parseDDS(): Unsupported FourCC code: ', int32ToFourCC(fourCC));
        return dds;
      }
    }
    dds.mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
      dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    dds.isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;
    dds.width = header[off_width];
    dds.height = header[off_height];
    var dataOffset = header[off_size] + 4;
    var width = dds.width;
    var height = dds.height;
    var faces = dds.isCubemap ? 6 : 1;
    for (var face = 0; face < faces; face++) {
      for (var i = 0; i < dds.mipmapCount; i++) {
        if (isRGBAUncompressed) {
          var byteArray = loadARGBMip(buffer, dataOffset, width, height);
          var dataLength = byteArray.length;
        } else {
          var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
          var byteArray = new Uint8Array(buffer, dataOffset, dataLength);
        }
        var mipmap = {
            'data': byteArray,
            'width': width,
            'height': height
          };
        dds.mipmaps.push(mipmap);
        dataOffset += dataLength;
        width = Math.max(width * 0.5, 1);
        height = Math.max(height * 0.5, 1);
      }
      width = dds.width;
      height = dds.height;
    }
    return dds;
  },
  getNormalMap: function (image, depth) {
    var cross = function (a, b) {
      return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
      ];
    };
    var subtract = function (a, b) {
      return [
        a[0] - b[0],
        a[1] - b[1],
        a[2] - b[2]
      ];
    };
    var normalize = function (a) {
      var l = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
      return [
        a[0] / l,
        a[1] / l,
        a[2] / l
      ];
    };
    depth = depth | 1;
    var width = image.width;
    var height = image.height;
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext('2d');
    context.drawImage(image, 0, 0);
    var data = context.getImageData(0, 0, width, height).data;
    var imageData = context.createImageData(width, height);
    var output = imageData.data;
    for (var x = 0; x < width; x++) {
      for (var y = 0; y < height; y++) {
        var ly = y - 1 < 0 ? 0 : y - 1;
        var uy = y + 1 > height - 1 ? height - 1 : y + 1;
        var lx = x - 1 < 0 ? 0 : x - 1;
        var ux = x + 1 > width - 1 ? width - 1 : x + 1;
        var points = [];
        var origin = [
            0,
            0,
            data[(y * width + x) * 4] / 255 * depth
          ];
        points.push([
          -1,
          0,
          data[(y * width + lx) * 4] / 255 * depth
        ]);
        points.push([
          -1,
          -1,
          data[(ly * width + lx) * 4] / 255 * depth
        ]);
        points.push([
          0,
          -1,
          data[(ly * width + x) * 4] / 255 * depth
        ]);
        points.push([
          1,
          -1,
          data[(ly * width + ux) * 4] / 255 * depth
        ]);
        points.push([
          1,
          0,
          data[(y * width + ux) * 4] / 255 * depth
        ]);
        points.push([
          1,
          1,
          data[(uy * width + ux) * 4] / 255 * depth
        ]);
        points.push([
          0,
          1,
          data[(uy * width + x) * 4] / 255 * depth
        ]);
        points.push([
          -1,
          1,
          data[(uy * width + lx) * 4] / 255 * depth
        ]);
        var normals = [];
        var num_points = points.length;
        for (var i = 0; i < num_points; i++) {
          var v1 = points[i];
          var v2 = points[(i + 1) % num_points];
          v1 = subtract(v1, origin);
          v2 = subtract(v2, origin);
          normals.push(normalize(cross(v1, v2)));
        }
        var normal = [
            0,
            0,
            0
          ];
        for (var i = 0; i < normals.length; i++) {
          normal[0] += normals[i][0];
          normal[1] += normals[i][1];
          normal[2] += normals[i][2];
        }
        normal[0] /= normals.length;
        normal[1] /= normals.length;
        normal[2] /= normals.length;
        var idx = (y * width + x) * 4;
        output[idx] = (normal[0] + 1) / 2 * 255 | 0;
        output[idx + 1] = (normal[1] + 1) / 2 * 255 | 0;
        output[idx + 2] = normal[2] * 255 | 0;
        output[idx + 3] = 255;
      }
    }
    context.putImageData(imageData, 0, 0);
    return canvas;
  },
  generateDataTexture: function (width, height, color) {
    var size = width * height;
    var data = new Uint8Array(3 * size);
    var r = Math.floor(color.r * 255);
    var g = Math.floor(color.g * 255);
    var b = Math.floor(color.b * 255);
    for (var i = 0; i < size; i++) {
      data[i * 3] = r;
      data[i * 3 + 1] = g;
      data[i * 3 + 2] = b;
    }
    var texture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);
    texture.needsUpdate = true;
    return texture;
  }
};
THREE.SceneUtils = {
  createMultiMaterialObject: function (geometry, materials) {
    var group = new THREE.Object3D();
    for (var i = 0, l = materials.length; i < l; i++) {
      group.add(new THREE.Mesh(geometry, materials[i]));
    }
    return group;
  },
  detach: function (child, parent, scene) {
    child.applyMatrix(parent.matrixWorld);
    parent.remove(child);
    scene.add(child);
  },
  attach: function (child, scene, parent) {
    var matrixWorldInverse = new THREE.Matrix4();
    matrixWorldInverse.getInverse(parent.matrixWorld);
    child.applyMatrix(matrixWorldInverse);
    scene.remove(child);
    parent.add(child);
  }
};
THREE.FontUtils = {
  faces: {},
  face: 'helvetiker',
  weight: 'normal',
  style: 'normal',
  size: 150,
  divisions: 10,
  getFace: function () {
    return this.faces[this.face][this.weight][this.style];
  },
  loadFace: function (data) {
    var family = data.familyName.toLowerCase();
    var ThreeFont = this;
    ThreeFont.faces[family] = ThreeFont.faces[family] || {};
    ThreeFont.faces[family][data.cssFontWeight] = ThreeFont.faces[family][data.cssFontWeight] || {};
    ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
    var face = ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
    return data;
  },
  drawText: function (text) {
    var characterPts = [], allPts = [];
    var i, p, face = this.getFace(), scale = this.size / face.resolution, offset = 0, chars = String(text).split(''), length = chars.length;
    var fontPaths = [];
    for (i = 0; i < length; i++) {
      var path = new THREE.Path();
      var ret = this.extractGlyphPoints(chars[i], face, scale, offset, path);
      offset += ret.offset;
      fontPaths.push(ret.path);
    }
    var width = offset / 2;
    return {
      paths: fontPaths,
      offset: width
    };
  },
  extractGlyphPoints: function (c, face, scale, offset, path) {
    var pts = [];
    var i, i2, divisions, outline, action, length, scaleX, scaleY, x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste, glyph = face.glyphs[c] || face.glyphs['?'];
    if (!glyph)
      return;
    if (glyph.o) {
      outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
      length = outline.length;
      scaleX = scale;
      scaleY = scale;
      for (i = 0; i < length;) {
        action = outline[i++];
        switch (action) {
        case 'm':
          x = outline[i++] * scaleX + offset;
          y = outline[i++] * scaleY;
          path.moveTo(x, y);
          break;
        case 'l':
          x = outline[i++] * scaleX + offset;
          y = outline[i++] * scaleY;
          path.lineTo(x, y);
          break;
        case 'q':
          cpx = outline[i++] * scaleX + offset;
          cpy = outline[i++] * scaleY;
          cpx1 = outline[i++] * scaleX + offset;
          cpy1 = outline[i++] * scaleY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          laste = pts[pts.length - 1];
          if (laste) {
            cpx0 = laste.x;
            cpy0 = laste.y;
            for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
              var t = i2 / divisions;
              var tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
              var ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
            }
          }
          break;
        case 'b':
          cpx = outline[i++] * scaleX + offset;
          cpy = outline[i++] * scaleY;
          cpx1 = outline[i++] * scaleX + offset;
          cpy1 = outline[i++] * -scaleY;
          cpx2 = outline[i++] * scaleX + offset;
          cpy2 = outline[i++] * -scaleY;
          path.bezierCurveTo(cpx, cpy, cpx1, cpy1, cpx2, cpy2);
          laste = pts[pts.length - 1];
          if (laste) {
            cpx0 = laste.x;
            cpy0 = laste.y;
            for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
              var t = i2 / divisions;
              var tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
              var ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
            }
          }
          break;
        }
      }
    }
    return {
      offset: glyph.ha * scale,
      path: path
    };
  }
};
THREE.FontUtils.generateShapes = function (text, parameters) {
  parameters = parameters || {};
  var size = parameters.size !== undefined ? parameters.size : 100;
  var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;
  var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
  var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
  var style = parameters.style !== undefined ? parameters.style : 'normal';
  THREE.FontUtils.size = size;
  THREE.FontUtils.divisions = curveSegments;
  THREE.FontUtils.face = font;
  THREE.FontUtils.weight = weight;
  THREE.FontUtils.style = style;
  var data = THREE.FontUtils.drawText(text);
  var paths = data.paths;
  var shapes = [];
  for (var p = 0, pl = paths.length; p < pl; p++) {
    Array.prototype.push.apply(shapes, paths[p].toShapes());
  }
  return shapes;
};
(function (namespace) {
  var EPSILON = 1e-10;
  var process = function (contour, indices) {
    var n = contour.length;
    if (n < 3)
      return null;
    var result = [], verts = [], vertIndices = [];
    var u, v, w;
    if (area(contour) > 0) {
      for (v = 0; v < n; v++)
        verts[v] = v;
    } else {
      for (v = 0; v < n; v++)
        verts[v] = n - 1 - v;
    }
    var nv = n;
    var count = 2 * nv;
    for (v = nv - 1; nv > 2;) {
      if (count-- <= 0) {
        console.log('Warning, unable to triangulate polygon!');
        if (indices)
          return vertIndices;
        return result;
      }
      u = v;
      if (nv <= u)
        u = 0;
      v = u + 1;
      if (nv <= v)
        v = 0;
      w = v + 1;
      if (nv <= w)
        w = 0;
      if (snip(contour, u, v, w, nv, verts)) {
        var a, b, c, s, t;
        a = verts[u];
        b = verts[v];
        c = verts[w];
        result.push([
          contour[a],
          contour[b],
          contour[c]
        ]);
        vertIndices.push([
          verts[u],
          verts[v],
          verts[w]
        ]);
        for (s = v, t = v + 1; t < nv; s++, t++) {
          verts[s] = verts[t];
        }
        nv--;
        count = 2 * nv;
      }
    }
    if (indices)
      return vertIndices;
    return result;
  };
  var area = function (contour) {
    var n = contour.length;
    var a = 0;
    for (var p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  };
  var snip = function (contour, u, v, w, n, verts) {
    var p;
    var ax, ay, bx, by;
    var cx, cy, px, py;
    ax = contour[verts[u]].x;
    ay = contour[verts[u]].y;
    bx = contour[verts[v]].x;
    by = contour[verts[v]].y;
    cx = contour[verts[w]].x;
    cy = contour[verts[w]].y;
    if (EPSILON > (bx - ax) * (cy - ay) - (by - ay) * (cx - ax))
      return false;
    var aX, aY, bX, bY, cX, cY;
    var apx, apy, bpx, bpy, cpx, cpy;
    var cCROSSap, bCROSScp, aCROSSbp;
    aX = cx - bx;
    aY = cy - by;
    bX = ax - cx;
    bY = ay - cy;
    cX = bx - ax;
    cY = by - ay;
    for (p = 0; p < n; p++) {
      if (p === u || p === v || p === w)
        continue;
      px = contour[verts[p]].x;
      py = contour[verts[p]].y;
      apx = px - ax;
      apy = py - ay;
      bpx = px - bx;
      bpy = py - by;
      cpx = px - cx;
      cpy = py - cy;
      aCROSSbp = aX * bpy - aY * bpx;
      cCROSSap = cX * apy - cY * apx;
      bCROSScp = bX * cpy - bY * cpx;
      if (aCROSSbp >= -EPSILON && bCROSScp >= -EPSILON && cCROSSap >= -EPSILON)
        return false;
    }
    return true;
  };
  namespace.Triangulate = process;
  namespace.Triangulate.area = area;
  return namespace;
}(THREE.FontUtils));
self._typeface_js = {
  faces: THREE.FontUtils.faces,
  loadFace: THREE.FontUtils.loadFace
};
THREE.typeface_js = self._typeface_js;
THREE.Curve = function () {
};
THREE.Curve.prototype.getPoint = function (t) {
  console.log('Warning, getPoint() not implemented!');
  return null;
};
THREE.Curve.prototype.getPointAt = function (u) {
  var t = this.getUtoTmapping(u);
  return this.getPoint(t);
};
THREE.Curve.prototype.getPoints = function (divisions) {
  if (!divisions)
    divisions = 5;
  var d, pts = [];
  for (d = 0; d <= divisions; d++) {
    pts.push(this.getPoint(d / divisions));
  }
  return pts;
};
THREE.Curve.prototype.getSpacedPoints = function (divisions) {
  if (!divisions)
    divisions = 5;
  var d, pts = [];
  for (d = 0; d <= divisions; d++) {
    pts.push(this.getPointAt(d / divisions));
  }
  return pts;
};
THREE.Curve.prototype.getLength = function () {
  var lengths = this.getLengths();
  return lengths[lengths.length - 1];
};
THREE.Curve.prototype.getLengths = function (divisions) {
  if (!divisions)
    divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;
  if (this.cacheArcLengths && this.cacheArcLengths.length == divisions + 1 && !this.needsUpdate) {
    return this.cacheArcLengths;
  }
  this.needsUpdate = false;
  var cache = [];
  var current, last = this.getPoint(0);
  var p, sum = 0;
  cache.push(0);
  for (p = 1; p <= divisions; p++) {
    current = this.getPoint(p / divisions);
    sum += current.distanceTo(last);
    cache.push(sum);
    last = current;
  }
  this.cacheArcLengths = cache;
  return cache;
};
THREE.Curve.prototype.updateArcLengths = function () {
  this.needsUpdate = true;
  this.getLengths();
};
THREE.Curve.prototype.getUtoTmapping = function (u, distance) {
  var arcLengths = this.getLengths();
  var i = 0, il = arcLengths.length;
  var targetArcLength;
  if (distance) {
    targetArcLength = distance;
  } else {
    targetArcLength = u * arcLengths[il - 1];
  }
  var low = 0, high = il - 1, comparison;
  while (low <= high) {
    i = Math.floor(low + (high - low) / 2);
    comparison = arcLengths[i] - targetArcLength;
    if (comparison < 0) {
      low = i + 1;
      continue;
    } else if (comparison > 0) {
      high = i - 1;
      continue;
    } else {
      high = i;
      break;
    }
  }
  i = high;
  if (arcLengths[i] == targetArcLength) {
    var t = i / (il - 1);
    return t;
  }
  var lengthBefore = arcLengths[i];
  var lengthAfter = arcLengths[i + 1];
  var segmentLength = lengthAfter - lengthBefore;
  var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
  var t = (i + segmentFraction) / (il - 1);
  return t;
};
THREE.Curve.prototype.getTangent = function (t) {
  var delta = 0.0001;
  var t1 = t - delta;
  var t2 = t + delta;
  if (t1 < 0)
    t1 = 0;
  if (t2 > 1)
    t2 = 1;
  var pt1 = this.getPoint(t1);
  var pt2 = this.getPoint(t2);
  var vec = pt2.clone().sub(pt1);
  return vec.normalize();
};
THREE.Curve.prototype.getTangentAt = function (u) {
  var t = this.getUtoTmapping(u);
  return this.getTangent(t);
};
THREE.Curve.Utils = {
  tangentQuadraticBezier: function (t, p0, p1, p2) {
    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
  },
  tangentCubicBezier: function (t, p0, p1, p2, p3) {
    return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
  },
  tangentSpline: function (t, p0, p1, p2, p3) {
    var h00 = 6 * t * t - 6 * t;
    var h10 = 3 * t * t - 4 * t + 1;
    var h01 = -6 * t * t + 6 * t;
    var h11 = 3 * t * t - 2 * t;
    return h00 + h10 + h01 + h11;
  },
  interpolate: function (p0, p1, p2, p3, t) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
};
THREE.Curve.create = function (constructor, getPointFunc) {
  constructor.prototype = Object.create(THREE.Curve.prototype);
  constructor.prototype.getPoint = getPointFunc;
  return constructor;
};
THREE.CurvePath = function () {
  this.curves = [];
  this.bends = [];
  this.autoClose = false;
};
THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
THREE.CurvePath.prototype.add = function (curve) {
  this.curves.push(curve);
};
THREE.CurvePath.prototype.checkConnection = function () {
};
THREE.CurvePath.prototype.closePath = function () {
  var startPoint = this.curves[0].getPoint(0);
  var endPoint = this.curves[this.curves.length - 1].getPoint(1);
  if (!startPoint.equals(endPoint)) {
    this.curves.push(new THREE.LineCurve(endPoint, startPoint));
  }
};
THREE.CurvePath.prototype.getPoint = function (t) {
  var d = t * this.getLength();
  var curveLengths = this.getCurveLengths();
  var i = 0, diff, curve;
  while (i < curveLengths.length) {
    if (curveLengths[i] >= d) {
      diff = curveLengths[i] - d;
      curve = this.curves[i];
      var u = 1 - diff / curve.getLength();
      return curve.getPointAt(u);
      break;
    }
    i++;
  }
  return null;
};
THREE.CurvePath.prototype.getLength = function () {
  var lens = this.getCurveLengths();
  return lens[lens.length - 1];
};
THREE.CurvePath.prototype.getCurveLengths = function () {
  if (this.cacheLengths && this.cacheLengths.length == this.curves.length) {
    return this.cacheLengths;
  }
  ;
  var lengths = [], sums = 0;
  var i, il = this.curves.length;
  for (i = 0; i < il; i++) {
    sums += this.curves[i].getLength();
    lengths.push(sums);
  }
  this.cacheLengths = lengths;
  return lengths;
};
THREE.CurvePath.prototype.getBoundingBox = function () {
  var points = this.getPoints();
  var maxX, maxY, maxZ;
  var minX, minY, minZ;
  maxX = maxY = Number.NEGATIVE_INFINITY;
  minX = minY = Number.POSITIVE_INFINITY;
  var p, i, il, sum;
  var v3 = points[0] instanceof THREE.Vector3;
  sum = v3 ? new THREE.Vector3() : new THREE.Vector2();
  for (i = 0, il = points.length; i < il; i++) {
    p = points[i];
    if (p.x > maxX)
      maxX = p.x;
    else if (p.x < minX)
      minX = p.x;
    if (p.y > maxY)
      maxY = p.y;
    else if (p.y < minY)
      minY = p.y;
    if (v3) {
      if (p.z > maxZ)
        maxZ = p.z;
      else if (p.z < minZ)
        minZ = p.z;
    }
    sum.add(p);
  }
  var ret = {
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      centroid: sum.divideScalar(il)
    };
  if (v3) {
    ret.maxZ = maxZ;
    ret.minZ = minZ;
  }
  return ret;
};
THREE.CurvePath.prototype.createPointsGeometry = function (divisions) {
  var pts = this.getPoints(divisions, true);
  return this.createGeometry(pts);
};
THREE.CurvePath.prototype.createSpacedPointsGeometry = function (divisions) {
  var pts = this.getSpacedPoints(divisions, true);
  return this.createGeometry(pts);
};
THREE.CurvePath.prototype.createGeometry = function (points) {
  var geometry = new THREE.Geometry();
  for (var i = 0; i < points.length; i++) {
    geometry.vertices.push(new THREE.Vector3(points[i].x, points[i].y, points[i].z || 0));
  }
  return geometry;
};
THREE.CurvePath.prototype.addWrapPath = function (bendpath) {
  this.bends.push(bendpath);
};
THREE.CurvePath.prototype.getTransformedPoints = function (segments, bends) {
  var oldPts = this.getPoints(segments);
  var i, il;
  if (!bends) {
    bends = this.bends;
  }
  for (i = 0, il = bends.length; i < il; i++) {
    oldPts = this.getWrapPoints(oldPts, bends[i]);
  }
  return oldPts;
};
THREE.CurvePath.prototype.getTransformedSpacedPoints = function (segments, bends) {
  var oldPts = this.getSpacedPoints(segments);
  var i, il;
  if (!bends) {
    bends = this.bends;
  }
  for (i = 0, il = bends.length; i < il; i++) {
    oldPts = this.getWrapPoints(oldPts, bends[i]);
  }
  return oldPts;
};
THREE.CurvePath.prototype.getWrapPoints = function (oldPts, path) {
  var bounds = this.getBoundingBox();
  var i, il, p, oldX, oldY, xNorm;
  for (i = 0, il = oldPts.length; i < il; i++) {
    p = oldPts[i];
    oldX = p.x;
    oldY = p.y;
    xNorm = oldX / bounds.maxX;
    xNorm = path.getUtoTmapping(xNorm, oldX);
    var pathPt = path.getPoint(xNorm);
    var normal = path.getNormalVector(xNorm).multiplyScalar(oldY);
    p.x = pathPt.x + normal.x;
    p.y = pathPt.y + normal.y;
  }
  return oldPts;
};
THREE.Gyroscope = function () {
  THREE.Object3D.call(this);
};
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld = function (force) {
  this.matrixAutoUpdate && this.updateMatrix();
  if (this.matrixWorldNeedsUpdate || force) {
    if (this.parent) {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld);
      this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject);
      this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld);
    } else {
      this.matrixWorld.copy(this.matrix);
    }
    this.matrixWorldNeedsUpdate = false;
    force = true;
  }
  for (var i = 0, l = this.children.length; i < l; i++) {
    this.children[i].updateMatrixWorld(force);
  }
};
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();
THREE.Path = function (points) {
  THREE.CurvePath.call(this);
  this.actions = [];
  if (points) {
    this.fromPoints(points);
  }
};
THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
THREE.PathActions = {
  MOVE_TO: 'moveTo',
  LINE_TO: 'lineTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo',
  BEZIER_CURVE_TO: 'bezierCurveTo',
  CSPLINE_THRU: 'splineThru',
  ARC: 'arc',
  ELLIPSE: 'ellipse'
};
THREE.Path.prototype.fromPoints = function (vectors) {
  this.moveTo(vectors[0].x, vectors[0].y);
  for (var v = 1, vlen = vectors.length; v < vlen; v++) {
    this.lineTo(vectors[v].x, vectors[v].y);
  }
  ;
};
THREE.Path.prototype.moveTo = function (x, y) {
  var args = Array.prototype.slice.call(arguments);
  this.actions.push({
    action: THREE.PathActions.MOVE_TO,
    args: args
  });
};
THREE.Path.prototype.lineTo = function (x, y) {
  var args = Array.prototype.slice.call(arguments);
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));
  this.curves.push(curve);
  this.actions.push({
    action: THREE.PathActions.LINE_TO,
    args: args
  });
};
THREE.Path.prototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
  var args = Array.prototype.slice.call(arguments);
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
  this.curves.push(curve);
  this.actions.push({
    action: THREE.PathActions.QUADRATIC_CURVE_TO,
    args: args
  });
};
THREE.Path.prototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
  var args = Array.prototype.slice.call(arguments);
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
  this.curves.push(curve);
  this.actions.push({
    action: THREE.PathActions.BEZIER_CURVE_TO,
    args: args
  });
};
THREE.Path.prototype.splineThru = function (pts) {
  var args = Array.prototype.slice.call(arguments);
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  var npts = [new THREE.Vector2(x0, y0)];
  Array.prototype.push.apply(npts, pts);
  var curve = new THREE.SplineCurve(npts);
  this.curves.push(curve);
  this.actions.push({
    action: THREE.PathActions.CSPLINE_THRU,
    args: args
  });
};
THREE.Path.prototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
};
THREE.Path.prototype.absarc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
};
THREE.Path.prototype.ellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
};
THREE.Path.prototype.absellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
  var args = Array.prototype.slice.call(arguments);
  var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
  this.curves.push(curve);
  var lastPoint = curve.getPoint(1);
  args.push(lastPoint.x);
  args.push(lastPoint.y);
  this.actions.push({
    action: THREE.PathActions.ELLIPSE,
    args: args
  });
};
THREE.Path.prototype.getSpacedPoints = function (divisions, closedPath) {
  if (!divisions)
    divisions = 40;
  var points = [];
  for (var i = 0; i < divisions; i++) {
    points.push(this.getPoint(i / divisions));
  }
  return points;
};
THREE.Path.prototype.getPoints = function (divisions, closedPath) {
  if (this.useSpacedPoints) {
    console.log('tata');
    return this.getSpacedPoints(divisions, closedPath);
  }
  divisions = divisions || 12;
  var points = [];
  var i, il, item, action, args;
  var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0, laste, j, t, tx, ty;
  for (i = 0, il = this.actions.length; i < il; i++) {
    item = this.actions[i];
    action = item.action;
    args = item.args;
    switch (action) {
    case THREE.PathActions.MOVE_TO:
      points.push(new THREE.Vector2(args[0], args[1]));
      break;
    case THREE.PathActions.LINE_TO:
      points.push(new THREE.Vector2(args[0], args[1]));
      break;
    case THREE.PathActions.QUADRATIC_CURVE_TO:
      cpx = args[2];
      cpy = args[3];
      cpx1 = args[0];
      cpy1 = args[1];
      if (points.length > 0) {
        laste = points[points.length - 1];
        cpx0 = laste.x;
        cpy0 = laste.y;
      } else {
        laste = this.actions[i - 1].args;
        cpx0 = laste[laste.length - 2];
        cpy0 = laste[laste.length - 1];
      }
      for (j = 1; j <= divisions; j++) {
        t = j / divisions;
        tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
        ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
        points.push(new THREE.Vector2(tx, ty));
      }
      break;
    case THREE.PathActions.BEZIER_CURVE_TO:
      cpx = args[4];
      cpy = args[5];
      cpx1 = args[0];
      cpy1 = args[1];
      cpx2 = args[2];
      cpy2 = args[3];
      if (points.length > 0) {
        laste = points[points.length - 1];
        cpx0 = laste.x;
        cpy0 = laste.y;
      } else {
        laste = this.actions[i - 1].args;
        cpx0 = laste[laste.length - 2];
        cpy0 = laste[laste.length - 1];
      }
      for (j = 1; j <= divisions; j++) {
        t = j / divisions;
        tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
        ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
        points.push(new THREE.Vector2(tx, ty));
      }
      break;
    case THREE.PathActions.CSPLINE_THRU:
      laste = this.actions[i - 1].args;
      var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);
      var spts = [last];
      var n = divisions * args[0].length;
      spts = spts.concat(args[0]);
      var spline = new THREE.SplineCurve(spts);
      for (j = 1; j <= n; j++) {
        points.push(spline.getPointAt(j / n));
      }
      break;
    case THREE.PathActions.ARC:
      var aX = args[0], aY = args[1], aRadius = args[2], aStartAngle = args[3], aEndAngle = args[4], aClockwise = !!args[5];
      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;
      for (j = 1; j <= tdivisions; j++) {
        t = j / tdivisions;
        if (!aClockwise) {
          t = 1 - t;
        }
        angle = aStartAngle + t * deltaAngle;
        tx = aX + aRadius * Math.cos(angle);
        ty = aY + aRadius * Math.sin(angle);
        points.push(new THREE.Vector2(tx, ty));
      }
      break;
    case THREE.PathActions.ELLIPSE:
      var aX = args[0], aY = args[1], xRadius = args[2], yRadius = args[3], aStartAngle = args[4], aEndAngle = args[5], aClockwise = !!args[6];
      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;
      for (j = 1; j <= tdivisions; j++) {
        t = j / tdivisions;
        if (!aClockwise) {
          t = 1 - t;
        }
        angle = aStartAngle + t * deltaAngle;
        tx = aX + xRadius * Math.cos(angle);
        ty = aY + yRadius * Math.sin(angle);
        points.push(new THREE.Vector2(tx, ty));
      }
      break;
    }
  }
  var lastPoint = points[points.length - 1];
  var EPSILON = 1e-10;
  if (Math.abs(lastPoint.x - points[0].x) < EPSILON && Math.abs(lastPoint.y - points[0].y) < EPSILON)
    points.splice(points.length - 1, 1);
  if (closedPath) {
    points.push(points[0]);
  }
  return points;
};
THREE.Path.prototype.toShapes = function (isCCW) {
  var i, il, item, action, args;
  var subPaths = [], lastPath = new THREE.Path();
  for (i = 0, il = this.actions.length; i < il; i++) {
    item = this.actions[i];
    args = item.args;
    action = item.action;
    if (action == THREE.PathActions.MOVE_TO) {
      if (lastPath.actions.length != 0) {
        subPaths.push(lastPath);
        lastPath = new THREE.Path();
      }
    }
    lastPath[action].apply(lastPath, args);
  }
  if (lastPath.actions.length != 0) {
    subPaths.push(lastPath);
  }
  if (subPaths.length == 0)
    return [];
  var solid, tmpPath, tmpShape, shapes = [];
  if (subPaths.length == 1) {
    tmpPath = subPaths[0];
    tmpShape = new THREE.Shape();
    tmpShape.actions = tmpPath.actions;
    tmpShape.curves = tmpPath.curves;
    shapes.push(tmpShape);
    return shapes;
  }
  var holesFirst = !THREE.Shape.Utils.isClockWise(subPaths[0].getPoints());
  holesFirst = isCCW ? !holesFirst : holesFirst;
  if (holesFirst) {
    tmpShape = new THREE.Shape();
    for (i = 0, il = subPaths.length; i < il; i++) {
      tmpPath = subPaths[i];
      solid = THREE.Shape.Utils.isClockWise(tmpPath.getPoints());
      solid = isCCW ? !solid : solid;
      if (solid) {
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        tmpShape = new THREE.Shape();
      } else {
        tmpShape.holes.push(tmpPath);
      }
    }
  } else {
    tmpShape = undefined;
    for (i = 0, il = subPaths.length; i < il; i++) {
      tmpPath = subPaths[i];
      solid = THREE.Shape.Utils.isClockWise(tmpPath.getPoints());
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (tmpShape)
          shapes.push(tmpShape);
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
      } else {
        tmpShape.holes.push(tmpPath);
      }
    }
    shapes.push(tmpShape);
  }
  return shapes;
};
THREE.Shape = function () {
  THREE.Path.apply(this, arguments);
  this.holes = [];
};
THREE.Shape.prototype = Object.create(THREE.Path.prototype);
THREE.Shape.prototype.extrude = function (options) {
  var extruded = new THREE.ExtrudeGeometry(this, options);
  return extruded;
};
THREE.Shape.prototype.makeGeometry = function (options) {
  var geometry = new THREE.ShapeGeometry(this, options);
  return geometry;
};
THREE.Shape.prototype.getPointsHoles = function (divisions) {
  var i, il = this.holes.length, holesPts = [];
  for (i = 0; i < il; i++) {
    holesPts[i] = this.holes[i].getTransformedPoints(divisions, this.bends);
  }
  return holesPts;
};
THREE.Shape.prototype.getSpacedPointsHoles = function (divisions) {
  var i, il = this.holes.length, holesPts = [];
  for (i = 0; i < il; i++) {
    holesPts[i] = this.holes[i].getTransformedSpacedPoints(divisions, this.bends);
  }
  return holesPts;
};
THREE.Shape.prototype.extractAllPoints = function (divisions) {
  return {
    shape: this.getTransformedPoints(divisions),
    holes: this.getPointsHoles(divisions)
  };
};
THREE.Shape.prototype.extractPoints = function (divisions) {
  if (this.useSpacedPoints) {
    return this.extractAllSpacedPoints(divisions);
  }
  return this.extractAllPoints(divisions);
};
THREE.Shape.prototype.extractAllSpacedPoints = function (divisions) {
  return {
    shape: this.getTransformedSpacedPoints(divisions),
    holes: this.getSpacedPointsHoles(divisions)
  };
};
THREE.Shape.Utils = {
  removeHoles: function (contour, holes) {
    var shape = contour.concat();
    var allpoints = shape.concat();
    var prevShapeVert, nextShapeVert, prevHoleVert, nextHoleVert, holeIndex, shapeIndex, shapeId, shapeGroup, h, h2, hole, shortest, d, p, pts1, pts2, tmpShape1, tmpShape2, tmpHole1, tmpHole2, verts = [];
    for (h = 0; h < holes.length; h++) {
      hole = holes[h];
      Array.prototype.push.apply(allpoints, hole);
      shortest = Number.POSITIVE_INFINITY;
      for (h2 = 0; h2 < hole.length; h2++) {
        pts1 = hole[h2];
        var dist = [];
        for (p = 0; p < shape.length; p++) {
          pts2 = shape[p];
          d = pts1.distanceToSquared(pts2);
          dist.push(d);
          if (d < shortest) {
            shortest = d;
            holeIndex = h2;
            shapeIndex = p;
          }
        }
      }
      prevShapeVert = shapeIndex - 1 >= 0 ? shapeIndex - 1 : shape.length - 1;
      prevHoleVert = holeIndex - 1 >= 0 ? holeIndex - 1 : hole.length - 1;
      var areaapts = [
          hole[holeIndex],
          shape[shapeIndex],
          shape[prevShapeVert]
        ];
      var areaa = THREE.FontUtils.Triangulate.area(areaapts);
      var areabpts = [
          hole[holeIndex],
          hole[prevHoleVert],
          shape[shapeIndex]
        ];
      var areab = THREE.FontUtils.Triangulate.area(areabpts);
      var shapeOffset = 1;
      var holeOffset = -1;
      var oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;
      shapeIndex += shapeOffset;
      holeIndex += holeOffset;
      if (shapeIndex < 0) {
        shapeIndex += shape.length;
      }
      shapeIndex %= shape.length;
      if (holeIndex < 0) {
        holeIndex += hole.length;
      }
      holeIndex %= hole.length;
      prevShapeVert = shapeIndex - 1 >= 0 ? shapeIndex - 1 : shape.length - 1;
      prevHoleVert = holeIndex - 1 >= 0 ? holeIndex - 1 : hole.length - 1;
      areaapts = [
        hole[holeIndex],
        shape[shapeIndex],
        shape[prevShapeVert]
      ];
      var areaa2 = THREE.FontUtils.Triangulate.area(areaapts);
      areabpts = [
        hole[holeIndex],
        hole[prevHoleVert],
        shape[shapeIndex]
      ];
      var areab2 = THREE.FontUtils.Triangulate.area(areabpts);
      if (areaa + areab > areaa2 + areab2) {
        shapeIndex = oldShapeIndex;
        holeIndex = oldHoleIndex;
        if (shapeIndex < 0) {
          shapeIndex += shape.length;
        }
        shapeIndex %= shape.length;
        if (holeIndex < 0) {
          holeIndex += hole.length;
        }
        holeIndex %= hole.length;
        prevShapeVert = shapeIndex - 1 >= 0 ? shapeIndex - 1 : shape.length - 1;
        prevHoleVert = holeIndex - 1 >= 0 ? holeIndex - 1 : hole.length - 1;
      } else {
      }
      tmpShape1 = shape.slice(0, shapeIndex);
      tmpShape2 = shape.slice(shapeIndex);
      tmpHole1 = hole.slice(holeIndex);
      tmpHole2 = hole.slice(0, holeIndex);
      var trianglea = [
          hole[holeIndex],
          shape[shapeIndex],
          shape[prevShapeVert]
        ];
      var triangleb = [
          hole[holeIndex],
          hole[prevHoleVert],
          shape[shapeIndex]
        ];
      verts.push(trianglea);
      verts.push(triangleb);
      shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
    }
    return {
      shape: shape,
      isolatedPts: verts,
      allpoints: allpoints
    };
  },
  triangulateShape: function (contour, holes) {
    var shapeWithoutHoles = THREE.Shape.Utils.removeHoles(contour, holes);
    var shape = shapeWithoutHoles.shape, allpoints = shapeWithoutHoles.allpoints, isolatedPts = shapeWithoutHoles.isolatedPts;
    var triangles = THREE.FontUtils.Triangulate(shape, false);
    var i, il, f, face, key, index, allPointsMap = {}, isolatedPointsMap = {};
    for (i = 0, il = allpoints.length; i < il; i++) {
      key = allpoints[i].x + ':' + allpoints[i].y;
      if (allPointsMap[key] !== undefined) {
        console.log('Duplicate point', key);
      }
      allPointsMap[key] = i;
    }
    for (i = 0, il = triangles.length; i < il; i++) {
      face = triangles[i];
      for (f = 0; f < 3; f++) {
        key = face[f].x + ':' + face[f].y;
        index = allPointsMap[key];
        if (index !== undefined) {
          face[f] = index;
        }
      }
    }
    for (i = 0, il = isolatedPts.length; i < il; i++) {
      face = isolatedPts[i];
      for (f = 0; f < 3; f++) {
        key = face[f].x + ':' + face[f].y;
        index = allPointsMap[key];
        if (index !== undefined) {
          face[f] = index;
        }
      }
    }
    return triangles.concat(isolatedPts);
  },
  isClockWise: function (pts) {
    return THREE.FontUtils.Triangulate.area(pts) < 0;
  },
  b2p0: function (t, p) {
    var k = 1 - t;
    return k * k * p;
  },
  b2p1: function (t, p) {
    return 2 * (1 - t) * t * p;
  },
  b2p2: function (t, p) {
    return t * t * p;
  },
  b2: function (t, p0, p1, p2) {
    return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);
  },
  b3p0: function (t, p) {
    var k = 1 - t;
    return k * k * k * p;
  },
  b3p1: function (t, p) {
    var k = 1 - t;
    return 3 * k * k * t * p;
  },
  b3p2: function (t, p) {
    var k = 1 - t;
    return 3 * k * t * t * p;
  },
  b3p3: function (t, p) {
    return t * t * t * p;
  },
  b3: function (t, p0, p1, p2, p3) {
    return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);
  }
};
THREE.LineCurve = function (v1, v2) {
  this.v1 = v1;
  this.v2 = v2;
};
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.LineCurve.prototype.getPoint = function (t) {
  var point = this.v2.clone().sub(this.v1);
  point.multiplyScalar(t).add(this.v1);
  return point;
};
THREE.LineCurve.prototype.getPointAt = function (u) {
  return this.getPoint(u);
};
THREE.LineCurve.prototype.getTangent = function (t) {
  var tangent = this.v2.clone().sub(this.v1);
  return tangent.normalize();
};
THREE.QuadraticBezierCurve = function (v0, v1, v2) {
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
};
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.getPoint = function (t) {
  var tx, ty;
  tx = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
  ty = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
  return new THREE.Vector2(tx, ty);
};
THREE.QuadraticBezierCurve.prototype.getTangent = function (t) {
  var tx, ty;
  tx = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x);
  ty = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y);
  var tangent = new THREE.Vector2(tx, ty);
  tangent.normalize();
  return tangent;
};
THREE.CubicBezierCurve = function (v0, v1, v2, v3) {
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;
};
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.CubicBezierCurve.prototype.getPoint = function (t) {
  var tx, ty;
  tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  return new THREE.Vector2(tx, ty);
};
THREE.CubicBezierCurve.prototype.getTangent = function (t) {
  var tx, ty;
  tx = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  ty = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  var tangent = new THREE.Vector2(tx, ty);
  tangent.normalize();
  return tangent;
};
THREE.SplineCurve = function (points) {
  this.points = points == undefined ? [] : points;
};
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.getPoint = function (t) {
  var v = new THREE.Vector2();
  var c = [];
  var points = this.points, point, intPoint, weight;
  point = (points.length - 1) * t;
  intPoint = Math.floor(point);
  weight = point - intPoint;
  c[0] = intPoint == 0 ? intPoint : intPoint - 1;
  c[1] = intPoint;
  c[2] = intPoint > points.length - 2 ? points.length - 1 : intPoint + 1;
  c[3] = intPoint > points.length - 3 ? points.length - 1 : intPoint + 2;
  v.x = THREE.Curve.Utils.interpolate(points[c[0]].x, points[c[1]].x, points[c[2]].x, points[c[3]].x, weight);
  v.y = THREE.Curve.Utils.interpolate(points[c[0]].y, points[c[1]].y, points[c[2]].y, points[c[3]].y, weight);
  return v;
};
THREE.EllipseCurve = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
  this.aX = aX;
  this.aY = aY;
  this.xRadius = xRadius;
  this.yRadius = yRadius;
  this.aStartAngle = aStartAngle;
  this.aEndAngle = aEndAngle;
  this.aClockwise = aClockwise;
};
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.getPoint = function (t) {
  var angle;
  var deltaAngle = this.aEndAngle - this.aStartAngle;
  if (deltaAngle < 0)
    deltaAngle += Math.PI * 2;
  if (deltaAngle > Math.PI * 2)
    deltaAngle -= Math.PI * 2;
  if (this.aClockwise === true) {
    angle = this.aEndAngle + (1 - t) * (Math.PI * 2 - deltaAngle);
  } else {
    angle = this.aStartAngle + t * deltaAngle;
  }
  var tx = this.aX + this.xRadius * Math.cos(angle);
  var ty = this.aY + this.yRadius * Math.sin(angle);
  return new THREE.Vector2(tx, ty);
};
THREE.ArcCurve = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
};
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
THREE.LineCurve3 = THREE.Curve.create(function (v1, v2) {
  this.v1 = v1;
  this.v2 = v2;
}, function (t) {
  var r = new THREE.Vector3();
  r.subVectors(this.v2, this.v1);
  r.multiplyScalar(t);
  r.add(this.v1);
  return r;
});
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (v0, v1, v2) {
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
}, function (t) {
  var tx, ty, tz;
  tx = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
  ty = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
  tz = THREE.Shape.Utils.b2(t, this.v0.z, this.v1.z, this.v2.z);
  return new THREE.Vector3(tx, ty, tz);
});
THREE.CubicBezierCurve3 = THREE.Curve.create(function (v0, v1, v2, v3) {
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;
}, function (t) {
  var tx, ty, tz;
  tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  tz = THREE.Shape.Utils.b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
  return new THREE.Vector3(tx, ty, tz);
});
THREE.SplineCurve3 = THREE.Curve.create(function (points) {
  this.points = points == undefined ? [] : points;
}, function (t) {
  var v = new THREE.Vector3();
  var c = [];
  var points = this.points, point, intPoint, weight;
  point = (points.length - 1) * t;
  intPoint = Math.floor(point);
  weight = point - intPoint;
  c[0] = intPoint == 0 ? intPoint : intPoint - 1;
  c[1] = intPoint;
  c[2] = intPoint > points.length - 2 ? points.length - 1 : intPoint + 1;
  c[3] = intPoint > points.length - 3 ? points.length - 1 : intPoint + 2;
  var pt0 = points[c[0]], pt1 = points[c[1]], pt2 = points[c[2]], pt3 = points[c[3]];
  v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);
  v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);
  v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);
  return v;
});
THREE.ClosedSplineCurve3 = THREE.Curve.create(function (points) {
  this.points = points == undefined ? [] : points;
}, function (t) {
  var v = new THREE.Vector3();
  var c = [];
  var points = this.points, point, intPoint, weight;
  point = (points.length - 0) * t;
  intPoint = Math.floor(point);
  weight = point - intPoint;
  intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
  c[0] = (intPoint - 1) % points.length;
  c[1] = intPoint % points.length;
  c[2] = (intPoint + 1) % points.length;
  c[3] = (intPoint + 2) % points.length;
  v.x = THREE.Curve.Utils.interpolate(points[c[0]].x, points[c[1]].x, points[c[2]].x, points[c[3]].x, weight);
  v.y = THREE.Curve.Utils.interpolate(points[c[0]].y, points[c[1]].y, points[c[2]].y, points[c[3]].y, weight);
  v.z = THREE.Curve.Utils.interpolate(points[c[0]].z, points[c[1]].z, points[c[2]].z, points[c[3]].z, weight);
  return v;
});
THREE.AnimationHandler = function () {
  var playing = [];
  var library = {};
  var that = {};
  that.update = function (deltaTimeMS) {
    for (var i = 0; i < playing.length; i++)
      playing[i].update(deltaTimeMS);
  };
  that.addToUpdate = function (animation) {
    if (playing.indexOf(animation) === -1)
      playing.push(animation);
  };
  that.removeFromUpdate = function (animation) {
    var index = playing.indexOf(animation);
    if (index !== -1)
      playing.splice(index, 1);
  };
  that.add = function (data) {
    if (library[data.name] !== undefined)
      console.log('THREE.AnimationHandler.add: Warning! ' + data.name + ' already exists in library. Overwriting.');
    library[data.name] = data;
    initData(data);
  };
  that.get = function (name) {
    if (typeof name === 'string') {
      if (library[name]) {
        return library[name];
      } else {
        console.log('THREE.AnimationHandler.get: Couldn\'t find animation ' + name);
        return null;
      }
    } else {
    }
  };
  that.parse = function (root) {
    var hierarchy = [];
    if (root instanceof THREE.SkinnedMesh) {
      for (var b = 0; b < root.bones.length; b++) {
        hierarchy.push(root.bones[b]);
      }
    } else {
      parseRecurseHierarchy(root, hierarchy);
    }
    return hierarchy;
  };
  var parseRecurseHierarchy = function (root, hierarchy) {
    hierarchy.push(root);
    for (var c = 0; c < root.children.length; c++)
      parseRecurseHierarchy(root.children[c], hierarchy);
  };
  var initData = function (data) {
    if (data.initialized === true)
      return;
    for (var h = 0; h < data.hierarchy.length; h++) {
      for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
        if (data.hierarchy[h].keys[k].time < 0)
          data.hierarchy[h].keys[k].time = 0;
        if (data.hierarchy[h].keys[k].rot !== undefined && !(data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {
          var quat = data.hierarchy[h].keys[k].rot;
          data.hierarchy[h].keys[k].rot = new THREE.Quaternion(quat[0], quat[1], quat[2], quat[3]);
        }
      }
      if (data.hierarchy[h].keys.length && data.hierarchy[h].keys[0].morphTargets !== undefined) {
        var usedMorphTargets = {};
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
          for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
            var morphTargetName = data.hierarchy[h].keys[k].morphTargets[m];
            usedMorphTargets[morphTargetName] = -1;
          }
        }
        data.hierarchy[h].usedMorphTargets = usedMorphTargets;
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
          var influences = {};
          for (var morphTargetName in usedMorphTargets) {
            for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
              if (data.hierarchy[h].keys[k].morphTargets[m] === morphTargetName) {
                influences[morphTargetName] = data.hierarchy[h].keys[k].morphTargetsInfluences[m];
                break;
              }
            }
            if (m === data.hierarchy[h].keys[k].morphTargets.length) {
              influences[morphTargetName] = 0;
            }
          }
          data.hierarchy[h].keys[k].morphTargetsInfluences = influences;
        }
      }
      for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
        if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
          data.hierarchy[h].keys.splice(k, 1);
          k--;
        }
      }
      for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
        data.hierarchy[h].keys[k].index = k;
      }
    }
    var lengthInFrames = parseInt(data.length * data.fps, 10);
    data.JIT = {};
    data.JIT.hierarchy = [];
    for (var h = 0; h < data.hierarchy.length; h++)
      data.JIT.hierarchy.push(new Array(lengthInFrames));
    data.initialized = true;
  };
  that.LINEAR = 0;
  that.CATMULLROM = 1;
  that.CATMULLROM_FORWARD = 2;
  return that;
}();
THREE.Animation = function (root, name, interpolationType) {
  this.root = root;
  this.data = THREE.AnimationHandler.get(name);
  this.hierarchy = THREE.AnimationHandler.parse(root);
  this.currentTime = 0;
  this.timeScale = 1;
  this.isPlaying = false;
  this.isPaused = true;
  this.loop = true;
  this.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;
  this.points = [];
  this.target = new THREE.Vector3();
};
THREE.Animation.prototype.play = function (loop, startTimeMS) {
  if (this.isPlaying === false) {
    this.isPlaying = true;
    this.loop = loop !== undefined ? loop : true;
    this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
    var h, hl = this.hierarchy.length, object;
    for (h = 0; h < hl; h++) {
      object = this.hierarchy[h];
      object.matrixAutoUpdate = true;
      if (object.animationCache === undefined) {
        object.animationCache = {};
        object.animationCache.prevKey = {
          pos: 0,
          rot: 0,
          scl: 0
        };
        object.animationCache.nextKey = {
          pos: 0,
          rot: 0,
          scl: 0
        };
        object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;
      }
      var prevKey = object.animationCache.prevKey;
      var nextKey = object.animationCache.nextKey;
      prevKey.pos = this.data.hierarchy[h].keys[0];
      prevKey.rot = this.data.hierarchy[h].keys[0];
      prevKey.scl = this.data.hierarchy[h].keys[0];
      nextKey.pos = this.getNextKeyWith('pos', h, 1);
      nextKey.rot = this.getNextKeyWith('rot', h, 1);
      nextKey.scl = this.getNextKeyWith('scl', h, 1);
    }
    this.update(0);
  }
  this.isPaused = false;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.Animation.prototype.pause = function () {
  if (this.isPaused === true) {
    THREE.AnimationHandler.addToUpdate(this);
  } else {
    THREE.AnimationHandler.removeFromUpdate(this);
  }
  this.isPaused = !this.isPaused;
};
THREE.Animation.prototype.stop = function () {
  this.isPlaying = false;
  this.isPaused = false;
  THREE.AnimationHandler.removeFromUpdate(this);
};
THREE.Animation.prototype.update = function (deltaTimeMS) {
  if (this.isPlaying === false)
    return;
  var types = [
      'pos',
      'rot',
      'scl'
    ];
  var type;
  var scale;
  var vector;
  var prevXYZ, nextXYZ;
  var prevKey, nextKey;
  var object;
  var animationCache;
  var frame;
  var JIThierarchy = this.data.JIT.hierarchy;
  var currentTime, unloopedCurrentTime;
  var currentPoint, forwardPoint, angle;
  this.currentTime += deltaTimeMS * this.timeScale;
  unloopedCurrentTime = this.currentTime;
  currentTime = this.currentTime = this.currentTime % this.data.length;
  frame = parseInt(Math.min(currentTime * this.data.fps, this.data.length * this.data.fps), 10);
  for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
    object = this.hierarchy[h];
    animationCache = object.animationCache;
    for (var t = 0; t < 3; t++) {
      type = types[t];
      prevKey = animationCache.prevKey[type];
      nextKey = animationCache.nextKey[type];
      if (nextKey.time <= unloopedCurrentTime) {
        if (currentTime < unloopedCurrentTime) {
          if (this.loop) {
            prevKey = this.data.hierarchy[h].keys[0];
            nextKey = this.getNextKeyWith(type, h, 1);
            while (nextKey.time < currentTime) {
              prevKey = nextKey;
              nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
            }
          } else {
            this.stop();
            return;
          }
        } else {
          do {
            prevKey = nextKey;
            nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
          } while (nextKey.time < currentTime);
        }
        animationCache.prevKey[type] = prevKey;
        animationCache.nextKey[type] = nextKey;
      }
      object.matrixAutoUpdate = true;
      object.matrixWorldNeedsUpdate = true;
      scale = (currentTime - prevKey.time) / (nextKey.time - prevKey.time);
      prevXYZ = prevKey[type];
      nextXYZ = nextKey[type];
      if (scale < 0 || scale > 1) {
        console.log('THREE.Animation.update: Warning! Scale out of bounds:' + scale + ' on bone ' + h);
        scale = scale < 0 ? 0 : 1;
      }
      if (type === 'pos') {
        vector = object.position;
        if (this.interpolationType === THREE.AnimationHandler.LINEAR) {
          vector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
          vector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
          vector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
        } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
          this.points[0] = this.getPrevKeyWith('pos', h, prevKey.index - 1)['pos'];
          this.points[1] = prevXYZ;
          this.points[2] = nextXYZ;
          this.points[3] = this.getNextKeyWith('pos', h, nextKey.index + 1)['pos'];
          scale = scale * 0.33 + 0.33;
          currentPoint = this.interpolateCatmullRom(this.points, scale);
          vector.x = currentPoint[0];
          vector.y = currentPoint[1];
          vector.z = currentPoint[2];
          if (this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
            forwardPoint = this.interpolateCatmullRom(this.points, scale * 1.01);
            this.target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
            this.target.sub(vector);
            this.target.y = 0;
            this.target.normalize();
            angle = Math.atan2(this.target.x, this.target.z);
            object.rotation.set(0, angle, 0);
          }
        }
      } else if (type === 'rot') {
        THREE.Quaternion.slerp(prevXYZ, nextXYZ, object.quaternion, scale);
      } else if (type === 'scl') {
        vector = object.scale;
        vector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
        vector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
        vector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
      }
    }
  }
};
THREE.Animation.prototype.interpolateCatmullRom = function (points, scale) {
  var c = [], v3 = [], point, intPoint, weight, w2, w3, pa, pb, pc, pd;
  point = (points.length - 1) * scale;
  intPoint = Math.floor(point);
  weight = point - intPoint;
  c[0] = intPoint === 0 ? intPoint : intPoint - 1;
  c[1] = intPoint;
  c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
  c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
  pa = points[c[0]];
  pb = points[c[1]];
  pc = points[c[2]];
  pd = points[c[3]];
  w2 = weight * weight;
  w3 = weight * w2;
  v3[0] = this.interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);
  v3[1] = this.interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);
  v3[2] = this.interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);
  return v3;
};
THREE.Animation.prototype.interpolate = function (p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
};
THREE.Animation.prototype.getNextKeyWith = function (type, h, key) {
  var keys = this.data.hierarchy[h].keys;
  if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
    key = key < keys.length - 1 ? key : keys.length - 1;
  } else {
    key = key % keys.length;
  }
  for (; key < keys.length; key++) {
    if (keys[key][type] !== undefined) {
      return keys[key];
    }
  }
  return this.data.hierarchy[h].keys[0];
};
THREE.Animation.prototype.getPrevKeyWith = function (type, h, key) {
  var keys = this.data.hierarchy[h].keys;
  if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
    key = key > 0 ? key : 0;
  } else {
    key = key >= 0 ? key : key + keys.length;
  }
  for (; key >= 0; key--) {
    if (keys[key][type] !== undefined) {
      return keys[key];
    }
  }
  return this.data.hierarchy[h].keys[keys.length - 1];
};
THREE.KeyFrameAnimation = function (root, data, JITCompile) {
  this.root = root;
  this.data = THREE.AnimationHandler.get(data);
  this.hierarchy = THREE.AnimationHandler.parse(root);
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = false;
  this.isPaused = true;
  this.loop = true;
  this.JITCompile = JITCompile !== undefined ? JITCompile : true;
  for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
    var keys = this.data.hierarchy[h].keys, sids = this.data.hierarchy[h].sids, obj = this.hierarchy[h];
    if (keys.length && sids) {
      for (var s = 0; s < sids.length; s++) {
        var sid = sids[s], next = this.getNextKeyWith(sid, h, 0);
        if (next) {
          next.apply(sid);
        }
      }
      obj.matrixAutoUpdate = false;
      this.data.hierarchy[h].node.updateMatrix();
      obj.matrixWorldNeedsUpdate = true;
    }
  }
};
THREE.KeyFrameAnimation.prototype.play = function (loop, startTimeMS) {
  if (!this.isPlaying) {
    this.isPlaying = true;
    this.loop = loop !== undefined ? loop : true;
    this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
    this.startTimeMs = startTimeMS;
    this.startTime = 10000000;
    this.endTime = -this.startTime;
    var h, hl = this.hierarchy.length, object, node;
    for (h = 0; h < hl; h++) {
      object = this.hierarchy[h];
      node = this.data.hierarchy[h];
      if (node.animationCache === undefined) {
        node.animationCache = {};
        node.animationCache.prevKey = null;
        node.animationCache.nextKey = null;
        node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;
      }
      var keys = this.data.hierarchy[h].keys;
      if (keys.length) {
        node.animationCache.prevKey = keys[0];
        node.animationCache.nextKey = keys[1];
        this.startTime = Math.min(keys[0].time, this.startTime);
        this.endTime = Math.max(keys[keys.length - 1].time, this.endTime);
      }
    }
    this.update(0);
  }
  this.isPaused = false;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.KeyFrameAnimation.prototype.pause = function () {
  if (this.isPaused) {
    THREE.AnimationHandler.addToUpdate(this);
  } else {
    THREE.AnimationHandler.removeFromUpdate(this);
  }
  this.isPaused = !this.isPaused;
};
THREE.KeyFrameAnimation.prototype.stop = function () {
  this.isPlaying = false;
  this.isPaused = false;
  THREE.AnimationHandler.removeFromUpdate(this);
  for (var h = 0; h < this.data.hierarchy.length; h++) {
    var obj = this.hierarchy[h];
    var node = this.data.hierarchy[h];
    if (node.animationCache !== undefined) {
      var original = node.animationCache.originalMatrix;
      if (obj instanceof THREE.Bone) {
        original.copy(obj.skinMatrix);
        obj.skinMatrix = original;
      } else {
        original.copy(obj.matrix);
        obj.matrix = original;
      }
      delete node.animationCache;
    }
  }
};
THREE.KeyFrameAnimation.prototype.update = function (deltaTimeMS) {
  if (!this.isPlaying)
    return;
  var prevKey, nextKey;
  var object;
  var node;
  var frame;
  var JIThierarchy = this.data.JIT.hierarchy;
  var currentTime, unloopedCurrentTime;
  var looped;
  this.currentTime += deltaTimeMS * this.timeScale;
  unloopedCurrentTime = this.currentTime;
  currentTime = this.currentTime = this.currentTime % this.data.length;
  if (currentTime < this.startTimeMs) {
    currentTime = this.currentTime = this.startTimeMs + currentTime;
  }
  frame = parseInt(Math.min(currentTime * this.data.fps, this.data.length * this.data.fps), 10);
  looped = currentTime < unloopedCurrentTime;
  if (looped && !this.loop) {
    for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
      var keys = this.data.hierarchy[h].keys, sids = this.data.hierarchy[h].sids, end = keys.length - 1, obj = this.hierarchy[h];
      if (keys.length) {
        for (var s = 0; s < sids.length; s++) {
          var sid = sids[s], prev = this.getPrevKeyWith(sid, h, end);
          if (prev) {
            prev.apply(sid);
          }
        }
        this.data.hierarchy[h].node.updateMatrix();
        obj.matrixWorldNeedsUpdate = true;
      }
    }
    this.stop();
    return;
  }
  if (currentTime < this.startTime) {
    return;
  }
  for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
    object = this.hierarchy[h];
    node = this.data.hierarchy[h];
    var keys = node.keys, animationCache = node.animationCache;
    if (this.JITCompile && JIThierarchy[h][frame] !== undefined) {
      if (object instanceof THREE.Bone) {
        object.skinMatrix = JIThierarchy[h][frame];
        object.matrixWorldNeedsUpdate = false;
      } else {
        object.matrix = JIThierarchy[h][frame];
        object.matrixWorldNeedsUpdate = true;
      }
    } else if (keys.length) {
      if (this.JITCompile && animationCache) {
        if (object instanceof THREE.Bone) {
          object.skinMatrix = animationCache.originalMatrix;
        } else {
          object.matrix = animationCache.originalMatrix;
        }
      }
      prevKey = animationCache.prevKey;
      nextKey = animationCache.nextKey;
      if (prevKey && nextKey) {
        if (nextKey.time <= unloopedCurrentTime) {
          if (looped && this.loop) {
            prevKey = keys[0];
            nextKey = keys[1];
            while (nextKey.time < currentTime) {
              prevKey = nextKey;
              nextKey = keys[prevKey.index + 1];
            }
          } else if (!looped) {
            var lastIndex = keys.length - 1;
            while (nextKey.time < currentTime && nextKey.index !== lastIndex) {
              prevKey = nextKey;
              nextKey = keys[prevKey.index + 1];
            }
          }
          animationCache.prevKey = prevKey;
          animationCache.nextKey = nextKey;
        }
        if (nextKey.time >= currentTime)
          prevKey.interpolate(nextKey, currentTime);
        else
          prevKey.interpolate(nextKey, nextKey.time);
      }
      this.data.hierarchy[h].node.updateMatrix();
      object.matrixWorldNeedsUpdate = true;
    }
  }
  if (this.JITCompile) {
    if (JIThierarchy[0][frame] === undefined) {
      this.hierarchy[0].updateMatrixWorld(true);
      for (var h = 0; h < this.hierarchy.length; h++) {
        if (this.hierarchy[h] instanceof THREE.Bone) {
          JIThierarchy[h][frame] = this.hierarchy[h].skinMatrix.clone();
        } else {
          JIThierarchy[h][frame] = this.hierarchy[h].matrix.clone();
        }
      }
    }
  }
};
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (sid, h, key) {
  var keys = this.data.hierarchy[h].keys;
  key = key % keys.length;
  for (; key < keys.length; key++) {
    if (keys[key].hasTarget(sid)) {
      return keys[key];
    }
  }
  return keys[0];
};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (sid, h, key) {
  var keys = this.data.hierarchy[h].keys;
  key = key >= 0 ? key : key + keys.length;
  for (; key >= 0; key--) {
    if (keys[key].hasTarget(sid)) {
      return keys[key];
    }
  }
  return keys[keys.length - 1];
};
THREE.CubeCamera = function (near, far, cubeResolution) {
  THREE.Object3D.call(this);
  var fov = 90, aspect = 1;
  var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
  this.add(cameraPX);
  var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
  this.add(cameraNX);
  var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
  this.add(cameraPY);
  var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
  this.add(cameraNY);
  var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
  this.add(cameraPZ);
  var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
  this.add(cameraNZ);
  this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {
    format: THREE.RGBFormat,
    magFilter: THREE.LinearFilter,
    minFilter: THREE.LinearFilter
  });
  this.updateCubeMap = function (renderer, scene) {
    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.generateMipmaps;
    renderTarget.generateMipmaps = false;
    renderTarget.activeCubeFace = 0;
    renderer.render(scene, cameraPX, renderTarget);
    renderTarget.activeCubeFace = 1;
    renderer.render(scene, cameraNX, renderTarget);
    renderTarget.activeCubeFace = 2;
    renderer.render(scene, cameraPY, renderTarget);
    renderTarget.activeCubeFace = 3;
    renderer.render(scene, cameraNY, renderTarget);
    renderTarget.activeCubeFace = 4;
    renderer.render(scene, cameraPZ, renderTarget);
    renderTarget.generateMipmaps = generateMipmaps;
    renderTarget.activeCubeFace = 5;
    renderer.render(scene, cameraNZ, renderTarget);
  };
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CombinedCamera = function (width, height, fov, near, far, orthoNear, orthoFar) {
  THREE.Camera.call(this);
  this.fov = fov;
  this.left = -width / 2;
  this.right = width / 2;
  this.top = height / 2;
  this.bottom = -height / 2;
  this.cameraO = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, orthoNear, orthoFar);
  this.cameraP = new THREE.PerspectiveCamera(fov, width / height, near, far);
  this.zoom = 1;
  this.toPerspective();
  var aspect = width / height;
};
THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective = function () {
  this.near = this.cameraP.near;
  this.far = this.cameraP.far;
  this.cameraP.fov = this.fov / this.zoom;
  this.cameraP.updateProjectionMatrix();
  this.projectionMatrix = this.cameraP.projectionMatrix;
  this.inPerspectiveMode = true;
  this.inOrthographicMode = false;
};
THREE.CombinedCamera.prototype.toOrthographic = function () {
  var fov = this.fov;
  var aspect = this.cameraP.aspect;
  var near = this.cameraP.near;
  var far = this.cameraP.far;
  var hyperfocus = (near + far) / 2;
  var halfHeight = Math.tan(fov / 2) * hyperfocus;
  var planeHeight = 2 * halfHeight;
  var planeWidth = planeHeight * aspect;
  var halfWidth = planeWidth / 2;
  halfHeight /= this.zoom;
  halfWidth /= this.zoom;
  this.cameraO.left = -halfWidth;
  this.cameraO.right = halfWidth;
  this.cameraO.top = halfHeight;
  this.cameraO.bottom = -halfHeight;
  this.cameraO.updateProjectionMatrix();
  this.near = this.cameraO.near;
  this.far = this.cameraO.far;
  this.projectionMatrix = this.cameraO.projectionMatrix;
  this.inPerspectiveMode = false;
  this.inOrthographicMode = true;
};
THREE.CombinedCamera.prototype.setSize = function (width, height) {
  this.cameraP.aspect = width / height;
  this.left = -width / 2;
  this.right = width / 2;
  this.top = height / 2;
  this.bottom = -height / 2;
};
THREE.CombinedCamera.prototype.setFov = function (fov) {
  this.fov = fov;
  if (this.inPerspectiveMode) {
    this.toPerspective();
  } else {
    this.toOrthographic();
  }
};
THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
  if (this.inPerspectiveMode) {
    this.toPerspective();
  } else {
    this.toPerspective();
    this.toOrthographic();
  }
};
THREE.CombinedCamera.prototype.setLens = function (focalLength, frameHeight) {
  if (frameHeight === undefined)
    frameHeight = 24;
  var fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
  this.setFov(fov);
  return fov;
};
THREE.CombinedCamera.prototype.setZoom = function (zoom) {
  this.zoom = zoom;
  if (this.inPerspectiveMode) {
    this.toPerspective();
  } else {
    this.toOrthographic();
  }
};
THREE.CombinedCamera.prototype.toFrontView = function () {
  this.rotation.x = 0;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toBackView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toLeftView = function () {
  this.rotation.x = 0;
  this.rotation.y = -Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toRightView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toTopView = function () {
  this.rotation.x = -Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toBottomView = function () {
  this.rotation.x = Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CircleGeometry = function (radius, segments, thetaStart, thetaLength) {
  THREE.Geometry.call(this);
  this.radius = radius = radius || 50;
  this.segments = segments = segments !== undefined ? Math.max(3, segments) : 8;
  this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
  this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
  var i, uvs = [], center = new THREE.Vector3(), centerUV = new THREE.Vector2(0.5, 0.5);
  this.vertices.push(center);
  uvs.push(centerUV);
  for (i = 0; i <= segments; i++) {
    var vertex = new THREE.Vector3();
    var segment = thetaStart + i / segments * thetaLength;
    vertex.x = radius * Math.cos(segment);
    vertex.y = radius * Math.sin(segment);
    this.vertices.push(vertex);
    uvs.push(new THREE.Vector2((vertex.x / radius + 1) / 2, (vertex.y / radius + 1) / 2));
  }
  var n = new THREE.Vector3(0, 0, 1);
  for (i = 1; i <= segments; i++) {
    var v1 = i;
    var v2 = i + 1;
    var v3 = 0;
    this.faces.push(new THREE.Face3(v1, v2, v3, [
      n,
      n,
      n
    ]));
    this.faceVertexUvs[0].push([
      uvs[i],
      uvs[i + 1],
      centerUV
    ]);
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CubeGeometry = function (width, height, depth, widthSegments, heightSegments, depthSegments) {
  THREE.Geometry.call(this);
  var scope = this;
  this.width = width;
  this.height = height;
  this.depth = depth;
  this.widthSegments = widthSegments || 1;
  this.heightSegments = heightSegments || 1;
  this.depthSegments = depthSegments || 1;
  var width_half = this.width / 2;
  var height_half = this.height / 2;
  var depth_half = this.depth / 2;
  buildPlane('z', 'y', -1, -1, this.depth, this.height, width_half, 0);
  buildPlane('z', 'y', 1, -1, this.depth, this.height, -width_half, 1);
  buildPlane('x', 'z', 1, 1, this.width, this.depth, height_half, 2);
  buildPlane('x', 'z', 1, -1, this.width, this.depth, -height_half, 3);
  buildPlane('x', 'y', 1, -1, this.width, this.height, depth_half, 4);
  buildPlane('x', 'y', -1, -1, this.width, this.height, -depth_half, 5);
  function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {
    var w, ix, iy, gridX = scope.widthSegments, gridY = scope.heightSegments, width_half = width / 2, height_half = height / 2, offset = scope.vertices.length;
    if (u === 'x' && v === 'y' || u === 'y' && v === 'x') {
      w = 'z';
    } else if (u === 'x' && v === 'z' || u === 'z' && v === 'x') {
      w = 'y';
      gridY = scope.depthSegments;
    } else if (u === 'z' && v === 'y' || u === 'y' && v === 'z') {
      w = 'x';
      gridX = scope.depthSegments;
    }
    var gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, normal = new THREE.Vector3();
    normal[w] = depth > 0 ? 1 : -1;
    for (iy = 0; iy < gridY1; iy++) {
      for (ix = 0; ix < gridX1; ix++) {
        var vector = new THREE.Vector3();
        vector[u] = (ix * segment_width - width_half) * udir;
        vector[v] = (iy * segment_height - height_half) * vdir;
        vector[w] = depth;
        scope.vertices.push(vector);
      }
    }
    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * (iy + 1);
        var c = ix + 1 + gridX1 * (iy + 1);
        var d = ix + 1 + gridX1 * iy;
        var uva = new THREE.Vector2(ix / gridX, 1 - iy / gridY);
        var uvb = new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY);
        var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY);
        var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY);
        var face = new THREE.Face3(a + offset, b + offset, d + offset);
        face.normal.copy(normal);
        face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
        face.materialIndex = materialIndex;
        scope.faces.push(face);
        scope.faceVertexUvs[0].push([
          uva,
          uvb,
          uvd
        ]);
        face = new THREE.Face3(b + offset, c + offset, d + offset);
        face.normal.copy(normal);
        face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
        face.materialIndex = materialIndex;
        scope.faces.push(face);
        scope.faceVertexUvs[0].push([
          uvb.clone(),
          uvc,
          uvd.clone()
        ]);
      }
    }
  }
  this.computeCentroids();
  this.mergeVertices();
};
THREE.CubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry = function (radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
  THREE.Geometry.call(this);
  this.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;
  this.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  this.height = height = height !== undefined ? height : 100;
  this.radialSegments = radialSegments = radialSegments || 8;
  this.heightSegments = heightSegments = heightSegments || 1;
  this.openEnded = openEnded = openEnded !== undefined ? openEnded : false;
  var heightHalf = height / 2;
  var x, y, vertices = [], uvs = [];
  for (y = 0; y <= heightSegments; y++) {
    var verticesRow = [];
    var uvsRow = [];
    var v = y / heightSegments;
    var radius = v * (radiusBottom - radiusTop) + radiusTop;
    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var vertex = new THREE.Vector3();
      vertex.x = radius * Math.sin(u * Math.PI * 2);
      vertex.y = -v * height + heightHalf;
      vertex.z = radius * Math.cos(u * Math.PI * 2);
      this.vertices.push(vertex);
      verticesRow.push(this.vertices.length - 1);
      uvsRow.push(new THREE.Vector2(u, 1 - v));
    }
    vertices.push(verticesRow);
    uvs.push(uvsRow);
  }
  var tanTheta = (radiusBottom - radiusTop) / height;
  var na, nb;
  for (x = 0; x < radialSegments; x++) {
    if (radiusTop !== 0) {
      na = this.vertices[vertices[0][x]].clone();
      nb = this.vertices[vertices[0][x + 1]].clone();
    } else {
      na = this.vertices[vertices[1][x]].clone();
      nb = this.vertices[vertices[1][x + 1]].clone();
    }
    na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();
    nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();
    for (y = 0; y < heightSegments; y++) {
      var v1 = vertices[y][x];
      var v2 = vertices[y + 1][x];
      var v3 = vertices[y + 1][x + 1];
      var v4 = vertices[y][x + 1];
      var n1 = na.clone();
      var n2 = na.clone();
      var n3 = nb.clone();
      var n4 = nb.clone();
      var uv1 = uvs[y][x].clone();
      var uv2 = uvs[y + 1][x].clone();
      var uv3 = uvs[y + 1][x + 1].clone();
      var uv4 = uvs[y][x + 1].clone();
      this.faces.push(new THREE.Face3(v1, v2, v4, [
        n1,
        n2,
        n4
      ]));
      this.faceVertexUvs[0].push([
        uv1,
        uv2,
        uv4
      ]);
      this.faces.push(new THREE.Face3(v2, v3, v4, [
        n2,
        n3,
        n4
      ]));
      this.faceVertexUvs[0].push([
        uv2,
        uv3,
        uv4
      ]);
    }
  }
  if (openEnded === false && radiusTop > 0) {
    this.vertices.push(new THREE.Vector3(0, heightHalf, 0));
    for (x = 0; x < radialSegments; x++) {
      var v1 = vertices[0][x];
      var v2 = vertices[0][x + 1];
      var v3 = this.vertices.length - 1;
      var n1 = new THREE.Vector3(0, 1, 0);
      var n2 = new THREE.Vector3(0, 1, 0);
      var n3 = new THREE.Vector3(0, 1, 0);
      var uv1 = uvs[0][x].clone();
      var uv2 = uvs[0][x + 1].clone();
      var uv3 = new THREE.Vector2(uv2.u, 0);
      this.faces.push(new THREE.Face3(v1, v2, v3, [
        n1,
        n2,
        n3
      ]));
      this.faceVertexUvs[0].push([
        uv1,
        uv2,
        uv3
      ]);
    }
  }
  if (openEnded === false && radiusBottom > 0) {
    this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));
    for (x = 0; x < radialSegments; x++) {
      var v1 = vertices[y][x + 1];
      var v2 = vertices[y][x];
      var v3 = this.vertices.length - 1;
      var n1 = new THREE.Vector3(0, -1, 0);
      var n2 = new THREE.Vector3(0, -1, 0);
      var n3 = new THREE.Vector3(0, -1, 0);
      var uv1 = uvs[y][x + 1].clone();
      var uv2 = uvs[y][x].clone();
      var uv3 = new THREE.Vector2(uv2.u, 1);
      this.faces.push(new THREE.Face3(v1, v2, v3, [
        n1,
        n2,
        n3
      ]));
      this.faceVertexUvs[0].push([
        uv1,
        uv2,
        uv3
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry = function (shapes, options) {
  if (typeof shapes === 'undefined') {
    shapes = [];
    return;
  }
  THREE.Geometry.call(this);
  shapes = shapes instanceof Array ? shapes : [shapes];
  this.shapebb = shapes[shapes.length - 1].getBoundingBox();
  this.addShapeList(shapes, options);
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.addShapeList = function (shapes, options) {
  var sl = shapes.length;
  for (var s = 0; s < sl; s++) {
    var shape = shapes[s];
    this.addShape(shape, options);
  }
};
THREE.ExtrudeGeometry.prototype.addShape = function (shape, options) {
  var amount = options.amount !== undefined ? options.amount : 100;
  var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
  var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
  var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
  var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
  var steps = options.steps !== undefined ? options.steps : 1;
  var extrudePath = options.extrudePath;
  var extrudePts, extrudeByPath = false;
  var material = options.material;
  var extrudeMaterial = options.extrudeMaterial;
  var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
  var shapebb = this.shapebb;
  var splineTube, binormal, normal, position2;
  if (extrudePath) {
    extrudePts = extrudePath.getSpacedPoints(steps);
    extrudeByPath = true;
    bevelEnabled = false;
    splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
    binormal = new THREE.Vector3();
    normal = new THREE.Vector3();
    position2 = new THREE.Vector3();
  }
  if (!bevelEnabled) {
    bevelSegments = 0;
    bevelThickness = 0;
    bevelSize = 0;
  }
  var ahole, h, hl;
  var scope = this;
  var bevelPoints = [];
  var shapesOffset = this.vertices.length;
  var shapePoints = shape.extractPoints(curveSegments);
  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;
  var reverse = !THREE.Shape.Utils.isClockWise(vertices);
  if (reverse) {
    vertices = vertices.reverse();
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      if (THREE.Shape.Utils.isClockWise(ahole)) {
        holes[h] = ahole.reverse();
      }
    }
    reverse = false;
  }
  var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
  var contour = vertices;
  for (h = 0, hl = holes.length; h < hl; h++) {
    ahole = holes[h];
    vertices = vertices.concat(ahole);
  }
  function scalePt2(pt, vec, size) {
    if (!vec)
      console.log('die');
    return vec.clone().multiplyScalar(size).add(pt);
  }
  var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length, cont, clen = contour.length;
  var RAD_TO_DEGREES = 180 / Math.PI;
  function getBevelVec(pt_i, pt_j, pt_k) {
    return getBevelVec2(pt_i, pt_j, pt_k);
  }
  function getBevelVec1(pt_i, pt_j, pt_k) {
    var anglea = Math.atan2(pt_j.y - pt_i.y, pt_j.x - pt_i.x);
    var angleb = Math.atan2(pt_k.y - pt_i.y, pt_k.x - pt_i.x);
    if (anglea > angleb) {
      angleb += Math.PI * 2;
    }
    var anglec = (anglea + angleb) / 2;
    var x = -Math.cos(anglec);
    var y = -Math.sin(anglec);
    var vec = new THREE.Vector2(x, y);
    return vec;
  }
  function getBevelVec2(pt_i, pt_j, pt_k) {
    var a = THREE.ExtrudeGeometry.__v1, b = THREE.ExtrudeGeometry.__v2, v_hat = THREE.ExtrudeGeometry.__v3, w_hat = THREE.ExtrudeGeometry.__v4, p = THREE.ExtrudeGeometry.__v5, q = THREE.ExtrudeGeometry.__v6, v, w, v_dot_w_hat, q_sub_p_dot_w_hat, s, intersection;
    a.set(pt_i.x - pt_j.x, pt_i.y - pt_j.y);
    b.set(pt_i.x - pt_k.x, pt_i.y - pt_k.y);
    v = a.normalize();
    w = b.normalize();
    v_hat.set(-v.y, v.x);
    w_hat.set(w.y, -w.x);
    p.copy(pt_i).add(v_hat);
    q.copy(pt_i).add(w_hat);
    if (p.equals(q)) {
      return w_hat.clone();
    }
    p.copy(pt_j).add(v_hat);
    q.copy(pt_k).add(w_hat);
    v_dot_w_hat = v.dot(w_hat);
    q_sub_p_dot_w_hat = q.sub(p).dot(w_hat);
    if (v_dot_w_hat === 0) {
      console.log('Either infinite or no solutions!');
      if (q_sub_p_dot_w_hat === 0) {
        console.log('Its finite solutions.');
      } else {
        console.log('Too bad, no solutions.');
      }
    }
    s = q_sub_p_dot_w_hat / v_dot_w_hat;
    if (s < 0) {
      return getBevelVec1(pt_i, pt_j, pt_k);
    }
    intersection = v.multiplyScalar(s).add(p);
    return intersection.sub(pt_i).clone();
  }
  var contourMovements = [];
  for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
    if (j === il)
      j = 0;
    if (k === il)
      k = 0;
    var pt_i = contour[i];
    var pt_j = contour[j];
    var pt_k = contour[k];
    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
  }
  var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
  for (h = 0, hl = holes.length; h < hl; h++) {
    ahole = holes[h];
    oneHoleMovements = [];
    for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
      if (j === il)
        j = 0;
      if (k === il)
        k = 0;
      oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
    }
    holesMovements.push(oneHoleMovements);
    verticesMovements = verticesMovements.concat(oneHoleMovements);
  }
  for (b = 0; b < bevelSegments; b++) {
    t = b / bevelSegments;
    z = bevelThickness * (1 - t);
    bs = bevelSize * Math.sin(t * Math.PI / 2);
    for (i = 0, il = contour.length; i < il; i++) {
      vert = scalePt2(contour[i], contourMovements[i], bs);
      v(vert.x, vert.y, -z);
    }
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = holesMovements[h];
      for (i = 0, il = ahole.length; i < il; i++) {
        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
        v(vert.x, vert.y, -z);
      }
    }
  }
  bs = bevelSize;
  for (i = 0; i < vlen; i++) {
    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
    if (!extrudeByPath) {
      v(vert.x, vert.y, 0);
    } else {
      normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
      binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
      position2.copy(extrudePts[0]).add(normal).add(binormal);
      v(position2.x, position2.y, position2.z);
    }
  }
  var s;
  for (s = 1; s <= steps; s++) {
    for (i = 0; i < vlen; i++) {
      vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
      if (!extrudeByPath) {
        v(vert.x, vert.y, amount / steps * s);
      } else {
        normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
        position2.copy(extrudePts[s]).add(normal).add(binormal);
        v(position2.x, position2.y, position2.z);
      }
    }
  }
  for (b = bevelSegments - 1; b >= 0; b--) {
    t = b / bevelSegments;
    z = bevelThickness * (1 - t);
    bs = bevelSize * Math.sin(t * Math.PI / 2);
    for (i = 0, il = contour.length; i < il; i++) {
      vert = scalePt2(contour[i], contourMovements[i], bs);
      v(vert.x, vert.y, amount + z);
    }
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = holesMovements[h];
      for (i = 0, il = ahole.length; i < il; i++) {
        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
        if (!extrudeByPath) {
          v(vert.x, vert.y, amount + z);
        } else {
          v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
        }
      }
    }
  }
  buildLidFaces();
  buildSideFaces();
  function buildLidFaces() {
    if (bevelEnabled) {
      var layer = 0;
      var offset = vlen * layer;
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[2] + offset, face[1] + offset, face[0] + offset, true);
      }
      layer = steps + bevelSegments * 2;
      offset = vlen * layer;
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[0] + offset, face[1] + offset, face[2] + offset, false);
      }
    } else {
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[2], face[1], face[0], true);
      }
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps, false);
      }
    }
  }
  function buildSideFaces() {
    var layeroffset = 0;
    sidewalls(contour, layeroffset);
    layeroffset += contour.length;
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      sidewalls(ahole, layeroffset);
      layeroffset += ahole.length;
    }
  }
  function sidewalls(contour, layeroffset) {
    var j, k;
    i = contour.length;
    while (--i >= 0) {
      j = i;
      k = i - 1;
      if (k < 0)
        k = contour.length - 1;
      var s = 0, sl = steps + bevelSegments * 2;
      for (s = 0; s < sl; s++) {
        var slen1 = vlen * s;
        var slen2 = vlen * (s + 1);
        var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
        f4(a, b, c, d, contour, s, sl, j, k);
      }
    }
  }
  function v(x, y, z) {
    scope.vertices.push(new THREE.Vector3(x, y, z));
  }
  function f3(a, b, c, isBottom) {
    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    scope.faces.push(new THREE.Face3(a, b, c, null, null, material));
    var uvs = isBottom ? uvgen.generateBottomUV(scope, shape, options, a, b, c) : uvgen.generateTopUV(scope, shape, options, a, b, c);
    scope.faceVertexUvs[0].push(uvs);
  }
  function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    d += shapesOffset;
    scope.faces.push(new THREE.Face3(a, b, d, null, null, extrudeMaterial));
    scope.faces.push(new THREE.Face3(b, c, d, null, null, extrudeMaterial));
    var uvs = uvgen.generateSideWallUV(scope, shape, wallContour, options, a, b, c, d, stepIndex, stepsLength, contourIndex1, contourIndex2);
    scope.faceVertexUvs[0].push([
      uvs[0],
      uvs[1],
      uvs[3]
    ]);
    scope.faceVertexUvs[0].push([
      uvs[1],
      uvs[2],
      uvs[3]
    ]);
  }
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
  generateTopUV: function (geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC) {
    var ax = geometry.vertices[indexA].x, ay = geometry.vertices[indexA].y, bx = geometry.vertices[indexB].x, by = geometry.vertices[indexB].y, cx = geometry.vertices[indexC].x, cy = geometry.vertices[indexC].y;
    return [
      new THREE.Vector2(ax, ay),
      new THREE.Vector2(bx, by),
      new THREE.Vector2(cx, cy)
    ];
  },
  generateBottomUV: function (geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC) {
    return this.generateTopUV(geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC);
  },
  generateSideWallUV: function (geometry, extrudedShape, wallContour, extrudeOptions, indexA, indexB, indexC, indexD, stepIndex, stepsLength, contourIndex1, contourIndex2) {
    var ax = geometry.vertices[indexA].x, ay = geometry.vertices[indexA].y, az = geometry.vertices[indexA].z, bx = geometry.vertices[indexB].x, by = geometry.vertices[indexB].y, bz = geometry.vertices[indexB].z, cx = geometry.vertices[indexC].x, cy = geometry.vertices[indexC].y, cz = geometry.vertices[indexC].z, dx = geometry.vertices[indexD].x, dy = geometry.vertices[indexD].y, dz = geometry.vertices[indexD].z;
    if (Math.abs(ay - by) < 0.01) {
      return [
        new THREE.Vector2(ax, 1 - az),
        new THREE.Vector2(bx, 1 - bz),
        new THREE.Vector2(cx, 1 - cz),
        new THREE.Vector2(dx, 1 - dz)
      ];
    } else {
      return [
        new THREE.Vector2(ay, 1 - az),
        new THREE.Vector2(by, 1 - bz),
        new THREE.Vector2(cy, 1 - cz),
        new THREE.Vector2(dy, 1 - dz)
      ];
    }
  }
};
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();
THREE.ShapeGeometry = function (shapes, options) {
  THREE.Geometry.call(this);
  if (shapes instanceof Array === false)
    shapes = [shapes];
  this.shapebb = shapes[shapes.length - 1].getBoundingBox();
  this.addShapeList(shapes, options);
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.addShapeList = function (shapes, options) {
  for (var i = 0, l = shapes.length; i < l; i++) {
    this.addShape(shapes[i], options);
  }
  return this;
};
THREE.ShapeGeometry.prototype.addShape = function (shape, options) {
  if (options === undefined)
    options = {};
  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
  var material = options.material;
  var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
  var shapebb = this.shapebb;
  var i, l, hole, s;
  var shapesOffset = this.vertices.length;
  var shapePoints = shape.extractPoints(curveSegments);
  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;
  var reverse = !THREE.Shape.Utils.isClockWise(vertices);
  if (reverse) {
    vertices = vertices.reverse();
    for (i = 0, l = holes.length; i < l; i++) {
      hole = holes[i];
      if (THREE.Shape.Utils.isClockWise(hole)) {
        holes[i] = hole.reverse();
      }
    }
    reverse = false;
  }
  var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
  var contour = vertices;
  for (i = 0, l = holes.length; i < l; i++) {
    hole = holes[i];
    vertices = vertices.concat(hole);
  }
  var vert, vlen = vertices.length;
  var face, flen = faces.length;
  var cont, clen = contour.length;
  for (i = 0; i < vlen; i++) {
    vert = vertices[i];
    this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));
  }
  for (i = 0; i < flen; i++) {
    face = faces[i];
    var a = face[0] + shapesOffset;
    var b = face[1] + shapesOffset;
    var c = face[2] + shapesOffset;
    this.faces.push(new THREE.Face3(a, b, c, null, null, material));
    this.faceVertexUvs[0].push(uvgen.generateBottomUV(this, shape, options, a, b, c));
  }
};
THREE.LatheGeometry = function (points, segments, phiStart, phiLength) {
  THREE.Geometry.call(this);
  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;
  var inversePointLength = 1 / (points.length - 1);
  var inverseSegments = 1 / segments;
  for (var i = 0, il = segments; i <= il; i++) {
    var phi = phiStart + i * inverseSegments * phiLength;
    var c = Math.cos(phi), s = Math.sin(phi);
    for (var j = 0, jl = points.length; j < jl; j++) {
      var pt = points[j];
      var vertex = new THREE.Vector3();
      vertex.x = c * pt.x - s * pt.y;
      vertex.y = s * pt.x + c * pt.y;
      vertex.z = pt.z;
      this.vertices.push(vertex);
    }
  }
  var np = points.length;
  for (var i = 0, il = segments; i < il; i++) {
    for (var j = 0, jl = points.length - 1; j < jl; j++) {
      var base = j + np * i;
      var a = base;
      var b = base + np;
      var c = base + 1 + np;
      var d = base + 1;
      var u0 = i * inverseSegments;
      var v0 = j * inversePointLength;
      var u1 = u0 + inverseSegments;
      var v1 = v0 + inversePointLength;
      this.faces.push(new THREE.Face3(a, b, d));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(u0, v0),
        new THREE.Vector2(u1, v0),
        new THREE.Vector2(u0, v1)
      ]);
      this.faces.push(new THREE.Face3(b, c, d));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(u1, v0),
        new THREE.Vector2(u1, v1),
        new THREE.Vector2(u0, v1)
      ]);
    }
  }
  this.mergeVertices();
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry = function (width, height, widthSegments, heightSegments) {
  THREE.Geometry.call(this);
  this.width = width;
  this.height = height;
  this.widthSegments = widthSegments || 1;
  this.heightSegments = heightSegments || 1;
  var ix, iz;
  var width_half = width / 2;
  var height_half = height / 2;
  var gridX = this.widthSegments;
  var gridZ = this.heightSegments;
  var gridX1 = gridX + 1;
  var gridZ1 = gridZ + 1;
  var segment_width = this.width / gridX;
  var segment_height = this.height / gridZ;
  var normal = new THREE.Vector3(0, 0, 1);
  for (iz = 0; iz < gridZ1; iz++) {
    for (ix = 0; ix < gridX1; ix++) {
      var x = ix * segment_width - width_half;
      var y = iz * segment_height - height_half;
      this.vertices.push(new THREE.Vector3(x, -y, 0));
    }
  }
  for (iz = 0; iz < gridZ; iz++) {
    for (ix = 0; ix < gridX; ix++) {
      var a = ix + gridX1 * iz;
      var b = ix + gridX1 * (iz + 1);
      var c = ix + 1 + gridX1 * (iz + 1);
      var d = ix + 1 + gridX1 * iz;
      var uva = new THREE.Vector2(ix / gridX, 1 - iz / gridZ);
      var uvb = new THREE.Vector2(ix / gridX, 1 - (iz + 1) / gridZ);
      var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iz + 1) / gridZ);
      var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iz / gridZ);
      var face = new THREE.Face3(a, b, d);
      face.normal.copy(normal);
      face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
      this.faces.push(face);
      this.faceVertexUvs[0].push([
        uva,
        uvb,
        uvd
      ]);
      face = new THREE.Face3(b, c, d);
      face.normal.copy(normal);
      face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
      this.faces.push(face);
      this.faceVertexUvs[0].push([
        uvb.clone(),
        uvc,
        uvd.clone()
      ]);
    }
  }
  this.computeCentroids();
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry = function (innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  THREE.Geometry.call(this);
  innerRadius = innerRadius || 0;
  outerRadius = outerRadius || 50;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
  thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
  phiSegments = phiSegments !== undefined ? Math.max(3, phiSegments) : 8;
  var i, o, uvs = [], radius = innerRadius, radiusStep = (outerRadius - innerRadius) / phiSegments;
  for (i = 0; i <= phiSegments; i++) {
    for (o = 0; o <= thetaSegments; o++) {
      var vertex = new THREE.Vector3();
      var segment = thetaStart + o / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      this.vertices.push(vertex);
      uvs.push(new THREE.Vector2((vertex.x / radius + 1) / 2, -(vertex.y / radius + 1) / 2 + 1));
    }
    radius += radiusStep;
  }
  var n = new THREE.Vector3(0, 0, 1);
  for (i = 0; i < phiSegments; i++) {
    var thetaSegment = i * thetaSegments;
    for (o = 0; o <= thetaSegments; o++) {
      var segment = o + thetaSegment;
      var v1 = segment + i;
      var v2 = segment + thetaSegments + i;
      var v3 = segment + thetaSegments + 1 + i;
      this.faces.push(new THREE.Face3(v1, v2, v3, [
        n,
        n,
        n
      ]));
      this.faceVertexUvs[0].push([
        uvs[v1],
        uvs[v2],
        uvs[v3]
      ]);
      v1 = segment + i;
      v2 = segment + thetaSegments + 1 + i;
      v3 = segment + 1 + i;
      this.faces.push(new THREE.Face3(v1, v2, v3, [
        n,
        n,
        n
      ]));
      this.faceVertexUvs[0].push([
        uvs[v1],
        uvs[v2],
        uvs[v3]
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry = function (radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  THREE.Geometry.call(this);
  this.radius = radius = radius || 50;
  this.widthSegments = widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  this.heightSegments = heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  this.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;
  this.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
  this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
  this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
  var x, y, vertices = [], uvs = [];
  for (y = 0; y <= heightSegments; y++) {
    var verticesRow = [];
    var uvsRow = [];
    for (x = 0; x <= widthSegments; x++) {
      var u = x / widthSegments;
      var v = y / heightSegments;
      var vertex = new THREE.Vector3();
      vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
      vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      this.vertices.push(vertex);
      verticesRow.push(this.vertices.length - 1);
      uvsRow.push(new THREE.Vector2(u, 1 - v));
    }
    vertices.push(verticesRow);
    uvs.push(uvsRow);
  }
  for (y = 0; y < this.heightSegments; y++) {
    for (x = 0; x < this.widthSegments; x++) {
      var v1 = vertices[y][x + 1];
      var v2 = vertices[y][x];
      var v3 = vertices[y + 1][x];
      var v4 = vertices[y + 1][x + 1];
      var n1 = this.vertices[v1].clone().normalize();
      var n2 = this.vertices[v2].clone().normalize();
      var n3 = this.vertices[v3].clone().normalize();
      var n4 = this.vertices[v4].clone().normalize();
      var uv1 = uvs[y][x + 1].clone();
      var uv2 = uvs[y][x].clone();
      var uv3 = uvs[y + 1][x].clone();
      var uv4 = uvs[y + 1][x + 1].clone();
      if (Math.abs(this.vertices[v1].y) === this.radius) {
        this.faces.push(new THREE.Face3(v1, v3, v4, [
          n1,
          n3,
          n4
        ]));
        this.faceVertexUvs[0].push([
          uv1,
          uv3,
          uv4
        ]);
      } else if (Math.abs(this.vertices[v3].y) === this.radius) {
        this.faces.push(new THREE.Face3(v1, v2, v3, [
          n1,
          n2,
          n3
        ]));
        this.faceVertexUvs[0].push([
          uv1,
          uv2,
          uv3
        ]);
      } else {
        this.faces.push(new THREE.Face3(v1, v2, v4, [
          n1,
          n2,
          n4
        ]));
        this.faceVertexUvs[0].push([
          uv1,
          uv2,
          uv4
        ]);
        this.faces.push(new THREE.Face3(v2, v3, v4, [
          n2,
          n3,
          n4
        ]));
        this.faceVertexUvs[0].push([
          uv2.clone(),
          uv3,
          uv4.clone()
        ]);
      }
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TextGeometry = function (text, parameters) {
  parameters = parameters || {};
  var textShapes = THREE.FontUtils.generateShapes(text, parameters);
  parameters.amount = parameters.height !== undefined ? parameters.height : 50;
  if (parameters.bevelThickness === undefined)
    parameters.bevelThickness = 10;
  if (parameters.bevelSize === undefined)
    parameters.bevelSize = 8;
  if (parameters.bevelEnabled === undefined)
    parameters.bevelEnabled = false;
  THREE.ExtrudeGeometry.call(this, textShapes, parameters);
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry = function (radius, tube, radialSegments, tubularSegments, arc) {
  THREE.Geometry.call(this);
  var scope = this;
  this.radius = radius || 100;
  this.tube = tube || 40;
  this.radialSegments = radialSegments || 8;
  this.tubularSegments = tubularSegments || 6;
  this.arc = arc || Math.PI * 2;
  var center = new THREE.Vector3(), uvs = [], normals = [];
  for (var j = 0; j <= this.radialSegments; j++) {
    for (var i = 0; i <= this.tubularSegments; i++) {
      var u = i / this.tubularSegments * this.arc;
      var v = j / this.radialSegments * Math.PI * 2;
      center.x = this.radius * Math.cos(u);
      center.y = this.radius * Math.sin(u);
      var vertex = new THREE.Vector3();
      vertex.x = (this.radius + this.tube * Math.cos(v)) * Math.cos(u);
      vertex.y = (this.radius + this.tube * Math.cos(v)) * Math.sin(u);
      vertex.z = this.tube * Math.sin(v);
      this.vertices.push(vertex);
      uvs.push(new THREE.Vector2(i / this.tubularSegments, j / this.radialSegments));
      normals.push(vertex.clone().sub(center).normalize());
    }
  }
  for (var j = 1; j <= this.radialSegments; j++) {
    for (var i = 1; i <= this.tubularSegments; i++) {
      var a = (this.tubularSegments + 1) * j + i - 1;
      var b = (this.tubularSegments + 1) * (j - 1) + i - 1;
      var c = (this.tubularSegments + 1) * (j - 1) + i;
      var d = (this.tubularSegments + 1) * j + i;
      var face = new THREE.Face3(a, b, d, [
          normals[a],
          normals[b],
          normals[d]
        ]);
      face.normal.add(normals[a]);
      face.normal.add(normals[b]);
      face.normal.add(normals[d]);
      face.normal.normalize();
      this.faces.push(face);
      this.faceVertexUvs[0].push([
        uvs[a].clone(),
        uvs[b].clone(),
        uvs[d].clone()
      ]);
      face = new THREE.Face3(b, c, d, [
        normals[b],
        normals[c],
        normals[d]
      ]);
      face.normal.add(normals[b]);
      face.normal.add(normals[c]);
      face.normal.add(normals[d]);
      face.normal.normalize();
      this.faces.push(face);
      this.faceVertexUvs[0].push([
        uvs[b].clone(),
        uvs[c].clone(),
        uvs[d].clone()
      ]);
    }
  }
  this.computeCentroids();
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry = function (radius, tube, radialSegments, tubularSegments, p, q, heightScale) {
  THREE.Geometry.call(this);
  var scope = this;
  this.radius = radius || 100;
  this.tube = tube || 40;
  this.radialSegments = radialSegments || 64;
  this.tubularSegments = tubularSegments || 8;
  this.p = p || 2;
  this.q = q || 3;
  this.heightScale = heightScale || 1;
  this.grid = new Array(this.radialSegments);
  var tang = new THREE.Vector3();
  var n = new THREE.Vector3();
  var bitan = new THREE.Vector3();
  for (var i = 0; i < this.radialSegments; ++i) {
    this.grid[i] = new Array(this.tubularSegments);
    var u = i / this.radialSegments * 2 * this.p * Math.PI;
    var p1 = getPos(u, this.q, this.p, this.radius, this.heightScale);
    var p2 = getPos(u + 0.01, this.q, this.p, this.radius, this.heightScale);
    tang.subVectors(p2, p1);
    n.addVectors(p2, p1);
    bitan.crossVectors(tang, n);
    n.crossVectors(bitan, tang);
    bitan.normalize();
    n.normalize();
    for (var j = 0; j < this.tubularSegments; ++j) {
      var v = j / this.tubularSegments * 2 * Math.PI;
      var cx = -this.tube * Math.cos(v);
      var cy = this.tube * Math.sin(v);
      var pos = new THREE.Vector3();
      pos.x = p1.x + cx * n.x + cy * bitan.x;
      pos.y = p1.y + cx * n.y + cy * bitan.y;
      pos.z = p1.z + cx * n.z + cy * bitan.z;
      this.grid[i][j] = scope.vertices.push(pos) - 1;
    }
  }
  for (var i = 0; i < this.radialSegments; ++i) {
    for (var j = 0; j < this.tubularSegments; ++j) {
      var ip = (i + 1) % this.radialSegments;
      var jp = (j + 1) % this.tubularSegments;
      var a = this.grid[i][j];
      var b = this.grid[ip][j];
      var c = this.grid[ip][jp];
      var d = this.grid[i][jp];
      var uva = new THREE.Vector2(i / this.radialSegments, j / this.tubularSegments);
      var uvb = new THREE.Vector2((i + 1) / this.radialSegments, j / this.tubularSegments);
      var uvc = new THREE.Vector2((i + 1) / this.radialSegments, (j + 1) / this.tubularSegments);
      var uvd = new THREE.Vector2(i / this.radialSegments, (j + 1) / this.tubularSegments);
      this.faces.push(new THREE.Face3(a, b, d));
      this.faceVertexUvs[0].push([
        uva,
        uvb,
        uvd
      ]);
      this.faces.push(new THREE.Face3(b, c, d));
      this.faceVertexUvs[0].push([
        uvb.clone(),
        uvc,
        uvd.clone()
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
  function getPos(u, in_q, in_p, radius, heightScale) {
    var cu = Math.cos(u);
    var su = Math.sin(u);
    var quOverP = in_q / in_p * u;
    var cs = Math.cos(quOverP);
    var tx = radius * (2 + cs) * 0.5 * cu;
    var ty = radius * (2 + cs) * su * 0.5;
    var tz = heightScale * radius * Math.sin(quOverP) * 0.5;
    return new THREE.Vector3(tx, ty, tz);
  }
};
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry = function (path, segments, radius, radialSegments, closed) {
  THREE.Geometry.call(this);
  this.path = path;
  this.segments = segments || 64;
  this.radius = radius || 1;
  this.radialSegments = radialSegments || 8;
  this.closed = closed || false;
  this.grid = [];
  var scope = this, tangent, normal, binormal, numpoints = this.segments + 1, x, y, z, tx, ty, tz, u, v, cx, cy, pos, pos2 = new THREE.Vector3(), i, j, ip, jp, a, b, c, d, uva, uvb, uvc, uvd;
  var frames = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;
  function vert(x, y, z) {
    return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;
  }
  for (i = 0; i < numpoints; i++) {
    this.grid[i] = [];
    u = i / (numpoints - 1);
    pos = path.getPointAt(u);
    tangent = tangents[i];
    normal = normals[i];
    binormal = binormals[i];
    for (j = 0; j < this.radialSegments; j++) {
      v = j / this.radialSegments * 2 * Math.PI;
      cx = -this.radius * Math.cos(v);
      cy = this.radius * Math.sin(v);
      pos2.copy(pos);
      pos2.x += cx * normal.x + cy * binormal.x;
      pos2.y += cx * normal.y + cy * binormal.y;
      pos2.z += cx * normal.z + cy * binormal.z;
      this.grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
    }
  }
  for (i = 0; i < this.segments; i++) {
    for (j = 0; j < this.radialSegments; j++) {
      ip = this.closed ? (i + 1) % this.segments : i + 1;
      jp = (j + 1) % this.radialSegments;
      a = this.grid[i][j];
      b = this.grid[ip][j];
      c = this.grid[ip][jp];
      d = this.grid[i][jp];
      uva = new THREE.Vector2(i / this.segments, j / this.radialSegments);
      uvb = new THREE.Vector2((i + 1) / this.segments, j / this.radialSegments);
      uvc = new THREE.Vector2((i + 1) / this.segments, (j + 1) / this.radialSegments);
      uvd = new THREE.Vector2(i / this.segments, (j + 1) / this.radialSegments);
      this.faces.push(new THREE.Face3(a, b, d));
      this.faceVertexUvs[0].push([
        uva,
        uvb,
        uvd
      ]);
      this.faces.push(new THREE.Face3(b, c, d));
      this.faceVertexUvs[0].push([
        uvb.clone(),
        uvc,
        uvd.clone()
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames = function (path, segments, closed) {
  var tangent = new THREE.Vector3(), normal = new THREE.Vector3(), binormal = new THREE.Vector3(), tangents = [], normals = [], binormals = [], vec = new THREE.Vector3(), mat = new THREE.Matrix4(), numpoints = segments + 1, theta, epsilon = 0.0001, smallest, tx, ty, tz, i, u, v;
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;
  for (i = 0; i < numpoints; i++) {
    u = i / (numpoints - 1);
    tangents[i] = path.getTangentAt(u);
    tangents[i].normalize();
  }
  initialNormal3();
  function initialNormal1(lastBinormal) {
    normals[0] = new THREE.Vector3();
    binormals[0] = new THREE.Vector3();
    if (lastBinormal === undefined)
      lastBinormal = new THREE.Vector3(0, 0, 1);
    normals[0].crossVectors(lastBinormal, tangents[0]).normalize();
    binormals[0].crossVectors(tangents[0], normals[0]).normalize();
  }
  function initialNormal2() {
    var t2 = path.getTangentAt(epsilon);
    normals[0] = new THREE.Vector3().subVectors(t2, tangents[0]).normalize();
    binormals[0] = new THREE.Vector3().crossVectors(tangents[0], normals[0]);
    normals[0].crossVectors(binormals[0], tangents[0]).normalize();
    binormals[0].crossVectors(tangents[0], normals[0]).normalize();
  }
  function initialNormal3() {
    normals[0] = new THREE.Vector3();
    binormals[0] = new THREE.Vector3();
    smallest = Number.MAX_VALUE;
    tx = Math.abs(tangents[0].x);
    ty = Math.abs(tangents[0].y);
    tz = Math.abs(tangents[0].z);
    if (tx <= smallest) {
      smallest = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= smallest) {
      smallest = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= smallest) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
  }
  for (i = 1; i < numpoints; i++) {
    normals[i] = normals[i - 1].clone();
    binormals[i] = binormals[i - 1].clone();
    vec.crossVectors(tangents[i - 1], tangents[i]);
    if (vec.length() > epsilon) {
      vec.normalize();
      theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
      normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
    }
    binormals[i].crossVectors(tangents[i], normals[i]);
  }
  if (closed) {
    theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
    theta /= numpoints - 1;
    if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
      theta = -theta;
    }
    for (i = 1; i < numpoints; i++) {
      normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
  }
};
THREE.PolyhedronGeometry = function (vertices, faces, radius, detail) {
  THREE.Geometry.call(this);
  radius = radius || 1;
  detail = detail || 0;
  var that = this;
  for (var i = 0, l = vertices.length; i < l; i++) {
    prepare(new THREE.Vector3(vertices[i][0], vertices[i][1], vertices[i][2]));
  }
  var midpoints = [], p = this.vertices;
  var f = [];
  for (var i = 0, l = faces.length; i < l; i++) {
    var v1 = p[faces[i][0]];
    var v2 = p[faces[i][1]];
    var v3 = p[faces[i][2]];
    f[i] = new THREE.Face3(v1.index, v2.index, v3.index, [
      v1.clone(),
      v2.clone(),
      v3.clone()
    ]);
  }
  for (var i = 0, l = f.length; i < l; i++) {
    subdivide(f[i], detail);
  }
  for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {
    var uvs = this.faceVertexUvs[0][i];
    var x0 = uvs[0].x;
    var x1 = uvs[1].x;
    var x2 = uvs[2].x;
    var max = Math.max(x0, Math.max(x1, x2));
    var min = Math.min(x0, Math.min(x1, x2));
    if (max > 0.9 && min < 0.1) {
      if (x0 < 0.2)
        uvs[0].x += 1;
      if (x1 < 0.2)
        uvs[1].x += 1;
      if (x2 < 0.2)
        uvs[2].x += 1;
    }
  }
  for (var i = 0, l = this.vertices.length; i < l; i++) {
    this.vertices[i].multiplyScalar(radius);
  }
  this.mergeVertices();
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
  function prepare(vector) {
    var vertex = vector.normalize().clone();
    vertex.index = that.vertices.push(vertex) - 1;
    var u = azimuth(vector) / 2 / Math.PI + 0.5;
    var v = inclination(vector) / Math.PI + 0.5;
    vertex.uv = new THREE.Vector2(u, 1 - v);
    return vertex;
  }
  function make(v1, v2, v3) {
    var face = new THREE.Face3(v1.index, v2.index, v3.index, [
        v1.clone(),
        v2.clone(),
        v3.clone()
      ]);
    face.centroid.add(v1).add(v2).add(v3).divideScalar(3);
    that.faces.push(face);
    var azi = azimuth(face.centroid);
    that.faceVertexUvs[0].push([
      correctUV(v1.uv, v1, azi),
      correctUV(v2.uv, v2, azi),
      correctUV(v3.uv, v3, azi)
    ]);
  }
  function subdivide(face, detail) {
    var cols = Math.pow(2, detail);
    var cells = Math.pow(4, detail);
    var a = prepare(that.vertices[face.a]);
    var b = prepare(that.vertices[face.b]);
    var c = prepare(that.vertices[face.c]);
    var v = [];
    for (var i = 0; i <= cols; i++) {
      v[i] = [];
      var aj = prepare(a.clone().lerp(c, i / cols));
      var bj = prepare(b.clone().lerp(c, i / cols));
      var rows = cols - i;
      for (var j = 0; j <= rows; j++) {
        if (j == 0 && i == cols) {
          v[i][j] = aj;
        } else {
          v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
        }
      }
    }
    for (var i = 0; i < cols; i++) {
      for (var j = 0; j < 2 * (cols - i) - 1; j++) {
        var k = Math.floor(j / 2);
        if (j % 2 == 0) {
          make(v[i][k + 1], v[i + 1][k], v[i][k]);
        } else {
          make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);
        }
      }
    }
  }
  function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
  }
  function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
  }
  function correctUV(uv, vector, azimuth) {
    if (azimuth < 0 && uv.x === 1)
      uv = new THREE.Vector2(uv.x - 1, uv.y);
    if (vector.x === 0 && vector.z === 0)
      uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
    return uv.clone();
  }
};
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.IcosahedronGeometry = function (radius, detail) {
  this.radius = radius;
  this.detail = detail;
  var t = (1 + Math.sqrt(5)) / 2;
  var vertices = [
      [
        -1,
        t,
        0
      ],
      [
        1,
        t,
        0
      ],
      [
        -1,
        -t,
        0
      ],
      [
        1,
        -t,
        0
      ],
      [
        0,
        -1,
        t
      ],
      [
        0,
        1,
        t
      ],
      [
        0,
        -1,
        -t
      ],
      [
        0,
        1,
        -t
      ],
      [
        t,
        0,
        -1
      ],
      [
        t,
        0,
        1
      ],
      [
        -t,
        0,
        -1
      ],
      [
        -t,
        0,
        1
      ]
    ];
  var faces = [
      [
        0,
        11,
        5
      ],
      [
        0,
        5,
        1
      ],
      [
        0,
        1,
        7
      ],
      [
        0,
        7,
        10
      ],
      [
        0,
        10,
        11
      ],
      [
        1,
        5,
        9
      ],
      [
        5,
        11,
        4
      ],
      [
        11,
        10,
        2
      ],
      [
        10,
        7,
        6
      ],
      [
        7,
        1,
        8
      ],
      [
        3,
        9,
        4
      ],
      [
        3,
        4,
        2
      ],
      [
        3,
        2,
        6
      ],
      [
        3,
        6,
        8
      ],
      [
        3,
        8,
        9
      ],
      [
        4,
        9,
        5
      ],
      [
        2,
        4,
        11
      ],
      [
        6,
        2,
        10
      ],
      [
        8,
        6,
        7
      ],
      [
        9,
        8,
        1
      ]
    ];
  THREE.PolyhedronGeometry.call(this, vertices, faces, radius, detail);
};
THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.OctahedronGeometry = function (radius, detail) {
  var vertices = [
      [
        1,
        0,
        0
      ],
      [
        -1,
        0,
        0
      ],
      [
        0,
        1,
        0
      ],
      [
        0,
        -1,
        0
      ],
      [
        0,
        0,
        1
      ],
      [
        0,
        0,
        -1
      ]
    ];
  var faces = [
      [
        0,
        2,
        4
      ],
      [
        0,
        4,
        3
      ],
      [
        0,
        3,
        5
      ],
      [
        0,
        5,
        2
      ],
      [
        1,
        2,
        5
      ],
      [
        1,
        5,
        3
      ],
      [
        1,
        3,
        4
      ],
      [
        1,
        4,
        2
      ]
    ];
  THREE.PolyhedronGeometry.call(this, vertices, faces, radius, detail);
};
THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TetrahedronGeometry = function (radius, detail) {
  var vertices = [
      [
        1,
        1,
        1
      ],
      [
        -1,
        -1,
        1
      ],
      [
        -1,
        1,
        -1
      ],
      [
        1,
        -1,
        -1
      ]
    ];
  var faces = [
      [
        2,
        1,
        0
      ],
      [
        0,
        3,
        2
      ],
      [
        1,
        3,
        0
      ],
      [
        2,
        3,
        1
      ]
    ];
  THREE.PolyhedronGeometry.call(this, vertices, faces, radius, detail);
};
THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry = function (func, slices, stacks) {
  THREE.Geometry.call(this);
  var verts = this.vertices;
  var faces = this.faces;
  var uvs = this.faceVertexUvs[0];
  var i, il, j, p;
  var u, v;
  var stackCount = stacks + 1;
  var sliceCount = slices + 1;
  for (i = 0; i <= stacks; i++) {
    v = i / stacks;
    for (j = 0; j <= slices; j++) {
      u = j / slices;
      p = func(u, v);
      verts.push(p);
    }
  }
  var a, b, c, d;
  var uva, uvb, uvc, uvd;
  for (i = 0; i < stacks; i++) {
    for (j = 0; j < slices; j++) {
      a = i * sliceCount + j;
      b = i * sliceCount + j + 1;
      c = (i + 1) * sliceCount + j + 1;
      d = (i + 1) * sliceCount + j;
      uva = new THREE.Vector2(j / slices, i / stacks);
      uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
      uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
      uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);
      faces.push(new THREE.Face3(a, b, d));
      uvs.push([
        uva,
        uvb,
        uvd
      ]);
      faces.push(new THREE.Face3(b, c, d));
      uvs.push([
        uvb.clone(),
        uvc,
        uvd.clone()
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.AxisHelper = function (size) {
  size = size || 1;
  var geometry = new THREE.Geometry();
  geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3(size, 0, 0), new THREE.Vector3(), new THREE.Vector3(0, size, 0), new THREE.Vector3(), new THREE.Vector3(0, 0, size));
  geometry.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
  var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  THREE.Line.call(this, geometry, material, THREE.LinePieces);
};
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ArrowHelper = function (dir, origin, length, hex) {
  THREE.Object3D.call(this);
  if (hex === undefined)
    hex = 16776960;
  if (length === undefined)
    length = 1;
  this.position = origin;
  var lineGeometry = new THREE.Geometry();
  lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0));
  lineGeometry.vertices.push(new THREE.Vector3(0, 1, 0));
  this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ color: hex }));
  this.line.matrixAutoUpdate = false;
  this.add(this.line);
  var coneGeometry = new THREE.CylinderGeometry(0, 0.05, 0.25, 5, 1);
  coneGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.875, 0));
  this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({ color: hex }));
  this.cone.matrixAutoUpdate = false;
  this.add(this.cone);
  this.setDirection(dir);
  this.setLength(length);
};
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.setDirection = function () {
  var axis = new THREE.Vector3();
  var radians;
  return function (dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      axis.set(dir.z, 0, -dir.x).normalize();
      radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(axis, radians);
    }
  };
}();
THREE.ArrowHelper.prototype.setLength = function (length) {
  this.scale.set(length, length, length);
};
THREE.ArrowHelper.prototype.setColor = function (hex) {
  this.line.material.color.setHex(hex);
  this.cone.material.color.setHex(hex);
};
THREE.BoxHelper = function (object) {
  var vertices = [
      new THREE.Vector3(1, 1, 1),
      new THREE.Vector3(-1, 1, 1),
      new THREE.Vector3(-1, -1, 1),
      new THREE.Vector3(1, -1, 1),
      new THREE.Vector3(1, 1, -1),
      new THREE.Vector3(-1, 1, -1),
      new THREE.Vector3(-1, -1, -1),
      new THREE.Vector3(1, -1, -1)
    ];
  this.vertices = vertices;
  var geometry = new THREE.Geometry();
  geometry.vertices.push(vertices[0], vertices[1], vertices[1], vertices[2], vertices[2], vertices[3], vertices[3], vertices[0], vertices[4], vertices[5], vertices[5], vertices[6], vertices[6], vertices[7], vertices[7], vertices[4], vertices[0], vertices[4], vertices[1], vertices[5], vertices[2], vertices[6], vertices[3], vertices[7]);
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({ color: 16776960 }), THREE.LinePieces);
  if (object !== undefined) {
    this.update(object);
  }
};
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update = function (object) {
  var geometry = object.geometry;
  if (geometry.boundingBox === null) {
    geometry.computeBoundingBox();
  }
  var min = geometry.boundingBox.min;
  var max = geometry.boundingBox.max;
  var vertices = this.vertices;
  vertices[0].set(max.x, max.y, max.z);
  vertices[1].set(min.x, max.y, max.z);
  vertices[2].set(min.x, min.y, max.z);
  vertices[3].set(max.x, min.y, max.z);
  vertices[4].set(max.x, max.y, min.z);
  vertices[5].set(min.x, max.y, min.z);
  vertices[6].set(min.x, min.y, min.z);
  vertices[7].set(max.x, min.y, min.z);
  this.geometry.computeBoundingSphere();
  this.geometry.verticesNeedUpdate = true;
  this.matrixAutoUpdate = false;
  this.matrixWorld = object.matrixWorld;
};
THREE.BoundingBoxHelper = function (object, hex) {
  var color = hex || 8947848;
  this.object = object;
  this.box = new THREE.Box3();
  THREE.Mesh.call(this, new THREE.CubeGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
    color: color,
    wireframe: true
  }));
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.update = function () {
  this.box.setFromObject(this.object);
  this.box.size(this.scale);
  this.box.center(this.position);
};
THREE.CameraHelper = function (camera) {
  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial({
      color: 16777215,
      vertexColors: THREE.FaceColors
    });
  var pointMap = {};
  var hexFrustum = 16755200;
  var hexCone = 16711680;
  var hexUp = 43775;
  var hexTarget = 16777215;
  var hexCross = 3355443;
  addLine('n1', 'n2', hexFrustum);
  addLine('n2', 'n4', hexFrustum);
  addLine('n4', 'n3', hexFrustum);
  addLine('n3', 'n1', hexFrustum);
  addLine('f1', 'f2', hexFrustum);
  addLine('f2', 'f4', hexFrustum);
  addLine('f4', 'f3', hexFrustum);
  addLine('f3', 'f1', hexFrustum);
  addLine('n1', 'f1', hexFrustum);
  addLine('n2', 'f2', hexFrustum);
  addLine('n3', 'f3', hexFrustum);
  addLine('n4', 'f4', hexFrustum);
  addLine('p', 'n1', hexCone);
  addLine('p', 'n2', hexCone);
  addLine('p', 'n3', hexCone);
  addLine('p', 'n4', hexCone);
  addLine('u1', 'u2', hexUp);
  addLine('u2', 'u3', hexUp);
  addLine('u3', 'u1', hexUp);
  addLine('c', 't', hexTarget);
  addLine('p', 'c', hexCross);
  addLine('cn1', 'cn2', hexCross);
  addLine('cn3', 'cn4', hexCross);
  addLine('cf1', 'cf2', hexCross);
  addLine('cf3', 'cf4', hexCross);
  function addLine(a, b, hex) {
    addPoint(a, hex);
    addPoint(b, hex);
  }
  function addPoint(id, hex) {
    geometry.vertices.push(new THREE.Vector3());
    geometry.colors.push(new THREE.Color(hex));
    if (pointMap[id] === undefined) {
      pointMap[id] = [];
    }
    pointMap[id].push(geometry.vertices.length - 1);
  }
  THREE.Line.call(this, geometry, material, THREE.LinePieces);
  this.camera = camera;
  this.matrixWorld = camera.matrixWorld;
  this.matrixAutoUpdate = false;
  this.pointMap = pointMap;
  this.update();
};
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update = function () {
  var vector = new THREE.Vector3();
  var camera = new THREE.Camera();
  var projector = new THREE.Projector();
  return function () {
    var scope = this;
    var w = 1, h = 1;
    camera.projectionMatrix.copy(this.camera.projectionMatrix);
    setPoint('c', 0, 0, -1);
    setPoint('t', 0, 0, 1);
    setPoint('n1', -w, -h, -1);
    setPoint('n2', w, -h, -1);
    setPoint('n3', -w, h, -1);
    setPoint('n4', w, h, -1);
    setPoint('f1', -w, -h, 1);
    setPoint('f2', w, -h, 1);
    setPoint('f3', -w, h, 1);
    setPoint('f4', w, h, 1);
    setPoint('u1', w * 0.7, h * 1.1, -1);
    setPoint('u2', -w * 0.7, h * 1.1, -1);
    setPoint('u3', 0, h * 2, -1);
    setPoint('cf1', -w, 0, 1);
    setPoint('cf2', w, 0, 1);
    setPoint('cf3', 0, -h, 1);
    setPoint('cf4', 0, h, 1);
    setPoint('cn1', -w, 0, -1);
    setPoint('cn2', w, 0, -1);
    setPoint('cn3', 0, -h, -1);
    setPoint('cn4', 0, h, -1);
    function setPoint(point, x, y, z) {
      vector.set(x, y, z);
      projector.unprojectVector(vector, camera);
      var points = scope.pointMap[point];
      if (points !== undefined) {
        for (var i = 0, il = points.length; i < il; i++) {
          scope.geometry.vertices[points[i]].copy(vector);
        }
      }
    }
    this.geometry.verticesNeedUpdate = true;
  };
}();
THREE.DirectionalLightHelper = function (light, size) {
  THREE.Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrixWorld = light.matrixWorld;
  this.matrixAutoUpdate = false;
  var geometry = new THREE.PlaneGeometry(size, size);
  var material = new THREE.MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
  material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.lightPlane = new THREE.Mesh(geometry, material);
  this.add(this.lightPlane);
  geometry = new THREE.Geometry();
  geometry.vertices.push(new THREE.Vector3());
  geometry.vertices.push(new THREE.Vector3());
  geometry.computeLineDistances();
  material = new THREE.LineBasicMaterial({ fog: false });
  material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.targetLine = new THREE.Line(geometry, material);
  this.add(this.targetLine);
  this.update();
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.dispose = function () {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};
THREE.DirectionalLightHelper.prototype.update = function () {
  var vector = new THREE.Vector3();
  return function () {
    vector.getPositionFromMatrix(this.light.matrixWorld).negate();
    this.lightPlane.lookAt(vector);
    this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine.geometry.vertices[1].copy(vector);
    this.targetLine.geometry.verticesNeedUpdate = true;
    this.targetLine.material.color.copy(this.lightPlane.material.color);
  };
}();
THREE.FaceNormalsHelper = function (object, size, hex, linewidth) {
  this.object = object;
  this.size = size || 1;
  var color = hex || 16776960;
  var width = linewidth || 1;
  var geometry = new THREE.Geometry();
  var faces = this.object.geometry.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    geometry.vertices.push(new THREE.Vector3());
    geometry.vertices.push(new THREE.Vector3());
  }
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
    color: color,
    linewidth: width
  }), THREE.LinePieces);
  this.matrixAutoUpdate = false;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update = function (object) {
  var v1 = new THREE.Vector3();
  return function (object) {
    this.object.updateMatrixWorld(true);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var vertices = this.geometry.vertices;
    var faces = this.object.geometry.faces;
    var worldMatrix = this.object.matrixWorld;
    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      v1.copy(face.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
      var idx = 2 * i;
      vertices[idx].copy(face.centroid).applyMatrix4(worldMatrix);
      vertices[idx + 1].addVectors(vertices[idx], v1);
    }
    this.geometry.verticesNeedUpdate = true;
    return this;
  };
}();
THREE.GridHelper = function (size, step) {
  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  this.color1 = new THREE.Color(4473924);
  this.color2 = new THREE.Color(8947848);
  for (var i = -size; i <= size; i += step) {
    geometry.vertices.push(new THREE.Vector3(-size, 0, i), new THREE.Vector3(size, 0, i), new THREE.Vector3(i, 0, -size), new THREE.Vector3(i, 0, size));
    var color = i === 0 ? this.color1 : this.color2;
    geometry.colors.push(color, color, color, color);
  }
  THREE.Line.call(this, geometry, material, THREE.LinePieces);
};
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors = function (colorCenterLine, colorGrid) {
  this.color1.set(colorCenterLine);
  this.color2.set(colorGrid);
  this.geometry.colorsNeedUpdate = true;
};
THREE.HemisphereLightHelper = function (light, sphereSize, arrowLength, domeSize) {
  THREE.Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrixWorld = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.colors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
  geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  for (var i = 0, il = 8; i < il; i++) {
    geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
  }
  var material = new THREE.MeshBasicMaterial({
      vertexColors: THREE.FaceColors,
      wireframe: true
    });
  this.lightSphere = new THREE.Mesh(geometry, material);
  this.add(this.lightSphere);
  this.update();
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.dispose = function () {
  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();
};
THREE.HemisphereLightHelper.prototype.update = function () {
  var vector = new THREE.Vector3();
  return function () {
    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
    this.lightSphere.lookAt(vector.getPositionFromMatrix(this.light.matrixWorld).negate());
    this.lightSphere.geometry.colorsNeedUpdate = true;
  };
}();
THREE.PointLightHelper = function (light, sphereSize) {
  this.light = light;
  this.light.updateMatrixWorld();
  var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
  var material = new THREE.MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
  material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  THREE.Mesh.call(this, geometry, material);
  this.matrixWorld = this.light.matrixWorld;
  this.matrixAutoUpdate = false;
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
};
THREE.PointLightHelper.prototype.update = function () {
  this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};
THREE.SpotLightHelper = function (light) {
  THREE.Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrixWorld = light.matrixWorld;
  this.matrixAutoUpdate = false;
  var geometry = new THREE.CylinderGeometry(0, 1, 1, 8, 1, true);
  geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
  geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  var material = new THREE.MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
  this.cone = new THREE.Mesh(geometry, material);
  this.add(this.cone);
  this.update();
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};
THREE.SpotLightHelper.prototype.update = function () {
  var vector = new THREE.Vector3();
  var vector2 = new THREE.Vector3();
  return function () {
    var coneLength = this.light.distance ? this.light.distance : 10000;
    var coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    vector.getPositionFromMatrix(this.light.matrixWorld);
    vector2.getPositionFromMatrix(this.light.target.matrixWorld);
    this.cone.lookAt(vector2.sub(vector));
    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  };
}();
THREE.VertexNormalsHelper = function (object, size, hex, linewidth) {
  this.object = object;
  this.size = size || 1;
  var color = hex || 16711680;
  var width = linewidth || 1;
  var geometry = new THREE.Geometry();
  var vertices = object.geometry.vertices;
  var faces = object.geometry.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
      geometry.vertices.push(new THREE.Vector3());
      geometry.vertices.push(new THREE.Vector3());
    }
  }
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
    color: color,
    linewidth: width
  }), THREE.LinePieces);
  this.matrixAutoUpdate = false;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update = function (object) {
  var v1 = new THREE.Vector3();
  return function (object) {
    var keys = [
        'a',
        'b',
        'c',
        'd'
      ];
    this.object.updateMatrixWorld(true);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var vertices = this.geometry.vertices;
    var verts = this.object.geometry.vertices;
    var faces = this.object.geometry.faces;
    var worldMatrix = this.object.matrixWorld;
    var idx = 0;
    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        var vertexId = face[keys[j]];
        var vertex = verts[vertexId];
        var normal = face.vertexNormals[j];
        vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
        v1.copy(normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
        v1.add(vertices[idx]);
        idx = idx + 1;
        vertices[idx].copy(v1);
        idx = idx + 1;
      }
    }
    this.geometry.verticesNeedUpdate = true;
    return this;
  };
}();
THREE.VertexTangentsHelper = function (object, size, hex, linewidth) {
  this.object = object;
  this.size = size || 1;
  var color = hex || 255;
  var width = linewidth || 1;
  var geometry = new THREE.Geometry();
  var vertices = object.geometry.vertices;
  var faces = object.geometry.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    for (var j = 0, jl = face.vertexTangents.length; j < jl; j++) {
      geometry.vertices.push(new THREE.Vector3());
      geometry.vertices.push(new THREE.Vector3());
    }
  }
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
    color: color,
    linewidth: width
  }), THREE.LinePieces);
  this.matrixAutoUpdate = false;
  this.update();
};
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update = function (object) {
  var v1 = new THREE.Vector3();
  return function (object) {
    var keys = [
        'a',
        'b',
        'c',
        'd'
      ];
    this.object.updateMatrixWorld(true);
    var vertices = this.geometry.vertices;
    var verts = this.object.geometry.vertices;
    var faces = this.object.geometry.faces;
    var worldMatrix = this.object.matrixWorld;
    var idx = 0;
    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      for (var j = 0, jl = face.vertexTangents.length; j < jl; j++) {
        var vertexId = face[keys[j]];
        var vertex = verts[vertexId];
        var tangent = face.vertexTangents[j];
        vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
        v1.copy(tangent).transformDirection(worldMatrix).multiplyScalar(this.size);
        v1.add(vertices[idx]);
        idx = idx + 1;
        vertices[idx].copy(v1);
        idx = idx + 1;
      }
    }
    this.geometry.verticesNeedUpdate = true;
    return this;
  };
}();
THREE.WireframeHelper = function (object) {
  var edge = [
      0,
      0
    ], hash = {};
  var sortFunction = function (a, b) {
    return a - b;
  };
  var keys = [
      'a',
      'b',
      'c',
      'd'
    ];
  var geometry = new THREE.Geometry();
  var vertices = object.geometry.vertices;
  var faces = object.geometry.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    for (var j = 0; j < 3; j++) {
      edge[0] = face[keys[j]];
      edge[1] = face[keys[(j + 1) % 3]];
      edge.sort(sortFunction);
      var key = edge.toString();
      if (hash[key] === undefined) {
        geometry.vertices.push(vertices[edge[0]]);
        geometry.vertices.push(vertices[edge[1]]);
        hash[key] = true;
      }
    }
  }
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({ color: 16777215 }), THREE.LinePieces);
  this.matrixAutoUpdate = false;
  this.matrixWorld = object.matrixWorld;
};
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ImmediateRenderObject = function () {
  THREE.Object3D.call(this);
  this.render = function (renderCallback) {
  };
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare = function (texture, size, distance, blending, color) {
  THREE.Object3D.call(this);
  this.lensFlares = [];
  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = undefined;
  if (texture !== undefined) {
    this.add(texture, size, distance, blending, color);
  }
};
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.add = function (texture, size, distance, blending, color, opacity) {
  if (size === undefined)
    size = -1;
  if (distance === undefined)
    distance = 0;
  if (opacity === undefined)
    opacity = 1;
  if (color === undefined)
    color = new THREE.Color(16777215);
  if (blending === undefined)
    blending = THREE.NormalBlending;
  distance = Math.min(distance, Math.max(0, distance));
  this.lensFlares.push({
    texture: texture,
    size: size,
    distance: distance,
    x: 0,
    y: 0,
    z: 0,
    scale: 1,
    rotation: 1,
    opacity: opacity,
    color: color,
    blending: blending
  });
};
THREE.LensFlare.prototype.updateLensFlares = function () {
  var f, fl = this.lensFlares.length;
  var flare;
  var vecX = -this.positionScreen.x * 2;
  var vecY = -this.positionScreen.y * 2;
  for (f = 0; f < fl; f++) {
    flare = this.lensFlares[f];
    flare.x = this.positionScreen.x + vecX * flare.distance;
    flare.y = this.positionScreen.y + vecY * flare.distance;
    flare.wantedRotation = flare.x * Math.PI * 0.25;
    flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
  }
};
THREE.MorphBlendMesh = function (geometry, material) {
  THREE.Mesh.call(this, geometry, material);
  this.animationsMap = {};
  this.animationsList = [];
  var numFrames = this.geometry.morphTargets.length;
  var name = '__default';
  var startFrame = 0;
  var endFrame = numFrames - 1;
  var fps = numFrames / 1;
  this.createAnimation(name, startFrame, endFrame, fps);
  this.setAnimationWeight(name, 1);
};
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.createAnimation = function (name, start, end, fps) {
  var animation = {
      startFrame: start,
      endFrame: end,
      length: end - start + 1,
      fps: fps,
      duration: (end - start) / fps,
      lastFrame: 0,
      currentFrame: 0,
      active: false,
      time: 0,
      direction: 1,
      weight: 1,
      directionBackwards: false,
      mirroredLoop: false
    };
  this.animationsMap[name] = animation;
  this.animationsList.push(animation);
};
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (fps) {
  var pattern = /([a-z]+)(\d+)/;
  var firstAnimation, frameRanges = {};
  var geometry = this.geometry;
  for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
    var morph = geometry.morphTargets[i];
    var chunks = morph.name.match(pattern);
    if (chunks && chunks.length > 1) {
      var name = chunks[1];
      var num = chunks[2];
      if (!frameRanges[name])
        frameRanges[name] = {
          start: Infinity,
          end: -Infinity
        };
      var range = frameRanges[name];
      if (i < range.start)
        range.start = i;
      if (i > range.end)
        range.end = i;
      if (!firstAnimation)
        firstAnimation = name;
    }
  }
  for (var name in frameRanges) {
    var range = frameRanges[name];
    this.createAnimation(name, range.start, range.end, fps);
  }
  this.firstAnimation = firstAnimation;
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (name) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.direction = 1;
    animation.directionBackwards = false;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (name) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.direction = -1;
    animation.directionBackwards = true;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationFPS = function (name, fps) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.fps = fps;
    animation.duration = (animation.end - animation.start) / animation.fps;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationDuration = function (name, duration) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.duration = duration;
    animation.fps = (animation.end - animation.start) / animation.duration;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationWeight = function (name, weight) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.weight = weight;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationTime = function (name, time) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.time = time;
  }
};
THREE.MorphBlendMesh.prototype.getAnimationTime = function (name) {
  var time = 0;
  var animation = this.animationsMap[name];
  if (animation) {
    time = animation.time;
  }
  return time;
};
THREE.MorphBlendMesh.prototype.getAnimationDuration = function (name) {
  var duration = -1;
  var animation = this.animationsMap[name];
  if (animation) {
    duration = animation.duration;
  }
  return duration;
};
THREE.MorphBlendMesh.prototype.playAnimation = function (name) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.time = 0;
    animation.active = true;
  } else {
    console.warn('animation[' + name + '] undefined');
  }
};
THREE.MorphBlendMesh.prototype.stopAnimation = function (name) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.active = false;
  }
};
THREE.MorphBlendMesh.prototype.update = function (delta) {
  for (var i = 0, il = this.animationsList.length; i < il; i++) {
    var animation = this.animationsList[i];
    if (!animation.active)
      continue;
    var frameTime = animation.duration / animation.length;
    animation.time += animation.direction * delta;
    if (animation.mirroredLoop) {
      if (animation.time > animation.duration || animation.time < 0) {
        animation.direction *= -1;
        if (animation.time > animation.duration) {
          animation.time = animation.duration;
          animation.directionBackwards = true;
        }
        if (animation.time < 0) {
          animation.time = 0;
          animation.directionBackwards = false;
        }
      }
    } else {
      animation.time = animation.time % animation.duration;
      if (animation.time < 0)
        animation.time += animation.duration;
    }
    var keyframe = animation.startFrame + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
    var weight = animation.weight;
    if (keyframe !== animation.currentFrame) {
      this.morphTargetInfluences[animation.lastFrame] = 0;
      this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
      this.morphTargetInfluences[keyframe] = 0;
      animation.lastFrame = animation.currentFrame;
      animation.currentFrame = keyframe;
    }
    var mix = animation.time % frameTime / frameTime;
    if (animation.directionBackwards)
      mix = 1 - mix;
    this.morphTargetInfluences[animation.currentFrame] = mix * weight;
    this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
  }
};
THREE.LensFlarePlugin = function () {
  var _gl, _renderer, _precision, _lensFlare = {};
  this.init = function (renderer) {
    _gl = renderer.context;
    _renderer = renderer;
    _precision = renderer.getPrecision();
    _lensFlare.vertices = new Float32Array(8 + 8);
    _lensFlare.faces = new Uint16Array(6);
    var i = 0;
    _lensFlare.vertices[i++] = -1;
    _lensFlare.vertices[i++] = -1;
    _lensFlare.vertices[i++] = 0;
    _lensFlare.vertices[i++] = 0;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = -1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 0;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = -1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 0;
    _lensFlare.vertices[i++] = 1;
    i = 0;
    _lensFlare.faces[i++] = 0;
    _lensFlare.faces[i++] = 1;
    _lensFlare.faces[i++] = 2;
    _lensFlare.faces[i++] = 0;
    _lensFlare.faces[i++] = 2;
    _lensFlare.faces[i++] = 3;
    _lensFlare.vertexBuffer = _gl.createBuffer();
    _lensFlare.elementBuffer = _gl.createBuffer();
    _gl.bindBuffer(_gl.ARRAY_BUFFER, _lensFlare.vertexBuffer);
    _gl.bufferData(_gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW);
    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer);
    _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW);
    _lensFlare.tempTexture = _gl.createTexture();
    _lensFlare.occlusionTexture = _gl.createTexture();
    _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.tempTexture);
    _gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST);
    _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.occlusionTexture);
    _gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST);
    if (_gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) <= 0) {
      _lensFlare.hasVertexTexture = false;
      _lensFlare.program = createProgram(THREE.ShaderFlares['lensFlare'], _precision);
    } else {
      _lensFlare.hasVertexTexture = true;
      _lensFlare.program = createProgram(THREE.ShaderFlares['lensFlareVertexTexture'], _precision);
    }
    _lensFlare.attributes = {};
    _lensFlare.uniforms = {};
    _lensFlare.attributes.vertex = _gl.getAttribLocation(_lensFlare.program, 'position');
    _lensFlare.attributes.uv = _gl.getAttribLocation(_lensFlare.program, 'uv');
    _lensFlare.uniforms.renderType = _gl.getUniformLocation(_lensFlare.program, 'renderType');
    _lensFlare.uniforms.map = _gl.getUniformLocation(_lensFlare.program, 'map');
    _lensFlare.uniforms.occlusionMap = _gl.getUniformLocation(_lensFlare.program, 'occlusionMap');
    _lensFlare.uniforms.opacity = _gl.getUniformLocation(_lensFlare.program, 'opacity');
    _lensFlare.uniforms.color = _gl.getUniformLocation(_lensFlare.program, 'color');
    _lensFlare.uniforms.scale = _gl.getUniformLocation(_lensFlare.program, 'scale');
    _lensFlare.uniforms.rotation = _gl.getUniformLocation(_lensFlare.program, 'rotation');
    _lensFlare.uniforms.screenPosition = _gl.getUniformLocation(_lensFlare.program, 'screenPosition');
  };
  this.render = function (scene, camera, viewportWidth, viewportHeight) {
    var flares = scene.__webglFlares, nFlares = flares.length;
    if (!nFlares)
      return;
    var tempPosition = new THREE.Vector3();
    var invAspect = viewportHeight / viewportWidth, halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5;
    var size = 16 / viewportHeight, scale = new THREE.Vector2(size * invAspect, size);
    var screenPosition = new THREE.Vector3(1, 1, 0), screenPositionPixels = new THREE.Vector2(1, 1);
    var uniforms = _lensFlare.uniforms, attributes = _lensFlare.attributes;
    _gl.useProgram(_lensFlare.program);
    _gl.enableVertexAttribArray(_lensFlare.attributes.vertex);
    _gl.enableVertexAttribArray(_lensFlare.attributes.uv);
    _gl.uniform1i(uniforms.occlusionMap, 0);
    _gl.uniform1i(uniforms.map, 1);
    _gl.bindBuffer(_gl.ARRAY_BUFFER, _lensFlare.vertexBuffer);
    _gl.vertexAttribPointer(attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0);
    _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8);
    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer);
    _gl.disable(_gl.CULL_FACE);
    _gl.depthMask(false);
    var i, j, jl, flare, sprite;
    for (i = 0; i < nFlares; i++) {
      size = 16 / viewportHeight;
      scale.set(size * invAspect, size);
      flare = flares[i];
      tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
      tempPosition.applyMatrix4(camera.matrixWorldInverse);
      tempPosition.applyProjection(camera.projectionMatrix);
      screenPosition.copy(tempPosition);
      screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
      screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
      if (_lensFlare.hasVertexTexture || screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight) {
        _gl.activeTexture(_gl.TEXTURE1);
        _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.tempTexture);
        _gl.copyTexImage2D(_gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
        _gl.uniform1i(uniforms.renderType, 0);
        _gl.uniform2f(uniforms.scale, scale.x, scale.y);
        _gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
        _gl.disable(_gl.BLEND);
        _gl.enable(_gl.DEPTH_TEST);
        _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);
        _gl.activeTexture(_gl.TEXTURE0);
        _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.occlusionTexture);
        _gl.copyTexImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
        _gl.uniform1i(uniforms.renderType, 1);
        _gl.disable(_gl.DEPTH_TEST);
        _gl.activeTexture(_gl.TEXTURE1);
        _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.tempTexture);
        _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);
        flare.positionScreen.copy(screenPosition);
        if (flare.customUpdateCallback) {
          flare.customUpdateCallback(flare);
        } else {
          flare.updateLensFlares();
        }
        _gl.uniform1i(uniforms.renderType, 2);
        _gl.enable(_gl.BLEND);
        for (j = 0, jl = flare.lensFlares.length; j < jl; j++) {
          sprite = flare.lensFlares[j];
          if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
            screenPosition.x = sprite.x;
            screenPosition.y = sprite.y;
            screenPosition.z = sprite.z;
            size = sprite.size * sprite.scale / viewportHeight;
            scale.x = size * invAspect;
            scale.y = size;
            _gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
            _gl.uniform2f(uniforms.scale, scale.x, scale.y);
            _gl.uniform1f(uniforms.rotation, sprite.rotation);
            _gl.uniform1f(uniforms.opacity, sprite.opacity);
            _gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
            _renderer.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
            _renderer.setTexture(sprite.texture, 1);
            _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);
          }
        }
      }
    }
    _gl.enable(_gl.CULL_FACE);
    _gl.enable(_gl.DEPTH_TEST);
    _gl.depthMask(true);
  };
  function createProgram(shader, precision) {
    var program = _gl.createProgram();
    var fragmentShader = _gl.createShader(_gl.FRAGMENT_SHADER);
    var vertexShader = _gl.createShader(_gl.VERTEX_SHADER);
    var prefix = 'precision ' + precision + ' float;\n';
    _gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
    _gl.shaderSource(vertexShader, prefix + shader.vertexShader);
    _gl.compileShader(fragmentShader);
    _gl.compileShader(vertexShader);
    _gl.attachShader(program, fragmentShader);
    _gl.attachShader(program, vertexShader);
    _gl.linkProgram(program);
    return program;
  }
  ;
};
THREE.ShadowMapPlugin = function () {
  var _gl, _renderer, _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4(), _min = new THREE.Vector3(), _max = new THREE.Vector3(), _matrixPosition = new THREE.Vector3();
  this.init = function (renderer) {
    _gl = renderer.context;
    _renderer = renderer;
    var depthShader = THREE.ShaderLib['depthRGBA'];
    var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
    _depthMaterial = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms
    });
    _depthMaterialMorph = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      morphTargets: true
    });
    _depthMaterialSkin = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      skinning: true
    });
    _depthMaterialMorphSkin = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      morphTargets: true,
      skinning: true
    });
    _depthMaterial._shadowPass = true;
    _depthMaterialMorph._shadowPass = true;
    _depthMaterialSkin._shadowPass = true;
    _depthMaterialMorphSkin._shadowPass = true;
  };
  this.render = function (scene, camera) {
    if (!(_renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate))
      return;
    this.update(scene, camera);
  };
  this.update = function (scene, camera) {
    var i, il, j, jl, n, shadowMap, shadowMatrix, shadowCamera, program, buffer, material, webglObject, object, light, renderList, lights = [], k = 0, fog = null;
    _gl.clearColor(1, 1, 1, 1);
    _gl.disable(_gl.BLEND);
    _gl.enable(_gl.CULL_FACE);
    _gl.frontFace(_gl.CCW);
    if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
      _gl.cullFace(_gl.FRONT);
    } else {
      _gl.cullFace(_gl.BACK);
    }
    _renderer.setDepthTest(true);
    for (i = 0, il = scene.__lights.length; i < il; i++) {
      light = scene.__lights[i];
      if (!light.castShadow)
        continue;
      if (light instanceof THREE.DirectionalLight && light.shadowCascade) {
        for (n = 0; n < light.shadowCascadeCount; n++) {
          var virtualLight;
          if (!light.shadowCascadeArray[n]) {
            virtualLight = createVirtualLight(light, n);
            virtualLight.originalCamera = camera;
            var gyro = new THREE.Gyroscope();
            gyro.position = light.shadowCascadeOffset;
            gyro.add(virtualLight);
            gyro.add(virtualLight.target);
            camera.add(gyro);
            light.shadowCascadeArray[n] = virtualLight;
            console.log('Created virtualLight', virtualLight);
          } else {
            virtualLight = light.shadowCascadeArray[n];
          }
          updateVirtualLight(light, n);
          lights[k] = virtualLight;
          k++;
        }
      } else {
        lights[k] = light;
        k++;
      }
    }
    for (i = 0, il = lights.length; i < il; i++) {
      light = lights[i];
      if (!light.shadowMap) {
        var shadowFilter = THREE.LinearFilter;
        if (_renderer.shadowMapType === THREE.PCFSoftShadowMap) {
          shadowFilter = THREE.NearestFilter;
        }
        var pars = {
            minFilter: shadowFilter,
            magFilter: shadowFilter,
            format: THREE.RGBAFormat
          };
        light.shadowMap = new THREE.WebGLRenderTarget(light.shadowMapWidth, light.shadowMapHeight, pars);
        light.shadowMapSize = new THREE.Vector2(light.shadowMapWidth, light.shadowMapHeight);
        light.shadowMatrix = new THREE.Matrix4();
      }
      if (!light.shadowCamera) {
        if (light instanceof THREE.SpotLight) {
          light.shadowCamera = new THREE.PerspectiveCamera(light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar);
        } else if (light instanceof THREE.DirectionalLight) {
          light.shadowCamera = new THREE.OrthographicCamera(light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar);
        } else {
          console.error('Unsupported light type for shadow');
          continue;
        }
        scene.add(light.shadowCamera);
        if (scene.autoUpdate === true)
          scene.updateMatrixWorld();
      }
      if (light.shadowCameraVisible && !light.cameraHelper) {
        light.cameraHelper = new THREE.CameraHelper(light.shadowCamera);
        light.shadowCamera.add(light.cameraHelper);
      }
      if (light.isVirtual && virtualLight.originalCamera == camera) {
        updateShadowCamera(camera, light);
      }
      shadowMap = light.shadowMap;
      shadowMatrix = light.shadowMatrix;
      shadowCamera = light.shadowCamera;
      shadowCamera.position.getPositionFromMatrix(light.matrixWorld);
      _matrixPosition.getPositionFromMatrix(light.target.matrixWorld);
      shadowCamera.lookAt(_matrixPosition);
      shadowCamera.updateMatrixWorld();
      shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
      if (light.cameraHelper)
        light.cameraHelper.visible = light.shadowCameraVisible;
      if (light.shadowCameraVisible)
        light.cameraHelper.update();
      shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      shadowMatrix.multiply(shadowCamera.projectionMatrix);
      shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
      _frustum.setFromMatrix(_projScreenMatrix);
      _renderer.setRenderTarget(shadowMap);
      _renderer.clear();
      renderList = scene.__webglObjects;
      for (j = 0, jl = renderList.length; j < jl; j++) {
        webglObject = renderList[j];
        object = webglObject.object;
        webglObject.render = false;
        if (object.visible && object.castShadow) {
          if (!(object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem) || !object.frustumCulled || _frustum.intersectsObject(object)) {
            object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
            webglObject.render = true;
          }
        }
      }
      var objectMaterial, useMorphing, useSkinning;
      for (j = 0, jl = renderList.length; j < jl; j++) {
        webglObject = renderList[j];
        if (webglObject.render) {
          object = webglObject.object;
          buffer = webglObject.buffer;
          objectMaterial = getObjectMaterial(object);
          useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
          useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
          if (object.customDepthMaterial) {
            material = object.customDepthMaterial;
          } else if (useSkinning) {
            material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
          } else if (useMorphing) {
            material = _depthMaterialMorph;
          } else {
            material = _depthMaterial;
          }
          if (buffer instanceof THREE.BufferGeometry) {
            _renderer.renderBufferDirect(shadowCamera, scene.__lights, fog, material, buffer, object);
          } else {
            _renderer.renderBuffer(shadowCamera, scene.__lights, fog, material, buffer, object);
          }
        }
      }
      renderList = scene.__webglObjectsImmediate;
      for (j = 0, jl = renderList.length; j < jl; j++) {
        webglObject = renderList[j];
        object = webglObject.object;
        if (object.visible && object.castShadow) {
          object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          _renderer.renderImmediateObject(shadowCamera, scene.__lights, fog, _depthMaterial, object);
        }
      }
    }
    var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
    _gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearAlpha);
    _gl.enable(_gl.BLEND);
    if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
      _gl.cullFace(_gl.BACK);
    }
  };
  function createVirtualLight(light, cascade) {
    var virtualLight = new THREE.DirectionalLight();
    virtualLight.isVirtual = true;
    virtualLight.onlyShadow = true;
    virtualLight.castShadow = true;
    virtualLight.shadowCameraNear = light.shadowCameraNear;
    virtualLight.shadowCameraFar = light.shadowCameraFar;
    virtualLight.shadowCameraLeft = light.shadowCameraLeft;
    virtualLight.shadowCameraRight = light.shadowCameraRight;
    virtualLight.shadowCameraBottom = light.shadowCameraBottom;
    virtualLight.shadowCameraTop = light.shadowCameraTop;
    virtualLight.shadowCameraVisible = light.shadowCameraVisible;
    virtualLight.shadowDarkness = light.shadowDarkness;
    virtualLight.shadowBias = light.shadowCascadeBias[cascade];
    virtualLight.shadowMapWidth = light.shadowCascadeWidth[cascade];
    virtualLight.shadowMapHeight = light.shadowCascadeHeight[cascade];
    virtualLight.pointsWorld = [];
    virtualLight.pointsFrustum = [];
    var pointsWorld = virtualLight.pointsWorld, pointsFrustum = virtualLight.pointsFrustum;
    for (var i = 0; i < 8; i++) {
      pointsWorld[i] = new THREE.Vector3();
      pointsFrustum[i] = new THREE.Vector3();
    }
    var nearZ = light.shadowCascadeNearZ[cascade];
    var farZ = light.shadowCascadeFarZ[cascade];
    pointsFrustum[0].set(-1, -1, nearZ);
    pointsFrustum[1].set(1, -1, nearZ);
    pointsFrustum[2].set(-1, 1, nearZ);
    pointsFrustum[3].set(1, 1, nearZ);
    pointsFrustum[4].set(-1, -1, farZ);
    pointsFrustum[5].set(1, -1, farZ);
    pointsFrustum[6].set(-1, 1, farZ);
    pointsFrustum[7].set(1, 1, farZ);
    return virtualLight;
  }
  function updateVirtualLight(light, cascade) {
    var virtualLight = light.shadowCascadeArray[cascade];
    virtualLight.position.copy(light.position);
    virtualLight.target.position.copy(light.target.position);
    virtualLight.lookAt(virtualLight.target);
    virtualLight.shadowCameraVisible = light.shadowCameraVisible;
    virtualLight.shadowDarkness = light.shadowDarkness;
    virtualLight.shadowBias = light.shadowCascadeBias[cascade];
    var nearZ = light.shadowCascadeNearZ[cascade];
    var farZ = light.shadowCascadeFarZ[cascade];
    var pointsFrustum = virtualLight.pointsFrustum;
    pointsFrustum[0].z = nearZ;
    pointsFrustum[1].z = nearZ;
    pointsFrustum[2].z = nearZ;
    pointsFrustum[3].z = nearZ;
    pointsFrustum[4].z = farZ;
    pointsFrustum[5].z = farZ;
    pointsFrustum[6].z = farZ;
    pointsFrustum[7].z = farZ;
  }
  function updateShadowCamera(camera, light) {
    var shadowCamera = light.shadowCamera, pointsFrustum = light.pointsFrustum, pointsWorld = light.pointsWorld;
    _min.set(Infinity, Infinity, Infinity);
    _max.set(-Infinity, -Infinity, -Infinity);
    for (var i = 0; i < 8; i++) {
      var p = pointsWorld[i];
      p.copy(pointsFrustum[i]);
      THREE.ShadowMapPlugin.__projector.unprojectVector(p, camera);
      p.applyMatrix4(shadowCamera.matrixWorldInverse);
      if (p.x < _min.x)
        _min.x = p.x;
      if (p.x > _max.x)
        _max.x = p.x;
      if (p.y < _min.y)
        _min.y = p.y;
      if (p.y > _max.y)
        _max.y = p.y;
      if (p.z < _min.z)
        _min.z = p.z;
      if (p.z > _max.z)
        _max.z = p.z;
    }
    shadowCamera.left = _min.x;
    shadowCamera.right = _max.x;
    shadowCamera.top = _max.y;
    shadowCamera.bottom = _min.y;
    shadowCamera.updateProjectionMatrix();
  }
  function getObjectMaterial(object) {
    return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[0] : object.material;
  }
  ;
};
THREE.ShadowMapPlugin.__projector = new THREE.Projector();
THREE.SpritePlugin = function () {
  var _gl, _renderer, _precision, _sprite = {};
  this.init = function (renderer) {
    _gl = renderer.context;
    _renderer = renderer;
    _precision = renderer.getPrecision();
    _sprite.vertices = new Float32Array(8 + 8);
    _sprite.faces = new Uint16Array(6);
    var i = 0;
    _sprite.vertices[i++] = -0.5;
    _sprite.vertices[i++] = -0.5;
    _sprite.vertices[i++] = 0;
    _sprite.vertices[i++] = 0;
    _sprite.vertices[i++] = 0.5;
    _sprite.vertices[i++] = -0.5;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = 0;
    _sprite.vertices[i++] = 0.5;
    _sprite.vertices[i++] = 0.5;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = -0.5;
    _sprite.vertices[i++] = 0.5;
    _sprite.vertices[i++] = 0;
    _sprite.vertices[i++] = 1;
    i = 0;
    _sprite.faces[i++] = 0;
    _sprite.faces[i++] = 1;
    _sprite.faces[i++] = 2;
    _sprite.faces[i++] = 0;
    _sprite.faces[i++] = 2;
    _sprite.faces[i++] = 3;
    _sprite.vertexBuffer = _gl.createBuffer();
    _sprite.elementBuffer = _gl.createBuffer();
    _gl.bindBuffer(_gl.ARRAY_BUFFER, _sprite.vertexBuffer);
    _gl.bufferData(_gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW);
    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer);
    _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW);
    _sprite.program = createProgram(THREE.ShaderSprite['sprite'], _precision);
    _sprite.attributes = {};
    _sprite.uniforms = {};
    _sprite.attributes.position = _gl.getAttribLocation(_sprite.program, 'position');
    _sprite.attributes.uv = _gl.getAttribLocation(_sprite.program, 'uv');
    _sprite.uniforms.uvOffset = _gl.getUniformLocation(_sprite.program, 'uvOffset');
    _sprite.uniforms.uvScale = _gl.getUniformLocation(_sprite.program, 'uvScale');
    _sprite.uniforms.rotation = _gl.getUniformLocation(_sprite.program, 'rotation');
    _sprite.uniforms.scale = _gl.getUniformLocation(_sprite.program, 'scale');
    _sprite.uniforms.alignment = _gl.getUniformLocation(_sprite.program, 'alignment');
    _sprite.uniforms.halfViewport = _gl.getUniformLocation(_sprite.program, 'halfViewport');
    _sprite.uniforms.color = _gl.getUniformLocation(_sprite.program, 'color');
    _sprite.uniforms.map = _gl.getUniformLocation(_sprite.program, 'map');
    _sprite.uniforms.opacity = _gl.getUniformLocation(_sprite.program, 'opacity');
    _sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation(_sprite.program, 'useScreenCoordinates');
    _sprite.uniforms.sizeAttenuation = _gl.getUniformLocation(_sprite.program, 'sizeAttenuation');
    _sprite.uniforms.screenPosition = _gl.getUniformLocation(_sprite.program, 'screenPosition');
    _sprite.uniforms.modelViewMatrix = _gl.getUniformLocation(_sprite.program, 'modelViewMatrix');
    _sprite.uniforms.projectionMatrix = _gl.getUniformLocation(_sprite.program, 'projectionMatrix');
    _sprite.uniforms.fogType = _gl.getUniformLocation(_sprite.program, 'fogType');
    _sprite.uniforms.fogDensity = _gl.getUniformLocation(_sprite.program, 'fogDensity');
    _sprite.uniforms.fogNear = _gl.getUniformLocation(_sprite.program, 'fogNear');
    _sprite.uniforms.fogFar = _gl.getUniformLocation(_sprite.program, 'fogFar');
    _sprite.uniforms.fogColor = _gl.getUniformLocation(_sprite.program, 'fogColor');
    _sprite.uniforms.alphaTest = _gl.getUniformLocation(_sprite.program, 'alphaTest');
  };
  this.render = function (scene, camera, viewportWidth, viewportHeight) {
    var sprites = scene.__webglSprites, nSprites = sprites.length;
    if (!nSprites)
      return;
    var attributes = _sprite.attributes, uniforms = _sprite.uniforms;
    var halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5;
    _gl.useProgram(_sprite.program);
    _gl.enableVertexAttribArray(attributes.position);
    _gl.enableVertexAttribArray(attributes.uv);
    _gl.disable(_gl.CULL_FACE);
    _gl.enable(_gl.BLEND);
    _gl.bindBuffer(_gl.ARRAY_BUFFER, _sprite.vertexBuffer);
    _gl.vertexAttribPointer(attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0);
    _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8);
    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer);
    _gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
    _gl.activeTexture(_gl.TEXTURE0);
    _gl.uniform1i(uniforms.map, 0);
    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;
    if (fog) {
      _gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
      if (fog instanceof THREE.Fog) {
        _gl.uniform1f(uniforms.fogNear, fog.near);
        _gl.uniform1f(uniforms.fogFar, fog.far);
        _gl.uniform1i(uniforms.fogType, 1);
        oldFogType = 1;
        sceneFogType = 1;
      } else if (fog instanceof THREE.FogExp2) {
        _gl.uniform1f(uniforms.fogDensity, fog.density);
        _gl.uniform1i(uniforms.fogType, 2);
        oldFogType = 2;
        sceneFogType = 2;
      }
    } else {
      _gl.uniform1i(uniforms.fogType, 0);
      oldFogType = 0;
      sceneFogType = 0;
    }
    var i, sprite, material, screenPosition, fogType, scale = [];
    for (i = 0; i < nSprites; i++) {
      sprite = sprites[i];
      material = sprite.material;
      if (!sprite.visible || material.opacity === 0)
        continue;
      if (!material.useScreenCoordinates) {
        sprite._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
        sprite.z = -sprite._modelViewMatrix.elements[14];
      } else {
        sprite.z = -sprite.position.z;
      }
    }
    sprites.sort(painterSortStable);
    for (i = 0; i < nSprites; i++) {
      sprite = sprites[i];
      material = sprite.material;
      if (!sprite.visible || material.opacity === 0)
        continue;
      if (material.map && material.map.image && material.map.image.width) {
        _gl.uniform1f(uniforms.alphaTest, material.alphaTest);
        if (material.useScreenCoordinates === true) {
          _gl.uniform1i(uniforms.useScreenCoordinates, 1);
          _gl.uniform3f(uniforms.screenPosition, (sprite.position.x * _renderer.devicePixelRatio - halfViewportWidth) / halfViewportWidth, (halfViewportHeight - sprite.position.y * _renderer.devicePixelRatio) / halfViewportHeight, Math.max(0, Math.min(1, sprite.position.z)));
          scale[0] = _renderer.devicePixelRatio * sprite.scale.x;
          scale[1] = _renderer.devicePixelRatio * sprite.scale.y;
        } else {
          _gl.uniform1i(uniforms.useScreenCoordinates, 0);
          _gl.uniform1i(uniforms.sizeAttenuation, material.sizeAttenuation ? 1 : 0);
          _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements);
          scale[0] = sprite.scale.x;
          scale[1] = sprite.scale.y;
        }
        if (scene.fog && material.fog) {
          fogType = sceneFogType;
        } else {
          fogType = 0;
        }
        if (oldFogType !== fogType) {
          _gl.uniform1i(uniforms.fogType, fogType);
          oldFogType = fogType;
        }
        _gl.uniform2f(uniforms.uvScale, material.uvScale.x, material.uvScale.y);
        _gl.uniform2f(uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y);
        _gl.uniform2f(uniforms.alignment, material.alignment.x, material.alignment.y);
        _gl.uniform1f(uniforms.opacity, material.opacity);
        _gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
        _gl.uniform1f(uniforms.rotation, sprite.rotation);
        _gl.uniform2fv(uniforms.scale, scale);
        _gl.uniform2f(uniforms.halfViewport, halfViewportWidth, halfViewportHeight);
        _renderer.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
        _renderer.setDepthTest(material.depthTest);
        _renderer.setDepthWrite(material.depthWrite);
        _renderer.setTexture(material.map, 0);
        _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);
      }
    }
    _gl.enable(_gl.CULL_FACE);
  };
  function createProgram(shader, precision) {
    var program = _gl.createProgram();
    var fragmentShader = _gl.createShader(_gl.FRAGMENT_SHADER);
    var vertexShader = _gl.createShader(_gl.VERTEX_SHADER);
    var prefix = 'precision ' + precision + ' float;\n';
    _gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
    _gl.shaderSource(vertexShader, prefix + shader.vertexShader);
    _gl.compileShader(fragmentShader);
    _gl.compileShader(vertexShader);
    _gl.attachShader(program, fragmentShader);
    _gl.attachShader(program, vertexShader);
    _gl.linkProgram(program);
    return program;
  }
  ;
  function painterSortStable(a, b) {
    if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return b.id - a.id;
    }
  }
  ;
};
THREE.DepthPassPlugin = function () {
  this.enabled = false;
  this.renderTarget = null;
  var _gl, _renderer, _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4();
  this.init = function (renderer) {
    _gl = renderer.context;
    _renderer = renderer;
    var depthShader = THREE.ShaderLib['depthRGBA'];
    var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
    _depthMaterial = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms
    });
    _depthMaterialMorph = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      morphTargets: true
    });
    _depthMaterialSkin = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      skinning: true
    });
    _depthMaterialMorphSkin = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      morphTargets: true,
      skinning: true
    });
    _depthMaterial._shadowPass = true;
    _depthMaterialMorph._shadowPass = true;
    _depthMaterialSkin._shadowPass = true;
    _depthMaterialMorphSkin._shadowPass = true;
  };
  this.render = function (scene, camera) {
    if (!this.enabled)
      return;
    this.update(scene, camera);
  };
  this.update = function (scene, camera) {
    var i, il, j, jl, n, program, buffer, material, webglObject, object, light, renderList, fog = null;
    _gl.clearColor(1, 1, 1, 1);
    _gl.disable(_gl.BLEND);
    _renderer.setDepthTest(true);
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    _renderer.setRenderTarget(this.renderTarget);
    _renderer.clear();
    renderList = scene.__webglObjects;
    for (j = 0, jl = renderList.length; j < jl; j++) {
      webglObject = renderList[j];
      object = webglObject.object;
      webglObject.render = false;
      if (object.visible) {
        if (!(object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem) || !object.frustumCulled || _frustum.intersectsObject(object)) {
          object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          webglObject.render = true;
        }
      }
    }
    var objectMaterial, useMorphing, useSkinning;
    for (j = 0, jl = renderList.length; j < jl; j++) {
      webglObject = renderList[j];
      if (webglObject.render) {
        object = webglObject.object;
        buffer = webglObject.buffer;
        if (object instanceof THREE.ParticleSystem && !object.customDepthMaterial)
          continue;
        objectMaterial = getObjectMaterial(object);
        if (objectMaterial)
          _renderer.setMaterialFaces(object.material);
        useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
        useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
        if (object.customDepthMaterial) {
          material = object.customDepthMaterial;
        } else if (useSkinning) {
          material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
        } else if (useMorphing) {
          material = _depthMaterialMorph;
        } else {
          material = _depthMaterial;
        }
        if (buffer instanceof THREE.BufferGeometry) {
          _renderer.renderBufferDirect(camera, scene.__lights, fog, material, buffer, object);
        } else {
          _renderer.renderBuffer(camera, scene.__lights, fog, material, buffer, object);
        }
      }
    }
    renderList = scene.__webglObjectsImmediate;
    for (j = 0, jl = renderList.length; j < jl; j++) {
      webglObject = renderList[j];
      object = webglObject.object;
      if (object.visible) {
        object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        _renderer.renderImmediateObject(camera, scene.__lights, fog, _depthMaterial, object);
      }
    }
    var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
    _gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearAlpha);
    _gl.enable(_gl.BLEND);
  };
  function getObjectMaterial(object) {
    return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[0] : object.material;
  }
  ;
};
THREE.ShaderFlares = {
  'lensFlareVertexTexture': {
    vertexShader: [
      'uniform lowp int renderType;',
      'uniform vec3 screenPosition;',
      'uniform vec2 scale;',
      'uniform float rotation;',
      'uniform sampler2D occlusionMap;',
      'attribute vec2 position;',
      'attribute vec2 uv;',
      'varying vec2 vUV;',
      'varying float vVisibility;',
      'void main() {',
      'vUV = uv;',
      'vec2 pos = position;',
      'if( renderType == 2 ) {',
      'vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',
      'vVisibility =        visibility.r / 9.0;',
      'vVisibility *= 1.0 - visibility.g / 9.0;',
      'vVisibility *=       visibility.b / 9.0;',
      'vVisibility *= 1.0 - visibility.a / 9.0;',
      'pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
      'pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
      '}',
      'gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform lowp int renderType;',
      'uniform sampler2D map;',
      'uniform float opacity;',
      'uniform vec3 color;',
      'varying vec2 vUV;',
      'varying float vVisibility;',
      'void main() {',
      'if( renderType == 0 ) {',
      'gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',
      '} else if( renderType == 1 ) {',
      'gl_FragColor = texture2D( map, vUV );',
      '} else {',
      'vec4 texture = texture2D( map, vUV );',
      'texture.a *= opacity * vVisibility;',
      'gl_FragColor = texture;',
      'gl_FragColor.rgb *= color;',
      '}',
      '}'
    ].join('\n')
  },
  'lensFlare': {
    vertexShader: [
      'uniform lowp int renderType;',
      'uniform vec3 screenPosition;',
      'uniform vec2 scale;',
      'uniform float rotation;',
      'attribute vec2 position;',
      'attribute vec2 uv;',
      'varying vec2 vUV;',
      'void main() {',
      'vUV = uv;',
      'vec2 pos = position;',
      'if( renderType == 2 ) {',
      'pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
      'pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
      '}',
      'gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
      '}'
    ].join('\n'),
    fragmentShader: [
      'precision mediump float;',
      'uniform lowp int renderType;',
      'uniform sampler2D map;',
      'uniform sampler2D occlusionMap;',
      'uniform float opacity;',
      'uniform vec3 color;',
      'varying vec2 vUV;',
      'void main() {',
      'if( renderType == 0 ) {',
      'gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );',
      '} else if( renderType == 1 ) {',
      'gl_FragColor = texture2D( map, vUV );',
      '} else {',
      'float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;',
      'visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;',
      'visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;',
      'visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;',
      'visibility = ( 1.0 - visibility / 4.0 );',
      'vec4 texture = texture2D( map, vUV );',
      'texture.a *= opacity * visibility;',
      'gl_FragColor = texture;',
      'gl_FragColor.rgb *= color;',
      '}',
      '}'
    ].join('\n')
  }
};
THREE.ShaderSprite = {
  'sprite': {
    vertexShader: [
      'uniform int useScreenCoordinates;',
      'uniform int sizeAttenuation;',
      'uniform vec3 screenPosition;',
      'uniform mat4 modelViewMatrix;',
      'uniform mat4 projectionMatrix;',
      'uniform float rotation;',
      'uniform vec2 scale;',
      'uniform vec2 alignment;',
      'uniform vec2 uvOffset;',
      'uniform vec2 uvScale;',
      'uniform vec2 halfViewport;',
      'attribute vec2 position;',
      'attribute vec2 uv;',
      'varying vec2 vUV;',
      'void main() {',
      'vUV = uvOffset + uv * uvScale;',
      'vec2 alignedPosition = ( position + alignment ) * scale;',
      'vec2 rotatedPosition;',
      'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
      'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
      'vec4 finalPosition;',
      'if( useScreenCoordinates != 0 ) {',
      'finalPosition = vec4( screenPosition.xy + ( rotatedPosition / halfViewport ), screenPosition.z, 1.0 );',
      '} else {',
      'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
      'finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );',
      'finalPosition = projectionMatrix * finalPosition;',
      '}',
      'gl_Position = finalPosition;',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 color;',
      'uniform sampler2D map;',
      'uniform float opacity;',
      'uniform int fogType;',
      'uniform vec3 fogColor;',
      'uniform float fogDensity;',
      'uniform float fogNear;',
      'uniform float fogFar;',
      'uniform float alphaTest;',
      'varying vec2 vUV;',
      'void main() {',
      'vec4 texture = texture2D( map, vUV );',
      'if ( texture.a < alphaTest ) discard;',
      'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
      'if ( fogType > 0 ) {',
      'float depth = gl_FragCoord.z / gl_FragCoord.w;',
      'float fogFactor = 0.0;',
      'if ( fogType == 1 ) {',
      'fogFactor = smoothstep( fogNear, fogFar, depth );',
      '} else {',
      'const float LOG2 = 1.442695;',
      'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
      'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
      '}',
      'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
      '}',
      '}'
    ].join('\n')
  }
};
'use strict';
void 0 === Date.now && (Date.now = function () {
  return new Date().valueOf();
});
var TWEEN = TWEEN || function () {
    var a = [];
    return {
      REVISION: '11dev',
      getAll: function () {
        return a;
      },
      removeAll: function () {
        a = [];
      },
      add: function (c) {
        a.push(c);
      },
      remove: function (c) {
        c = a.indexOf(c);
        -1 !== c && a.splice(c, 1);
      },
      update: function (c) {
        if (0 === a.length)
          return !1;
        for (var b = 0, d = a.length, c = void 0 !== c ? c : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); b < d;)
          a[b].update(c) ? b++ : (a.splice(b, 1), d--);
        return !0;
      }
    };
  }();
TWEEN.Tween = function (a) {
  var c = {}, b = {}, d = {}, e = 1000, g = 0, h = !1, n = 0, l = null, v = TWEEN.Easing.Linear.None, w = TWEEN.Interpolation.Linear, p = [], q = null, r = !1, s = null, t = null, j;
  for (j in a)
    c[j] = parseFloat(a[j], 10);
  this.to = function (a, c) {
    void 0 !== c && (e = c);
    b = a;
    return this;
  };
  this.start = function (e) {
    TWEEN.add(this);
    r = !1;
    l = void 0 !== e ? e : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now();
    l += n;
    for (var f in b) {
      if (b[f] instanceof Array) {
        if (0 === b[f].length)
          continue;
        b[f] = [a[f]].concat(b[f]);
      }
      c[f] = a[f];
      !1 === c[f] instanceof Array && (c[f] *= 1);
      d[f] = c[f] || 0;
    }
    return this;
  };
  this.stop = function () {
    TWEEN.remove(this);
    return this;
  };
  this.delay = function (a) {
    n = a;
    return this;
  };
  this.repeat = function (a) {
    g = a;
    return this;
  };
  this.yoyo = function (a) {
    h = a;
    return this;
  };
  this.easing = function (a) {
    v = a;
    return this;
  };
  this.interpolation = function (a) {
    w = a;
    return this;
  };
  this.chain = function () {
    p = arguments;
    return this;
  };
  this.onStart = function (a) {
    q = a;
    return this;
  };
  this.onUpdate = function (a) {
    s = a;
    return this;
  };
  this.onComplete = function (a) {
    t = a;
    return this;
  };
  this.update = function (m) {
    var f;
    if (m < l)
      return !0;
    !1 === r && (null !== q && q.call(a), r = !0);
    var i = (m - l) / e, i = 1 < i ? 1 : i, j = v(i);
    for (f in b) {
      var u = c[f] || 0, k = b[f];
      k instanceof Array ? a[f] = w(k, j) : ('string' === typeof k && (k = u + parseFloat(k, 10)), 'number' === typeof k && (a[f] = u + (k - u) * j));
    }
    null !== s && s.call(a, j);
    if (1 == i)
      if (0 < g) {
        isFinite(g) && g--;
        for (f in d)
          'string' === typeof b[f] && (d[f] += parseFloat(b[f], 10)), h && (i = d[f], d[f] = b[f], b[f] = i), c[f] = d[f];
        l = m + n;
      } else {
        null !== t && t.call(a);
        f = 0;
        for (i = p.length; f < i; f++)
          p[f].start(m);
        return !1;
      }
    return !0;
  };
};
TWEEN.Easing = {
  Linear: {
    None: function (a) {
      return a;
    }
  },
  Quadratic: {
    In: function (a) {
      return a * a;
    },
    Out: function (a) {
      return a * (2 - a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1);
    }
  },
  Cubic: {
    In: function (a) {
      return a * a * a;
    },
    Out: function (a) {
      return --a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2);
    }
  },
  Quartic: {
    In: function (a) {
      return a * a * a * a;
    },
    Out: function (a) {
      return 1 - --a * a * a * a;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a : -0.5 * ((a -= 2) * a * a * a - 2);
    }
  },
  Quintic: {
    In: function (a) {
      return a * a * a * a * a;
    },
    Out: function (a) {
      return --a * a * a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a * a : 0.5 * ((a -= 2) * a * a * a * a + 2);
    }
  },
  Sinusoidal: {
    In: function (a) {
      return 1 - Math.cos(a * Math.PI / 2);
    },
    Out: function (a) {
      return Math.sin(a * Math.PI / 2);
    },
    InOut: function (a) {
      return 0.5 * (1 - Math.cos(Math.PI * a));
    }
  },
  Exponential: {
    In: function (a) {
      return 0 === a ? 0 : Math.pow(1024, a - 1);
    },
    Out: function (a) {
      return 1 === a ? 1 : 1 - Math.pow(2, -10 * a);
    },
    InOut: function (a) {
      return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? 0.5 * Math.pow(1024, a - 1) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2);
    }
  },
  Circular: {
    In: function (a) {
      return 1 - Math.sqrt(1 - a * a);
    },
    Out: function (a) {
      return Math.sqrt(1 - --a * a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
    }
  },
  Elastic: {
    In: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return -(b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4));
    },
    Out: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return b * Math.pow(2, -10 * a) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    },
    InOut: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return 1 > (a *= 2) ? -0.5 * b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) : 0.5 * b * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    }
  },
  Back: {
    In: function (a) {
      return a * a * (2.70158 * a - 1.70158);
    },
    Out: function (a) {
      return --a * a * (2.70158 * a + 1.70158) + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * (3.5949095 * a - 2.5949095) : 0.5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2);
    }
  },
  Bounce: {
    In: function (a) {
      return 1 - TWEEN.Easing.Bounce.Out(1 - a);
    },
    Out: function (a) {
      return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
    },
    InOut: function (a) {
      return 0.5 > a ? 0.5 * TWEEN.Easing.Bounce.In(2 * a) : 0.5 * TWEEN.Easing.Bounce.Out(2 * a - 1) + 0.5;
    }
  }
};
TWEEN.Interpolation = {
  Linear: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.Linear;
    return 0 > c ? g(a[0], a[1], d) : 1 < c ? g(a[b], a[b - 1], b - d) : g(a[e], a[e + 1 > b ? b : e + 1], d - e);
  },
  Bezier: function (a, c) {
    var b = 0, d = a.length - 1, e = Math.pow, g = TWEEN.Interpolation.Utils.Bernstein, h;
    for (h = 0; h <= d; h++)
      b += e(1 - c, d - h) * e(c, h) * a[h] * g(d, h);
    return b;
  },
  CatmullRom: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.CatmullRom;
    return a[0] === a[b] ? (0 > c && (e = Math.floor(d = b * (1 + c))), g(a[(e - 1 + b) % b], a[e], a[(e + 1) % b], a[(e + 2) % b], d - e)) : 0 > c ? a[0] - (g(a[0], a[0], a[1], a[1], -d) - a[0]) : 1 < c ? a[b] - (g(a[b], a[b], a[b - 1], a[b - 1], d - b) - a[b]) : g(a[e ? e - 1 : 0], a[e], a[b < e + 1 ? b : e + 1], a[b < e + 2 ? b : e + 2], d - e);
  },
  Utils: {
    Linear: function (a, c, b) {
      return (c - a) * b + a;
    },
    Bernstein: function (a, c) {
      var b = TWEEN.Interpolation.Utils.Factorial;
      return b(a) / b(c) / b(a - c);
    },
    Factorial: function () {
      var a = [1];
      return function (c) {
        var b = 1, d;
        if (a[c])
          return a[c];
        for (d = c; 1 < d; d--)
          b *= d;
        return a[c] = b;
      };
    }(),
    CatmullRom: function (a, c, b, d, e) {
      var a = 0.5 * (b - a), d = 0.5 * (d - c), g = e * e;
      return (2 * c - 2 * b + a + d) * e * g + (-3 * c + 3 * b - 2 * a - d) * g + a * e + c;
    }
  }
};
(function ($window, $document, tagName, url, namespace, a, m) {
  $window['GoogleAnalyticsObject'] = namespace;
  $window[namespace] = $window[namespace] || function () {
    ($window[namespace].q = $window[namespace].q || []).push(arguments);
  }, $window[namespace].l = 1 * new Date();
  a = $document.createElement(tagName), m = $document.getElementsByTagName(tagName)[0];
  a.async = 1;
  a.src = url;
  m.parentNode.insertBefore(a, m);
}(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga'));
var Stats = function () {
  var startTime = Date.now(), prevTime = startTime;
  var ms = 0, msMin = Infinity, msMax = 0;
  var fps = 0, fpsMin = Infinity, fpsMax = 0;
  var frames = 0, mode = 0;
  var container = document.createElement('div');
  container.id = 'stats';
  container.addEventListener('mousedown', function (event) {
    event.preventDefault();
    setMode(++mode % 2);
  }, false);
  container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';
  var fpsDiv = document.createElement('div');
  fpsDiv.id = 'fps';
  fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
  container.appendChild(fpsDiv);
  var fpsText = document.createElement('div');
  fpsText.id = 'fpsText';
  fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  fpsText.innerHTML = 'FPS';
  fpsDiv.appendChild(fpsText);
  var fpsGraph = document.createElement('div');
  fpsGraph.id = 'fpsGraph';
  fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
  fpsDiv.appendChild(fpsGraph);
  while (fpsGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
    fpsGraph.appendChild(bar);
  }
  var msDiv = document.createElement('div');
  msDiv.id = 'ms';
  msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
  container.appendChild(msDiv);
  var msText = document.createElement('div');
  msText.id = 'msText';
  msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  msText.innerHTML = 'MS';
  msDiv.appendChild(msText);
  var msGraph = document.createElement('div');
  msGraph.id = 'msGraph';
  msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
  msDiv.appendChild(msGraph);
  while (msGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
    msGraph.appendChild(bar);
  }
  var setMode = function (value) {
    mode = value;
    switch (mode) {
    case 0:
      fpsDiv.style.display = 'block';
      msDiv.style.display = 'none';
      break;
    case 1:
      fpsDiv.style.display = 'none';
      msDiv.style.display = 'block';
      break;
    }
  };
  var updateGraph = function (dom, value) {
    var child = dom.appendChild(dom.firstChild);
    child.style.height = value + 'px';
  };
  return {
    REVISION: 11,
    domElement: container,
    setMode: setMode,
    begin: function () {
      startTime = Date.now();
    },
    end: function () {
      var time = Date.now();
      ms = time - startTime;
      msMin = Math.min(msMin, ms);
      msMax = Math.max(msMax, ms);
      msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
      updateGraph(msGraph, Math.min(30, 30 - ms / 200 * 30));
      frames++;
      if (time > prevTime + 1000) {
        fps = Math.round(frames * 1000 / (time - prevTime));
        fpsMin = Math.min(fpsMin, fps);
        fpsMax = Math.max(fpsMax, fps);
        fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
        updateGraph(fpsGraph, Math.min(30, 30 - fps / 100 * 30));
        prevTime = time;
        frames = 0;
      }
      return time;
    },
    update: function () {
      startTime = this.end();
    }
  };
};
(function () {
  var app;
  app = angular.module('app', [
    'async',
    'jed',
    'jquery',
    'underscore'
  ]);
  app.run([
    '$rootScope',
    '$window',
    '$location',
    'cookie',
    'i18n',
    function ($rootScope, $window, $location, cookie, i18n) {
      var GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME, isMenuLocation;
      GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME = 'github-application-client-id';
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      GITHUB_LOGIN_COOKIE_NAME = 'github-login';
      $rootScope.i18n = i18n;
      $rootScope.breadcrumbStrategy = { progressive: false };
      $rootScope.clientId = function () {
        return cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
      };
      $rootScope.log = function (thing) {
      };
      $rootScope.alert = function (thing) {
        return alert(thing);
      };
      $rootScope.isLoggedIn = function () {
        return cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.loginEnabled = function () {
        return !cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.logout = function () {
        cookie.removeItem(GITHUB_TOKEN_COOKIE_NAME);
        return cookie.removeItem(GITHUB_LOGIN_COOKIE_NAME);
      };
      $rootScope.login = function () {
        var clientId;
        clientId = cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
        return $window.location.href = 'https://github.com/login/oauth/authorize?client_id=' + clientId + '&amp;scope=repo,user,gist';
      };
      $rootScope.userLogin = function () {
        return cookie.getItem(GITHUB_LOGIN_COOKIE_NAME);
      };
      isMenuLocation = function () {
        if ($window.location && $window.location.href) {
          return !$window.location.href.match(new RegExp('/workbench$')) && !$window.location.href.match(new RegExp('/users/')) && !$window.location.href.match(new RegExp('/gists/'));
        } else {
          return false;
        }
      };
      $rootScope.isHomePage = function () {
        return true;
      };
      $rootScope.jumpIcon = function () {
        if (isMenuLocation()) {
          return 'icon-edit';
        } else {
          return 'icon-home';
        }
      };
      $rootScope.jumpText = function () {
        if (isMenuLocation()) {
          return 'Workbench';
        } else {
          return 'Home';
        }
      };
      return $rootScope.jumpHRef = function () {
        if (isMenuLocation()) {
          return '/workbench';
        } else {
          return '/';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('HomeCtrl', [
    '$rootScope',
    '$scope',
    '$http',
    '$location',
    '$window',
    'GitHubAuthManager',
    function ($rootScope, $scope, $http, $location, $window, authManager) {
      var EVENT_CATEGORY;
      EVENT_CATEGORY = 'home';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/home');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      $scope.work = function () {
        ga('send', 'event', EVENT_CATEGORY, 'work');
        $location.path('/work');
      };
      $scope.browse = function () {
        ga('send', 'event', EVENT_CATEGORY, 'browse');
        $location.path('/browse');
      };
      return $scope.user = function () {
        var path;
        ga('send', 'event', EVENT_CATEGORY, 'user');
        path = '/users/' + $scope.userLogin();
        $location.path(path);
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewFileCtrl', [
    '$scope',
    'GitHub',
    'Base64',
    'cookie',
    '$',
    '_',
    function ($scope, github, base64, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-file';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-file');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-file-dialog').on('show', function () {
        return $scope.file = {
          name: '',
          message: ''
        };
      });
      $('#new-file-dialog').on('shown', function () {
      });
      $('#new-file-dialog').on('hide', function () {
      });
      $('#new-file-dialog').on('hidden', function () {
      });
      return $scope.createFile = function () {
        var content, path;
        ga('send', 'event', EVENT_CATEGORY, 'createFile');
        content = base64.encode('# ' + $scope.file.name + '\n');
        path = $scope.path ? '' + $scope.path + '/' + $scope.file.name : $scope.file.name;
        return github.putFile(token, $scope.user.login, $scope.repo.name, path, $scope.file.message, content, void 0, function (err, response, status, headers, config) {
          var messages;
          if (!err) {
            $scope.$emit('createdFile', $scope.user, $scope.repo, response.content, response.commit);
            return $('#new-file-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewGistCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    function ($scope, github, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-gist';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-gist');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-gist-dialog').on('show', function () {
        return $scope.gist = {
          path: '',
          description: '',
          'private': 'false',
          markdownReadme: true,
          pythonReadme: true
        };
      });
      $('#new-gist-dialog').on('shown', function () {
      });
      $('#new-gist-dialog').on('hide', function () {
      });
      $('#new-gist-dialog').on('hidden', function () {
      });
      return $scope.createGist = function () {
        var data;
        ga('send', 'event', EVENT_CATEGORY, 'createGist');
        data = {};
        data.description = $scope.gist.description;
        data['public'] = true;
        data.files = { 'main.py': { 'content': '# main.py' } };
        return github.postGist(token, data, function (err, response, status, headers, config) {
          var messages;
          if (!err) {
            $scope.$emit('createdGist', $scope.user, response);
            return $('#new-gist-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewRepoCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    function ($scope, github, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-repo';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-repo');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-repo-dialog').on('show', function () {
        return $scope.repo = {
          path: '',
          description: '',
          'private': 'false',
          markdownReadme: true,
          pythonReadme: true
        };
      });
      $('#new-repo-dialog').on('shown', function () {
      });
      $('#new-repo-dialog').on('hide', function () {
      });
      $('#new-repo-dialog').on('hidden', function () {
      });
      return $scope.createRepo = function () {
        ga('send', 'event', EVENT_CATEGORY, 'createRepo');
        return github.postRepo(token, $scope.repo.name, $scope.repo.description, false, $scope.repo.markdownReadme, function (err, repo) {
          var messages;
          if (!err) {
            $scope.$emit('createdRepo', $scope.user, repo);
            return $('#new-repo-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('PrinterCtrl', [
    '$scope',
    function ($scope) {
      var EVENT_CATEGORY, PRESERVE_ELEMENT_ID, escapeHtml;
      EVENT_CATEGORY = 'printer';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/printer');
      ga('send', 'pageview');
      PRESERVE_ELEMENT_ID = 'a5f435e0-c92e-11e2-8b8b-0800200c9a66';
      escapeHtml = function (s) {
        return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      };
      $scope.$on('reset', function (e) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = '';
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
      return $scope.$on('print', function (e, text) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = elem.innerHTML + escapeHtml(text);
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('TreeCtrl', [
    '$rootScope',
    '$scope',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    function ($rootScope, $scope, $window, $routeParams, $, _, github, base64, cookie) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, n, steps, token, _i;
      EVENT_CATEGORY = 'tree';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/tree');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $('.carousel').carousel({ interval: false });
      $scope.contextItem = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $scope.repo.name;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems = response;
          } else {
            console.log('err: ' + err + ', reponse: ' + response + ', status ' + status);
            return alert('' + err.message + '. Cause: ' + response.message + '.');
          }
        });
      } else {
        $scope.contextItem.name = '';
        $scope.contextItem.type = void 0;
      }
      $scope.isNewFileEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.newFile = function () {
        if ($scope.isNewFileEnabled()) {
          return $('#new-file-dialog').modal({
            show: true,
            backdrop: true
          });
        } else {
          return alert('Create a New File is not enabled.');
        }
      };
      $scope.$on('createdFile', function (e, user, repo, item, commit) {
        return $scope.contextItem.childItems.push(item);
      });
      $scope.isDeleteItemEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.deleteItem = function (idx) {
        var childItem;
        ga('send', 'event', EVENT_CATEGORY, 'deleteItem');
        childItem = $scope.contextItem.childItems[idx];
        return github.deleteFile(token, $scope.user.login, $scope.repo.name, childItem.path, 'Delete item.', childItem.sha, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems.splice(idx, 1);
          } else {
            return alert('Error deleting item: ' + err);
          }
        });
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        return 'active';
      };
      $scope.hrefFromItem = function (item) {
        var collectionName;
        collectionName = item.type === 'file' ? 'blob' : item.type === 'dir' ? 'tree' : 'unknown';
        return '/users/' + $scope.user.login + '/repos/' + $scope.repo.name + '/' + collectionName + '/' + $scope.branch.name + '/' + item.path;
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('UserCtrl', [
    '$rootScope',
    '$scope',
    '$routeParams',
    'GitHub',
    'cookie',
    '$',
    '_',
    'async',
    function ($rootScope, $scope, $routeParams, github, cookie, $, _, async) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, findIndex, loadGists, loadRepos, token;
      EVENT_CATEGORY = 'user';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/user');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      loadGists = function (callback) {
        return github.getGists(token, function (err, gists) {
          if (!err) {
            $scope.gists = _.filter(_.map(gists, function (gist) {
              return {
                'id': gist.id,
                'description': gist.description,
                'html_url': gist.html_url
              };
            }), function (gist) {
              return true;
            });
          } else {
            alert('Error retrieving user Gists');
          }
          return callback(err, gists);
        });
      };
      loadRepos = function (callback) {
        return github.getUserRepos(token, function (err, repos) {
          if (!err) {
            $scope.repos = _.filter(repos, function (repo) {
              return repo.language === 'Python';
            });
          } else {
            alert('Error retrieving user Repositories');
          }
          return callback(err, repos);
        });
      };
      async.parallel([
        function (callback) {
          return github.getUser(token, function (err, user) {
            if (!err) {
              $scope.user = user;
            } else {
              alert('Error retrieving user profile');
            }
            return callback(err, user);
          });
        },
        function (callback) {
          return loadRepos(callback);
        },
        function (callback) {
          return loadGists(callback);
        }
      ], function (err, results) {
      });
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-1';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-0';
        } else {
          return 'active distance-0';
        }
      };
      $scope.newGist = function () {
        return $('#new-gist-dialog').modal({
          show: true,
          backdrop: true
        });
      };
      findIndex = function (xs, match) {
        var i, length, x, _i, _ref;
        length = xs;
        for (i = _i = 0, _ref = length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          x = xs[i];
          if (match(x)) {
            return x;
          }
        }
        return -1;
      };
      $scope.deleteGist = function (owner, id) {
        ga('send', 'event', EVENT_CATEGORY, 'deleteGist');
        return github.deleteGist(token, owner, id, function (err, response, status, headers, config) {
          var index;
          if (!err) {
            index = findIndex($scope.gists, function (gist) {
              return gist.id === id;
            });
            return $scope.gists.splice(index, 1);
          } else {
            return alert('Error deleting gist: ' + err);
          }
        });
      };
      $scope.$on('createdGist', function (e, user, gist) {
        return $scope.gists.push(gist);
      });
      $scope.newRepo = function (owner) {
        return $('#new-repo-dialog').modal({
          show: true,
          backdrop: true
        });
      };
      $scope.deleteRepo = function (owner, repo) {
        ga('send', 'event', EVENT_CATEGORY, 'deleteRepo');
        return github.deleteRepo(token, owner, repo, function (err, response, status, headers, config) {
          if (!err) {
          } else {
            return alert('Error deleting repo: ' + err);
          }
        });
      };
      return $scope.$on('createdRepo', function (e, user, repo) {
        return $scope.repos.push(repo);
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('WorkCtrl', [
    '$rootScope',
    '$scope',
    '$location',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    'GitHubAuthManager',
    function ($rootScope, $scope, $location, $window, $routeParams, $, _, github, base64, cookie, authManager) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, code, editor, isFullScreen, n, setFullScreen, steps, token, winHeight, winWidth, _i;
      EVENT_CATEGORY = 'work';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/work');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $scope.contextItem = {};
      $scope.contextGist = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $routeParams.repo;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, file) {
          var contextItem;
          if (!err) {
            contextItem = {
              name: file.name,
              path: file.path,
              sha: file.sha,
              type: file.type,
              parentItem: $scope.contextItem,
              childItems: []
            };
            $scope.contextItem = contextItem;
            if (file.encoding === 'base64') {
              return editor.setValue(base64.decode(file.content));
            } else {
              return alert('Unknown encoding: ' + file.encoding);
            }
          } else {
            return alert('Error retrieving the page');
          }
        });
      } else if ($routeParams.gistId) {
        github.getGist(token, $routeParams.gistId, function (err, gist) {
          if (!err) {
            $scope.contextGist = gist;
            $scope.contextItem.name = 'main.py';
            return editor.setValue(gist.files['main.py'].content);
          } else {
            return alert('Error retrieving the Gist.');
          }
        });
      } else {
        $scope.contextItem.name = 'Untitled';
        $scope.contextItem.type = void 0;
      }
      winHeight = function () {
        return $window.innerHeight || ($window.document.documentElement || $window.document.body).clientHeight;
      };
      winWidth = function () {
        return $window.innerWidth || ($window.document.documentElement || $window.document.body).clientWidth;
      };
      isFullScreen = function (cm) {
        return /\bCodeMirror-fullscreen\b/.test(cm.getWrapperElement().className);
      };
      setFullScreen = function (cm, full) {
        var wrapperElement;
        wrapperElement = cm.getWrapperElement();
        if (full) {
          wrapperElement.className += ' CodeMirror-fullscreen';
          wrapperElement.style.height = winHeight() + 'px';
          document.documentElement.style.overflow = 'hidden';
        } else {
          wrapperElement.className = wrapperElement.className.replace(' CodeMirror-fullscreen', '');
          wrapperElement.style.height = '600px';
          document.documentElement.style.overflow = '';
        }
        return cm.refresh();
      };
      code = document.getElementById('code');
      if (code) {
        editor = CodeMirror.fromTextArea(code, {
          'autofocus': false,
          'indentUnit': 4,
          'lineNumbers': true,
          'lineWrapping': true,
          'autoMatchParens': true,
          'parserConfig': {
            'pythonVersion': 2,
            'strictErrors': true
          },
          'theme': 'twilight',
          'extraKeys': {
            'Tab': function (cm) {
              var spaces;
              spaces = Array(cm.getOption('indentUnit') + 1).join(' ');
              return cm.replaceSelection(spaces, 'end', '+input');
            },
            'Ctrl-S': function (cm) {
              return $scope.saveFile();
            },
            'Ctrl-Enter': function (cm) {
              return $scope.run();
            }
          }
        });
      } else {
        alert('The code element could not be found');
      }
      $scope.run = function () {
        var e, message, name, prog, text;
        ga('send', 'event', EVENT_CATEGORY, 'run');
        $rootScope.$broadcast('reset');
        $scope.messages.length = 0;
        prog = editor.getValue();
        Sk.canvas = 'canvas';
        Sk.configure({
          'output': function (text) {
            return $rootScope.$broadcast('print', text);
          },
          'debugout': function (arg) {
            return console.log('' + JSON.stringify(arg, null, 2));
          },
          'read': function (searchPath) {
            if (Sk.builtinFiles === void 0 || Sk.builtinFiles['files'][searchPath] === void 0) {
              throw new Error('File not found: \'' + searchPath + '\'');
            } else {
              return Sk.builtinFiles['files'][searchPath];
            }
          }
        });
        if (prog.trim().length > 0) {
          try {
            return eval(Sk.importMainWithBody('<stdin>', false, prog.trim()));
          } catch (_error) {
            e = _error;
            if (typeof e !== 'undefined') {
              if (typeof e.toString === 'function') {
                message = e.toString();
                name = message.substring(0, message.indexOf(':'));
                text = message.substring(message.indexOf(':') + 1);
                return $scope.messages.push({
                  name: name,
                  text: text,
                  severity: 'error'
                });
              } else {
                return console.log(JSON.stringify(e, null, 2));
              }
            }
          }
        }
      };
      $scope.saveFile = function () {
        var content, data, description, files;
        ga('send', 'event', EVENT_CATEGORY, 'savePage');
        content = base64.encode(editor.getValue());
        if ($scope.user) {
          return github.putFile(token, $scope.user.login, $scope.repo.name, $scope.contextItem.path, 'Save file.', content, $scope.contextItem.sha, function (err, response, status, headers, config) {
            if (!err) {
              return $scope.contextItem.sha = response.content.sha;
            } else {
              return alert('Error saving file to repository. Cause: ' + err.message);
            }
          });
        } else {
          if ($scope.contextGist.id) {
            description = $scope.contextGist.description;
            files = { 'main.py': { content: editor.getValue() } };
            return github.patchGist(token, $scope.contextGist.id, {
              description: description,
              files: files
            }, function (err, response, status, headers, config) {
              if (!err) {
              } else {
                return alert('Error patching Gist. Cause: ' + err.message);
              }
            });
          } else {
            files = { 'main.py': { content: editor.getValue() } };
            data = {};
            data.description = 'GeometryZen Gist';
            data['public'] = true;
            data.files = files;
            return github.postGist(token, data, function (err, response, status, headers, config) {
              if (!err) {
                return $location.path('/gists/' + response.id);
              } else {
                return alert('Error posting Gist. Cause: ' + err.message);
              }
            });
          }
        }
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          if ($scope.workEnabled()) {
            return '';
          } else {
            return 'active';
          }
        }
      };
      $scope.repoEnabled = function () {
        return $scope.repo && $scope.repo.name;
      };
      $scope.workEnabled = function () {
        return $scope.contextItem && $scope.contextItem.type === 'file' || !($scope.repo && $scope.repo.name);
      };
      $scope.saveEnabled = function () {
        if ($scope.user) {
          return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login && $scope.contextItem && $scope.contextItem.type === 'file';
        } else {
          return true;
        }
      };
      $scope.runEnabled = function () {
        return $scope.workEnabled();
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
      if (editor) {
        setFullScreen(editor, false);
      }
      CodeMirror.on($window, 'resize', function () {
        var showing;
        showing = $window.document.body.getElementsByClassName('CodeMirror-fullscreen')[0];
        if (showing) {
          return showing.CodeMirror.getWrapperElement().style.height = winHeight() + 'px';
        } else {
        }
      });
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('aHome', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/a-home.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('githubAuthorize', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/github-authorize.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('printer', function () {
    return {
      restrict: 'E',
      templateUrl: 'angular/printer.html'
    };
  });
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('userLinks', function () {
    return {
      restrict: 'E',
      replace: true,
      template: '<div class="user-links">\n  <a class="btn btn-secondary" ng-href="{{jumpHRef()}}">\n    <i class="{{jumpIcon()}}"/>\n    <span>{{jumpText()}}</span>\n  </a>\n  <button class="btn btn-secondary" ng-click="logout()" href="#" ng-show="isLoggedIn()">\n    <i class="icon-signout"></i>\n    <span>{{userLogin()}}</span>\n  </button>\n  <a class="btn btn-secondary" ng-hide="isLoggedIn()" ng-click="login()">\n    <i class="icon-signin"/>\n    <span>Sign in</span>\n  </a>\n</div>'
    };
  });
}.call(this));
(function () {
  var app;
  app = angular.module('app');
  app.config([
    '$routeProvider',
    '$locationProvider',
    function ($routeProvider, $locationProvider) {
      $routeProvider.when('/', {
        templateUrl: 'angular/home.html',
        controller: 'HomeCtrl'
      });
      $routeProvider.when('/workbench', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/gists/:gistId', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user', {
        templateUrl: 'angular/user.html',
        controller: 'UserCtrl'
      });
      $routeProvider.otherwise({ redirectTo: '/' });
      return $locationProvider.html5Mode(true);
    }
  ]);
}.call(this));
(function () {
  var _keyStr, _utf8_decode, _utf8_encode;
  _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  _utf8_decode = function (utftext) {
    var c, c1, c2, c3, i, string;
    string = '';
    i = 0;
    c = c1 = c2 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode((c & 31) << 6 | c2 & 63);
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        i += 3;
      }
    }
    return string;
  };
  _utf8_encode = function (string) {
    var c, n, utftext, _i, _ref;
    string = string.replace(/\r\n/g, '\n');
    utftext = '';
    for (n = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
      c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  };
  angular.module('app').factory('Base64', [
    '$window',
    function ($window) {
      return {
        decode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
          while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 !== 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
              output = output + String.fromCharCode(chr3);
            }
          }
          output = _utf8_decode(output);
          return output;
        },
        encode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = _utf8_encode(input);
          while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
              enc4 = 64;
            }
            output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
          }
          return output;
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('GitHub', [
    '$http',
    function ($http) {
      var GITHUB_DOMAIN, GITHUB_PROTOCOL, Gist, HTTP_METHOD_DELETE, HTTP_METHOD_GET, HTTP_METHOD_PATCH, HTTP_METHOD_POST, HTTP_METHOD_PUT, Repo, User;
      GITHUB_PROTOCOL = 'https';
      GITHUB_DOMAIN = 'api.github.com';
      HTTP_METHOD_DELETE = 'DELETE';
      HTTP_METHOD_GET = 'GET';
      HTTP_METHOD_PATCH = 'PATCH';
      HTTP_METHOD_POST = 'POST';
      HTTP_METHOD_PUT = 'PUT';
      User = function () {
        function User(name, login) {
          this.name = name;
          this.login = login;
        }
        return User;
      }();
      Gist = function () {
        function Gist(id, description, isPublic, files, html_url) {
          this.id = id;
          this.description = description;
          this['public'] = isPublic;
          this.files = files;
          this.html_url = html_url;
        }
        return Gist;
      }();
      Repo = function () {
        function Repo(name, description, language, html_url) {
          this.name = name;
          this.description = description;
          this.language = language;
          this.html_url = html_url;
        }
        return Repo;
      }();
      return {
        getUser: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user',
            headers: headers
          }).success(function (user, status, headers, config) {
            return done(null, new User(user.name, user.login), status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getUserRepos: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos',
            headers: headers
          }).success(function (repos, status, headers, config) {
            repos = _.map(repos, function (repo) {
              return new Repo(repo.name, repo.description, repo.language, repo.html_url);
            });
            return done(null, repos, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getRepoContents: function (token, user, repo, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': { Authorization: 'token ' + token }
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getPathContents: function (token, user, repo, path, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          if (path) {
            url = '' + url + '/' + path;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': headers
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        putFile: function (token, owner, repo, path, message, content, sha, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            content: content
          };
          if (sha) {
            data.sha = sha;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_PUT,
            url: url,
            data: data,
            headers: headers
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteFile: function (token, owner, repo, path, message, sha, done) {
          var data, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            sha: sha
          };
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            data: data,
            headers: { Authorization: 'token ' + token }
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        postRepo: function (token, name, description, priv, autoInit, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos';
          data = {
            name: name,
            description: description,
            'private': priv,
            auto_init: autoInit
          };
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_POST,
            url: url,
            data: data,
            headers: headers
          }).success(function (repo, status, headers, config) {
            return done(null, repo, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteRepo: function (token, owner, repo, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo;
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            headers: { Authorization: 'token ' + token }
          }).success(function (repo, status, headers, config) {
            return done(null, repo, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getGist: function (token, id, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + id;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': headers
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        patchGist: function (token, gistId, data, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + gistId;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_PATCH,
            url: url,
            data: data,
            headers: headers
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        postGist: function (token, data, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists';
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_POST,
            url: url,
            data: data,
            headers: headers
          }).success(function (response, status, headers, config) {
            return done(null, response, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteGist: function (token, owner, id, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + id;
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            headers: { Authorization: 'token ' + token }
          }).success(function (response, status, headers, config) {
            return done(null, response, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getUserGists: function (token, user, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/users/' + user + '/gists',
            headers: headers
          }).success(function (gists, status, headers, config) {
            gists = _.map(gists, function (gist) {
              return gist;
            });
            return done(null, gists, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getGists: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists',
            headers: headers
          }).success(function (gists, status, headers, config) {
            console.log;
            gists = _.map(gists, function (gist) {
              return new Gist(gist.id, gist.description, gist['public'], gist.files, gist.html_url);
            });
            return done(null, gists, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        }
      };
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.service('GitHubAuthManager', [
    '$http',
    '$location',
    '$window',
    'cookie',
    'GitHub',
    function ($http, $location, $window, cookie, github) {
      return this.handleLoginCallback = function (done) {
        var GATEKEEPER_DOMAIN, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME, code, match;
        GATEKEEPER_DOMAIN = '' + $location.protocol() + '://' + $location.host() + ':' + $location.port();
        GITHUB_TOKEN_COOKIE_NAME = 'github-token';
        GITHUB_LOGIN_COOKIE_NAME = 'github-login';
        match = $window.location.href.match(/\?code=([a-z0-9]*)/);
        if (match) {
          $location.search({});
          code = match[1];
          return $http.get('' + GATEKEEPER_DOMAIN + '/authenticate/' + code).success(function (data, status, headers, config) {
            var token;
            token = data.token;
            cookie.setItem(GITHUB_TOKEN_COOKIE_NAME, token);
            return github.getUser(token, function (error, user) {
              if (!error) {
                cookie.setItem(GITHUB_LOGIN_COOKIE_NAME, user.login);
                return done(null, token);
              } else {
                return done(new Error('Unable to retrieve your user information.'));
              }
            });
          }).error(function (data, status, headers, config) {
            return done(new Error('Unable to retrieve your authentication token.'));
          });
        } else if ($window.location.href.match(/\?error=access_denied/)) {
          return $location.search({});
        }
      };
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('async', []);
  module.factory('async', [
    '$window',
    function ($window) {
      return $window.async;
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('cookie', [function () {
      return {
        getItem: function (name) {
          var escapedName;
          escapedName = escape(name).replace(/[\-\.\+\*]/g, '\\$&');
          return unescape(document.cookie.replace(new RegExp('(?:(?:^|.*;)\\s*' + escapedName + '\\s*\\=\\s*([^;]*).*$)|^.*$'), '$1')) || null;
        },
        setItem: function (name, value, end, path, domain, secure) {
          var cookie, expires;
          if (!name || /^(?:expires|max\-age|path|domain|secure)$/i.test(name)) {
            throw new Error('Illegal name');
          }
          if (end) {
            switch (end.constructor) {
            case Number:
              expires = end === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : '; max-age=' + end;
              break;
            case String:
              expires = '; expires=' + end;
              break;
            case Date:
              expires = '; expires=' + end.toGMTString();
              break;
            default:
              expires = '';
            }
          } else {
            expires = '';
          }
          domain = domain ? '; domain=' + domain : '';
          path = path ? '; path=' + path : '';
          secure = secure ? '; secure' : '';
          cookie = '' + escape(name) + '=' + escape(value) + expires + domain + path + secure;
          document.cookie = cookie;
        },
        removeItem: function (name, path) {
          if (!name || !this.hasItem(name)) {
            return false;
          }
          return this.setItem(name, '', new Date(0), path);
        },
        hasItem: function (name) {
          return new RegExp('(?:^|;\\s*)' + escape(name).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\=').test(document.cookie);
        }
      };
    }]);
}.call(this));
(function () {
  var locale_data_multi;
  locale_data_multi = {
    'messages_3': {
      '': {
        domain: 'messages_3',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_1'
      ],
      'test singular': [
        'test plural',
        'test_1 singular',
        'test_1 plural'
      ],
      'context\x04test': [
        null,
        'test_1 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_1 context singular',
        'test_1 context plural'
      ]
    },
    'messages_4': {
      '': {
        domain: 'messages_4',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_2'
      ],
      'test singular': [
        'test plural',
        'test_2 singular',
        'test_2 plural'
      ],
      'context\x04test': [
        null,
        'test_2 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_2 context singular',
        'test_2 context plural'
      ]
    }
  };
  angular.module('jed', []).factory('i18n', [
    '$window',
    function (w) {
      return new w.Jed({
        domain: 'the_domain',
        missing_key_callback: function (key) {
          return console.log(key);
        },
        locale_data: {
          'the_domain': {
            '': {
              domain: 'the_domain',
              lang: 'en',
              'plural-forms': 'nplurals=2; plural=(n != 1);'
            },
            'Create a New Gist': [
              null,
              'Create a New Gist'
            ],
            'Create gist': [
              null,
              'Create gist'
            ],
            'Gist': [
              null,
              'Gist',
              'Gists'
            ],
            'Gist name': [
              null,
              'Gist name'
            ],
            'My Gist': [
              null,
              'My Gist',
              'My Gists'
            ],
            'Great gist names are short and memorable.': [
              null,
              'Great gist names are short and memorable.'
            ],
            'Initialize this gist with a README.md': [
              null,
              'Initialize this gist with a README.md'
            ],
            'This will allow you to clone the gist immediately in GitHub.': [
              null,
              'This will allow you to clone the gist immediately in GitHub.'
            ],
            'Create a New Repo': [
              null,
              'Create a New Repository'
            ],
            'Create repo': [
              null,
              'Create repository'
            ],
            'Repo': [
              null,
              'Repository',
              'Repositories'
            ],
            'Repo name': [
              null,
              'Repository name'
            ],
            'My Repo': [
              null,
              'My Repository',
              'My Repository'
            ],
            'Great repo names are short and memorable.': [
              null,
              'Great repository names are short and memorable.'
            ],
            'Initialize this repo with a README.md': [
              null,
              'Initialize this repository with a README.md'
            ],
            'This will allow you to clone the repo immediately in GitHub.': [
              null,
              'This will allow you to clone the repository immediately in GitHub.'
            ],
            'Create a New File': [
              null,
              'Create a New File'
            ],
            'Create file': [
              null,
              'Create file'
            ],
            'File': [
              null,
              'File',
              'Files'
            ],
            'File name': [
              null,
              'File name'
            ],
            'My Space': [
              null,
              'My Universe'
            ],
            'icon-gist': [
              null,
              'icon-briefcase'
            ],
            'icon-repo': [
              null,
              'icon-briefcase'
            ],
            'icon-dir': [
              null,
              'icon-book'
            ],
            'icon-file': [
              null,
              'icon-file-alt'
            ],
            'icon-question': [
              null,
              'icon-question'
            ]
          }
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('jquery', []).factory('$', [
    '$window',
    function ($window) {
      return $window.$;
    }
  ]);
}.call(this));
(function () {
  angular.module('underscore', []).factory('_', [
    '$window',
    function ($window) {
      return $window._;
    }
  ]);
}.call(this));
angular.module('app').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('angular/a-home.html', '<a href="/">\n' + '  <i class="icon-home"></i>\n' + '  <span>Home</span>\n' + '</a>\n');
    $templateCache.put('angular/github-authorize.html', '<li>\n' + '  <!-- When logged out, present the user with an OAuth link-->\n' + '  <a ng-hide="isLoggedIn()" ng-href="https://github.com/login/oauth/authorize?client_id={{clientId()}}&amp;scope=repo,user,gist">\n' + '    <i class="icon-signin"></i>\n' + '    <span>Log In</span>\n' + '  </a>\n' + '\n' + '  <!-- TODO: When logged in, we would like to have a dropdown menu-->\n' + '  <a ng-show="isLoggedIn()" ng-click="logout()" href="#">\n' + '    <i class="icon-signout icon-white"></i>\n' + '    <span>{{userLogin()}}</span>\n' + '  </a>\n' + '</li>');
    $templateCache.put('angular/home.html', '<div id="home-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="active">\n' + '              <a-home></a-home>\n' + '            </li>\n' + '            <li ng-show="isLoggedIn()">\n' + '              <a ng-href="/users/{{userLogin()}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-eye-open"></i>\n' + '                <span>Learn</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <!--li><a href="http://www.youtube.com/user/geometryzen">Watch</a></li-->\n' + '                <li><a href="http://geometryzen.github.io/mission/" target="_blank">Our Mission</a></li>\n' + '                <li><a href="/users/geometryzen/repos/demos/tree/master">Browse Examples</a></li>\n' + '                <li><a href="http://geometryzen.github.io/start/" target="_blank">Getting Started</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-external-link"></i>\n' + '                <span>Discuss</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="http://groups.google.com/group/geometryzen?src=email&amp;hl=en" target="_blank">Mailing List</a></li>\n' + '                <li><a href="http://webchat.freenode.net/?channels=geometryzen&amp;uio=d4" target="_blank">Web Chat</a></li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://twitter.com/#!/geometryzen" target="_blank">Twitter</a></li>\n' + '                <li><a href="https://plus.google.com/u/0/s/Geometry%20Zen/communities" target="_blank">Google+</a></li>\n' + '                <li class="divider"></li>\n' + '                <li class="dropdown-submenu">\n' + '                  <a href="#">Source Code</a>\n' + '                  <ul class="dropdown-menu">\n' + '                    <li><a href="https://github.com/david-geo-holmes/geometry-zen" target="_blank">Application Repository</a></li>\n' + '                    <li><a href="https://github.com/geometryzen/geometryzen.github.io" target="_blank">Documentation Repository</a></li>\n' + '                  </ul>\n' + '                </li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://github.com/geometryzen/geometryzen/issues" target="_blank">Issue Tracker</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/faq/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-question-sign"></i>\n' + '                <span>FAQ</span>\n' + '              </a>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-book"></i>\n' + '                <span>Pages</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '          <!--\n' + '          <ul class="mainnav pull-right">\n' + '-           <github-authorize></github-authorize>\n' + '-         </ul>\n' + '          -->\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span12">\n' + '        <div class="widget">\n' + '          <!--\n' + '          <div class="widget-header">\n' + '            <i class="icon-cogs"></i>\n' + '            <h3>Geometry Zen</h3>\n' + '          </div>\n' + '          -->\n' + '          <div class="widget-content">\n' + '            <div class="text-center">\n' + '              <h1>\n' + '                <large>Geometry Zen</large>\n' + '              </h1>\n' + '              <h1>\n' + '                <small><em>Looking at the multiverse from a Geometric Algebra perspective</em></small>\n' + '              </h1>\n' + '              <br/>\n' + '              <p><em>Geometry Zen</em> is a free, online, open-source, and collaborative tool for <em>Computational Modeling</em> combining the <em>Python</em> programming language, <em>3D visualization</em> (WebGL), <em>Physical Units</em>, and <em>Geometric Algebra</em>, the <em>Unified Mathematical Language for Physics and Engineering in the 21st Century</em>.</p>\n' + '              <p></p>\n' + '              <br/>\n' + '            </div>\n' + '            <div class="text-center">\n' + '              <iframe class="youtube-player" type="text/html" width="480" height="360"\n' + '                      src="http://www.youtube.com/embed/vRIEyxENcn0" frameborder="0" allowfullscreen>\n' + '              </iframe>\n' + '            </div>\n' + '            <div class="text-right">\n' + '              <blockquote>\n' + '                <p class="muted">...for geometry, you know, is the gate of science,<br/>and the gate is so low and small<br/>that one can only enter it as a little child.</p>\n' + '                <small>\n' + '                  <a href="http://en.wikipedia.org/wiki/William_Kingdon_Clifford" target="_blank">William K. Clifford</a> <cite title="Source Title"></cite>\n' + '                </small>\n' + '              </blockquote>\n' + '              <blockquote>\n' + '                <p class="muted">Geometry without algebra is dumb!<br/>Algebra without geometry is blind!</p>\n' + '                <small><a href="http://en.wikipedia.org/wiki/David_Hestenes" target="_blank">David O. Hestenes</a> <cite title="Source Title"></cite>\n' + '                </small>\n' + '              </blockquote>\n' + '            </div>\n' + '            <div class="text-center">\n' + '              <a href="/users/geometryzen/repos/demos/tree/master" class="btn btn-primary">\n' + '                <i class="icon-th"></i>\n' + '                <span>Browse Examples</span>\n' + '              </a>\n' + '              <a href="{{jumpHRef()}}" class="btn btn-secondary">\n' + '                <i class="{{jumpIcon()}}"></i>\n' + '                <span>{{jumpText()}}</span>\n' + '              </a>\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '    <div class="row-fluid">\n' + '      <div class="span6">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="icon-thumbs-up"></i>\n' + '            <h3>Features and Benefits of Geometry Zen</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <div class="accordion" id="fabAccordion">\n' + '              <!-- STEM -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse0">\n' + '                    Science, Technology, Engineering and Mathematics (STEM)\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse0" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Geometry Zen is all about enabling young students to become excited about, and engaged in, the mastery of the mathematical, scientific and engineering disciplines that are at the heart of our modern technologies and cultural understanding of our place in the universe.</p>\n' + '                    <p>We believe that by providing an appropriate tool and competent mentoring, students will naturally want to explore and grow.</p>\n' + '                    <p>Geometry Zen is the embodiment of using modern technology to accelerate and deepen the understanding and mastery of STEM.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Web Browser Platform -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse1">\n' + '                    Web Browser Platform\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse1" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Nothing to install and no plug-ins!</p>\n' + '                    <p>Just use a WebGL compliant browser such as Google Chrome or Mozilla Firefox. Apple Safari may also be used with WebGL turned on.</p>\n' + '                    <p>Note that Microsoft Internet Explorer will be supporting WebGL in Windows 8.1</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Modeling Workbench -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse2">\n' + '                    Modeling Workbench\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse2" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Juxtaposes an analytical programming editor with a 2D or 3D geometry view, reinforcing the learning of the mathematical notation as well as the geometric interpretation.</p>\n' + '                    <p>Geometry Zen has been designed to provide constructive feedback to the student, encouraging exploration and mastery.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Python Language -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse3">\n' + '                    Python Language\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse3" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Geometry Zen has chosen Python as the user programming language because of its\' ability to express mathematical notation (esp. binary operators) in a natural way. In addition, Python is easy to learn, even for very young students, but is powerful enough to be used in academic and industry research. Finally, Python is used worldwide in scientific academia and also for Information Technology (IT) projects.</p>\n' + '                    <p>The Python implementation is based on the open-source Skulpt project which has a thriving community and has been used in Coursera and universities.</p>\n' + '                    <p>The Geometry Zen project is an active contributor to the Skulpt project.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- WebGL rendering -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse4">\n' + '                    2D and 3D (WebGL) visual rendering\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse4" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Fast GPU-based WebGL rendering provides smooth animation of simulations.</p>\n' + '                    <p>Geometry Zen provides several modules supporting rendering using WebGL.</p>\n' + '                    <p>For educational modelling and simulations an easy-to-use \'visual\' module provides functionality similar to Visual Python.</p>\n' + '                    <p>For full-blown 3D rendering with cameras, meshes and textures, the Three.JS library has been exposed as the \'three\' module.</p>\n' + '                    <p>2D rendering is supported through both the HTML5 Canvas API as well as the CreateJS animation API.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Geometric Algebra-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse5">\n' + '                    Geometric Algebra(s)\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse5" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Geometric Algebra provides the motivation for the Geometry Zen project.</p>\n' + '                    <p>Support for 2D and 3D Euclidean Multivectors is provided using the \'e2ga\' and \'e3ga\' modules.</p>\n' + '                    <p>Projective, Spacetime and Conformal algebras will be supported in future for advanced Computer Graphics and Inverse Kinematics.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Units of Measure-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse7">\n' + '                    Units of Measure\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse7" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Permits algebraic manipulations, even if the units differ, with automatic conversion.</p>\n' + '                    <p>The \'units\' module provides the SI (Systeme Internationale) standard units of measurement including the kilogram, meter, second and coulomb. Derived units such as the newton, joule, watt, ampere, volt, tesla and electron volt are also understood. Users can define their own units of measure such as feet and pounds. The \'units\' module is designed to encourage exploration and mastery by providing constructive feedback for illegal expressions.</p>\n' + '                    <p>Units can be combined with any quantity (Geometric Algebra multivector) to create the concept of a measure(ment).</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Dimensional Analysis-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse6">\n' + '                    Dimensional Analysis\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse6" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Automatic verification of the correctness of physical expressions.</p>\n' + '                    <p>The \'units\' module supports tracking the dimensionality of expressions along the dimensions of Mass (M), Length (L), Time (T) and Charge, with rational exponents.<p/>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Coordinate Systems-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse8">\n' + '                    Coordinate Systems\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse8" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Enter initial configuration in a coordinate system that reflects the symmetry of the system. Cartesian coordinates are currently supported.</p>\n' + '                    <p>Through the use of Geometric Algebra, Geometry Zen encourages the manipulation of mathematical expressions in a coordinate-free way that is also independent of the dimensionality of the space.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Tutorials-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse9">\n' + '                    Tutorials\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse9" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>A comprehensive introduction to {{marketing.name}} and Geometric Algebra (Coming soon).</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Examples-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse10">\n' + '                    Examples\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse10" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Allow you to explore the capabilities and potential of Geometry Zen.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Works disconnected-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse11">\n' + '                    Works disconnected\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse11" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>No need to be connected to the internet unless you want to share your work with others.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- OAuth authentication-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse13">\n' + '                    OAuth authentication\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse13" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Secure authentication and authorization using GitHub. No extra passwords to memorize.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- GitHub repository-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse14">\n' + '                    GitHub repository\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse14" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Save and share your models in public repositories or use private repositories for assignments and problems. Search for public Geometry Zen models by other authors, improve on them, return the favor by offering back your changes.</p>\n' + '                    <p>Geometry Zen uses GitHub as the backing store for your work. GitHub is the modern coding repository and is increasingly being used to manage and version content. Using GitHub ensures that your work is always backed up and will never be lost. Moreover, it also opens up tremendous opportunities for sharing and collaboration using the features that have made GitHub so successful.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Issue Tracking-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse15">\n' + '                    Issue Tracking\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse15" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Want something incorporated, fixed or improved? <a href="https://github.com/david-geo-holmes/geometry-zen/issues">Discuss your issue</a> with the Geometry Zen community! GitHub provides a built-in issue tracker for this purpose.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Community-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse16">\n' + '                    Community\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse16" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Geometry Zen engages the community to make forward progress that meets everyone\'s needs.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Designed for Mobile -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse17">\n' + '                    Designed for Mobile\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse17" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Designed to be responsive and used on mobile tablet devices. However, the mobile technology has not yet caught up with WebGL.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- 100% freedom-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse18">\n' + '                    100% freedom\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse18" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Freedom to run, copy, distribute, study, improve and change the software.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- 100% free-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse19">\n' + '                    100% free\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse19" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>That\'s right. We don\'t believe that education should be witheld from those without the financial means.</p>\n' + '                    <p>That being said, we do accept philanthropic donations in order to faciltate student workshops.</p>\n' + '                    <p>We can also negotiate support contracts to provide premium levels of service.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Open Source Software-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse20">\n' + '                    Open Source Software\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse20" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>What else would it be? You can find it here at the <a href="https://github.com/david-geo-holmes/geometry-zen">Geometry Zen GitHub project.</a></p>\n' + '                    <p>We believe that the best way to deliver quality software that meets the needs of all users is through open-source principles.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Support-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse21">\n' + '                    Support\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse21" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>If you need specific support for enhancements or levels of service, please contact us.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '\n' + '            </div> <!-- accordion -->\n' + '          </div> <!-- div.widget-content -->\n' + '        </div> <!-- div.widget -->\n' + '      </div> <!-- div.span -->\n' + '\n' + '      <div class="span6">\n' + '        <div class="widget stacked">\n' + '          <div class="widget-header">\n' + '            <i class="icon-bullhorn"></i>\n' + '            <h3>Tell me More!</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <div id="introCarousel" class="carousel slide" data-interval="false">\n' + '              <ol class="carousel-indicators">\n' + '                <li data-target="#introCarousel" data-slide-to="0" class="active"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="1"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="2"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="3"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="4"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="5"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="6"></li>\n' + '              </ol>\n' + '              <div class="carousel-inner">\n' + '\n' + '                <div class="active item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>How do I use Geometry Zen?</h4>\n' + '                    <p>Students, researchers and educators construct a concise mathematical model of the system of interest using the Python programming language. They then get to explore and experience their model through a 2D Canvas or 3D WebGL Visualization along with keyboard, mouse and touch interaction. Geometry Zen provides native tools for Multivectors (Geometric Numbers that generalize vectors and scalars), Dimensionality checking (Mass, Length, Time, Charge), SI units (kilogram, meter, second, coulomb), automated Units of Measure conversion, and Coordinate systems. All you need to have is a web browser and the desire to learn.</p>\n' + '                    <h5 class="muted">[1 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>Will it grow with me as my mastery increases?</h4>\n' + '                    <p>The Geometry Zen programming environment is completely general (there is full access to the browser window and document object model), allowing for the construction of arbitrarly complex demonstrations, problem sets, simulations, and even games. Models may be exchanged through GitHub private and public repositories or Gists allowing for collaborative development of learning materials and problem solving. Yet Geometry Zen is simple enough to be used by very young students exploring programming and mathematics for the first time.</p>\n' + '                    <h5 class="muted">[2 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>Will it cost me anything?</h4>\n' + '                    <p>Geometry Zen is 100% free to use and is Open Source Software. Grants and donations are used to further develop and maintain the software through student workshops. Maintenance fees will only be charged to users requesting priority features or additional levels of support.</p>\n' + '                    <h5 class="muted">[3 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>What do I need to get started?</h4>\n' + '                    <p>Geometry Zen requires no software installation other than a WebGL compliant web browser. <a href="https://www.google.com/chrome" target="_blank">The Google Chrome</a> or Mozilla Firefox browsers are strongly recommended. Geometry Zen is certified for use on a Personal Computer (Linux, Mac or Windows) and we have designed it to run on Android and iOS tablets as their support for WebGL becomes available.</p>\n' + '                    <h5 class="muted">[4 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>How do I get started?</h4>\n' + '                    <p>Take a look at some of the examples and try them in the Modeling Workbench. Try your own examples in the Workbench and save them as anonymous Gists with sharable URLs. You\'ll soon want to Sign In and create yourself a GitHub account (if you don\'t have one already), that way you will be able to save your work to your own account and share it with others from there. GitHub provides a host of other useful features for storing content; it\'s what all the cool kids are using to manage content and code.</p>\n' + '                    <h5 class="muted">[5 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>What if I have more questions?</h4>\n' + '                    <p>The frequently asked questions page is probably you best next stop. There\'s also the Geometry Zen <em>pages</em> and the online Geometry Zen community.</p>\n' + '                    <h5 class="muted">[6 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>What if want to contribute or get involved?</h4>\n' + '                    <p>You can donate, <a href="https://github.com/david-geo-holmes/geometry-zen" target="_blank">write code</a>, create learning content, create documentation, and provide <a href="https://github.com/david-geo-holmes/geometry-zen/issues" target="_blank">feedback</a>.</p>\n' + '                    <h5 class="muted">[7 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '              </div>\n' + '              <a class="carousel-control left" data-target="#introCarousel" data-slide="prev">&lsaquo;</a>\n' + '              <a class="carousel-control right" data-target="#introCarousel" data-slide="next">&rsaquo;</a>\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div> <!-- div.row-fluid -->\n' + '    <div class="row-fluid">\n' + '      <div class="span6">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="icon-cogs"></i>\n' + '            <h3>Geometric Algebra in a Nutshell</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <p>Geometry is a branch of mathematics with a tradition going back at least as far as the Greek geometers, Appolonius of Perga [Pergaeus] and Euclid.</p>\n' + '            <p>Descartes showed how geometric curve-drawing machines could be described mathematically using <em>Algebraic Expressions</em>. Finding the loci of points representing the curves involed solving these polynomial equations.</p>\n' + '            <p>An <em>Algebra</em> is the name given to a special kind of mathematical object. Roughly speaking, an Algebra is a <em>Linear or Vector Space</em>, whose elements are <em>vectors</em> and <em>scalars</em>, coupled with an operation called <em>multiplication</em> such that the result of multiplication always stays in the Linear Space (closure). Algebras are very useful because of the ease of computation and expressiveness of the notation.</p>\n' + '            <p><em>Geometric Algebra</em> is an Algebra with an <em>associative</em> multiplication property. Geometric Algebra can be thought of as the generalization of the concept of a number to describe geometric quantities and defines the rules for manipulating those numbers. In essence, Geometric Algebra is about learning how to correctly multiply and interpret Geometric Numbers so that we can describe, and make predictions about the universe we live in.</p>\n' + '            <p>Many of the Physical Laws that describe the phenomena of nature are Geometric in Character and can be wriiten down concisely using Algebras. That is to say, the laws have a precise mathematical structure that is amenable to a geometric interpretation. Geometric Algebra unifies these two aspects in a single mathematical tool. By learning and using Geometric Algebra (and Geometric Calculus) the student gains a new perspective illuminating other areas of mathematics, accelerates the mastery of higher level concepts, and acquires a lasting foundation for understanding the universe and making new discoveries.</p>\n' + '          </div> <!-- div.widget-content -->\n' + '        </div> <!-- div.widget -->\n' + '      </div> <!-- div.span -->\n' + '      <div class="span6">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="icon-time"></i>\n' + '            <h3>Geometry Timeline</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <table class="table table-condensed">\n' + '              <tbody>\n' + '                <tr>\n' + '                  <td><span nowrap=nowrap>300 BCE</span></td>\n' + '                  <td>Euclid of Alexandria</td>\n' + '                  <td><em>&quot;Father of Geometry&quot;</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td><span nowrap=nowrap>262 BCE</span></td>\n' + '                  <td>Appolonius of Perga</td>\n' + '                  <td><em>Conics</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td><span nowrap=nowrap>250 CE</span></td>\n' + '                  <td>Diophantes</td>\n' + '                  <td><em>Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1545</td>\n' + '                  <td>Cardano</td>\n' + '                  <td><em>Imaginary numbers</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1637</td>\n' + '                  <td>Descartes</td>\n' + '                  <td><em>Coordinates, Algebraic Geometry</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1798</td>\n' + '                  <td>Gauss</td>\n' + '                  <td><em>Complex Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1840</td>\n' + '                  <td>Grassman</td>\n' + '                  <td><em>Linear Algebra, Vector Space</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1843</td>\n' + '                  <td>Hamilton</td>\n' + '                  <td><em>Quaternions</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1844</td>\n' + '                  <td>Grassman</td>\n' + '                  <td><em>Extensive Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1854</td>\n' + '                  <td>Cayley</td>\n' + '                  <td><em>Matrix Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1870</td>\n' + '                  <td>Gibbs and Heaviside</td>\n' + '                  <td><em>Vector Calculus</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1878</td>\n' + '                  <td>Clifford</td>\n' + '                  <td><em>Geometric Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1890</td>\n' + '                  <td>Ricci</td>\n' + '                  <td><em>Tensors</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1899</td>\n' + '                  <td>Cartan</td>\n' + '                  <td><em>Differential Forms</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1928</td>\n' + '                  <td>Dirac</td>\n' + '                  <td><em>Spin Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1957</td>\n' + '                  <td>Riesz</td>\n' + '                  <td><em>Clifford Numbers, Spinors</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1966</td>\n' + '                  <td>Hestenes</td>\n' + '                  <td><em>Space Time Algebra, Geometric Calculus</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1984</td>\n' + '                  <td>Hestenes and Sobczyk</td>\n' + '                  <td><em>Clifford Algebra to Geometric Calculus</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1986</td>\n' + '                  <td>Hestenes</td>\n' + '                  <td><em>New Foundations for Classical Mechanics</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>2003</td>\n' + '                  <td>Doran and Lasenby</td>\n' + '                  <td><em>Geometric Algebra for Physicists</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>2007</td>\n' + '                  <td>Dorst, Fontijne and Mann</td>\n' + '                  <td><em>Geometric Algebra for Computer Science</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>2009</td>\n' + '                  <td>Perwass</td>\n' + '                  <td><em>Geometric Algebra with Applications in Engineering</em></td>\n' + '                </tr>\n' + '              </tbody>\n' + '            </table> <!-- table.table-->\n' + '            <dl class="dl-horizontal">\n' + '            </dl>\n' + '          </div> <!-- dive.widget-content -->\n' + '        </div> <!-- div.widget -->\n' + '      </div> <!-- div.span4 -->\n' + '    </div> <!-- div.row-fluid -->\n' + '  </div> <!-- div.container-fluid -->\n' + '</div> <!-- div.home-view -->\n' + '<script>\n' + '  $(\'.accordion\').on(\'show\', function (e) {\n' + '    $(e.target).prev(\'.accordion-heading\').parent ().addClass(\'open\');\n' + '  });\n' + '\n' + '  $(\'.accordion\').on(\'hide\', function (e) {\n' + '    $(this).find(\'.accordion-toggle\').not($(e.target)).parents (\'.accordion-group\').removeClass(\'open\');\n' + '  });\n' + '    \n' + '  $(\'.accordion\').each (function () {       \n' + '    $(this).find (\'.accordion-body.in\').parent ().addClass (\'open\');\n' + '  });\n' + '</script>\n');
    $templateCache.put('angular/printer.html', '<div ng-controller="PrinterCtrl" class="container-fluid">\n' + '  <div class="row-fluid">\n' + '    <div class="span12">\n' + '      <!-- Using anything other than a pre(serve) element is likely too be slow -->\n' + '      <!-- PRESERVE_ELEMENT_ID is defined in the printer controller -->\n' + '      <pre id="a5f435e0-c92e-11e2-8b8b-0800200c9a66" class="printer"></pre>\n' + '    </div>\n' + '  </div>\n' + '</div>\n' + '\n');
    $templateCache.put('angular/tree.html', '<div id="repo-view">\n' + '\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="{{repoBreadcrumbClass()}}">\n' + '              <a ng-click="bookView()" href="#">\n' + '                <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                <span>{{i18n.translate("Repo").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="work-layout" class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="widget">\n' + '        <div class="widget-header">\n' + '          <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '          <h3>{{repo.name}}</h3>\n' + '        </div>\n' + '        <div class="widget-content">\n' + '          <div>\n' + '            <!--\n' + '            <i class="icon-user muted"></i>\n' + '            <span><a ng-href="/users/{{user.login}}">{{user.login}}</a></span>\n' + '            -->\n' + '            <!--\n' + '            <a ng-href="https://github.com/{{user.login}}" target="_blank" class="muted">\n' + '              <i class="icon-github"></i>\n' + '            </a>\n' + '            -->\n' + '            <span>{{repo.description}}</span>\n' + '          </div>\n' + '          <ul class="nav nav-tabs" id="myTab">\n' + '            <li><a data-target="#items" data-toggle="tab">{{i18n.translate(\'File\').ifPlural(2, \'Files\').fetch()}}</a></li>\n' + '            <!--li><a data-target="#commits" data-toggle="tab">Commits</a></li-->\n' + '            <!--li><a data-target="#branches" data-toggle="tab">Branches</a></li-->\n' + '          </ul>\n' + '          <div class="tab-content">\n' + '            <div class="tab-pane" id="items">\n' + '              <div class ="row-fluid">\n' + '                <table class="table table-condensed">\n' + '                  <tbody>\n' + '                    <tr ng-show="isNewFileEnabled()">\n' + '                      <td nowrap=nowrap>\n' + '                        <!--input type="text" placeHolder="Filter..."></input-->\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <button ng-click="newFile()" ng-show="isNewFileEnabled()" class="btn btn-primary">\n' + '                          <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}}"></i>\n' + '                          <span>{{i18n.translate("Create a New File").fetch()}}</span>\n' + '                        </button>\n' + '                      </td>\n' + '                    </tr>\n' + '                    <!-- Reminder: An item is a book or a page -->\n' + '                    <tr ng-repeat="item in contextItem.childItems">\n' + '                      <td nowrap=nowrap>\n' + '                        <h3>\n' + '                          <i class="{{i18n.translate(iconFromItem(item)).fetch()}} muted"></i>\n' + '                          <a href="{{hrefFromItem(item)}}" class="btn btn-link">\n' + '                            <span>{{item.name}}</span>\n' + '                          </a>\n' + '                        </h3>\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <a href="{{item.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                          <i class="icon-github"></i>\n' + '                          <span>GitHub</span>\n' + '                        </a>\n' + '                      </td>\n' + '                    </tr>\n' + '                  </tbody>\n' + '                </table>\n' + '              </div>\n' + '            </div>\n' + '            <div class="tab-pane" id="commits">\n' + '              <p>Under Construction: Commits</p>\n' + '            </div>\n' + '            <div class="tab-pane" id="branches">\n' + '              <p>Under Construction: Branches</p>\n' + '            </div>\n' + '          </div>\n' + '          <script>\n' + '            $(function () {\n' + '              $(\'#myTab a[data-target="#items"]\').tab(\'show\');\n' + '            })\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#items"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#commits"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#branches"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '        </div> <!-- div.widget-content -->\n' + '      </div> <!-- div.widget -->\n' + '    </div> <!-- div.row-fluid -->\n' + '  </div> <!-- div.container-fluid -->\n' + '  <div id="new-file-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-file-dialog-label" aria-hidden="true">\n' + '    <div class="modal-header">\n' + '      <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '      <h3 id="new-file-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}} muted"></i> {{i18n.translate("Create a New File").fetch()}}</h3>\n' + '    </div>\n' + '    <form ng-controller="NewFileCtrl">\n' + '      <fieldset>\n' + '        <div class="modal-body">\n' + '          <label>{{i18n.translate(\'File name\').fetch()}}</label>\n' + '          <input type="text" name="name" ng-model="file.name"></input>\n' + '          <label>Commit message:</label>\n' + '          <input type="text" name="message" ng-model="file.message" placeholder="{{i18n.translate(\'Create file\').fetch()}}"></input>\n' + '        </div>\n' + '        <div class="modal-footer">\n' + '          <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '          <button type="submit" ng-click="createFile()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create file").fetch()}}</button>\n' + '        </div>\n' + '      </fieldset>\n' + '    </form>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('angular/user.html', '<div id="user-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li>\n' + '              <a ng-href="/workbench" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div> <!-- /.subnav-collapse -->\n' + '      </div> <!-- /container -->\n' + '    </div> <!-- /subnavbar-inner -->\n' + '  </div> <!-- /subnavbar -->\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span4">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '              <i class="icon-user"></i>\n' + '              <h3>Profile</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <h3>\n' + '              <span>{{user.name}}</span>\n' + '            </h3>\n' + '            <h4>\n' + '              <span>{{user.login}}</span>\n' + '            </h4>\n' + '            <!-- HATEOAS GitHub link? -->\n' + '            <!--\n' + '            <a href="https://github.com/{{user.login}}?tab=repositories" target="_blank" class="btn btn-secondary">\n' + '              <i class="icon-github"></i>\n' + '              <span>GitHub</span>\n' + '            </a>\n' + '            -->\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span8">\n' + '        <div class="widget stacked">\n' + '          <div class="widget-content">\n' + '            <ul class="nav nav-tabs" id="myTab">\n' + '              <li><a data-target="#gists" data-toggle="tab">{{i18n.translate("Gist").ifPlural(2, "Gists").fetch()}}</a></li>\n' + '              <li><a data-target="#repos" data-toggle="tab">{{i18n.translate("Repo").ifPlural(2, "Repos").fetch()}}</a></li>\n' + '            </ul>\n' + '            <div class="tab-content">\n' + '              <div class="tab-pane" id="gists">\n' + '                <div class ="row-fluid">\n' + '                  <table class="table table-condensed">\n' + '                    <tbody>\n' + '                      <tr>\n' + '                        <td nowrap=nowrap>\n' + '                          <!--input type="text" placeHolder="Filter..."></input-->\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <button ng-click="newGist()" class="btn btn-primary">\n' + '                            <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-gist\').fetch()}}"></i>\n' + '                            <span>{{i18n.translate("Create a New Gist").fetch()}}</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                      <tr ng-repeat="gist in gists">\n' + '                        <td nowrap=nowrap>\n' + '                          <h3>\n' + '                            <i class="{{i18n.translate(\'icon-gist\').fetch()}} muted"></i>\n' + '                            <a href="/gists/{{gist.id}}" class="btn btn-link">\n' + '                              <span>{{gist.id}}</span>\n' + '                            </a>\n' + '                          </h3>\n' + '                          <p>{{gist.description}}</p>\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <a href="{{gist.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                            <i class="icon-github"></i>\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                          <!--\n' + '                          <button ng-click="deleteGist(user.login, gist.id)" class="btn btn-tertiary">\n' + '                            <i class="icon-minus-sign-alt"></i>\n' + '                            <span>Delete</span>\n' + '                          </button>\n' + '                          -->\n' + '                        </td>\n' + '                      </tr>\n' + '                    </tbody>\n' + '                  </table>\n' + '                </div>\n' + '              </div>\n' + '              <div class="tab-pane" id="repos">\n' + '                <div class ="row-fluid">\n' + '                  <table class="table table-condensed">\n' + '                    <tbody>\n' + '                      <tr>\n' + '                        <td nowrap=nowrap>\n' + '                          <!--input type="text" placeHolder="Filter..."></input-->\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <button ng-click="newRepo(user.login)" class="btn btn-primary">\n' + '                            <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                            <span>{{i18n.translate("Create a New Repo").fetch()}}</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                      <tr ng-repeat="repo in repos">\n' + '                        <td nowrap=nowrap>\n' + '                          <h3>\n' + '                            <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i>\n' + '                            <a href="/users/{{user.login}}/repos/{{repo.name}}/tree/master" class="btn btn-link">\n' + '                              <span>{{repo.name}}</span>\n' + '                            </a>\n' + '                          </h3>\n' + '                          <p>{{repo.description}}</p>\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <a href="{{repo.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                            <i class="icon-github"></i>\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                          <!--\n' + '                          <button ng-click="deleteRepo(user.login, repo.name)" class="btn btn-tertiary">\n' + '                            <i class="icon-minus-sign-alt"></i>\n' + '                            <span>Delete</span>\n' + '                          </button>\n' + '                          -->\n' + '                        </td>\n' + '                      </tr>\n' + '                    </tbody>\n' + '                  </table>\n' + '                </div>\n' + '              </div>\n' + '            </div>\n' + '            <script>\n' + '              $(function () {\n' + '                $(\'#myTab a[data-target="#gists"]\').tab(\'show\');\n' + '              })\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#gists"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#repos"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '          </div>\n' + '        </div>\n' + '\n' + '        <div id="new-gist-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-gist-dialog-label" aria-hidden="true">\n' + '          <div class="modal-header">\n' + '            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '            <h3 id="new-gist-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-gist\').fetch()}} muted"></i> {{i18n.translate("Create a New Gist").fetch()}}</h3>\n' + '          </div>\n' + '          <form ng-controller="NewGistCtrl">\n' + '            <fieldset>\n' + '              <div class="modal-body">\n' + '                <label>Description<span class="muted"> (optional)</span></label>\n' + '                <input type="text" name="description" ng-model="gist.description"></input>\n' + '              </div>\n' + '              <div class="modal-footer">\n' + '                <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '                <button type="submit" ng-click="createGist()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create gist").fetch()}}</button>\n' + '              </div>\n' + '            </fieldset>\n' + '          </form>\n' + '        </div>\n' + '\n' + '        <div id="new-repo-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-repo-dialog-label" aria-hidden="true">\n' + '          <div class="modal-header">\n' + '            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '            <h3 id="new-repo-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> {{i18n.translate("Create a New Repo").fetch()}}</h3>\n' + '          </div>\n' + '          <form ng-controller="NewRepoCtrl">\n' + '            <fieldset>\n' + '              <div class="modal-body">\n' + '                <label>{{i18n.translate("Repo name").fetch()}}</label>\n' + '                <input type="text" name="repo" ng-model="repo.name"></input>\n' + '                <span class="help-block">{{i18n.translate("Great repo names are short and memorable.").fetch()}}</span>\n' + '                <label>Description<span class="muted"> (optional)</span></label>\n' + '                <input type="text" name="description" ng-model="repo.description"></input>\n' + '                <!--\n' + '                <hr/>\n' + '                <input type="radio" ng-model="repo.private" value="false"> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> Public<br/>\n' + '                <span class="help-block">Anyone can see this repository. You choose who can commit.</span>\n' + '                <input type="radio" ng-model="repo.private" value="true"> Private <br/>\n' + '                <span class="help-block">You choose who can see and commit to this repository.</span>\n' + '                -->\n' + '                <hr/>\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="markdown-readme" ng-model="repo.markdownReadme"> {{i18n.translate("Initialize this repo with a README.md").fetch()}}</input>\n' + '                </label>\n' + '                <span class="help-block">{{i18n.translate("This will allow you to clone the repo immediately in GitHub.").fetch()}}</span>\n' + '                <!--\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="python-readme" ng-model="repo.pythonReadme"> Initialize this book with a README.py</input>\n' + '                </label>\n' + '                <span class="help-block">Having at least one Python file will ensure that the GitHub repository is visible to Geometry Zen.</span>\n' + '                -->\n' + '              </div>\n' + '              <div class="modal-footer">\n' + '                <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '                <button type="submit" ng-click="createRepo()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create repo").fetch()}}</button>\n' + '              </div>\n' + '            </fieldset>\n' + '          </form>\n' + '        </div>\n' + '\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>');
    $templateCache.put('angular/work.html', '<div id="work-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.name}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="active">\n' + '              <a ng-click="reload()" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="saveEnabled()">\n' + '              <a ng-click="saveFile()" href="#">\n' + '                <i class="icon-save"></i>\n' + '                <span>Save</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="runEnabled()">\n' + '              <a ng-click="run()" href="#">\n' + '                <i class="icon-cogs"></i>\n' + '                <span>Run</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="work-layout" class="container-fluid">\n' + '\n' + '    <div class="row-fluid">\n' + '      <div class="span12">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="icon-cogs"></i>\n' + '            <h3>Output</h3>\n' + '          </div>\n' + '          <div id="canvas-container" class="widget-plain"></div>\n' + '          <div id="printer-container" class="widget-content">\n' + '            <printer></printer>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '\n' + '    <div class="row-fluid" ng-show="messages.length &gt; 0">\n' + '      <div class="span12">\n' + '        <div class="widget stacked">\n' + '          <div class="widget-header">\n' + '            <i class="icon-inbox"></i>\n' + '            <h3>Message</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <div class="alert alert-block alert-{{message.severity}}" ng-repeat="message in messages">\n' + '              <button type="button" class="close" data-dismiss="alert">&times;</button>\n' + '              <h4>{{message.name}}</h4>\n' + '              {{message.text}}\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '\n' + '    <div class="row-fluid">\n' + '      <div class="span12">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="{{i18n.translate(\'icon-file\').fetch()}} muted"></i>\n' + '            <h3>{{contextItem.name}}</h3>\n' + '          </div>\n' + '          <div id="textarea-container" class="widget-plain">\n' + '            <textarea id="code"></textarea>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '\n' + '  </div>\n' + '</div>');
  }
]);